// Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.

// This is a specialised implementation of a System module loader.

// @ts-nocheck
/* eslint-disable */
let System, __instantiateAsync, __instantiate;

(() => {
  const r = new Map();

  System = {
    register(id, d, f) {
      r.set(id, { d, f, exp: {} });
    }
  };

  function gC(id, main) {
    return {
      id,
      import: async id => r.get(id)?.exp,
      meta: { url: id, main }
    };
  }

  function gE(exp) {
    return (id, v) => {
      v = typeof id === "string" ? { [id]: v } : id;
      for (const [id, value] of Object.entries(v)) {
        Object.defineProperty(exp, id, {
          value,
          writable: true,
          enumerable: true
        });
      }
    };
  }

  function rF(main) {
    for (const [id, m] of r.entries()) {
      const { f, exp } = m;
      const { execute: e, setters: s } = f(gE(exp), gC(id, id === main));
      delete m.f;
      m.e = e;
      m.s = s;
    }
  }

  async function gExpA(id) {
    if (!r.has(id)) return;
    const m = r.get(id);
    if (m.s) {
      const { d, e, s } = m;
      delete m.s;
      delete m.e;
      for (let i = 0; i < s.length; i++) s[i](await gExpA(d[i]));
      const r = e();
      if (r) await r;
    }
    return m.exp;
  }

  function gExp(id) {
    if (!r.has(id)) return;
    const m = r.get(id);
    if (m.s) {
      const { d, e, s } = m;
      delete m.s;
      delete m.e;
      for (let i = 0; i < s.length; i++) s[i](gExp(d[i]));
      e();
    }
    return m.exp;
  }

  __instantiateAsync = async m => {
    System = __instantiateAsync = __instantiate = undefined;
    rF(m);
    return gExpA(m);
  };

  __instantiate = m => {
    System = __instantiateAsync = __instantiate = undefined;
    rF(m);
    return gExp(m);
  };
})();

System.register("http://localhost:5501/src/utils/array", [], function (exports_1, context_1) {
    "use strict";
    var padArrayRight, test_padArrayRight_empty, test_padArrayRight_existing;
    var __moduleName = context_1 && context_1.id;
    return {
        setters: [],
        execute: function () {
            exports_1("padArrayRight", padArrayRight = (arr, length, fill) => {
                return [...arr, ...Array(length).fill(fill)].slice(0, length);
            });
            exports_1("test_padArrayRight_empty", test_padArrayRight_empty = () => {
                return [padArrayRight([], 2, "a"), ["a", "a"]];
            });
            exports_1("test_padArrayRight_existing", test_padArrayRight_existing = () => {
                return [padArrayRight(["a"], 2, "b"), ["a", "b"]];
            });
        }
    };
});
System.register("http://localhost:5501/src/utils/css", [], function (exports_2, context_2) {
    "use strict";
    var getCssVariable, setCssVariable, injectCss, componentCss;
    var __moduleName = context_2 && context_2.id;
    return {
        setters: [],
        execute: function () {
            exports_2("getCssVariable", getCssVariable = (value, el = document.body) => getComputedStyle(el).getPropertyValue(value));
            exports_2("setCssVariable", setCssVariable = (key, value, el = document.body.style) => el.setProperty(key, value));
            exports_2("injectCss", injectCss = css => {
                const el = document.createElement("style");
                el.innerHTML = css;
                document.querySelector("head").appendChild(el);
            });
            exports_2("componentCss", componentCss = components => {
                const css = Object.entries(components)
                    .filter(([_, { css }]) => css)
                    .map(([key, { css }]) => css)
                    .join(" ")
                    .replace("\n", " ")
                    .replace(/\s+/g, " ");
                injectCss(css);
            });
        }
    };
});
System.register("http://localhost:5501/src/utils/error", [], function (exports_3, context_3) {
    "use strict";
    var onError, onWarning, onCompilerError;
    var __moduleName = context_3 && context_3.id;
    return {
        setters: [],
        execute: function () {
            exports_3("onError", onError = error => console.log(error));
            exports_3("onWarning", onWarning = error => console.log(error));
            exports_3("onCompilerError", onCompilerError = error => console.log(error));
        }
    };
});
// From https://gist.github.com/hkwon/766a7344c9f29675bd9eb49281a7936a
System.register("http://localhost:5501/src/utils/events", [], function (exports_4, context_4) {
    "use strict";
    var events, send, receive;
    var __moduleName = context_4 && context_4.id;
    function Events() {
        const subscriptions = {};
        this.on = function subscribeCallbackToEvent(eventType, callback) {
            const id = Symbol("id");
            if (!subscriptions[eventType])
                subscriptions[eventType] = {};
            subscriptions[eventType][id] = callback;
        };
        this.emit = function publishEventWithArgs(eventType, arg) {
            if (!subscriptions[eventType])
                return;
            Object.getOwnPropertySymbols(subscriptions[eventType]).forEach(key => subscriptions[eventType][key](arg));
        };
    }
    return {
        setters: [],
        execute: function () {
            events = new Events();
            exports_4("send", send = (key, payload = null) => {
                return events.emit(key, payload);
            });
            exports_4("receive", receive = (key, callback) => events.on(key, callback));
        }
    };
});
System.register("https://unpkg.com/vue@3.0.0-alpha.4/dist/vue.esm", [], function (exports_5, context_5) {
    "use strict";
    var PublicPatchFlags, PatchFlagNames, GLOBALS_WHITE_LISTED, isGloballyWhitelisted, range, HTML_TAGS, SVG_TAGS, VOID_TAGS, isHTMLTag, isSVGTag, isVoidTag, EMPTY_OBJ, EMPTY_ARR, NOOP, NO, isOn, extend, hasOwnProperty, hasOwn, isArray, isFunction, isString, isSymbol, isObject, objectToString, toTypeString, isPlainObject, isReservedProp, camelizeRE, camelize, hyphenateRE, hyphenate, capitalize, hasChanged, errorMessages, locStub, FRAGMENT, PORTAL, SUSPENSE, KEEP_ALIVE, BASE_TRANSITION, OPEN_BLOCK, CREATE_BLOCK, CREATE_VNODE, CREATE_COMMENT, CREATE_TEXT, RESOLVE_COMPONENT, RESOLVE_DYNAMIC_COMPONENT, RESOLVE_DIRECTIVE, WITH_DIRECTIVES, RENDER_LIST, RENDER_SLOT, CREATE_SLOTS, TO_DISPLAY_STRING, MERGE_PROPS, TO_HANDLERS, CAMELIZE, SET_BLOCK_TRACKING, PUSH_SCOPE_ID, POP_SCOPE_ID, WITH_SCOPE_ID, helperNameMap, isBuiltInType, nonIdentifierRE, isSimpleIdentifier, memberExpRE, isMemberExpression, defaultParserOptions, CCR_REPLACEMENTS, transformIf, transformFor, forAliasRE, forIteratorRE, stripParensRE, isStaticExp, defaultFallback, trackSlotScopes, directiveImportMap, transformElement, transformSlotOutlet, fnExpRE, transformOn, transformBind, isText$1, transformText, transformOnce, transformModel, isRawTextContainer, parserOptionsMinimal, transformStyle, listDelimiterRE, propertyDelimiterRE, transformCloak, DOMErrorMessages, transformVHtml, transformVText, V_MODEL_RADIO, V_MODEL_CHECKBOX, V_MODEL_TEXT, V_MODEL_SELECT, V_MODEL_DYNAMIC, V_ON_WITH_MODIFIERS, V_ON_WITH_KEYS, V_SHOW, TRANSITION, TRANSITION_GROUP, transformModel$1, isEventOptionModifier, isNonKeyModifier, isKeyboardEvent, generateModifiers, transformOn$1, transformShow, parserOptions, targetMap, effectStack, activeEffect, ITERATE_KEY, shouldTrack, LOCKED, builtInSymbols, get, readonlyGet, shallowReadonlyGet, arrayIdentityInstrumentations, set, readonlySet, shallowReadonlySet, mutableHandlers, readonlyHandlers, shallowReadonlyHandlers, toReactive, toReadonly, getProto, mutableInstrumentations, readonlyInstrumentations, iteratorMethods, mutableCollectionHandlers, readonlyCollectionHandlers, rawToReactive, reactiveToRaw, rawToReadonly, readonlyToRaw, readonlyValues, nonReactiveValues, collectionTypes, isObservableType, canObserve, convert, ErrorTypeStrings, stack, classifyRE, classify, currentScopeId, Fragment, Portal, Text, Comment, blockStack, currentBlock, shouldTrack$1, handlersRE, queue, postFlushCbs, p, isFlushing, isFlushPending, RECURSION_LIMIT, dedupe, currentRenderingInstance, accessedAttrs, normalizationMap, isSimpleType, normalizeSlotValue, normalizeSlot, isBuiltInDirective, directiveToVnodeHooksMap, SuspenseImpl, Suspense, queuePostRenderEffect, BaseTransitionImpl, BaseTransition, isKeepAlive, KeepAliveImpl, KeepAlive, createHook, onBeforeMount, onMounted, onBeforeUpdate, onUpdated, onBeforeUnmount, onUnmounted, onRenderTriggered, onRenderTracked, onErrorCaptured, invoke, publicPropertiesMap, unwrapRef, PublicInstanceProxyHandlers, runtimeCompiledRenderProxyHandlers, emptyAppContext, currentInstance, currentSuspense, getCurrentInstance, setCurrentInstance, isBuiltInTag, compile$1, SetupProxySymbol, SetupProxyHandlers, PublicShapeFlags, COMPONENTS, DIRECTIVES, version, PatchFlags, toDisplayString$1, capitalize$1, camelize$1, doc, svgNS, nodeOps, importantRE, prefixes, prefixCache, _getNow, cachedNow, p$1, reset, getNow, getModelAssigner, vModelText, vModelCheckbox, vModelRadio, vModelSelect, vModelDynamic, systemModifiers, modifierGuards, withModifiers, keyNames, withKeys, vShow, TRANSITION$1, ANIMATION, Transition, TransitionPropsValidators, positionMap, newPositionMap, TransitionGroupImpl, TransitionGroup, _a, baseRender, baseCreateApp, render, createApp, runtimeDom, compileCache;
    var __moduleName = context_5 && context_5.id;
    // Make a map and return a function for checking if a key
    // is in that map.
    //
    // IMPORTANT: all calls of this function must be prefixed with /*#__PURE__*/
    // So that rollup can tree-shake them if necessary.
    function makeMap(str, expectsLowerCase) {
        const map = Object.create(null);
        const list = str.split(',');
        for (let i = 0; i < list.length; i++) {
            map[list[i]] = true;
        }
        return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];
    }
    function generateCodeFrame(source, start = 0, end = source.length) {
        const lines = source.split(/\r?\n/);
        let count = 0;
        const res = [];
        for (let i = 0; i < lines.length; i++) {
            count += lines[i].length + 1;
            if (count >= start) {
                for (let j = i - range; j <= i + range || end > count; j++) {
                    if (j < 0 || j >= lines.length)
                        continue;
                    const line = j + 1;
                    res.push(`${line}${' '.repeat(3 - String(line).length)}|  ${lines[j]}`);
                    const lineLength = lines[j].length;
                    if (j === i) {
                        // push underline
                        const pad = start - (count - lineLength) + 1;
                        const length = Math.max(1, end > count ? lineLength - pad : end - start);
                        res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length));
                    }
                    else if (j > i) {
                        if (end > count) {
                            const length = Math.max(Math.min(end - count, lineLength), 1);
                            res.push(`   |  ` + '^'.repeat(length));
                        }
                        count += lineLength + 1;
                    }
                }
                break;
            }
        }
        return res.join('\n');
    }
    function isPromise(val) {
        return isObject(val) && isFunction(val.then) && isFunction(val.catch);
    }
    function toRawType(value) {
        return toTypeString(value).slice(8, -1);
    }
    function cacheStringFunction(fn) {
        const cache = Object.create(null);
        return ((str) => {
            const hit = cache[str];
            return hit || (cache[str] = fn(str));
        });
    }
    // for converting {{ interpolation }} values to displayed strings.
    function toDisplayString(val) {
        return val == null
            ? ''
            : isArray(val) || (isPlainObject(val) && val.toString === objectToString)
                ? JSON.stringify(val, null, 2)
                : String(val);
    }
    function defaultOnError(error) {
        throw error;
    }
    function createCompilerError(code, loc, messages) {
        const msg = (messages || errorMessages)[code];
        const error = new SyntaxError(String(msg));
        error.code = code;
        error.loc = loc;
        return error;
    }
    function createArrayExpression(elements, loc = locStub) {
        return {
            type: 16 /* JS_ARRAY_EXPRESSION */,
            loc,
            elements
        };
    }
    function createObjectExpression(properties, loc = locStub) {
        return {
            type: 14 /* JS_OBJECT_EXPRESSION */,
            loc,
            properties
        };
    }
    function createObjectProperty(key, value) {
        return {
            type: 15 /* JS_PROPERTY */,
            loc: locStub,
            key: isString(key) ? createSimpleExpression(key, true) : key,
            value
        };
    }
    function createSimpleExpression(content, isStatic, loc = locStub, isConstant = false) {
        return {
            type: 4 /* SIMPLE_EXPRESSION */,
            loc,
            isConstant,
            content,
            isStatic
        };
    }
    function createCompoundExpression(children, loc = locStub) {
        return {
            type: 8 /* COMPOUND_EXPRESSION */,
            loc,
            children
        };
    }
    function createCallExpression(callee, args = [], loc = locStub) {
        return {
            type: 13 /* JS_CALL_EXPRESSION */,
            loc,
            callee,
            arguments: args
        };
    }
    function createFunctionExpression(params, returns, newline = false, isSlot = false, loc = locStub) {
        return {
            type: 17 /* JS_FUNCTION_EXPRESSION */,
            params,
            returns,
            newline,
            isSlot,
            loc
        };
    }
    function createSequenceExpression(expressions) {
        return {
            type: 18 /* JS_SEQUENCE_EXPRESSION */,
            expressions,
            loc: locStub
        };
    }
    function createConditionalExpression(test, consequent, alternate) {
        return {
            type: 19 /* JS_CONDITIONAL_EXPRESSION */,
            test,
            consequent,
            alternate,
            loc: locStub
        };
    }
    function createCacheExpression(index, value, isVNode = false) {
        return {
            type: 20 /* JS_CACHE_EXPRESSION */,
            index,
            value,
            isVNode,
            loc: locStub
        };
    }
    function registerRuntimeHelpers(helpers) {
        Object.getOwnPropertySymbols(helpers).forEach(s => {
            helperNameMap[s] = helpers[s];
        });
    }
    function isCoreComponent(tag) {
        if (isBuiltInType(tag, 'Portal')) {
            return PORTAL;
        }
        else if (isBuiltInType(tag, 'Suspense')) {
            return SUSPENSE;
        }
        else if (isBuiltInType(tag, 'KeepAlive')) {
            return KEEP_ALIVE;
        }
        else if (isBuiltInType(tag, 'BaseTransition')) {
            return BASE_TRANSITION;
        }
    }
    function getInnerRange(loc, offset, length) {
        const source = loc.source.substr(offset, length);
        const newLoc = {
            source,
            start: advancePositionWithClone(loc.start, loc.source, offset),
            end: loc.end
        };
        if (length != null) {
            newLoc.end = advancePositionWithClone(loc.start, loc.source, offset + length);
        }
        return newLoc;
    }
    function advancePositionWithClone(pos, source, numberOfCharacters = source.length) {
        return advancePositionWithMutation({ ...pos }, source, numberOfCharacters);
    }
    // advance by mutation without cloning (for performance reasons), since this
    // gets called a lot in the parser
    function advancePositionWithMutation(pos, source, numberOfCharacters = source.length) {
        let linesCount = 0;
        let lastNewLinePos = -1;
        for (let i = 0; i < numberOfCharacters; i++) {
            if (source.charCodeAt(i) === 10 /* newline char code */) {
                linesCount++;
                lastNewLinePos = i;
            }
        }
        pos.offset += numberOfCharacters;
        pos.line += linesCount;
        pos.column =
            lastNewLinePos === -1
                ? pos.column + numberOfCharacters
                : numberOfCharacters - lastNewLinePos;
        return pos;
    }
    function assert(condition, msg) {
        /* istanbul ignore if */
        if (!condition) {
            throw new Error(msg || `unexpected compiler condition`);
        }
    }
    function findDir(node, name, allowEmpty = false) {
        for (let i = 0; i < node.props.length; i++) {
            const p = node.props[i];
            if (p.type === 7 /* DIRECTIVE */ &&
                (allowEmpty || p.exp) &&
                (isString(name) ? p.name === name : name.test(p.name))) {
                return p;
            }
        }
    }
    function findProp(node, name, dynamicOnly = false) {
        for (let i = 0; i < node.props.length; i++) {
            const p = node.props[i];
            if (p.type === 6 /* ATTRIBUTE */) {
                if (dynamicOnly)
                    continue;
                if (p.name === name && p.value) {
                    return p;
                }
            }
            else if (p.name === 'bind' &&
                p.arg &&
                p.arg.type === 4 /* SIMPLE_EXPRESSION */ &&
                p.arg.isStatic &&
                p.arg.content === name &&
                p.exp) {
                return p;
            }
        }
    }
    function createBlockExpression(blockExp, context) {
        return createSequenceExpression([
            createCallExpression(context.helper(OPEN_BLOCK)),
            blockExp
        ]);
    }
    function isVSlot(p) {
        return p.type === 7 /* DIRECTIVE */ && p.name === 'slot';
    }
    function isTemplateNode(node) {
        return (node.type === 1 /* ELEMENT */ && node.tagType === 3 /* TEMPLATE */);
    }
    function isSlotOutlet(node) {
        return node.type === 1 /* ELEMENT */ && node.tagType === 2 /* SLOT */;
    }
    function injectProp(node, prop, context) {
        let propsWithInjection;
        const props = node.callee === RENDER_SLOT ? node.arguments[2] : node.arguments[1];
        if (props == null || isString(props)) {
            propsWithInjection = createObjectExpression([prop]);
        }
        else if (props.type === 13 /* JS_CALL_EXPRESSION */) {
            // merged props... add ours
            // only inject key to object literal if it's the first argument so that
            // if doesn't override user provided keys
            const first = props.arguments[0];
            if (!isString(first) && first.type === 14 /* JS_OBJECT_EXPRESSION */) {
                first.properties.unshift(prop);
            }
            else {
                props.arguments.unshift(createObjectExpression([prop]));
            }
            propsWithInjection = props;
        }
        else if (props.type === 14 /* JS_OBJECT_EXPRESSION */) {
            let alreadyExists = false;
            // check existing key to avoid overriding user provided keys
            if (prop.key.type === 4 /* SIMPLE_EXPRESSION */) {
                const propKeyName = prop.key.content;
                alreadyExists = props.properties.some(p => (p.key.type === 4 /* SIMPLE_EXPRESSION */ &&
                    p.key.content === propKeyName));
            }
            if (!alreadyExists) {
                props.properties.unshift(prop);
            }
            propsWithInjection = props;
        }
        else {
            // single v-bind with expression, return a merged replacement
            propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
                createObjectExpression([prop]),
                props
            ]);
        }
        if (node.callee === RENDER_SLOT) {
            node.arguments[2] = propsWithInjection;
        }
        else {
            node.arguments[1] = propsWithInjection;
        }
    }
    function toValidAssetId(name, type) {
        return `_${type}_${name.replace(/[^\w]/g, '_')}`;
    }
    function baseParse(content, options = {}) {
        const context = createParserContext(content, options);
        const start = getCursor(context);
        return {
            type: 0 /* ROOT */,
            children: parseChildren(context, 0 /* DATA */, []),
            helpers: [],
            components: [],
            directives: [],
            hoists: [],
            imports: [],
            cached: 0,
            codegenNode: undefined,
            loc: getSelection(context, start)
        };
    }
    function createParserContext(content, options) {
        return {
            options: {
                ...defaultParserOptions,
                ...options
            },
            column: 1,
            line: 1,
            offset: 0,
            originalSource: content,
            source: content,
            inPre: false
        };
    }
    function parseChildren(context, mode, ancestors) {
        const parent = last(ancestors);
        const ns = parent ? parent.ns : 0 /* HTML */;
        const nodes = [];
        while (!isEnd(context, mode, ancestors)) {
            const s = context.source;
            let node = undefined;
            if (mode === 0 /* DATA */) {
                if (!context.inPre && startsWith(s, context.options.delimiters[0])) {
                    // '{{'
                    node = parseInterpolation(context, mode);
                }
                else if (s[0] === '<') {
                    // https://html.spec.whatwg.org/multipage/parsing.html#tag-open-state
                    if (s.length === 1) {
                        emitError(context, 8 /* EOF_BEFORE_TAG_NAME */, 1);
                    }
                    else if (s[1] === '!') {
                        // https://html.spec.whatwg.org/multipage/parsing.html#markup-declaration-open-state
                        if (startsWith(s, '<!--')) {
                            node = parseComment(context);
                        }
                        else if (startsWith(s, '<!DOCTYPE')) {
                            // Ignore DOCTYPE by a limitation.
                            node = parseBogusComment(context);
                        }
                        else if (startsWith(s, '<![CDATA[')) {
                            if (ns !== 0 /* HTML */) {
                                node = parseCDATA(context, ancestors);
                            }
                            else {
                                emitError(context, 2 /* CDATA_IN_HTML_CONTENT */);
                                node = parseBogusComment(context);
                            }
                        }
                        else {
                            emitError(context, 14 /* INCORRECTLY_OPENED_COMMENT */);
                            node = parseBogusComment(context);
                        }
                    }
                    else if (s[1] === '/') {
                        // https://html.spec.whatwg.org/multipage/parsing.html#end-tag-open-state
                        if (s.length === 2) {
                            emitError(context, 8 /* EOF_BEFORE_TAG_NAME */, 2);
                        }
                        else if (s[2] === '>') {
                            emitError(context, 17 /* MISSING_END_TAG_NAME */, 2);
                            advanceBy(context, 3);
                            continue;
                        }
                        else if (/[a-z]/i.test(s[2])) {
                            emitError(context, 31 /* X_INVALID_END_TAG */);
                            parseTag(context, 1 /* End */, parent);
                            continue;
                        }
                        else {
                            emitError(context, 15 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */, 2);
                            node = parseBogusComment(context);
                        }
                    }
                    else if (/[a-z]/i.test(s[1])) {
                        node = parseElement(context, ancestors);
                    }
                    else if (s[1] === '?') {
                        emitError(context, 28 /* UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */, 1);
                        node = parseBogusComment(context);
                    }
                    else {
                        emitError(context, 15 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */, 1);
                    }
                }
            }
            if (!node) {
                node = parseText(context, mode);
            }
            if (isArray(node)) {
                for (let i = 0; i < node.length; i++) {
                    pushNode(nodes, node[i]);
                }
            }
            else {
                pushNode(nodes, node);
            }
        }
        // Whitespace management for more efficient output
        // (same as v2 whitespace: 'condense')
        let removedWhitespace = false;
        if (mode !== 2 /* RAWTEXT */ &&
            (!parent || !context.options.isPreTag(parent.tag))) {
            for (let i = 0; i < nodes.length; i++) {
                const node = nodes[i];
                if (node.type === 2 /* TEXT */) {
                    if (!node.content.trim()) {
                        const prev = nodes[i - 1];
                        const next = nodes[i + 1];
                        // If:
                        // - the whitespace is the first or last node, or:
                        // - the whitespace is adjacent to a comment, or:
                        // - the whitespace is between two elements AND contains newline
                        // Then the whitespace is ignored.
                        if (!prev ||
                            !next ||
                            prev.type === 3 /* COMMENT */ ||
                            next.type === 3 /* COMMENT */ ||
                            (prev.type === 1 /* ELEMENT */ &&
                                next.type === 1 /* ELEMENT */ &&
                                /[\r\n]/.test(node.content))) {
                            removedWhitespace = true;
                            nodes[i] = null;
                        }
                        else {
                            // Otherwise, condensed consecutive whitespace inside the text down to
                            // a single space
                            node.content = ' ';
                        }
                    }
                    else {
                        node.content = node.content.replace(/\s+/g, ' ');
                    }
                }
            }
        }
        return removedWhitespace ? nodes.filter(Boolean) : nodes;
    }
    function pushNode(nodes, node) {
        if (node.type === 2 /* TEXT */) {
            const prev = last(nodes);
            // Merge if both this and the previous node are text and those are
            // consecutive. This happens for cases like "a < b".
            if (prev &&
                prev.type === 2 /* TEXT */ &&
                prev.loc.end.offset === node.loc.start.offset) {
                prev.content += node.content;
                prev.loc.end = node.loc.end;
                prev.loc.source += node.loc.source;
                return;
            }
        }
        nodes.push(node);
    }
    function parseCDATA(context, ancestors) {
        advanceBy(context, 9);
        const nodes = parseChildren(context, 3 /* CDATA */, ancestors);
        if (context.source.length === 0) {
            emitError(context, 9 /* EOF_IN_CDATA */);
        }
        else {
            advanceBy(context, 3);
        }
        return nodes;
    }
    function parseComment(context) {
        const start = getCursor(context);
        let content;
        // Regular comment.
        const match = /--(\!)?>/.exec(context.source);
        if (!match) {
            content = context.source.slice(4);
            advanceBy(context, context.source.length);
            emitError(context, 10 /* EOF_IN_COMMENT */);
        }
        else {
            if (match.index <= 3) {
                emitError(context, 0 /* ABRUPT_CLOSING_OF_EMPTY_COMMENT */);
            }
            if (match[1]) {
                emitError(context, 13 /* INCORRECTLY_CLOSED_COMMENT */);
            }
            content = context.source.slice(4, match.index);
            // Advancing with reporting nested comments.
            const s = context.source.slice(0, match.index);
            let prevIndex = 1, nestedIndex = 0;
            while ((nestedIndex = s.indexOf('<!--', prevIndex)) !== -1) {
                advanceBy(context, nestedIndex - prevIndex + 1);
                if (nestedIndex + 4 < s.length) {
                    emitError(context, 20 /* NESTED_COMMENT */);
                }
                prevIndex = nestedIndex + 1;
            }
            advanceBy(context, match.index + match[0].length - prevIndex + 1);
        }
        return {
            type: 3 /* COMMENT */,
            content,
            loc: getSelection(context, start)
        };
    }
    function parseBogusComment(context) {
        const start = getCursor(context);
        const contentStart = context.source[1] === '?' ? 1 : 2;
        let content;
        const closeIndex = context.source.indexOf('>');
        if (closeIndex === -1) {
            content = context.source.slice(contentStart);
            advanceBy(context, context.source.length);
        }
        else {
            content = context.source.slice(contentStart, closeIndex);
            advanceBy(context, closeIndex + 1);
        }
        return {
            type: 3 /* COMMENT */,
            content,
            loc: getSelection(context, start)
        };
    }
    function parseElement(context, ancestors) {
        // Start tag.
        const wasInPre = context.inPre;
        const parent = last(ancestors);
        const element = parseTag(context, 0 /* Start */, parent);
        const isPreBoundary = context.inPre && !wasInPre;
        if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {
            return element;
        }
        // Children.
        ancestors.push(element);
        const mode = context.options.getTextMode(element.tag, element.ns, parent);
        const children = parseChildren(context, mode, ancestors);
        ancestors.pop();
        element.children = children;
        // End tag.
        if (startsWithEndTagOpen(context.source, element.tag)) {
            parseTag(context, 1 /* End */, parent);
        }
        else {
            emitError(context, 32 /* X_MISSING_END_TAG */, 0, element.loc.start);
            if (context.source.length === 0 && element.tag.toLowerCase() === 'script') {
                const first = children[0];
                if (first && startsWith(first.loc.source, '<!--')) {
                    emitError(context, 11 /* EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */);
                }
            }
        }
        element.loc = getSelection(context, element.loc.start);
        if (isPreBoundary) {
            context.inPre = false;
        }
        return element;
    }
    /**
     * Parse a tag (E.g. `<div id=a>`) with that type (start tag or end tag).
     */
    function parseTag(context, type, parent) {
        // Tag open.
        const start = getCursor(context);
        const match = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context.source);
        const tag = match[1];
        const ns = context.options.getNamespace(tag, parent);
        advanceBy(context, match[0].length);
        advanceSpaces(context);
        // save current state in case we need to re-parse attributes with v-pre
        const cursor = getCursor(context);
        const currentSource = context.source;
        // Attributes.
        let props = parseAttributes(context, type);
        // check v-pre
        if (!context.inPre &&
            props.some(p => p.type === 7 /* DIRECTIVE */ && p.name === 'pre')) {
            context.inPre = true;
            // reset context
            extend(context, cursor);
            context.source = currentSource;
            // re-parse attrs and filter out v-pre itself
            props = parseAttributes(context, type).filter(p => p.name !== 'v-pre');
        }
        // Tag close.
        let isSelfClosing = false;
        if (context.source.length === 0) {
            emitError(context, 12 /* EOF_IN_TAG */);
        }
        else {
            isSelfClosing = startsWith(context.source, '/>');
            if (type === 1 /* End */ && isSelfClosing) {
                emitError(context, 7 /* END_TAG_WITH_TRAILING_SOLIDUS */);
            }
            advanceBy(context, isSelfClosing ? 2 : 1);
        }
        let tagType = 0 /* ELEMENT */;
        const options = context.options;
        if (!context.inPre && !options.isCustomElement(tag)) {
            if (options.isNativeTag) {
                if (!options.isNativeTag(tag))
                    tagType = 1 /* COMPONENT */;
            }
            else if (isCoreComponent(tag) ||
                (options.isBuiltInComponent && options.isBuiltInComponent(tag)) ||
                /^[A-Z]/.test(tag)) {
                tagType = 1 /* COMPONENT */;
            }
            if (tag === 'slot') {
                tagType = 2 /* SLOT */;
            }
            else if (tag === 'template') {
                tagType = 3 /* TEMPLATE */;
            }
        }
        return {
            type: 1 /* ELEMENT */,
            ns,
            tag,
            tagType,
            props,
            isSelfClosing,
            children: [],
            loc: getSelection(context, start),
            codegenNode: undefined // to be created during transform phase
        };
    }
    function parseAttributes(context, type) {
        const props = [];
        const attributeNames = new Set();
        while (context.source.length > 0 &&
            !startsWith(context.source, '>') &&
            !startsWith(context.source, '/>')) {
            if (startsWith(context.source, '/')) {
                emitError(context, 29 /* UNEXPECTED_SOLIDUS_IN_TAG */);
                advanceBy(context, 1);
                advanceSpaces(context);
                continue;
            }
            if (type === 1 /* End */) {
                emitError(context, 6 /* END_TAG_WITH_ATTRIBUTES */);
            }
            const attr = parseAttribute(context, attributeNames);
            if (type === 0 /* Start */) {
                props.push(attr);
            }
            if (/^[^\t\r\n\f />]/.test(context.source)) {
                emitError(context, 19 /* MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */);
            }
            advanceSpaces(context);
        }
        return props;
    }
    function parseAttribute(context, nameSet) {
        // Name.
        const start = getCursor(context);
        const match = /^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(context.source);
        const name = match[0];
        if (nameSet.has(name)) {
            emitError(context, 5 /* DUPLICATE_ATTRIBUTE */);
        }
        nameSet.add(name);
        if (name[0] === '=') {
            emitError(context, 26 /* UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */);
        }
        {
            const pattern = /["'<]/g;
            let m;
            while ((m = pattern.exec(name)) !== null) {
                emitError(context, 24 /* UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */, m.index);
            }
        }
        advanceBy(context, name.length);
        // Value
        let value = undefined;
        if (/^[\t\r\n\f ]*=/.test(context.source)) {
            advanceSpaces(context);
            advanceBy(context, 1);
            advanceSpaces(context);
            value = parseAttributeValue(context);
            if (!value) {
                emitError(context, 16 /* MISSING_ATTRIBUTE_VALUE */);
            }
        }
        const loc = getSelection(context, start);
        if (!context.inPre && /^(v-|:|@|#)/.test(name)) {
            const match = /(?:^v-([a-z0-9-]+))?(?:(?::|^@|^#)([^\.]+))?(.+)?$/i.exec(name);
            let arg;
            if (match[2]) {
                const startOffset = name.indexOf(match[2]);
                const loc = getSelection(context, getNewPosition(context, start, startOffset), getNewPosition(context, start, startOffset + match[2].length));
                let content = match[2];
                let isStatic = true;
                if (content.startsWith('[')) {
                    isStatic = false;
                    if (!content.endsWith(']')) {
                        emitError(context, 34 /* X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */);
                    }
                    content = content.substr(1, content.length - 2);
                }
                arg = {
                    type: 4 /* SIMPLE_EXPRESSION */,
                    content,
                    isStatic,
                    isConstant: isStatic,
                    loc
                };
            }
            if (value && value.isQuoted) {
                const valueLoc = value.loc;
                valueLoc.start.offset++;
                valueLoc.start.column++;
                valueLoc.end = advancePositionWithClone(valueLoc.start, value.content);
                valueLoc.source = valueLoc.source.slice(1, -1);
            }
            return {
                type: 7 /* DIRECTIVE */,
                name: match[1] ||
                    (startsWith(name, ':')
                        ? 'bind'
                        : startsWith(name, '@')
                            ? 'on'
                            : 'slot'),
                exp: value && {
                    type: 4 /* SIMPLE_EXPRESSION */,
                    content: value.content,
                    isStatic: false,
                    // Treat as non-constant by default. This can be potentially set to
                    // true by `transformExpression` to make it eligible for hoisting.
                    isConstant: false,
                    loc: value.loc
                },
                arg,
                modifiers: match[3] ? match[3].substr(1).split('.') : [],
                loc
            };
        }
        return {
            type: 6 /* ATTRIBUTE */,
            name,
            value: value && {
                type: 2 /* TEXT */,
                content: value.content,
                loc: value.loc
            },
            loc
        };
    }
    function parseAttributeValue(context) {
        const start = getCursor(context);
        let content;
        const quote = context.source[0];
        const isQuoted = quote === `"` || quote === `'`;
        if (isQuoted) {
            // Quoted value.
            advanceBy(context, 1);
            const endIndex = context.source.indexOf(quote);
            if (endIndex === -1) {
                content = parseTextData(context, context.source.length, 4 /* ATTRIBUTE_VALUE */);
            }
            else {
                content = parseTextData(context, endIndex, 4 /* ATTRIBUTE_VALUE */);
                advanceBy(context, 1);
            }
        }
        else {
            // Unquoted
            const match = /^[^\t\r\n\f >]+/.exec(context.source);
            if (!match) {
                return undefined;
            }
            let unexpectedChars = /["'<=`]/g;
            let m;
            while ((m = unexpectedChars.exec(match[0])) !== null) {
                emitError(context, 25 /* UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */, m.index);
            }
            content = parseTextData(context, match[0].length, 4 /* ATTRIBUTE_VALUE */);
        }
        return { content, isQuoted, loc: getSelection(context, start) };
    }
    function parseInterpolation(context, mode) {
        const [open, close] = context.options.delimiters;
        const closeIndex = context.source.indexOf(close, open.length);
        if (closeIndex === -1) {
            emitError(context, 33 /* X_MISSING_INTERPOLATION_END */);
            return undefined;
        }
        const start = getCursor(context);
        advanceBy(context, open.length);
        const innerStart = getCursor(context);
        const innerEnd = getCursor(context);
        const rawContentLength = closeIndex - open.length;
        const rawContent = context.source.slice(0, rawContentLength);
        const preTrimContent = parseTextData(context, rawContentLength, mode);
        const content = preTrimContent.trim();
        const startOffset = preTrimContent.indexOf(content);
        if (startOffset > 0) {
            advancePositionWithMutation(innerStart, rawContent, startOffset);
        }
        const endOffset = rawContentLength - (preTrimContent.length - content.length - startOffset);
        advancePositionWithMutation(innerEnd, rawContent, endOffset);
        advanceBy(context, close.length);
        return {
            type: 5 /* INTERPOLATION */,
            content: {
                type: 4 /* SIMPLE_EXPRESSION */,
                isStatic: false,
                // Set `isConstant` to false by default and will decide in transformExpression
                isConstant: false,
                content,
                loc: getSelection(context, innerStart, innerEnd)
            },
            loc: getSelection(context, start)
        };
    }
    function parseText(context, mode) {
        const endTokens = ['<', context.options.delimiters[0]];
        if (mode === 3 /* CDATA */) {
            endTokens.push(']]>');
        }
        let endIndex = context.source.length;
        for (let i = 0; i < endTokens.length; i++) {
            const index = context.source.indexOf(endTokens[i], 1);
            if (index !== -1 && endIndex > index) {
                endIndex = index;
            }
        }
        const start = getCursor(context);
        const content = parseTextData(context, endIndex, mode);
        return {
            type: 2 /* TEXT */,
            content,
            loc: getSelection(context, start)
        };
    }
    /**
     * Get text data with a given length from the current location.
     * This translates HTML entities in the text data.
     */
    function parseTextData(context, length, mode) {
        let rawText = context.source.slice(0, length);
        if (mode === 2 /* RAWTEXT */ ||
            mode === 3 /* CDATA */ ||
            rawText.indexOf('&') === -1) {
            advanceBy(context, length);
            return rawText;
        }
        // DATA or RCDATA containing "&"". Entity decoding required.
        const end = context.offset + length;
        let decodedText = '';
        function advance(length) {
            advanceBy(context, length);
            rawText = rawText.slice(length);
        }
        while (context.offset < end) {
            const head = /&(?:#x?)?/i.exec(rawText);
            if (!head || context.offset + head.index >= end) {
                const remaining = end - context.offset;
                decodedText += rawText.slice(0, remaining);
                advance(remaining);
                break;
            }
            // Advance to the "&".
            decodedText += rawText.slice(0, head.index);
            advance(head.index);
            if (head[0] === '&') {
                // Named character reference.
                let name = '', value = undefined;
                if (/[0-9a-z]/i.test(rawText[1])) {
                    for (let length = context.options.maxCRNameLength; !value && length > 0; --length) {
                        name = rawText.substr(1, length);
                        value = context.options.namedCharacterReferences[name];
                    }
                    if (value) {
                        const semi = name.endsWith(';');
                        if (mode === 4 /* ATTRIBUTE_VALUE */ &&
                            !semi &&
                            /[=a-z0-9]/i.test(rawText[1 + name.length] || '')) {
                            decodedText += '&' + name;
                            advance(1 + name.length);
                        }
                        else {
                            decodedText += value;
                            advance(1 + name.length);
                            if (!semi) {
                                emitError(context, 18 /* MISSING_SEMICOLON_AFTER_CHARACTER_REFERENCE */);
                            }
                        }
                    }
                    else {
                        emitError(context, 30 /* UNKNOWN_NAMED_CHARACTER_REFERENCE */);
                        decodedText += '&' + name;
                        advance(1 + name.length);
                    }
                }
                else {
                    decodedText += '&';
                    advance(1);
                }
            }
            else {
                // Numeric character reference.
                const hex = head[0] === '&#x';
                const pattern = hex ? /^&#x([0-9a-f]+);?/i : /^&#([0-9]+);?/;
                const body = pattern.exec(rawText);
                if (!body) {
                    decodedText += head[0];
                    emitError(context, 1 /* ABSENCE_OF_DIGITS_IN_NUMERIC_CHARACTER_REFERENCE */);
                    advance(head[0].length);
                }
                else {
                    // https://html.spec.whatwg.org/multipage/parsing.html#numeric-character-reference-end-state
                    let cp = Number.parseInt(body[1], hex ? 16 : 10);
                    if (cp === 0) {
                        emitError(context, 22 /* NULL_CHARACTER_REFERENCE */);
                        cp = 0xfffd;
                    }
                    else if (cp > 0x10ffff) {
                        emitError(context, 3 /* CHARACTER_REFERENCE_OUTSIDE_UNICODE_RANGE */);
                        cp = 0xfffd;
                    }
                    else if (cp >= 0xd800 && cp <= 0xdfff) {
                        emitError(context, 23 /* SURROGATE_CHARACTER_REFERENCE */);
                        cp = 0xfffd;
                    }
                    else if ((cp >= 0xfdd0 && cp <= 0xfdef) || (cp & 0xfffe) === 0xfffe) {
                        emitError(context, 21 /* NONCHARACTER_CHARACTER_REFERENCE */);
                    }
                    else if ((cp >= 0x01 && cp <= 0x08) ||
                        cp === 0x0b ||
                        (cp >= 0x0d && cp <= 0x1f) ||
                        (cp >= 0x7f && cp <= 0x9f)) {
                        emitError(context, 4 /* CONTROL_CHARACTER_REFERENCE */);
                        cp = CCR_REPLACEMENTS[cp] || cp;
                    }
                    decodedText += String.fromCodePoint(cp);
                    advance(body[0].length);
                    if (!body[0].endsWith(';')) {
                        emitError(context, 18 /* MISSING_SEMICOLON_AFTER_CHARACTER_REFERENCE */);
                    }
                }
            }
        }
        return decodedText;
    }
    function getCursor(context) {
        const { column, line, offset } = context;
        return { column, line, offset };
    }
    function getSelection(context, start, end) {
        end = end || getCursor(context);
        return {
            start,
            end,
            source: context.originalSource.slice(start.offset, end.offset)
        };
    }
    function last(xs) {
        return xs[xs.length - 1];
    }
    function startsWith(source, searchString) {
        return source.startsWith(searchString);
    }
    function advanceBy(context, numberOfCharacters) {
        const { source } = context;
        advancePositionWithMutation(context, source, numberOfCharacters);
        context.source = source.slice(numberOfCharacters);
    }
    function advanceSpaces(context) {
        const match = /^[\t\r\n\f ]+/.exec(context.source);
        if (match) {
            advanceBy(context, match[0].length);
        }
    }
    function getNewPosition(context, start, numberOfCharacters) {
        return advancePositionWithClone(start, context.originalSource.slice(start.offset, numberOfCharacters), numberOfCharacters);
    }
    function emitError(context, code, offset, loc = getCursor(context)) {
        if (offset) {
            loc.offset += offset;
            loc.column += offset;
        }
        context.options.onError(createCompilerError(code, {
            start: loc,
            end: loc,
            source: ''
        }));
    }
    function isEnd(context, mode, ancestors) {
        const s = context.source;
        switch (mode) {
            case 0 /* DATA */:
                if (startsWith(s, '</')) {
                    //TODO: probably bad performance
                    for (let i = ancestors.length - 1; i >= 0; --i) {
                        if (startsWithEndTagOpen(s, ancestors[i].tag)) {
                            return true;
                        }
                    }
                }
                break;
            case 1 /* RCDATA */:
            case 2 /* RAWTEXT */: {
                const parent = last(ancestors);
                if (parent && startsWithEndTagOpen(s, parent.tag)) {
                    return true;
                }
                break;
            }
            case 3 /* CDATA */:
                if (startsWith(s, ']]>')) {
                    return true;
                }
                break;
        }
        return !s;
    }
    function startsWithEndTagOpen(source, tag) {
        return (startsWith(source, '</') &&
            source.substr(2, tag.length).toLowerCase() === tag.toLowerCase() &&
            /[\t\n\f />]/.test(source[2 + tag.length] || '>'));
    }
    function hoistStatic(root, context) {
        walk(root.children, context, new Map(), isSingleElementRoot(root, root.children[0]));
    }
    function isSingleElementRoot(root, child) {
        const { children } = root;
        return (children.length === 1 &&
            child.type === 1 /* ELEMENT */ &&
            !isSlotOutlet(child));
    }
    function walk(children, context, resultCache, doNotHoistNode = false) {
        for (let i = 0; i < children.length; i++) {
            const child = children[i];
            // only plain elements are eligible for hoisting.
            if (child.type === 1 /* ELEMENT */ &&
                child.tagType === 0 /* ELEMENT */) {
                if (!doNotHoistNode && isStaticNode(child, resultCache)) {
                    // whole tree is static
                    child.codegenNode = context.hoist(child.codegenNode);
                    continue;
                }
                else {
                    // node may contain dynamic children, but its props may be eligible for
                    // hoisting.
                    const codegenNode = child.codegenNode;
                    if (codegenNode.type === 13 /* JS_CALL_EXPRESSION */) {
                        const flag = getPatchFlag(codegenNode);
                        if ((!flag ||
                            flag === 32 /* NEED_PATCH */ ||
                            flag === 1 /* TEXT */) &&
                            !hasDynamicKeyOrRef(child) &&
                            !hasCachedProps()) {
                            const props = getNodeProps(child);
                            if (props && props !== `null`) {
                                getVNodeCall(codegenNode).arguments[1] = context.hoist(props);
                            }
                        }
                    }
                }
            }
            if (child.type === 1 /* ELEMENT */) {
                walk(child.children, context, resultCache);
            }
            else if (child.type === 11 /* FOR */) {
                // Do not hoist v-for single child because it has to be a block
                walk(child.children, context, resultCache, child.children.length === 1);
            }
            else if (child.type === 9 /* IF */) {
                for (let i = 0; i < child.branches.length; i++) {
                    const branchChildren = child.branches[i].children;
                    // Do not hoist v-if single child because it has to be a block
                    walk(branchChildren, context, resultCache, branchChildren.length === 1);
                }
            }
        }
    }
    function isStaticNode(node, resultCache = new Map()) {
        switch (node.type) {
            case 1 /* ELEMENT */:
                if (node.tagType !== 0 /* ELEMENT */) {
                    return false;
                }
                const cached = resultCache.get(node);
                if (cached !== undefined) {
                    return cached;
                }
                const codegenNode = node.codegenNode;
                if (codegenNode.type !== 13 /* JS_CALL_EXPRESSION */) {
                    return false;
                }
                const flag = getPatchFlag(codegenNode);
                if (!flag && !hasDynamicKeyOrRef(node) && !hasCachedProps()) {
                    // element self is static. check its children.
                    for (let i = 0; i < node.children.length; i++) {
                        if (!isStaticNode(node.children[i], resultCache)) {
                            resultCache.set(node, false);
                            return false;
                        }
                    }
                    resultCache.set(node, true);
                    return true;
                }
                else {
                    resultCache.set(node, false);
                    return false;
                }
            case 2 /* TEXT */:
            case 3 /* COMMENT */:
                return true;
            case 9 /* IF */:
            case 11 /* FOR */:
                return false;
            case 5 /* INTERPOLATION */:
            case 12 /* TEXT_CALL */:
                return isStaticNode(node.content, resultCache);
            case 4 /* SIMPLE_EXPRESSION */:
                return node.isConstant;
            case 8 /* COMPOUND_EXPRESSION */:
                return node.children.every(child => {
                    return (isString(child) || isSymbol(child) || isStaticNode(child, resultCache));
                });
            default:
                return false;
        }
    }
    function hasDynamicKeyOrRef(node) {
        return !!(findProp(node, 'key', true) || findProp(node, 'ref', true));
    }
    function hasCachedProps(node) {
        {
            return false;
        }
    }
    function getNodeProps(node) {
        const codegenNode = node.codegenNode;
        if (codegenNode.type === 13 /* JS_CALL_EXPRESSION */) {
            return getVNodeArgAt(codegenNode, 1);
        }
    }
    function getVNodeArgAt(node, index) {
        return getVNodeCall(node).arguments[index];
    }
    function getVNodeCall(node) {
        return node.callee === WITH_DIRECTIVES ? node.arguments[0] : node;
    }
    function getPatchFlag(node) {
        const flag = getVNodeArgAt(node, 3);
        return flag ? parseInt(flag, 10) : undefined;
    }
    function createTransformContext(root, { prefixIdentifiers = false, hoistStatic = false, cacheHandlers = false, nodeTransforms = [], directiveTransforms = {}, isBuiltInComponent = NOOP, onError = defaultOnError }) {
        const context = {
            // options
            prefixIdentifiers,
            hoistStatic,
            cacheHandlers,
            nodeTransforms,
            directiveTransforms,
            isBuiltInComponent,
            onError,
            // state
            root,
            helpers: new Set(),
            components: new Set(),
            directives: new Set(),
            hoists: [],
            imports: new Set(),
            cached: 0,
            identifiers: {},
            scopes: {
                vFor: 0,
                vSlot: 0,
                vPre: 0,
                vOnce: 0
            },
            parent: null,
            currentNode: root,
            childIndex: 0,
            // methods
            helper(name) {
                context.helpers.add(name);
                return name;
            },
            helperString(name) {
                return ((context.prefixIdentifiers ? `` : `_`) +
                    helperNameMap[context.helper(name)]);
            },
            replaceNode(node) {
                /* istanbul ignore if */
                {
                    if (!context.currentNode) {
                        throw new Error(`Node being replaced is already removed.`);
                    }
                    if (!context.parent) {
                        throw new Error(`Cannot replace root node.`);
                    }
                }
                context.parent.children[context.childIndex] = context.currentNode = node;
            },
            removeNode(node) {
                if (!context.parent) {
                    throw new Error(`Cannot remove root node.`);
                }
                const list = context.parent.children;
                const removalIndex = node
                    ? list.indexOf(node)
                    : context.currentNode
                        ? context.childIndex
                        : -1;
                /* istanbul ignore if */
                if (removalIndex < 0) {
                    throw new Error(`node being removed is not a child of current parent`);
                }
                if (!node || node === context.currentNode) {
                    // current node removed
                    context.currentNode = null;
                    context.onNodeRemoved();
                }
                else {
                    // sibling node removed
                    if (context.childIndex > removalIndex) {
                        context.childIndex--;
                        context.onNodeRemoved();
                    }
                }
                context.parent.children.splice(removalIndex, 1);
            },
            onNodeRemoved: () => { },
            addIdentifiers(exp) {
            },
            removeIdentifiers(exp) {
            },
            hoist(exp) {
                context.hoists.push(exp);
                return createSimpleExpression(`_hoisted_${context.hoists.length}`, false, exp.loc, true);
            },
            cache(exp, isVNode = false) {
                return createCacheExpression(++context.cached, exp, isVNode);
            }
        };
        return context;
    }
    function transform(root, options) {
        const context = createTransformContext(root, options);
        traverseNode(root, context);
        if (options.hoistStatic) {
            hoistStatic(root, context);
        }
        finalizeRoot(root, context);
    }
    function finalizeRoot(root, context) {
        const { helper } = context;
        const { children } = root;
        const child = children[0];
        if (children.length === 1) {
            // if the single child is an element, turn it into a block.
            if (isSingleElementRoot(root, child) && child.codegenNode) {
                // single element root is never hoisted so codegenNode will never be
                // SimpleExpressionNode
                const codegenNode = child.codegenNode;
                if (codegenNode.type !== 20 /* JS_CACHE_EXPRESSION */) {
                    if (codegenNode.callee === WITH_DIRECTIVES) {
                        codegenNode.arguments[0].callee = helper(CREATE_BLOCK);
                    }
                    else {
                        codegenNode.callee = helper(CREATE_BLOCK);
                    }
                    root.codegenNode = createBlockExpression(codegenNode, context);
                }
                else {
                    root.codegenNode = codegenNode;
                }
            }
            else {
                // - single <slot/>, IfNode, ForNode: already blocks.
                // - single text node: always patched.
                // root codegen falls through via genNode()
                root.codegenNode = child;
            }
        }
        else if (children.length > 1) {
            // root has multiple nodes - return a fragment block.
            root.codegenNode = createBlockExpression(createCallExpression(helper(CREATE_BLOCK), [
                helper(FRAGMENT),
                `null`,
                root.children,
                `${64 /* STABLE_FRAGMENT */} /* ${PatchFlagNames[64 /* STABLE_FRAGMENT */]} */`
            ]), context);
        }
        // finalize meta information
        root.helpers = [...context.helpers];
        root.components = [...context.components];
        root.directives = [...context.directives];
        root.imports = [...context.imports];
        root.hoists = context.hoists;
        root.cached = context.cached;
    }
    function traverseChildren(parent, context) {
        let i = 0;
        const nodeRemoved = () => {
            i--;
        };
        for (; i < parent.children.length; i++) {
            const child = parent.children[i];
            if (isString(child))
                continue;
            context.currentNode = child;
            context.parent = parent;
            context.childIndex = i;
            context.onNodeRemoved = nodeRemoved;
            traverseNode(child, context);
        }
    }
    function traverseNode(node, context) {
        // apply transform plugins
        const { nodeTransforms } = context;
        const exitFns = [];
        for (let i = 0; i < nodeTransforms.length; i++) {
            const onExit = nodeTransforms[i](node, context);
            if (onExit) {
                if (isArray(onExit)) {
                    exitFns.push(...onExit);
                }
                else {
                    exitFns.push(onExit);
                }
            }
            if (!context.currentNode) {
                // node was removed
                return;
            }
            else {
                // node may have been replaced
                node = context.currentNode;
            }
        }
        switch (node.type) {
            case 3 /* COMMENT */:
                // inject import for the Comment symbol, which is needed for creating
                // comment nodes with `createVNode`
                context.helper(CREATE_COMMENT);
                break;
            case 5 /* INTERPOLATION */:
                // no need to traverse, but we need to inject toString helper
                context.helper(TO_DISPLAY_STRING);
                break;
            // for container types, further traverse downwards
            case 9 /* IF */:
                for (let i = 0; i < node.branches.length; i++) {
                    traverseChildren(node.branches[i], context);
                }
                break;
            case 11 /* FOR */:
            case 1 /* ELEMENT */:
            case 0 /* ROOT */:
                traverseChildren(node, context);
                break;
        }
        // exit transforms
        let i = exitFns.length;
        while (i--) {
            exitFns[i]();
        }
    }
    function createStructuralDirectiveTransform(name, fn) {
        const matches = isString(name)
            ? (n) => n === name
            : (n) => name.test(n);
        return (node, context) => {
            if (node.type === 1 /* ELEMENT */) {
                const { props } = node;
                // structural directive transforms are not concerned with slots
                // as they are handled separately in vSlot.ts
                if (node.tagType === 3 /* TEMPLATE */ && props.some(isVSlot)) {
                    return;
                }
                const exitFns = [];
                for (let i = 0; i < props.length; i++) {
                    const prop = props[i];
                    if (prop.type === 7 /* DIRECTIVE */ && matches(prop.name)) {
                        // structural directives are removed to avoid infinite recursion
                        // also we remove them *before* applying so that it can further
                        // traverse itself in case it moves the node around
                        props.splice(i, 1);
                        i--;
                        const onExit = fn(node, prop, context);
                        if (onExit)
                            exitFns.push(onExit);
                    }
                }
                return exitFns;
            }
        };
    }
    function createCodegenContext(ast, { mode = 'function', prefixIdentifiers = mode === 'module', sourceMap = false, filename = `template.vue.html`, scopeId = null }) {
        const context = {
            mode,
            prefixIdentifiers,
            sourceMap,
            filename,
            scopeId,
            source: ast.loc.source,
            code: ``,
            column: 1,
            line: 1,
            offset: 0,
            indentLevel: 0,
            map: undefined,
            helper(key) {
                const name = helperNameMap[key];
                return prefixIdentifiers ? name : `_${name}`;
            },
            push(code, node) {
                context.code += code;
            },
            indent() {
                newline(++context.indentLevel);
            },
            deindent(withoutNewLine = false) {
                if (withoutNewLine) {
                    --context.indentLevel;
                }
                else {
                    newline(--context.indentLevel);
                }
            },
            newline() {
                newline(context.indentLevel);
            }
        };
        function newline(n) {
            context.push('\n' + `  `.repeat(n));
        }
        return context;
    }
    function generate(ast, options = {}) {
        const context = createCodegenContext(ast, options);
        const { mode, push, helper, prefixIdentifiers, indent, deindent, newline, scopeId } = context;
        const hasHelpers = ast.helpers.length > 0;
        const useWithBlock = !prefixIdentifiers && mode !== 'module';
        // preambles
        if (mode === 'function') {
            // Generate const declaration for helpers
            // In prefix mode, we place the const declaration at top so it's done
            // only once; But if we not prefixing, we place the declaration inside the
            // with block so it doesn't incur the `in` check cost for every helper access.
            if (hasHelpers) {
                if (prefixIdentifiers) {
                    push(`const { ${ast.helpers.map(helper).join(', ')} } = Vue\n`);
                }
                else {
                    // "with" mode.
                    // save Vue in a separate variable to avoid collision
                    push(`const _Vue = Vue\n`);
                    // in "with" mode, helpers are declared inside the with block to avoid
                    // has check cost, but hoists are lifted out of the function - we need
                    // to provide the helper here.
                    if (ast.hoists.length) {
                        const staticHelpers = [CREATE_VNODE, CREATE_COMMENT, CREATE_TEXT]
                            .filter(helper => ast.helpers.includes(helper))
                            .map(s => `${helperNameMap[s]}: _${helperNameMap[s]}`)
                            .join(', ');
                        push(`const { ${staticHelpers} } = Vue\n`);
                    }
                }
            }
            genHoists(ast.hoists, context);
            newline();
            push(`return `);
        }
        else {
            if (hasHelpers) {
                push(`import { ${ast.helpers.map(helper).join(', ')} } from "vue"\n`);
            }
            if (ast.imports.length) {
                genImports(ast.imports, context);
                newline();
            }
            genHoists(ast.hoists, context);
            newline();
            push(`export `);
        }
        push(`function render() {`);
        indent();
        if (useWithBlock) {
            push(`with (this) {`);
            indent();
            // function mode const declarations should be inside with block
            // also they should be renamed to avoid collision with user properties
            if (hasHelpers) {
                push(`const { ${ast.helpers
                    .map(s => `${helperNameMap[s]}: _${helperNameMap[s]}`)
                    .join(', ')} } = _Vue`);
                newline();
                if (ast.cached > 0) {
                    push(`const _cache = $cache`);
                    newline();
                }
                newline();
            }
        }
        else {
            push(`const _ctx = this`);
            if (ast.cached > 0) {
                newline();
                push(`const _cache = _ctx.$cache`);
            }
            newline();
        }
        // generate asset resolution statements
        if (ast.components.length) {
            genAssets(ast.components, 'component', context);
        }
        if (ast.directives.length) {
            genAssets(ast.directives, 'directive', context);
        }
        if (ast.components.length || ast.directives.length) {
            newline();
        }
        // generate the VNode tree expression
        push(`return `);
        if (ast.codegenNode) {
            genNode(ast.codegenNode, context);
        }
        else {
            push(`null`);
        }
        if (useWithBlock) {
            deindent();
            push(`}`);
        }
        deindent();
        push(`}`);
        return {
            ast,
            code: context.code,
            // SourceMapGenerator does have toJSON() method but it's not in the types
            map: context.map ? context.map.toJSON() : undefined
        };
    }
    function genAssets(assets, type, context) {
        const resolver = context.helper(type === 'component' ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE);
        for (let i = 0; i < assets.length; i++) {
            const id = assets[i];
            context.push(`const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)})`);
            context.newline();
        }
    }
    function genHoists(hoists, context) {
        if (!hoists.length) {
            return;
        }
        const { push, newline, helper, scopeId, mode } = context;
        newline();
        hoists.forEach((exp, i) => {
            push(`const _hoisted_${i + 1} = `);
            genNode(exp, context);
            newline();
        });
    }
    function genImports(importsOptions, context) {
        if (!importsOptions.length) {
            return;
        }
        importsOptions.forEach(imports => {
            context.push(`import `);
            genNode(imports.exp, context);
            context.push(` from '${imports.path}'`);
            context.newline();
        });
    }
    function isText(n) {
        return (isString(n) ||
            n.type === 4 /* SIMPLE_EXPRESSION */ ||
            n.type === 2 /* TEXT */ ||
            n.type === 5 /* INTERPOLATION */ ||
            n.type === 8 /* COMPOUND_EXPRESSION */);
    }
    function genNodeListAsArray(nodes, context) {
        const multilines = nodes.length > 3 ||
            (nodes.some(n => isArray(n) || !isText(n)));
        context.push(`[`);
        multilines && context.indent();
        genNodeList(nodes, context, multilines);
        multilines && context.deindent();
        context.push(`]`);
    }
    function genNodeList(nodes, context, multilines = false) {
        const { push, newline } = context;
        for (let i = 0; i < nodes.length; i++) {
            const node = nodes[i];
            if (isString(node)) {
                push(node);
            }
            else if (isArray(node)) {
                genNodeListAsArray(node, context);
            }
            else {
                genNode(node, context);
            }
            if (i < nodes.length - 1) {
                if (multilines) {
                    push(',');
                    newline();
                }
                else {
                    push(', ');
                }
            }
        }
    }
    function genNode(node, context) {
        if (isString(node)) {
            context.push(node);
            return;
        }
        if (isSymbol(node)) {
            context.push(context.helper(node));
            return;
        }
        switch (node.type) {
            case 1 /* ELEMENT */:
            case 9 /* IF */:
            case 11 /* FOR */:
                assert(node.codegenNode != null, `Codegen node is missing for element/if/for node. ` +
                    `Apply appropriate transforms first.`);
                genNode(node.codegenNode, context);
                break;
            case 2 /* TEXT */:
                genText(node, context);
                break;
            case 4 /* SIMPLE_EXPRESSION */:
                genExpression(node, context);
                break;
            case 5 /* INTERPOLATION */:
                genInterpolation(node, context);
                break;
            case 12 /* TEXT_CALL */:
                genNode(node.codegenNode, context);
                break;
            case 8 /* COMPOUND_EXPRESSION */:
                genCompoundExpression(node, context);
                break;
            case 3 /* COMMENT */:
                genComment(node, context);
                break;
            case 13 /* JS_CALL_EXPRESSION */:
                genCallExpression(node, context);
                break;
            case 14 /* JS_OBJECT_EXPRESSION */:
                genObjectExpression(node, context);
                break;
            case 16 /* JS_ARRAY_EXPRESSION */:
                genArrayExpression(node, context);
                break;
            case 17 /* JS_FUNCTION_EXPRESSION */:
                genFunctionExpression(node, context);
                break;
            case 18 /* JS_SEQUENCE_EXPRESSION */:
                genSequenceExpression(node, context);
                break;
            case 19 /* JS_CONDITIONAL_EXPRESSION */:
                genConditionalExpression(node, context);
                break;
            case 20 /* JS_CACHE_EXPRESSION */:
                genCacheExpression(node, context);
                break;
            /* istanbul ignore next */
            default:
                {
                    assert(false, `unhandled codegen node type: ${node.type}`);
                    // make sure we exhaust all possible types
                    const exhaustiveCheck = node;
                    return exhaustiveCheck;
                }
        }
    }
    function genText(node, context) {
        context.push(JSON.stringify(node.content), node);
    }
    function genExpression(node, context) {
        const { content, isStatic } = node;
        context.push(isStatic ? JSON.stringify(content) : content, node);
    }
    function genInterpolation(node, context) {
        const { push, helper } = context;
        push(`${helper(TO_DISPLAY_STRING)}(`);
        genNode(node.content, context);
        push(`)`);
    }
    function genCompoundExpression(node, context) {
        for (let i = 0; i < node.children.length; i++) {
            const child = node.children[i];
            if (isString(child)) {
                context.push(child);
            }
            else {
                genNode(child, context);
            }
        }
    }
    function genExpressionAsPropertyKey(node, context) {
        const { push } = context;
        if (node.type === 8 /* COMPOUND_EXPRESSION */) {
            push(`[`);
            genCompoundExpression(node, context);
            push(`]`);
        }
        else if (node.isStatic) {
            // only quote keys if necessary
            const text = isSimpleIdentifier(node.content)
                ? node.content
                : JSON.stringify(node.content);
            push(text, node);
        }
        else {
            push(`[${node.content}]`, node);
        }
    }
    function genComment(node, context) {
        {
            const { push, helper } = context;
            push(`${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`, node);
        }
    }
    // JavaScript
    function genCallExpression(node, context) {
        const callee = isString(node.callee)
            ? node.callee
            : context.helper(node.callee);
        context.push(callee + `(`, node);
        genNodeList(node.arguments, context);
        context.push(`)`);
    }
    function genObjectExpression(node, context) {
        const { push, indent, deindent, newline } = context;
        const { properties } = node;
        if (!properties.length) {
            push(`{}`, node);
            return;
        }
        const multilines = properties.length > 1 ||
            (properties.some(p => p.value.type !== 4 /* SIMPLE_EXPRESSION */));
        push(multilines ? `{` : `{ `);
        multilines && indent();
        for (let i = 0; i < properties.length; i++) {
            const { key, value } = properties[i];
            // key
            genExpressionAsPropertyKey(key, context);
            push(`: `);
            // value
            genNode(value, context);
            if (i < properties.length - 1) {
                // will only reach this if it's multilines
                push(`,`);
                newline();
            }
        }
        multilines && deindent();
        push(multilines ? `}` : ` }`);
    }
    function genArrayExpression(node, context) {
        genNodeListAsArray(node.elements, context);
    }
    function genFunctionExpression(node, context) {
        const { push, indent, deindent, scopeId, mode } = context;
        const { params, returns, newline, isSlot } = node;
        push(`(`, node);
        if (isArray(params)) {
            genNodeList(params, context);
        }
        else if (params) {
            genNode(params, context);
        }
        push(`) => `);
        if (newline) {
            push(`{`);
            indent();
            push(`return `);
        }
        if (isArray(returns)) {
            genNodeListAsArray(returns, context);
        }
        else {
            genNode(returns, context);
        }
        if (newline) {
            deindent();
            push(`}`);
        }
    }
    function genConditionalExpression(node, context) {
        const { test, consequent, alternate } = node;
        const { push, indent, deindent, newline } = context;
        if (test.type === 4 /* SIMPLE_EXPRESSION */) {
            const needsParens = !isSimpleIdentifier(test.content);
            needsParens && push(`(`);
            genExpression(test, context);
            needsParens && push(`)`);
        }
        else {
            push(`(`);
            genCompoundExpression(test, context);
            push(`)`);
        }
        indent();
        context.indentLevel++;
        push(`? `);
        genNode(consequent, context);
        context.indentLevel--;
        newline();
        push(`: `);
        const isNested = alternate.type === 19 /* JS_CONDITIONAL_EXPRESSION */;
        if (!isNested) {
            context.indentLevel++;
        }
        genNode(alternate, context);
        if (!isNested) {
            context.indentLevel--;
        }
        deindent(true /* without newline */);
    }
    function genSequenceExpression(node, context) {
        context.push(`(`);
        genNodeList(node.expressions, context);
        context.push(`)`);
    }
    function genCacheExpression(node, context) {
        const { push, helper, indent, deindent, newline } = context;
        push(`_cache[${node.index}] || (`);
        if (node.isVNode) {
            indent();
            push(`${helper(SET_BLOCK_TRACKING)}(-1),`);
            newline();
        }
        push(`_cache[${node.index}] = `);
        genNode(node.value, context);
        if (node.isVNode) {
            push(`,`);
            newline();
            push(`${helper(SET_BLOCK_TRACKING)}(1),`);
            newline();
            push(`_cache[${node.index}]`);
            deindent();
        }
        push(`)`);
    }
    function createIfBranch(node, dir) {
        return {
            type: 10 /* IF_BRANCH */,
            loc: node.loc,
            condition: dir.name === 'else' ? undefined : dir.exp,
            children: node.tagType === 3 /* TEMPLATE */ ? node.children : [node]
        };
    }
    function createCodegenNodeForBranch(branch, index, context) {
        if (branch.condition) {
            return createConditionalExpression(branch.condition, createChildrenCodegenNode(branch, index, context), 
            // make sure to pass in asBlock: true so that the comment node call
            // closes the current block.
            createCallExpression(context.helper(CREATE_COMMENT), [
                '"v-if"',
                'true'
            ]));
        }
        else {
            return createChildrenCodegenNode(branch, index, context);
        }
    }
    function createChildrenCodegenNode(branch, index, context) {
        const { helper } = context;
        const keyProperty = createObjectProperty(`key`, createSimpleExpression(index + '', false));
        const { children } = branch;
        const child = children[0];
        const needFragmentWrapper = children.length !== 1 || child.type !== 1 /* ELEMENT */;
        if (needFragmentWrapper) {
            const blockArgs = [
                helper(FRAGMENT),
                createObjectExpression([keyProperty]),
                children
            ];
            if (children.length === 1 && child.type === 11 /* FOR */) {
                // optimize away nested fragments when child is a ForNode
                const forBlockArgs = child.codegenNode.expressions[1].arguments;
                // directly use the for block's children and patchFlag
                blockArgs[2] = forBlockArgs[2];
                blockArgs[3] = forBlockArgs[3];
            }
            return createCallExpression(helper(CREATE_BLOCK), blockArgs);
        }
        else {
            const childCodegen = child.codegenNode;
            let vnodeCall = childCodegen;
            // Element with custom directives. Locate the actual createVNode() call.
            if (vnodeCall.callee === WITH_DIRECTIVES) {
                vnodeCall = vnodeCall.arguments[0];
            }
            // Change createVNode to createBlock.
            if (vnodeCall.callee === CREATE_VNODE) {
                vnodeCall.callee = helper(CREATE_BLOCK);
            }
            // inject branch key
            injectProp(vnodeCall, keyProperty, context);
            return childCodegen;
        }
    }
    function parseForExpression(input, context) {
        const loc = input.loc;
        const exp = input.content;
        const inMatch = exp.match(forAliasRE);
        if (!inMatch)
            return;
        const [, LHS, RHS] = inMatch;
        const result = {
            source: createAliasExpression(loc, RHS.trim(), exp.indexOf(RHS, LHS.length)),
            value: undefined,
            key: undefined,
            index: undefined
        };
        let valueContent = LHS.trim()
            .replace(stripParensRE, '')
            .trim();
        const trimmedOffset = LHS.indexOf(valueContent);
        const iteratorMatch = valueContent.match(forIteratorRE);
        if (iteratorMatch) {
            valueContent = valueContent.replace(forIteratorRE, '').trim();
            const keyContent = iteratorMatch[1].trim();
            let keyOffset;
            if (keyContent) {
                keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);
                result.key = createAliasExpression(loc, keyContent, keyOffset);
            }
            if (iteratorMatch[2]) {
                const indexContent = iteratorMatch[2].trim();
                if (indexContent) {
                    result.index = createAliasExpression(loc, indexContent, exp.indexOf(indexContent, result.key
                        ? keyOffset + keyContent.length
                        : trimmedOffset + valueContent.length));
                }
            }
        }
        if (valueContent) {
            result.value = createAliasExpression(loc, valueContent, trimmedOffset);
        }
        return result;
    }
    function createAliasExpression(range, content, offset) {
        return createSimpleExpression(content, false, getInnerRange(range, offset, content.length));
    }
    function createForLoopParams({ value, key, index }) {
        const params = [];
        if (value) {
            params.push(value);
        }
        if (key) {
            if (!value) {
                params.push(createSimpleExpression(`_`, false));
            }
            params.push(key);
        }
        if (index) {
            if (!key) {
                if (!value) {
                    params.push(createSimpleExpression(`_`, false));
                }
                params.push(createSimpleExpression(`__`, false));
            }
            params.push(index);
        }
        return params;
    }
    // Instead of being a DirectiveTransform, v-slot processing is called during
    // transformElement to build the slots object for a component.
    function buildSlots(node, context) {
        const { children, loc } = node;
        const slotsProperties = [];
        const dynamicSlots = [];
        // If the slot is inside a v-for or another v-slot, force it to be dynamic
        // since it likely uses a scope variable.
        let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;
        // 1. Check for default slot with slotProps on component itself.
        //    <Comp v-slot="{ prop }"/>
        const onComponentDefaultSlot = findDir(node, 'slot', true);
        if (onComponentDefaultSlot) {
            const { arg, exp, loc } = onComponentDefaultSlot;
            if (arg) {
                context.onError(createCompilerError(42 /* X_V_SLOT_NAMED_SLOT_ON_COMPONENT */, loc));
            }
            slotsProperties.push(buildDefaultSlot(exp, children, loc));
        }
        // 2. Iterate through children and check for template slots
        //    <template v-slot:foo="{ prop }">
        let hasTemplateSlots = false;
        let hasNamedDefaultSlot = false;
        const implicitDefaultChildren = [];
        const seenSlotNames = new Set();
        for (let i = 0; i < children.length; i++) {
            const slotElement = children[i];
            let slotDir;
            if (!isTemplateNode(slotElement) ||
                !(slotDir = findDir(slotElement, 'slot', true))) {
                // not a <template v-slot>, skip.
                if (slotElement.type !== 3 /* COMMENT */) {
                    implicitDefaultChildren.push(slotElement);
                }
                continue;
            }
            if (onComponentDefaultSlot) {
                // already has on-component default slot - this is incorrect usage.
                context.onError(createCompilerError(43 /* X_V_SLOT_MIXED_SLOT_USAGE */, slotDir.loc));
                break;
            }
            hasTemplateSlots = true;
            const { children: slotChildren, loc: slotLoc } = slotElement;
            const { arg: slotName = createSimpleExpression(`default`, true), exp: slotProps, loc: dirLoc } = slotDir;
            // check if name is dynamic.
            let staticSlotName;
            if (isStaticExp(slotName)) {
                staticSlotName = slotName ? slotName.content : `default`;
            }
            else {
                hasDynamicSlots = true;
            }
            const slotFunction = createFunctionExpression(slotProps, slotChildren, false /* newline */, true /* isSlot */, slotChildren.length ? slotChildren[0].loc : slotLoc);
            // check if this slot is conditional (v-if/v-for)
            let vIf;
            let vElse;
            let vFor;
            if ((vIf = findDir(slotElement, 'if'))) {
                hasDynamicSlots = true;
                dynamicSlots.push(createConditionalExpression(vIf.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback));
            }
            else if ((vElse = findDir(slotElement, /^else(-if)?$/, true /* allowEmpty */))) {
                // find adjacent v-if
                let j = i;
                let prev;
                while (j--) {
                    prev = children[j];
                    if (prev.type !== 3 /* COMMENT */) {
                        break;
                    }
                }
                if (prev && isTemplateNode(prev) && findDir(prev, 'if')) {
                    // remove node
                    children.splice(i, 1);
                    i--;
                    // attach this slot to previous conditional
                    let conditional = dynamicSlots[dynamicSlots.length - 1];
                    while (conditional.alternate.type === 19 /* JS_CONDITIONAL_EXPRESSION */) {
                        conditional = conditional.alternate;
                    }
                    conditional.alternate = vElse.exp
                        ? createConditionalExpression(vElse.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback)
                        : buildDynamicSlot(slotName, slotFunction);
                }
                else {
                    context.onError(createCompilerError(36 /* X_V_ELSE_NO_ADJACENT_IF */, vElse.loc));
                }
            }
            else if ((vFor = findDir(slotElement, 'for'))) {
                hasDynamicSlots = true;
                const parseResult = vFor.parseResult ||
                    parseForExpression(vFor.exp);
                if (parseResult) {
                    // Render the dynamic slots as an array and add it to the createSlot()
                    // args. The runtime knows how to handle it appropriately.
                    dynamicSlots.push(createCallExpression(context.helper(RENDER_LIST), [
                        parseResult.source,
                        createFunctionExpression(createForLoopParams(parseResult), buildDynamicSlot(slotName, slotFunction), true /* force newline */)
                    ]));
                }
                else {
                    context.onError(createCompilerError(38 /* X_V_FOR_MALFORMED_EXPRESSION */, vFor.loc));
                }
            }
            else {
                // check duplicate static names
                if (staticSlotName) {
                    if (seenSlotNames.has(staticSlotName)) {
                        context.onError(createCompilerError(44 /* X_V_SLOT_DUPLICATE_SLOT_NAMES */, dirLoc));
                        continue;
                    }
                    seenSlotNames.add(staticSlotName);
                    if (staticSlotName === 'default') {
                        hasNamedDefaultSlot = true;
                    }
                }
                slotsProperties.push(createObjectProperty(slotName, slotFunction));
            }
        }
        if (!onComponentDefaultSlot) {
            if (!hasTemplateSlots) {
                // implicit default slot (on component)
                slotsProperties.push(buildDefaultSlot(undefined, children, loc));
            }
            else if (implicitDefaultChildren.length) {
                // implicit default slot (mixed with named slots)
                if (hasNamedDefaultSlot) {
                    context.onError(createCompilerError(45 /* X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */, implicitDefaultChildren[0].loc));
                }
                else {
                    slotsProperties.push(buildDefaultSlot(undefined, implicitDefaultChildren, loc));
                }
            }
        }
        let slots = createObjectExpression(slotsProperties.concat(createObjectProperty(`_compiled`, createSimpleExpression(`true`, false))), loc);
        if (dynamicSlots.length) {
            slots = createCallExpression(context.helper(CREATE_SLOTS), [
                slots,
                createArrayExpression(dynamicSlots)
            ]);
        }
        return {
            slots,
            hasDynamicSlots
        };
    }
    function buildDefaultSlot(slotProps, children, loc) {
        return createObjectProperty(`default`, createFunctionExpression(slotProps, children, false /* newline */, true /* isSlot */, children.length ? children[0].loc : loc));
    }
    function buildDynamicSlot(name, fn) {
        return createObjectExpression([
            createObjectProperty(`name`, name),
            createObjectProperty(`fn`, fn)
        ]);
    }
    function stringifyDynamicPropNames(props) {
        let propsNamesString = `[`;
        for (let i = 0, l = props.length; i < l; i++) {
            propsNamesString += JSON.stringify(props[i]);
            if (i < l - 1)
                propsNamesString += ', ';
        }
        return propsNamesString + `]`;
    }
    function buildProps(node, context, props = node.props) {
        const elementLoc = node.loc;
        const isComponent = node.tagType === 1 /* COMPONENT */;
        let properties = [];
        const mergeArgs = [];
        const runtimeDirectives = [];
        // patchFlag analysis
        let patchFlag = 0;
        let hasRef = false;
        let hasClassBinding = false;
        let hasStyleBinding = false;
        let hasDynamicKeys = false;
        const dynamicPropNames = [];
        const analyzePatchFlag = ({ key, value }) => {
            if (key.type === 4 /* SIMPLE_EXPRESSION */ && key.isStatic) {
                if (value.type === 20 /* JS_CACHE_EXPRESSION */ ||
                    ((value.type === 4 /* SIMPLE_EXPRESSION */ ||
                        value.type === 8 /* COMPOUND_EXPRESSION */) &&
                        isStaticNode(value))) {
                    return;
                }
                const name = key.content;
                if (name === 'ref') {
                    hasRef = true;
                }
                else if (name === 'class') {
                    hasClassBinding = true;
                }
                else if (name === 'style') {
                    hasStyleBinding = true;
                }
                else if (name !== 'key') {
                    dynamicPropNames.push(name);
                }
            }
            else {
                hasDynamicKeys = true;
            }
        };
        for (let i = 0; i < props.length; i++) {
            // static attribute
            const prop = props[i];
            if (prop.type === 6 /* ATTRIBUTE */) {
                const { loc, name, value } = prop;
                if (name === 'ref') {
                    hasRef = true;
                }
                properties.push(createObjectProperty(createSimpleExpression(name, true, getInnerRange(loc, 0, name.length)), createSimpleExpression(value ? value.content : '', true, value ? value.loc : loc)));
            }
            else {
                // directives
                const { name, arg, exp, loc } = prop;
                // skip v-slot - it is handled by its dedicated transform.
                if (name === 'slot') {
                    if (!isComponent) {
                        context.onError(createCompilerError(46 /* X_V_SLOT_MISPLACED */, loc));
                    }
                    continue;
                }
                // skip v-once - it is handled by its dedicated transform.
                if (name === 'once') {
                    continue;
                }
                // special case for v-bind and v-on with no argument
                const isBind = name === 'bind';
                const isOn = name === 'on';
                if (!arg && (isBind || isOn)) {
                    hasDynamicKeys = true;
                    if (exp) {
                        if (properties.length) {
                            mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
                            properties = [];
                        }
                        if (isBind) {
                            mergeArgs.push(exp);
                        }
                        else {
                            // v-on="obj" -> toHandlers(obj)
                            mergeArgs.push({
                                type: 13 /* JS_CALL_EXPRESSION */,
                                loc,
                                callee: context.helper(TO_HANDLERS),
                                arguments: [exp]
                            });
                        }
                    }
                    else {
                        context.onError(createCompilerError(isBind
                            ? 39 /* X_V_BIND_NO_EXPRESSION */
                            : 40 /* X_V_ON_NO_EXPRESSION */, loc));
                    }
                    continue;
                }
                const directiveTransform = context.directiveTransforms[name];
                if (directiveTransform) {
                    // has built-in directive transform.
                    const { props, needRuntime } = directiveTransform(prop, node, context);
                    props.forEach(analyzePatchFlag);
                    properties.push(...props);
                    if (needRuntime) {
                        runtimeDirectives.push(prop);
                        if (isSymbol(needRuntime)) {
                            directiveImportMap.set(prop, needRuntime);
                        }
                    }
                }
                else {
                    // no built-in transform, this is a user custom directive.
                    runtimeDirectives.push(prop);
                }
            }
        }
        let propsExpression = undefined;
        // has v-bind="object" or v-on="object", wrap with mergeProps
        if (mergeArgs.length) {
            if (properties.length) {
                mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
            }
            if (mergeArgs.length > 1) {
                propsExpression = createCallExpression(context.helper(MERGE_PROPS), mergeArgs, elementLoc);
            }
            else {
                // single v-bind with nothing else - no need for a mergeProps call
                propsExpression = mergeArgs[0];
            }
        }
        else if (properties.length) {
            propsExpression = createObjectExpression(dedupeProperties(properties), elementLoc);
        }
        // patchFlag analysis
        if (hasDynamicKeys) {
            patchFlag |= 16 /* FULL_PROPS */;
        }
        else {
            if (hasClassBinding) {
                patchFlag |= 2 /* CLASS */;
            }
            if (hasStyleBinding) {
                patchFlag |= 4 /* STYLE */;
            }
            if (dynamicPropNames.length) {
                patchFlag |= 8 /* PROPS */;
            }
        }
        if (patchFlag === 0 && (hasRef || runtimeDirectives.length > 0)) {
            patchFlag |= 32 /* NEED_PATCH */;
        }
        return {
            props: propsExpression,
            directives: runtimeDirectives,
            patchFlag,
            dynamicPropNames
        };
    }
    // Dedupe props in an object literal.
    // Literal duplicated attributes would have been warned during the parse phase,
    // however, it's possible to encounter duplicated `onXXX` handlers with different
    // modifiers. We also need to merge static and dynamic class / style attributes.
    // - onXXX handlers / style: merge into array
    // - class: merge into single expression with concatenation
    function dedupeProperties(properties) {
        const knownProps = new Map();
        const deduped = [];
        for (let i = 0; i < properties.length; i++) {
            const prop = properties[i];
            // dynamic keys are always allowed
            if (prop.key.type === 8 /* COMPOUND_EXPRESSION */ || !prop.key.isStatic) {
                deduped.push(prop);
                continue;
            }
            const name = prop.key.content;
            const existing = knownProps.get(name);
            if (existing) {
                if (name === 'style' ||
                    name === 'class' ||
                    name.startsWith('on') ||
                    name.startsWith('vnode')) {
                    mergeAsArray(existing, prop);
                }
                // unexpected duplicate, should have emitted error during parse
            }
            else {
                knownProps.set(name, prop);
                deduped.push(prop);
            }
        }
        return deduped;
    }
    function mergeAsArray(existing, incoming) {
        if (existing.value.type === 16 /* JS_ARRAY_EXPRESSION */) {
            existing.value.elements.push(incoming.value);
        }
        else {
            existing.value = createArrayExpression([existing.value, incoming.value], existing.loc);
        }
    }
    function buildDirectiveArgs(dir, context) {
        const dirArgs = [];
        const runtime = directiveImportMap.get(dir);
        if (runtime) {
            context.helper(runtime);
            dirArgs.push(context.helperString(runtime));
        }
        else {
            // inject statement for resolving directive
            context.helper(RESOLVE_DIRECTIVE);
            context.directives.add(dir.name);
            dirArgs.push(toValidAssetId(dir.name, `directive`));
        }
        const { loc } = dir;
        if (dir.exp)
            dirArgs.push(dir.exp);
        if (dir.arg) {
            if (!dir.exp) {
                dirArgs.push(`void 0`);
            }
            dirArgs.push(dir.arg);
        }
        if (Object.keys(dir.modifiers).length) {
            if (!dir.arg) {
                if (!dir.exp) {
                    dirArgs.push(`void 0`);
                }
                dirArgs.push(`void 0`);
            }
            const trueExpression = createSimpleExpression(`true`, false, loc);
            dirArgs.push(createObjectExpression(dir.modifiers.map(modifier => createObjectProperty(modifier, trueExpression)), loc));
        }
        return createArrayExpression(dirArgs, dir.loc);
    }
    function createTransformProps(props = []) {
        return { props, needRuntime: false };
    }
    // we name it `baseCompile` so that higher order compilers like
    // @vue/compiler-dom can export `compile` while re-exporting everything else.
    function baseCompile(template, options = {}) {
        const onError = options.onError || defaultOnError;
        const isModuleMode = options.mode === 'module';
        /* istanbul ignore if */
        {
            if (options.prefixIdentifiers === true) {
                onError(createCompilerError(51 /* X_PREFIX_ID_NOT_SUPPORTED */));
            }
            else if (isModuleMode) {
                onError(createCompilerError(52 /* X_MODULE_MODE_NOT_SUPPORTED */));
            }
        }
        const prefixIdentifiers = !true;
        if (options.cacheHandlers) {
            onError(createCompilerError(53 /* X_CACHE_HANDLER_NOT_SUPPORTED */));
        }
        if (options.scopeId && !isModuleMode) {
            onError(createCompilerError(54 /* X_SCOPE_ID_NOT_SUPPORTED */));
        }
        const ast = isString(template) ? baseParse(template, options) : template;
        transform(ast, {
            ...options,
            prefixIdentifiers,
            nodeTransforms: [
                transformOnce,
                transformIf,
                transformFor,
                ...([]),
                transformSlotOutlet,
                transformElement,
                trackSlotScopes,
                transformText,
                ...(options.nodeTransforms || []) // user transforms
            ],
            directiveTransforms: {
                on: transformOn,
                bind: transformBind,
                model: transformModel,
                ...(options.directiveTransforms || {}) // user transforms
            }
        });
        return generate(ast, {
            ...options,
            prefixIdentifiers
        });
    }
    function parseInlineCSS(cssText) {
        const res = {};
        cssText.split(listDelimiterRE).forEach(item => {
            if (item) {
                const tmp = item.split(propertyDelimiterRE);
                tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
            }
        });
        return res;
    }
    function createDOMCompilerError(code, loc) {
        return createCompilerError(code, loc, DOMErrorMessages);
    }
    function compile(template, options = {}) {
        return baseCompile(template, {
            ...parserOptions,
            ...options,
            nodeTransforms: [transformStyle, ...(options.nodeTransforms || [])],
            directiveTransforms: {
                cloak: transformCloak,
                html: transformVHtml,
                text: transformVText,
                model: transformModel$1,
                on: transformOn$1,
                show: transformShow,
                ...(options.directiveTransforms || {})
            },
            isBuiltInComponent: tag => {
                if (isBuiltInType(tag, `Transition`)) {
                    return TRANSITION;
                }
                else if (isBuiltInType(tag, `TransitionGroup`)) {
                    return TRANSITION_GROUP;
                }
            }
        });
    }
    function isEffect(fn) {
        return fn != null && fn._isEffect === true;
    }
    function effect(fn, options = EMPTY_OBJ) {
        if (isEffect(fn)) {
            fn = fn.raw;
        }
        const effect = createReactiveEffect(fn, options);
        if (!options.lazy) {
            effect();
        }
        return effect;
    }
    exports_5("effect", effect);
    function stop(effect) {
        if (effect.active) {
            cleanup(effect);
            if (effect.options.onStop) {
                effect.options.onStop();
            }
            effect.active = false;
        }
    }
    function createReactiveEffect(fn, options) {
        const effect = function reactiveEffect(...args) {
            return run(effect, fn, args);
        };
        effect._isEffect = true;
        effect.active = true;
        effect.raw = fn;
        effect.deps = [];
        effect.options = options;
        return effect;
    }
    function run(effect, fn, args) {
        if (!effect.active) {
            return fn(...args);
        }
        if (!effectStack.includes(effect)) {
            cleanup(effect);
            try {
                effectStack.push(effect);
                activeEffect = effect;
                return fn(...args);
            }
            finally {
                effectStack.pop();
                activeEffect = effectStack[effectStack.length - 1];
            }
        }
    }
    function cleanup(effect) {
        const { deps } = effect;
        if (deps.length) {
            for (let i = 0; i < deps.length; i++) {
                deps[i].delete(effect);
            }
            deps.length = 0;
        }
    }
    function pauseTracking() {
        shouldTrack = false;
    }
    function resumeTracking() {
        shouldTrack = true;
    }
    function track(target, type, key) {
        if (!shouldTrack || activeEffect === undefined) {
            return;
        }
        let depsMap = targetMap.get(target);
        if (depsMap === void 0) {
            targetMap.set(target, (depsMap = new Map()));
        }
        let dep = depsMap.get(key);
        if (dep === void 0) {
            depsMap.set(key, (dep = new Set()));
        }
        if (!dep.has(activeEffect)) {
            dep.add(activeEffect);
            activeEffect.deps.push(dep);
            if (activeEffect.options.onTrack) {
                activeEffect.options.onTrack({
                    effect: activeEffect,
                    target,
                    type,
                    key
                });
            }
        }
    }
    function trigger(target, type, key, extraInfo) {
        const depsMap = targetMap.get(target);
        if (depsMap === void 0) {
            // never been tracked
            return;
        }
        const effects = new Set();
        const computedRunners = new Set();
        if (type === "clear" /* CLEAR */) {
            // collection being cleared, trigger all effects for target
            depsMap.forEach(dep => {
                addRunners(effects, computedRunners, dep);
            });
        }
        else {
            // schedule runs for SET | ADD | DELETE
            if (key !== void 0) {
                addRunners(effects, computedRunners, depsMap.get(key));
            }
            // also run for iteration key on ADD | DELETE
            if (type === "add" /* ADD */ || type === "delete" /* DELETE */) {
                const iterationKey = isArray(target) ? 'length' : ITERATE_KEY;
                addRunners(effects, computedRunners, depsMap.get(iterationKey));
            }
        }
        const run = (effect) => {
            scheduleRun(effect, target, type, key, extraInfo);
        };
        // Important: computed effects must be run first so that computed getters
        // can be invalidated before any normal effects that depend on them are run.
        computedRunners.forEach(run);
        effects.forEach(run);
    }
    function addRunners(effects, computedRunners, effectsToAdd) {
        if (effectsToAdd !== void 0) {
            effectsToAdd.forEach(effect => {
                if (effect.options.computed) {
                    computedRunners.add(effect);
                }
                else {
                    effects.add(effect);
                }
            });
        }
    }
    function scheduleRun(effect, target, type, key, extraInfo) {
        if (effect.options.onTrigger) {
            const event = {
                effect,
                target,
                key,
                type
            };
            effect.options.onTrigger(extraInfo ? extend(event, extraInfo) : event);
        }
        if (effect.options.scheduler !== void 0) {
            effect.options.scheduler(effect);
        }
        else {
            effect();
        }
    }
    function lock() {
        LOCKED = true;
    }
    function unlock() {
        LOCKED = false;
    }
    function createGetter(isReadonly = false, shallow = false) {
        return function get(target, key, receiver) {
            if (isArray(target) && hasOwn(arrayIdentityInstrumentations, key)) {
                return Reflect.get(arrayIdentityInstrumentations, key, receiver);
            }
            const res = Reflect.get(target, key, receiver);
            if (isSymbol(key) && builtInSymbols.has(key)) {
                return res;
            }
            if (shallow) {
                track(target, "get" /* GET */, key);
                // TODO strict mode that returns a shallow-readonly version of the value
                return res;
            }
            if (isRef(res)) {
                return res.value;
            }
            track(target, "get" /* GET */, key);
            return isObject(res)
                ? isReadonly
                    ? // need to lazy access readonly and reactive here to avoid
                        // circular dependency
                        readonly(res)
                    : reactive(res)
                : res;
        };
    }
    function createSetter(isReadonly = false, shallow = false) {
        return function set(target, key, value, receiver) {
            if (isReadonly && LOCKED) {
                {
                    console.warn(`Set operation on key "${String(key)}" failed: target is readonly.`, target);
                }
                return true;
            }
            const oldValue = target[key];
            if (!shallow) {
                value = toRaw(value);
                if (isRef(oldValue) && !isRef(value)) {
                    oldValue.value = value;
                    return true;
                }
            }
            const hadKey = hasOwn(target, key);
            const result = Reflect.set(target, key, value, receiver);
            // don't trigger if target is something up in the prototype chain of original
            if (target === toRaw(receiver)) {
                /* istanbul ignore else */
                {
                    const extraInfo = { oldValue, newValue: value };
                    if (!hadKey) {
                        trigger(target, "add" /* ADD */, key, extraInfo);
                    }
                    else if (hasChanged(value, oldValue)) {
                        trigger(target, "set" /* SET */, key, extraInfo);
                    }
                }
            }
            return result;
        };
    }
    function deleteProperty(target, key) {
        const hadKey = hasOwn(target, key);
        const oldValue = target[key];
        const result = Reflect.deleteProperty(target, key);
        if (result && hadKey) {
            /* istanbul ignore else */
            {
                trigger(target, "delete" /* DELETE */, key, { oldValue });
            }
        }
        return result;
    }
    function has(target, key) {
        const result = Reflect.has(target, key);
        track(target, "has" /* HAS */, key);
        return result;
    }
    function ownKeys(target) {
        track(target, "iterate" /* ITERATE */, ITERATE_KEY);
        return Reflect.ownKeys(target);
    }
    function get$1(target, key, wrap) {
        target = toRaw(target);
        key = toRaw(key);
        track(target, "get" /* GET */, key);
        return wrap(getProto(target).get.call(target, key));
    }
    function has$1(key) {
        const target = toRaw(this);
        key = toRaw(key);
        track(target, "has" /* HAS */, key);
        return getProto(target).has.call(target, key);
    }
    function size(target) {
        target = toRaw(target);
        track(target, "iterate" /* ITERATE */, ITERATE_KEY);
        return Reflect.get(getProto(target), 'size', target);
    }
    function add(value) {
        value = toRaw(value);
        const target = toRaw(this);
        const proto = getProto(target);
        const hadKey = proto.has.call(target, value);
        const result = proto.add.call(target, value);
        if (!hadKey) {
            /* istanbul ignore else */
            {
                trigger(target, "add" /* ADD */, value, { newValue: value });
            }
        }
        return result;
    }
    function set$1(key, value) {
        value = toRaw(value);
        key = toRaw(key);
        const target = toRaw(this);
        const proto = getProto(target);
        const hadKey = proto.has.call(target, key);
        const oldValue = proto.get.call(target, key);
        const result = proto.set.call(target, key, value);
        /* istanbul ignore else */
        {
            const extraInfo = { oldValue, newValue: value };
            if (!hadKey) {
                trigger(target, "add" /* ADD */, key, extraInfo);
            }
            else if (hasChanged(value, oldValue)) {
                trigger(target, "set" /* SET */, key, extraInfo);
            }
        }
        return result;
    }
    function deleteEntry(key) {
        key = toRaw(key);
        const target = toRaw(this);
        const proto = getProto(target);
        const hadKey = proto.has.call(target, key);
        const oldValue = proto.get ? proto.get.call(target, key) : undefined;
        // forward the operation before queueing reactions
        const result = proto.delete.call(target, key);
        if (hadKey) {
            /* istanbul ignore else */
            {
                trigger(target, "delete" /* DELETE */, key, { oldValue });
            }
        }
        return result;
    }
    function clear() {
        const target = toRaw(this);
        const hadItems = target.size !== 0;
        const oldTarget = target instanceof Map
            ? new Map(target)
            : new Set(target);
        // forward the operation before queueing reactions
        const result = getProto(target).clear.call(target);
        if (hadItems) {
            /* istanbul ignore else */
            {
                trigger(target, "clear" /* CLEAR */, void 0, { oldTarget });
            }
        }
        return result;
    }
    function createForEach(isReadonly) {
        return function forEach(callback, thisArg) {
            const observed = this;
            const target = toRaw(observed);
            const wrap = isReadonly ? toReadonly : toReactive;
            track(target, "iterate" /* ITERATE */, ITERATE_KEY);
            // important: create sure the callback is
            // 1. invoked with the reactive map as `this` and 3rd arg
            // 2. the value received should be a corresponding reactive/readonly.
            function wrappedCallback(value, key) {
                return callback.call(observed, wrap(value), wrap(key), observed);
            }
            return getProto(target).forEach.call(target, wrappedCallback, thisArg);
        };
    }
    function createIterableMethod(method, isReadonly) {
        return function (...args) {
            const target = toRaw(this);
            const isPair = method === 'entries' ||
                (method === Symbol.iterator && target instanceof Map);
            const innerIterator = getProto(target)[method].apply(target, args);
            const wrap = isReadonly ? toReadonly : toReactive;
            track(target, "iterate" /* ITERATE */, ITERATE_KEY);
            // return a wrapped iterator which returns observed versions of the
            // values emitted from the real iterator
            return {
                // iterator protocol
                next() {
                    const { value, done } = innerIterator.next();
                    return done
                        ? { value, done }
                        : {
                            value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
                            done
                        };
                },
                // iterable protocol
                [Symbol.iterator]() {
                    return this;
                }
            };
        };
    }
    function createReadonlyMethod(method, type) {
        return function (...args) {
            if (LOCKED) {
                {
                    const key = args[0] ? `on key "${args[0]}" ` : ``;
                    console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));
                }
                return type === "delete" /* DELETE */ ? false : this;
            }
            else {
                return method.apply(this, args);
            }
        };
    }
    function createInstrumentationGetter(instrumentations) {
        return (target, key, receiver) => Reflect.get(hasOwn(instrumentations, key) && key in target
            ? instrumentations
            : target, key, receiver);
    }
    function reactive(target) {
        // if trying to observe a readonly proxy, return the readonly version.
        if (readonlyToRaw.has(target)) {
            return target;
        }
        // target is explicitly marked as readonly by user
        if (readonlyValues.has(target)) {
            return readonly(target);
        }
        return createReactiveObject(target, rawToReactive, reactiveToRaw, mutableHandlers, mutableCollectionHandlers);
    }
    exports_5("reactive", reactive);
    function readonly(target) {
        // value is a mutable observable, retrieve its original and return
        // a readonly version.
        if (reactiveToRaw.has(target)) {
            target = reactiveToRaw.get(target);
        }
        return createReactiveObject(target, rawToReadonly, readonlyToRaw, readonlyHandlers, readonlyCollectionHandlers);
    }
    exports_5("readonly", readonly);
    // @internal
    // Return a reactive-copy of the original object, where only the root level
    // properties are readonly, and does NOT unwrap refs nor recursively convert
    // returned properties.
    // This is used for creating the props proxy object for stateful components.
    function shallowReadonly(target) {
        return createReactiveObject(target, rawToReadonly, readonlyToRaw, shallowReadonlyHandlers, readonlyCollectionHandlers);
    }
    function createReactiveObject(target, toProxy, toRaw, baseHandlers, collectionHandlers) {
        if (!isObject(target)) {
            {
                console.warn(`value cannot be made reactive: ${String(target)}`);
            }
            return target;
        }
        // target already has corresponding Proxy
        let observed = toProxy.get(target);
        if (observed !== void 0) {
            return observed;
        }
        // target is already a Proxy
        if (toRaw.has(target)) {
            return target;
        }
        // only a whitelist of value types can be observed.
        if (!canObserve(target)) {
            return target;
        }
        const handlers = collectionTypes.has(target.constructor)
            ? collectionHandlers
            : baseHandlers;
        observed = new Proxy(target, handlers);
        toProxy.set(target, observed);
        toRaw.set(observed, target);
        return observed;
    }
    function isReactive(value) {
        return reactiveToRaw.has(value) || readonlyToRaw.has(value);
    }
    exports_5("isReactive", isReactive);
    function isReadonly(value) {
        return readonlyToRaw.has(value);
    }
    exports_5("isReadonly", isReadonly);
    function toRaw(observed) {
        return reactiveToRaw.get(observed) || readonlyToRaw.get(observed) || observed;
    }
    exports_5("toRaw", toRaw);
    function markReadonly(value) {
        readonlyValues.add(value);
        return value;
    }
    exports_5("markReadonly", markReadonly);
    function markNonReactive(value) {
        nonReactiveValues.add(value);
        return value;
    }
    exports_5("markNonReactive", markNonReactive);
    function isRef(r) {
        return r ? r._isRef === true : false;
    }
    exports_5("isRef", isRef);
    function ref(value) {
        if (isRef(value)) {
            return value;
        }
        value = convert(value);
        const r = {
            _isRef: true,
            get value() {
                track(r, "get" /* GET */, 'value');
                return value;
            },
            set value(newVal) {
                value = convert(newVal);
                trigger(r, "set" /* SET */, 'value', { newValue: newVal });
            }
        };
        return r;
    }
    exports_5("ref", ref);
    function toRefs(object) {
        if (!isReactive(object)) {
            console.warn(`toRefs() expects a reactive object but received a plain one.`);
        }
        const ret = {};
        for (const key in object) {
            ret[key] = toProxyRef(object, key);
        }
        return ret;
    }
    exports_5("toRefs", toRefs);
    function toProxyRef(object, key) {
        return {
            _isRef: true,
            get value() {
                return object[key];
            },
            set value(newVal) {
                object[key] = newVal;
            }
        };
    }
    function computed(getterOrOptions) {
        let getter;
        let setter;
        if (isFunction(getterOrOptions)) {
            getter = getterOrOptions;
            setter = () => {
                console.warn('Write operation failed: computed value is readonly');
            };
        }
        else {
            getter = getterOrOptions.get;
            setter = getterOrOptions.set;
        }
        let dirty = true;
        let value;
        const runner = effect(getter, {
            lazy: true,
            // mark effect as computed so that it gets priority during trigger
            computed: true,
            scheduler: () => {
                dirty = true;
            }
        });
        return {
            _isRef: true,
            // expose effect so computed can be stopped
            effect: runner,
            get value() {
                if (dirty) {
                    value = runner();
                    dirty = false;
                }
                // When computed effects are accessed in a parent effect, the parent
                // should track all the dependencies the computed property has tracked.
                // This should also apply for chained computed properties.
                trackChildRun(runner);
                return value;
            },
            set value(newValue) {
                setter(newValue);
            }
        };
    }
    function trackChildRun(childRunner) {
        if (activeEffect === undefined) {
            return;
        }
        for (let i = 0; i < childRunner.deps.length; i++) {
            const dep = childRunner.deps[i];
            if (!dep.has(activeEffect)) {
                dep.add(activeEffect);
                activeEffect.deps.push(dep);
            }
        }
    }
    function callWithErrorHandling(fn, instance, type, args) {
        let res;
        try {
            res = args ? fn(...args) : fn();
        }
        catch (err) {
            handleError(err, instance, type);
        }
        return res;
    }
    exports_5("callWithErrorHandling", callWithErrorHandling);
    function callWithAsyncErrorHandling(fn, instance, type, args) {
        if (isFunction(fn)) {
            const res = callWithErrorHandling(fn, instance, type, args);
            if (res != null && !res._isVue && isPromise(res)) {
                res.catch((err) => {
                    handleError(err, instance, type);
                });
            }
            return res;
        }
        const values = [];
        for (let i = 0; i < fn.length; i++) {
            values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
        }
        return values;
    }
    exports_5("callWithAsyncErrorHandling", callWithAsyncErrorHandling);
    function handleError(err, instance, type) {
        const contextVNode = instance ? instance.vnode : null;
        if (instance) {
            let cur = instance.parent;
            // the exposed instance is the render proxy to keep it consistent with 2.x
            const exposedInstance = instance.proxy;
            // in production the hook receives only the error code
            const errorInfo = ErrorTypeStrings[type];
            while (cur) {
                const errorCapturedHooks = cur.ec;
                if (errorCapturedHooks !== null) {
                    for (let i = 0; i < errorCapturedHooks.length; i++) {
                        if (errorCapturedHooks[i](err, exposedInstance, errorInfo)) {
                            return;
                        }
                    }
                }
                cur = cur.parent;
            }
            // app-level handling
            const appErrorHandler = instance.appContext.config.errorHandler;
            if (appErrorHandler) {
                callWithErrorHandling(appErrorHandler, null, 9 /* APP_ERROR_HANDLER */, [err, exposedInstance, errorInfo]);
                return;
            }
        }
        logError(err, type, contextVNode);
    }
    exports_5("handleError", handleError);
    function logError(err, type, contextVNode) {
        // default behavior is crash in prod & test, recover in dev.
        {
            const info = ErrorTypeStrings[type];
            if (contextVNode) {
                pushWarningContext(contextVNode);
            }
            warn(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
            console.error(err);
            if (contextVNode) {
                popWarningContext();
            }
        }
    }
    function pushWarningContext(vnode) {
        stack.push(vnode);
    }
    function popWarningContext() {
        stack.pop();
    }
    function warn(msg, ...args) {
        // avoid props formatting or warn handler tracking deps that might be mutated
        // during patch, leading to infinite recursion.
        pauseTracking();
        const instance = stack.length ? stack[stack.length - 1].component : null;
        const appWarnHandler = instance && instance.appContext.config.warnHandler;
        const trace = getComponentTrace();
        if (appWarnHandler) {
            callWithErrorHandling(appWarnHandler, instance, 10 /* APP_WARN_HANDLER */, [
                msg + args.join(''),
                instance && instance.proxy,
                trace
                    .map(({ vnode }) => `at <${formatComponentName(vnode)}>`)
                    .join('\n'),
                trace
            ]);
        }
        else {
            const warnArgs = [`[Vue warn]: ${msg}`, ...args];
            if (trace.length &&
                // avoid spamming console during tests
                !false) {
                warnArgs.push(`\n`, ...formatTrace(trace));
            }
            console.warn(...warnArgs);
        }
        resumeTracking();
    }
    exports_5("warn", warn);
    function getComponentTrace() {
        let currentVNode = stack[stack.length - 1];
        if (!currentVNode) {
            return [];
        }
        // we can't just use the stack because it will be incomplete during updates
        // that did not start from the root. Re-construct the parent chain using
        // instance parent pointers.
        const normalizedStack = [];
        while (currentVNode) {
            const last = normalizedStack[0];
            if (last && last.vnode === currentVNode) {
                last.recurseCount++;
            }
            else {
                normalizedStack.push({
                    vnode: currentVNode,
                    recurseCount: 0
                });
            }
            const parentInstance = currentVNode.component
                .parent;
            currentVNode = parentInstance && parentInstance.vnode;
        }
        return normalizedStack;
    }
    function formatTrace(trace) {
        const logs = [];
        trace.forEach((entry, i) => {
            logs.push(...(i === 0 ? [] : [`\n`]), ...formatTraceEntry(entry));
        });
        return logs;
    }
    function formatTraceEntry({ vnode, recurseCount }) {
        const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
        const open = ` at <${formatComponentName(vnode)}`;
        const close = `>` + postfix;
        const rootLabel = vnode.component.parent == null ? `(Root)` : ``;
        return vnode.props
            ? [open, ...formatProps(vnode.props), close, rootLabel]
            : [open + close, rootLabel];
    }
    function formatComponentName(vnode, file) {
        const Component = vnode.type;
        let name = isFunction(Component)
            ? Component.displayName || Component.name
            : Component.name;
        if (!name && file) {
            const match = file.match(/([^/\\]+)\.vue$/);
            if (match) {
                name = match[1];
            }
        }
        return name ? classify(name) : 'Anonymous';
    }
    function formatProps(props) {
        const res = [];
        const keys = Object.keys(props);
        keys.slice(0, 3).forEach(key => {
            res.push(...formatProp(key, props[key]));
        });
        if (keys.length > 3) {
            res.push(` ...`);
        }
        return res;
    }
    function formatProp(key, value, raw) {
        if (isString(value)) {
            value = JSON.stringify(value);
            return raw ? value : [`${key}=${value}`];
        }
        else if (typeof value === 'number' ||
            typeof value === 'boolean' ||
            value == null) {
            return raw ? value : [`${key}=${value}`];
        }
        else if (isRef(value)) {
            value = formatProp(key, toRaw(value.value), true);
            return raw ? value : [`${key}=Ref<`, value, `>`];
        }
        else if (isFunction(value)) {
            return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
        }
        else {
            value = toRaw(value);
            return raw ? value : [`${key}=`, value];
        }
    }
    function pushScopeId(id) {
    }
    exports_5("pushScopeId", pushScopeId);
    function popScopeId() {
    }
    exports_5("popScopeId", popScopeId);
    function withScopeId(id) {
        {
            return undefined;
        }
    }
    exports_5("withScopeId", withScopeId);
    // Open a block.
    // This must be called before `createBlock`. It cannot be part of `createBlock`
    // because the children of the block are evaluated before `createBlock` itself
    // is called. The generated code typically looks like this:
    //
    //   function render() {
    //     return (openBlock(),createBlock('div', null, [...]))
    //   }
    //
    // disableTracking is true when creating a fragment block, since a fragment
    // always diffs its children.
    function openBlock(disableTracking) {
        blockStack.push((currentBlock = disableTracking ? null : []));
    }
    exports_5("openBlock", openBlock);
    // Block tracking sometimes needs to be disabled, for example during the
    // creation of a tree that needs to be cached by v-once. The compiler generates
    // code like this:
    //   _cache[1] || (
    //     setBlockTracking(-1),
    //     _cache[1] = createVNode(...),
    //     setBlockTracking(1),
    //     _cache[1]
    //   )
    function setBlockTracking(value) {
        shouldTrack$1 += value;
    }
    exports_5("setBlockTracking", setBlockTracking);
    // Create a block root vnode. Takes the same exact arguments as `createVNode`.
    // A block root keeps track of dynamic nodes within the block in the
    // `dynamicChildren` array.
    function createBlock(type, props, children, patchFlag, dynamicProps) {
        // avoid a block with patchFlag tracking itself
        shouldTrack$1--;
        const vnode = createVNode(type, props, children, patchFlag, dynamicProps);
        shouldTrack$1++;
        // save current block children on the block vnode
        vnode.dynamicChildren = currentBlock || EMPTY_ARR;
        // close block
        blockStack.pop();
        currentBlock = blockStack[blockStack.length - 1] || null;
        // a block is always going to be patched, so track it as a child of its
        // parent block
        if (currentBlock !== null) {
            currentBlock.push(vnode);
        }
        return vnode;
    }
    exports_5("createBlock", createBlock);
    function isVNode(value) {
        return value ? value._isVNode === true : false;
    }
    function isSameVNodeType(n1, n2) {
        return n1.type === n2.type && n1.key === n2.key;
    }
    function createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null) {
        if (!type) {
            warn(`Invalid vnode type when creating vnode: ${type}.`);
            type = Comment;
        }
        // class & style normalization.
        if (props !== null) {
            // for reactive or proxy objects, we need to clone it to enable mutation.
            if (isReactive(props) || SetupProxySymbol in props) {
                props = extend({}, props);
            }
            let { class: klass, style } = props;
            if (klass != null && !isString(klass)) {
                props.class = normalizeClass(klass);
            }
            if (style != null) {
                // reactive state objects need to be cloned since they are likely to be
                // mutated
                if (isReactive(style) && !isArray(style)) {
                    style = extend({}, style);
                }
                props.style = normalizeStyle(style);
            }
        }
        // encode the vnode type information into a bitmap
        const shapeFlag = isString(type)
            ? 1 /* ELEMENT */
            : type.__isSuspense === true
                ? 64 /* SUSPENSE */
                : isObject(type)
                    ? 4 /* STATEFUL_COMPONENT */
                    : isFunction(type)
                        ? 2 /* FUNCTIONAL_COMPONENT */
                        : 0;
        const vnode = {
            _isVNode: true,
            type,
            props,
            key: (props !== null && props.key) || null,
            ref: (props !== null && props.ref) || null,
            scopeId: currentScopeId,
            children: null,
            component: null,
            suspense: null,
            dirs: null,
            transition: null,
            el: null,
            anchor: null,
            target: null,
            shapeFlag,
            patchFlag,
            dynamicProps,
            dynamicChildren: null,
            appContext: null
        };
        normalizeChildren(vnode, children);
        // presence of a patch flag indicates this node needs patching on updates.
        // component nodes also should always be patched, because even if the
        // component doesn't need to update, it needs to persist the instance on to
        // the next vnode so that it can be properly unmounted later.
        if (shouldTrack$1 > 0 &&
            currentBlock !== null &&
            (patchFlag > 0 ||
                shapeFlag & 64 /* SUSPENSE */ ||
                shapeFlag & 4 /* STATEFUL_COMPONENT */ ||
                shapeFlag & 2 /* FUNCTIONAL_COMPONENT */)) {
            currentBlock.push(vnode);
        }
        return vnode;
    }
    exports_5("createVNode", createVNode);
    function cloneVNode(vnode, extraProps) {
        // This is intentionally NOT using spread or extend to avoid the runtime
        // key enumeration cost.
        return {
            _isVNode: true,
            type: vnode.type,
            props: extraProps
                ? vnode.props
                    ? mergeProps(vnode.props, extraProps)
                    : extraProps
                : vnode.props,
            key: vnode.key,
            ref: vnode.ref,
            scopeId: vnode.scopeId,
            children: vnode.children,
            target: vnode.target,
            shapeFlag: vnode.shapeFlag,
            patchFlag: vnode.patchFlag,
            dynamicProps: vnode.dynamicProps,
            dynamicChildren: vnode.dynamicChildren,
            appContext: vnode.appContext,
            dirs: vnode.dirs,
            transition: vnode.transition,
            // These should technically only be non-null on mounted VNodes. However,
            // they *should* be copied for kept-alive vnodes. So we just always copy
            // them since them being non-null during a mount doesn't affect the logic as
            // they will simply be overwritten.
            component: vnode.component,
            suspense: vnode.suspense,
            el: vnode.el,
            anchor: vnode.anchor
        };
    }
    exports_5("cloneVNode", cloneVNode);
    function createTextVNode(text = ' ', flag = 0) {
        return createVNode(Text, null, text, flag);
    }
    exports_5("createTextVNode", createTextVNode);
    function createCommentVNode(text = '', 
    // when used as the v-else branch, the comment node must be created as a
    // block to ensure correct updates.
    asBlock = false) {
        return asBlock
            ? createBlock(Comment, null, text)
            : createVNode(Comment, null, text);
    }
    exports_5("createCommentVNode", createCommentVNode);
    function normalizeVNode(child) {
        if (child == null || typeof child === 'boolean') {
            // empty placeholder
            return createVNode(Comment);
        }
        else if (isArray(child)) {
            // fragment
            return createVNode(Fragment, null, child);
        }
        else if (typeof child === 'object') {
            // already vnode, this should be the most common since compiled templates
            // always produce all-vnode children arrays
            return child.el === null ? child : cloneVNode(child);
        }
        else {
            // strings and numbers
            return createVNode(Text, null, String(child));
        }
    }
    // optimized normalization for template-compiled render fns
    function cloneIfMounted(child) {
        return child.el === null ? child : cloneVNode(child);
    }
    function normalizeChildren(vnode, children) {
        let type = 0;
        if (children == null) {
            children = null;
        }
        else if (isArray(children)) {
            type = 16 /* ARRAY_CHILDREN */;
        }
        else if (typeof children === 'object') {
            type = 32 /* SLOTS_CHILDREN */;
        }
        else if (isFunction(children)) {
            children = { default: children };
            type = 32 /* SLOTS_CHILDREN */;
        }
        else {
            children = String(children);
            type = 8 /* TEXT_CHILDREN */;
        }
        vnode.children = children;
        vnode.shapeFlag |= type;
    }
    function normalizeStyle(value) {
        if (isArray(value)) {
            const res = {};
            for (let i = 0; i < value.length; i++) {
                const normalized = normalizeStyle(value[i]);
                if (normalized) {
                    for (const key in normalized) {
                        res[key] = normalized[key];
                    }
                }
            }
            return res;
        }
        else if (isObject(value)) {
            return value;
        }
    }
    function normalizeClass(value) {
        let res = '';
        if (isString(value)) {
            res = value;
        }
        else if (isArray(value)) {
            for (let i = 0; i < value.length; i++) {
                res += normalizeClass(value[i]) + ' ';
            }
        }
        else if (isObject(value)) {
            for (const name in value) {
                if (value[name]) {
                    res += name + ' ';
                }
            }
        }
        return res.trim();
    }
    function mergeProps(...args) {
        const ret = {};
        extend(ret, args[0]);
        for (let i = 1; i < args.length; i++) {
            const toMerge = args[i];
            for (const key in toMerge) {
                if (key === 'class') {
                    ret.class = normalizeClass([ret.class, toMerge.class]);
                }
                else if (key === 'style') {
                    ret.style = normalizeStyle([ret.style, toMerge.style]);
                }
                else if (handlersRE.test(key)) {
                    // on*, vnode*
                    const existing = ret[key];
                    ret[key] = existing
                        ? [].concat(existing, toMerge[key])
                        : toMerge[key];
                }
                else {
                    ret[key] = toMerge[key];
                }
            }
        }
        return ret;
    }
    exports_5("mergeProps", mergeProps);
    function nextTick(fn) {
        return fn ? p.then(fn) : p;
    }
    exports_5("nextTick", nextTick);
    function queueJob(job) {
        if (!queue.includes(job)) {
            queue.push(job);
            queueFlush();
        }
    }
    function queuePostFlushCb(cb) {
        if (!isArray(cb)) {
            postFlushCbs.push(cb);
        }
        else {
            postFlushCbs.push(...cb);
        }
        queueFlush();
    }
    function queueFlush() {
        if (!isFlushing && !isFlushPending) {
            isFlushPending = true;
            nextTick(flushJobs);
        }
    }
    function flushPostFlushCbs(seen) {
        if (postFlushCbs.length) {
            const cbs = dedupe(postFlushCbs);
            postFlushCbs.length = 0;
            {
                seen = seen || new Map();
            }
            for (let i = 0; i < cbs.length; i++) {
                {
                    checkRecursiveUpdates(seen, cbs[i]);
                }
                cbs[i]();
            }
        }
    }
    function flushJobs(seen) {
        isFlushPending = false;
        isFlushing = true;
        let job;
        {
            seen = seen || new Map();
        }
        while ((job = queue.shift())) {
            {
                checkRecursiveUpdates(seen, job);
            }
            callWithErrorHandling(job, null, 12 /* SCHEDULER */);
        }
        flushPostFlushCbs(seen);
        isFlushing = false;
        // some postFlushCb queued jobs!
        // keep flushing until it drains.
        if (queue.length || postFlushCbs.length) {
            flushJobs(seen);
        }
    }
    function checkRecursiveUpdates(seen, fn) {
        if (!seen.has(fn)) {
            seen.set(fn, 1);
        }
        else {
            const count = seen.get(fn);
            if (count > RECURSION_LIMIT) {
                throw new Error('Maximum recursive updates exceeded. ' +
                    "You may have code that is mutating state in your component's " +
                    'render function or updated hook or watcher source function.');
            }
            else {
                seen.set(fn, count + 1);
            }
        }
    }
    function markAttrsAccessed() {
        accessedAttrs = true;
    }
    function renderComponentRoot(instance) {
        const { type: Component, vnode, proxy, withProxy, props, slots, attrs, emit } = instance;
        let result;
        currentRenderingInstance = instance;
        {
            accessedAttrs = false;
        }
        try {
            if (vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */) {
                result = normalizeVNode(instance.render.call(withProxy || proxy));
            }
            else {
                // functional
                const render = Component;
                result = normalizeVNode(render.length > 1
                    ? render(props, {
                        attrs,
                        slots,
                        emit
                    })
                    : render(props, null /* we know it doesn't need it */));
            }
            // attr merging
            if (Component.props != null &&
                Component.inheritAttrs !== false &&
                attrs !== EMPTY_OBJ &&
                Object.keys(attrs).length) {
                if (result.shapeFlag & 1 /* ELEMENT */ ||
                    result.shapeFlag & 6 /* COMPONENT */) {
                    result = cloneVNode(result, attrs);
                }
                else if (true && !accessedAttrs && result.type !== Comment) {
                    warn(`Extraneous non-props attributes (${Object.keys(attrs).join(',')}) ` +
                        `were passed to component but could not be automatically inherited ` +
                        `because component renders fragment or text root nodes.`);
                }
            }
            // inherit transition data
            if (vnode.transition != null) {
                if (true &&
                    !(result.shapeFlag & 6 /* COMPONENT */) &&
                    !(result.shapeFlag & 1 /* ELEMENT */) &&
                    result.type !== Comment) {
                    warn(`Component inside <Transition> renders non-element root node ` +
                        `that cannot be animated.`);
                }
                result.transition = vnode.transition;
            }
        }
        catch (err) {
            handleError(err, instance, 1 /* RENDER_FUNCTION */);
            result = createVNode(Comment);
        }
        currentRenderingInstance = null;
        return result;
    }
    function shouldUpdateComponent(prevVNode, nextVNode, parentComponent, optimized) {
        const { props: prevProps, children: prevChildren } = prevVNode;
        const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
        if (patchFlag > 0) {
            if (patchFlag & 512 /* DYNAMIC_SLOTS */) {
                // slot content that references values that might have changed,
                // e.g. in a v-for
                return true;
            }
            if (patchFlag & 16 /* FULL_PROPS */) {
                // presence of this flag indicates props are always non-null
                return hasPropsChanged(prevProps, nextProps);
            }
            else if (patchFlag & 8 /* PROPS */) {
                const dynamicProps = nextVNode.dynamicProps;
                for (let i = 0; i < dynamicProps.length; i++) {
                    const key = dynamicProps[i];
                    if (nextProps[key] !== prevProps[key]) {
                        return true;
                    }
                }
            }
        }
        else if (!optimized) {
            // this path is only taken by manually written render functions
            // so presence of any children leads to a forced update
            if (prevChildren != null || nextChildren != null) {
                if (nextChildren == null || !nextChildren.$stable) {
                    return true;
                }
            }
            if (prevProps === nextProps) {
                return false;
            }
            if (prevProps === null) {
                return nextProps !== null;
            }
            if (nextProps === null) {
                return true;
            }
            return hasPropsChanged(prevProps, nextProps);
        }
        return false;
    }
    function hasPropsChanged(prevProps, nextProps) {
        const nextKeys = Object.keys(nextProps);
        if (nextKeys.length !== Object.keys(prevProps).length) {
            return true;
        }
        for (let i = 0; i < nextKeys.length; i++) {
            const key = nextKeys[i];
            if (nextProps[key] !== prevProps[key]) {
                return true;
            }
        }
        return false;
    }
    function updateHOCHostEl({ vnode, parent }, el // HostNode
    ) {
        while (parent && parent.subTree === vnode) {
            (vnode = parent.vnode).el = el;
            parent = parent.parent;
        }
    }
    // resolve raw VNode data.
    // - filter out reserved keys (key, ref)
    // - extract class and style into $attrs (to be merged onto child
    //   component root)
    // - for the rest:
    //   - if has declared props: put declared ones in `props`, the rest in `attrs`
    //   - else: everything goes in `props`.
    function resolveProps(instance, rawProps, _options) {
        const hasDeclaredProps = _options != null;
        if (!rawProps && !hasDeclaredProps) {
            return;
        }
        const { 0: options, 1: needCastKeys } = normalizePropsOptions(_options);
        const props = {};
        let attrs = void 0;
        // update the instance propsProxy (passed to setup()) to trigger potential
        // changes
        const propsProxy = instance.propsProxy;
        const setProp = propsProxy
            ? (key, val) => {
                props[key] = val;
                propsProxy[key] = val;
            }
            : (key, val) => {
                props[key] = val;
            };
        // allow mutation of propsProxy (which is readonly by default)
        unlock();
        if (rawProps != null) {
            for (const key in rawProps) {
                // key, ref are reserved and never passed down
                if (key === 'key' || key === 'ref')
                    continue;
                // prop option names are camelized during normalization, so to support
                // kebab -> camel conversion here we need to camelize the key.
                if (hasDeclaredProps) {
                    const camelKey = camelize(key);
                    if (hasOwn(options, camelKey)) {
                        setProp(camelKey, rawProps[key]);
                    }
                    else {
                        (attrs || (attrs = {}))[key] = rawProps[key];
                    }
                }
                else {
                    setProp(key, rawProps[key]);
                }
            }
        }
        if (hasDeclaredProps) {
            // set default values & cast booleans
            for (let i = 0; i < needCastKeys.length; i++) {
                const key = needCastKeys[i];
                let opt = options[key];
                if (opt == null)
                    continue;
                const isAbsent = !hasOwn(props, key);
                const hasDefault = hasOwn(opt, 'default');
                const currentValue = props[key];
                // default values
                if (hasDefault && currentValue === undefined) {
                    const defaultValue = opt.default;
                    setProp(key, isFunction(defaultValue) ? defaultValue() : defaultValue);
                }
                // boolean casting
                if (opt[0 /* shouldCast */]) {
                    if (isAbsent && !hasDefault) {
                        setProp(key, false);
                    }
                    else if (opt[1 /* shouldCastTrue */] &&
                        (currentValue === '' || currentValue === hyphenate(key))) {
                        setProp(key, true);
                    }
                }
            }
            // validation
            if (rawProps) {
                for (const key in options) {
                    let opt = options[key];
                    if (opt == null)
                        continue;
                    let rawValue;
                    if (!(key in rawProps) && hyphenate(key) in rawProps) {
                        rawValue = rawProps[hyphenate(key)];
                    }
                    else {
                        rawValue = rawProps[key];
                    }
                    validateProp(key, toRaw(rawValue), opt, !hasOwn(props, key));
                }
            }
        }
        else {
            // if component has no declared props, $attrs === $props
            attrs = props;
        }
        // in case of dynamic props, check if we need to delete keys from
        // the props proxy
        const { patchFlag } = instance.vnode;
        if (propsProxy !== null &&
            (patchFlag === 0 || patchFlag & 16 /* FULL_PROPS */)) {
            const rawInitialProps = toRaw(propsProxy);
            for (const key in rawInitialProps) {
                if (!hasOwn(props, key)) {
                    delete propsProxy[key];
                }
            }
        }
        // lock readonly
        lock();
        instance.props = props;
        instance.attrs = options ? attrs || EMPTY_OBJ : props;
    }
    function normalizePropsOptions(raw) {
        if (!raw) {
            return [];
        }
        if (normalizationMap.has(raw)) {
            return normalizationMap.get(raw);
        }
        const options = {};
        const needCastKeys = [];
        if (isArray(raw)) {
            for (let i = 0; i < raw.length; i++) {
                if (!isString(raw[i])) {
                    warn(`props must be strings when using array syntax.`, raw[i]);
                }
                const normalizedKey = camelize(raw[i]);
                if (normalizedKey[0] !== '$') {
                    options[normalizedKey] = EMPTY_OBJ;
                }
                else {
                    warn(`Invalid prop name: "${normalizedKey}" is a reserved property.`);
                }
            }
        }
        else {
            if (!isObject(raw)) {
                warn(`invalid props options`, raw);
            }
            for (const key in raw) {
                const normalizedKey = camelize(key);
                if (normalizedKey[0] !== '$') {
                    const opt = raw[key];
                    const prop = (options[normalizedKey] =
                        isArray(opt) || isFunction(opt) ? { type: opt } : opt);
                    if (prop != null) {
                        const booleanIndex = getTypeIndex(Boolean, prop.type);
                        const stringIndex = getTypeIndex(String, prop.type);
                        prop[0 /* shouldCast */] = booleanIndex > -1;
                        prop[1 /* shouldCastTrue */] = booleanIndex < stringIndex;
                        // if the prop needs boolean casting or default value
                        if (booleanIndex > -1 || hasOwn(prop, 'default')) {
                            needCastKeys.push(normalizedKey);
                        }
                    }
                }
                else {
                    warn(`Invalid prop name: "${normalizedKey}" is a reserved property.`);
                }
            }
        }
        const normalized = [options, needCastKeys];
        normalizationMap.set(raw, normalized);
        return normalized;
    }
    // use function string name to check type constructors
    // so that it works across vms / iframes.
    function getType(ctor) {
        const match = ctor && ctor.toString().match(/^\s*function (\w+)/);
        return match ? match[1] : '';
    }
    function isSameType(a, b) {
        return getType(a) === getType(b);
    }
    function getTypeIndex(type, expectedTypes) {
        if (isArray(expectedTypes)) {
            for (let i = 0, len = expectedTypes.length; i < len; i++) {
                if (isSameType(expectedTypes[i], type)) {
                    return i;
                }
            }
        }
        else if (isObject(expectedTypes)) {
            return isSameType(expectedTypes, type) ? 0 : -1;
        }
        return -1;
    }
    function validateProp(name, value, prop, isAbsent) {
        const { type, required, validator } = prop;
        // required!
        if (required && isAbsent) {
            warn('Missing required prop: "' + name + '"');
            return;
        }
        // missing but optional
        if (value == null && !prop.required) {
            return;
        }
        // type check
        if (type != null && type !== true) {
            let isValid = false;
            const types = isArray(type) ? type : [type];
            const expectedTypes = [];
            // value is valid as long as one of the specified types match
            for (let i = 0; i < types.length && !isValid; i++) {
                const { valid, expectedType } = assertType(value, types[i]);
                expectedTypes.push(expectedType || '');
                isValid = valid;
            }
            if (!isValid) {
                warn(getInvalidTypeMessage(name, value, expectedTypes));
                return;
            }
        }
        // custom validator
        if (validator && !validator(value)) {
            warn('Invalid prop: custom validator check failed for prop "' + name + '".');
        }
    }
    function assertType(value, type) {
        let valid;
        const expectedType = getType(type);
        if (isSimpleType(expectedType)) {
            const t = typeof value;
            valid = t === expectedType.toLowerCase();
            // for primitive wrapper objects
            if (!valid && t === 'object') {
                valid = value instanceof type;
            }
        }
        else if (expectedType === 'Object') {
            valid = toRawType(value) === 'Object';
        }
        else if (expectedType === 'Array') {
            valid = isArray(value);
        }
        else {
            valid = value instanceof type;
        }
        return {
            valid,
            expectedType
        };
    }
    function getInvalidTypeMessage(name, value, expectedTypes) {
        let message = `Invalid prop: type check failed for prop "${name}".` +
            ` Expected ${expectedTypes.map(capitalize).join(', ')}`;
        const expectedType = expectedTypes[0];
        const receivedType = toRawType(value);
        const expectedValue = styleValue(value, expectedType);
        const receivedValue = styleValue(value, receivedType);
        // check if we need to specify expected value
        if (expectedTypes.length === 1 &&
            isExplicable(expectedType) &&
            !isBoolean(expectedType, receivedType)) {
            message += ` with value ${expectedValue}`;
        }
        message += `, got ${receivedType} `;
        // check if we need to specify received value
        if (isExplicable(receivedType)) {
            message += `with value ${receivedValue}.`;
        }
        return message;
    }
    function styleValue(value, type) {
        if (type === 'String') {
            return `"${value}"`;
        }
        else if (type === 'Number') {
            return `${Number(value)}`;
        }
        else {
            return `${value}`;
        }
    }
    function isExplicable(type) {
        const explicitTypes = ['string', 'number', 'boolean'];
        return explicitTypes.some(elem => type.toLowerCase() === elem);
    }
    function isBoolean(...args) {
        return args.some(elem => elem.toLowerCase() === 'boolean');
    }
    function resolveSlots(instance, children) {
        let slots;
        if (instance.vnode.shapeFlag & 32 /* SLOTS_CHILDREN */) {
            const rawSlots = children;
            if (rawSlots._compiled) {
                // pre-normalized slots object generated by compiler
                slots = children;
            }
            else {
                slots = {};
                for (const key in rawSlots) {
                    if (key === '$stable')
                        continue;
                    const value = rawSlots[key];
                    if (isFunction(value)) {
                        slots[key] = normalizeSlot(key, value);
                    }
                    else if (value != null) {
                        {
                            warn(`Non-function value encountered for slot "${key}". ` +
                                `Prefer function slots for better performance.`);
                        }
                        const normalized = normalizeSlotValue(value);
                        slots[key] = () => normalized;
                    }
                }
            }
        }
        else if (children !== null) {
            // non slot object children (direct value) passed to a component
            if (!isKeepAlive(instance.vnode)) {
                warn(`Non-function value encountered for default slot. ` +
                    `Prefer function slots for better performance.`);
            }
            const normalized = normalizeSlotValue(children);
            slots = { default: () => normalized };
        }
        instance.slots = slots || EMPTY_OBJ;
    }
    function validateDirectiveName(name) {
        if (isBuiltInDirective(name)) {
            warn('Do not use built-in directive ids as custom directive id: ' + name);
        }
    }
    function withDirectives(vnode, directives) {
        const internalInstance = currentRenderingInstance;
        if (internalInstance === null) {
            warn(`withDirectives can only be used inside render functions.`);
            return vnode;
        }
        const instance = internalInstance.proxy;
        const props = vnode.props || (vnode.props = {});
        const bindings = vnode.dirs || (vnode.dirs = new Array(directives.length));
        const injected = {};
        for (let i = 0; i < directives.length; i++) {
            let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
            if (isFunction(dir)) {
                dir = {
                    mounted: dir,
                    updated: dir
                };
            }
            bindings[i] = {
                dir,
                instance,
                value,
                oldValue: void 0,
                arg,
                modifiers
            };
            // inject onVnodeXXX hooks
            for (const key in dir) {
                if (!injected[key]) {
                    const { 0: hookName, 1: hook } = directiveToVnodeHooksMap[key];
                    const existing = props[hookName];
                    props[hookName] = existing ? [].concat(existing, hook) : hook;
                    injected[key] = true;
                }
            }
        }
        return vnode;
    }
    exports_5("withDirectives", withDirectives);
    function invokeDirectiveHook(hook, instance, vnode, prevVNode = null) {
        callWithAsyncErrorHandling(hook, instance, 7 /* DIRECTIVE_HOOK */, [
            vnode,
            prevVNode
        ]);
    }
    function createAppContext() {
        return {
            config: {
                devtools: true,
                performance: false,
                isNativeTag: NO,
                isCustomElement: NO,
                errorHandler: undefined,
                warnHandler: undefined
            },
            mixins: [],
            components: {},
            directives: {},
            provides: {}
        };
    }
    function createAppAPI(render) {
        return function createApp(rootComponent, rootProps = null) {
            if (rootProps != null && !isObject(rootProps)) {
                warn(`root props passed to app.mount() must be an object.`);
                rootProps = null;
            }
            const context = createAppContext();
            const installedPlugins = new Set();
            let isMounted = false;
            const app = {
                _component: rootComponent,
                _props: rootProps,
                _container: null,
                get config() {
                    return context.config;
                },
                set config(v) {
                    {
                        warn(`app.config cannot be replaced. Modify individual options instead.`);
                    }
                },
                use(plugin, ...options) {
                    if (installedPlugins.has(plugin)) {
                        warn(`Plugin has already been applied to target app.`);
                    }
                    else if (plugin && isFunction(plugin.install)) {
                        installedPlugins.add(plugin);
                        plugin.install(app, ...options);
                    }
                    else if (isFunction(plugin)) {
                        installedPlugins.add(plugin);
                        plugin(app, ...options);
                    }
                    else {
                        warn(`A plugin must either be a function or an object with an "install" ` +
                            `function.`);
                    }
                    return app;
                },
                mixin(mixin) {
                    if (!context.mixins.includes(mixin)) {
                        context.mixins.push(mixin);
                    }
                    else {
                        warn('Mixin has already been applied to target app' +
                            (mixin.name ? `: ${mixin.name}` : ''));
                    }
                    return app;
                },
                component(name, component) {
                    {
                        validateComponentName(name, context.config);
                    }
                    if (!component) {
                        return context.components[name];
                    }
                    if (context.components[name]) {
                        warn(`Component "${name}" has already been registered in target app.`);
                    }
                    context.components[name] = component;
                    return app;
                },
                directive(name, directive) {
                    {
                        validateDirectiveName(name);
                    }
                    if (!directive) {
                        return context.directives[name];
                    }
                    if (context.directives[name]) {
                        warn(`Directive "${name}" has already been registered in target app.`);
                    }
                    context.directives[name] = directive;
                    return app;
                },
                mount(rootContainer) {
                    if (!isMounted) {
                        const vnode = createVNode(rootComponent, rootProps);
                        // store app context on the root VNode.
                        // this will be set on the root instance on initial mount.
                        vnode.appContext = context;
                        render(vnode, rootContainer);
                        isMounted = true;
                        app._container = rootContainer;
                        return vnode.component.proxy;
                    }
                    else {
                        warn(`App has already been mounted. Create a new app instance instead.`);
                    }
                },
                unmount() {
                    if (isMounted) {
                        render(null, app._container);
                    }
                    else {
                        warn(`Cannot unmount an app that is not mounted.`);
                    }
                },
                provide(key, value) {
                    if (key in context.provides) {
                        warn(`App already provides property with key "${key}". ` +
                            `It will be overwritten with the new value.`);
                    }
                    // TypeScript doesn't allow symbols as index type
                    // https://github.com/Microsoft/TypeScript/issues/24587
                    context.provides[key] = value;
                    return app;
                }
            };
            return app;
        };
    }
    function mountSuspense(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized, rendererInternals) {
        const { patch, options: { createElement } } = rendererInternals;
        const hiddenContainer = createElement('div');
        const suspense = (n2.suspense = createSuspenseBoundary(n2, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, optimized, rendererInternals));
        const { content, fallback } = normalizeSuspenseChildren(n2);
        suspense.subTree = content;
        suspense.fallbackTree = fallback;
        // start mounting the content subtree in an off-dom container
        patch(null, content, hiddenContainer, null, parentComponent, suspense, isSVG, optimized);
        // now check if we have encountered any async deps
        if (suspense.deps > 0) {
            // mount the fallback tree
            patch(null, fallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
            isSVG, optimized);
            n2.el = fallback.el;
        }
        else {
            // Suspense has no async deps. Just resolve.
            suspense.resolve();
        }
    }
    function patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, optimized, { patch }) {
        const suspense = (n2.suspense = n1.suspense);
        suspense.vnode = n2;
        const { content, fallback } = normalizeSuspenseChildren(n2);
        const oldSubTree = suspense.subTree;
        const oldFallbackTree = suspense.fallbackTree;
        if (!suspense.isResolved) {
            patch(oldSubTree, content, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, optimized);
            if (suspense.deps > 0) {
                // still pending. patch the fallback tree.
                patch(oldFallbackTree, fallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
                isSVG, optimized);
                n2.el = fallback.el;
            }
            // If deps somehow becomes 0 after the patch it means the patch caused an
            // async dep component to unmount and removed its dep. It will cause the
            // suspense to resolve and we don't need to do anything here.
        }
        else {
            // just normal patch inner content as a fragment
            patch(oldSubTree, content, container, anchor, parentComponent, suspense, isSVG, optimized);
            n2.el = content.el;
        }
        suspense.subTree = content;
        suspense.fallbackTree = fallback;
    }
    function createSuspenseBoundary(vnode, parent, parentComponent, container, hiddenContainer, anchor, isSVG, optimized, rendererInternals) {
        const { patch, move, unmount, next, options: { parentNode } } = rendererInternals;
        const suspense = {
            vnode,
            parent,
            parentComponent,
            isSVG,
            optimized,
            container,
            hiddenContainer,
            anchor,
            deps: 0,
            subTree: null,
            fallbackTree: null,
            isResolved: false,
            isUnmounted: false,
            effects: [],
            resolve() {
                {
                    if (suspense.isResolved) {
                        throw new Error(`resolveSuspense() is called on an already resolved suspense boundary.`);
                    }
                    if (suspense.isUnmounted) {
                        throw new Error(`resolveSuspense() is called on an already unmounted suspense boundary.`);
                    }
                }
                const { vnode, subTree, fallbackTree, effects, parentComponent, container } = suspense;
                // this is initial anchor on mount
                let { anchor } = suspense;
                // unmount fallback tree
                if (fallbackTree.el) {
                    // if the fallback tree was mounted, it may have been moved
                    // as part of a parent suspense. get the latest anchor for insertion
                    anchor = next(fallbackTree);
                    unmount(fallbackTree, parentComponent, suspense, true);
                }
                // move content from off-dom container to actual container
                move(subTree, container, anchor, 0 /* ENTER */);
                const el = (vnode.el = subTree.el);
                // suspense as the root node of a component...
                if (parentComponent && parentComponent.subTree === vnode) {
                    parentComponent.vnode.el = el;
                    updateHOCHostEl(parentComponent, el);
                }
                // check if there is a pending parent suspense
                let parent = suspense.parent;
                let hasUnresolvedAncestor = false;
                while (parent) {
                    if (!parent.isResolved) {
                        // found a pending parent suspense, merge buffered post jobs
                        // into that parent
                        parent.effects.push(...effects);
                        hasUnresolvedAncestor = true;
                        break;
                    }
                    parent = parent.parent;
                }
                // no pending parent suspense, flush all jobs
                if (!hasUnresolvedAncestor) {
                    queuePostFlushCb(effects);
                }
                suspense.isResolved = true;
                // invoke @resolve event
                const onResolve = vnode.props && vnode.props.onResolve;
                if (isFunction(onResolve)) {
                    onResolve();
                }
            },
            recede() {
                suspense.isResolved = false;
                const { vnode, subTree, fallbackTree, parentComponent, container, hiddenContainer, isSVG, optimized } = suspense;
                // move content tree back to the off-dom container
                const anchor = next(subTree);
                move(subTree, hiddenContainer, null, 1 /* LEAVE */);
                // remount the fallback tree
                patch(null, fallbackTree, container, anchor, parentComponent, null, // fallback tree will not have suspense context
                isSVG, optimized);
                const el = (vnode.el = fallbackTree.el);
                // suspense as the root node of a component...
                if (parentComponent && parentComponent.subTree === vnode) {
                    parentComponent.vnode.el = el;
                    updateHOCHostEl(parentComponent, el);
                }
                // invoke @recede event
                const onRecede = vnode.props && vnode.props.onRecede;
                if (isFunction(onRecede)) {
                    onRecede();
                }
            },
            move(container, anchor, type) {
                move(suspense.isResolved ? suspense.subTree : suspense.fallbackTree, container, anchor, type);
                suspense.container = container;
            },
            next() {
                return next(suspense.isResolved ? suspense.subTree : suspense.fallbackTree);
            },
            registerDep(instance, setupRenderEffect) {
                // suspense is already resolved, need to recede.
                // use queueJob so it's handled synchronously after patching the current
                // suspense tree
                if (suspense.isResolved) {
                    queueJob(() => {
                        suspense.recede();
                    });
                }
                suspense.deps++;
                instance
                    .asyncDep.catch(err => {
                    handleError(err, instance, 0 /* SETUP_FUNCTION */);
                })
                    .then(asyncSetupResult => {
                    // retry when the setup() promise resolves.
                    // component may have been unmounted before resolve.
                    if (instance.isUnmounted || suspense.isUnmounted) {
                        return;
                    }
                    suspense.deps--;
                    // retry from this component
                    instance.asyncResolved = true;
                    const { vnode } = instance;
                    {
                        pushWarningContext(vnode);
                    }
                    handleSetupResult(instance, asyncSetupResult, suspense);
                    setupRenderEffect(instance, suspense, vnode, 
                    // component may have been moved before resolve
                    parentNode(instance.subTree.el), next(instance.subTree), isSVG);
                    updateHOCHostEl(instance, vnode.el);
                    {
                        popWarningContext();
                    }
                    if (suspense.deps === 0) {
                        suspense.resolve();
                    }
                });
            },
            unmount(parentSuspense, doRemove) {
                suspense.isUnmounted = true;
                unmount(suspense.subTree, parentComponent, parentSuspense, doRemove);
                if (!suspense.isResolved) {
                    unmount(suspense.fallbackTree, parentComponent, parentSuspense, doRemove);
                }
            }
        };
        return suspense;
    }
    function normalizeSuspenseChildren(vnode) {
        const { shapeFlag, children } = vnode;
        if (shapeFlag & 32 /* SLOTS_CHILDREN */) {
            const { default: d, fallback } = children;
            return {
                content: normalizeVNode(isFunction(d) ? d() : d),
                fallback: normalizeVNode(isFunction(fallback) ? fallback() : fallback)
            };
        }
        else {
            return {
                content: normalizeVNode(children),
                fallback: normalizeVNode(null)
            };
        }
    }
    function queueEffectWithSuspense(fn, suspense) {
        if (suspense !== null && !suspense.isResolved) {
            if (isArray(fn)) {
                suspense.effects.push(...fn);
            }
            else {
                suspense.effects.push(fn);
            }
        }
        else {
            queuePostFlushCb(fn);
        }
    }
    function createDevEffectOptions(instance) {
        return {
            scheduler: queueJob,
            onTrack: instance.rtc ? e => invokeHooks(instance.rtc, e) : void 0,
            onTrigger: instance.rtg ? e => invokeHooks(instance.rtg, e) : void 0
        };
    }
    function invokeHooks(hooks, arg) {
        for (let i = 0; i < hooks.length; i++) {
            hooks[i](arg);
        }
    }
    /**
     * The createRenderer function accepts two generic arguments:
     * HostNode and HostElement, corresponding to Node and Element types in the
     * host environment. For example, for runtime-dom, HostNode would be the DOM
     * `Node` interface and HostElement would be the DOM `Element` interface.
     *
     * Custom renderers can pass in the platform specific types like this:
     *
     * ``` js
     * const { render, createApp } = createRenderer<Node, Element>({
     *   patchProp,
     *   ...nodeOps
     * })
     * ```
     */
    function createRenderer(options) {
        const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, querySelector: hostQuerySelector, setScopeId: hostSetScopeId } = options;
        const internals = {
            patch,
            unmount,
            move,
            next: getNextHostNode,
            options
        };
        function patch(n1, // null means this is a mount
        n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, optimized = false) {
            // patching & not same type, unmount old tree
            if (n1 != null && !isSameVNodeType(n1, n2)) {
                anchor = getNextHostNode(n1);
                unmount(n1, parentComponent, parentSuspense, true);
                n1 = null;
            }
            const { type, shapeFlag } = n2;
            switch (type) {
                case Text:
                    processText(n1, n2, container, anchor);
                    break;
                case Comment:
                    processCommentNode(n1, n2, container, anchor);
                    break;
                case Fragment:
                    processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
                    break;
                case Portal:
                    processPortal(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
                    break;
                default:
                    if (shapeFlag & 1 /* ELEMENT */) {
                        processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
                    }
                    else if (shapeFlag & 6 /* COMPONENT */) {
                        processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
                    }
                    else if (shapeFlag & 64 /* SUSPENSE */) {
                        type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized, internals);
                    }
                    else {
                        warn('Invalid HostVNode type:', n2.type, `(${typeof n2.type})`);
                    }
            }
        }
        function processText(n1, n2, container, anchor) {
            if (n1 == null) {
                hostInsert((n2.el = hostCreateText(n2.children)), container, anchor);
            }
            else {
                const el = (n2.el = n1.el);
                if (n2.children !== n1.children) {
                    hostSetText(el, n2.children);
                }
            }
        }
        function processCommentNode(n1, n2, container, anchor) {
            if (n1 == null) {
                hostInsert((n2.el = hostCreateComment(n2.children || '')), container, anchor);
            }
            else {
                // there's no support for dynamic comments
                n2.el = n1.el;
            }
        }
        function processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) {
            isSVG = isSVG || n2.type === 'svg';
            if (n1 == null) {
                mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
            }
            else {
                patchElement(n1, n2, parentComponent, parentSuspense, isSVG, optimized);
            }
            if (n2.ref !== null && parentComponent !== null) {
                setRef(n2.ref, n1 && n1.ref, parentComponent, n2.el);
            }
        }
        function mountElement(vnode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) {
            const el = (vnode.el = hostCreateElement(vnode.type, isSVG));
            const { type, props, shapeFlag, transition, scopeId } = vnode;
            // props
            if (props != null) {
                for (const key in props) {
                    if (isReservedProp(key))
                        continue;
                    hostPatchProp(el, key, props[key], null, isSVG);
                }
                if (props.onVnodeBeforeMount != null) {
                    invokeDirectiveHook(props.onVnodeBeforeMount, parentComponent, vnode);
                }
            }
            // children
            if (shapeFlag & 8 /* TEXT_CHILDREN */) {
                hostSetElementText(el, vnode.children);
            }
            else if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== 'foreignObject', optimized || vnode.dynamicChildren !== null);
            }
            if (transition != null && !transition.persisted) {
                transition.beforeEnter(el);
            }
            hostInsert(el, container, anchor);
            const vnodeMountedHook = props && props.onVnodeMounted;
            if (vnodeMountedHook != null ||
                (transition != null && !transition.persisted)) {
                queuePostRenderEffect(() => {
                    vnodeMountedHook &&
                        invokeDirectiveHook(vnodeMountedHook, parentComponent, vnode);
                    transition && !transition.persisted && transition.enter(el);
                }, parentSuspense);
            }
        }
        function mountChildren(children, container, anchor, parentComponent, parentSuspense, isSVG, optimized, start = 0) {
            for (let i = start; i < children.length; i++) {
                const child = (children[i] = optimized
                    ? cloneIfMounted(children[i])
                    : normalizeVNode(children[i]));
                patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
            }
        }
        function patchElement(n1, n2, parentComponent, parentSuspense, isSVG, optimized) {
            const el = (n2.el = n1.el);
            let { patchFlag, dynamicChildren } = n2;
            const oldProps = (n1 && n1.props) || EMPTY_OBJ;
            const newProps = n2.props || EMPTY_OBJ;
            if (newProps.onVnodeBeforeUpdate != null) {
                invokeDirectiveHook(newProps.onVnodeBeforeUpdate, parentComponent, n2, n1);
            }
            if (patchFlag > 0) {
                // the presence of a patchFlag means this element's render code was
                // generated by the compiler and can take the fast path.
                // in this path old node and new node are guaranteed to have the same shape
                // (i.e. at the exact same position in the source template)
                if (patchFlag & 16 /* FULL_PROPS */) {
                    // element props contain dynamic keys, full diff needed
                    patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
                }
                else {
                    // class
                    // this flag is matched when the element has dynamic class bindings.
                    if (patchFlag & 2 /* CLASS */) {
                        if (oldProps.class !== newProps.class) {
                            hostPatchProp(el, 'class', newProps.class, null, isSVG);
                        }
                    }
                    // style
                    // this flag is matched when the element has dynamic style bindings
                    if (patchFlag & 4 /* STYLE */) {
                        hostPatchProp(el, 'style', newProps.style, oldProps.style, isSVG);
                    }
                    // props
                    // This flag is matched when the element has dynamic prop/attr bindings
                    // other than class and style. The keys of dynamic prop/attrs are saved for
                    // faster iteration.
                    // Note dynamic keys like :[foo]="bar" will cause this optimization to
                    // bail out and go through a full diff because we need to unset the old key
                    if (patchFlag & 8 /* PROPS */) {
                        // if the flag is present then dynamicProps must be non-null
                        const propsToUpdate = n2.dynamicProps;
                        for (let i = 0; i < propsToUpdate.length; i++) {
                            const key = propsToUpdate[i];
                            const prev = oldProps[key];
                            const next = newProps[key];
                            if (prev !== next) {
                                hostPatchProp(el, key, next, prev, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);
                            }
                        }
                    }
                }
                // text
                // This flag is matched when the element has only dynamic text children.
                // this flag is terminal (i.e. skips children diffing).
                if (patchFlag & 1 /* TEXT */) {
                    if (n1.children !== n2.children) {
                        hostSetElementText(el, n2.children);
                    }
                    return; // terminal
                }
            }
            else if (!optimized && dynamicChildren == null) {
                // unoptimized, full diff
                patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
            }
            const areChildrenSVG = isSVG && n2.type !== 'foreignObject';
            if (dynamicChildren != null) {
                patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG);
            }
            else if (!optimized) {
                // full diff
                patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG);
            }
            if (newProps.onVnodeUpdated != null) {
                queuePostRenderEffect(() => {
                    invokeDirectiveHook(newProps.onVnodeUpdated, parentComponent, n2, n1);
                }, parentSuspense);
            }
        }
        // The fast path for blocks.
        function patchBlockChildren(oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG) {
            for (let i = 0; i < newChildren.length; i++) {
                const oldVNode = oldChildren[i];
                const newVNode = newChildren[i];
                // Determine the container (parent element) for the patch.
                const container = 
                // - In the case of a Fragment, we need to provide the actual parent
                // of the Fragment itself so it can move its children.
                oldVNode.type === Fragment ||
                    // - In the case of different nodes, there is going to be a replacement
                    // which also requires the correct parent container
                    !isSameVNodeType(oldVNode, newVNode) ||
                    // - In the case of a component, it could contain anything.
                    oldVNode.shapeFlag & 6 /* COMPONENT */
                    ? hostParentNode(oldVNode.el)
                    : // In other cases, the parent container is not actually used so we
                        // just pass the block element here to avoid a DOM parentNode call.
                        fallbackContainer;
                patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, true);
            }
        }
        function patchProps(el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) {
            if (oldProps !== newProps) {
                for (const key in newProps) {
                    if (isReservedProp(key))
                        continue;
                    const next = newProps[key];
                    const prev = oldProps[key];
                    if (next !== prev) {
                        hostPatchProp(el, key, next, prev, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
                    }
                }
                if (oldProps !== EMPTY_OBJ) {
                    for (const key in oldProps) {
                        if (!isReservedProp(key) && !(key in newProps)) {
                            hostPatchProp(el, key, null, null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
                        }
                    }
                }
            }
        }
        let devFragmentID = 0;
        function processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) {
            const fragmentStartAnchor = (n2.el = n1
                ? n1.el
                : hostCreateComment(`fragment-${devFragmentID}-start`));
            const fragmentEndAnchor = (n2.anchor = n1
                ? n1.anchor
                : hostCreateComment(`fragment-${devFragmentID}-end`));
            let { patchFlag, dynamicChildren } = n2;
            if (patchFlag > 0) {
                optimized = true;
            }
            if (n1 == null) {
                {
                    devFragmentID++;
                }
                hostInsert(fragmentStartAnchor, container, anchor);
                hostInsert(fragmentEndAnchor, container, anchor);
                // a fragment can only have array children
                // since they are either generated by the compiler, or implicitly created
                // from arrays.
                mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, optimized);
            }
            else {
                if (patchFlag & 64 /* STABLE_FRAGMENT */ && dynamicChildren != null) {
                    // a stable fragment (template root or <template v-for>) doesn't need to
                    // patch children order, but it may contain dynamicChildren.
                    patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG);
                }
                else {
                    // keyed / unkeyed, or manual fragments.
                    // for keyed & unkeyed, since they are compiler generated from v-for,
                    // each child is guaranteed to be a block so the fragment will never
                    // have dynamicChildren.
                    patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, optimized);
                }
            }
        }
        function processPortal(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) {
            const targetSelector = n2.props && n2.props.target;
            const { patchFlag, shapeFlag, children } = n2;
            if (n1 == null) {
                const target = (n2.target = isString(targetSelector)
                    ? hostQuerySelector(targetSelector)
                    : targetSelector);
                if (target != null) {
                    if (shapeFlag & 8 /* TEXT_CHILDREN */) {
                        hostSetElementText(target, children);
                    }
                    else if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                        mountChildren(children, target, null, parentComponent, parentSuspense, isSVG, optimized);
                    }
                }
                else {
                    warn('Invalid Portal target on mount:', target, `(${typeof target})`);
                }
            }
            else {
                // update content
                const target = (n2.target = n1.target);
                if (patchFlag === 1 /* TEXT */) {
                    hostSetElementText(target, children);
                }
                else if (n2.dynamicChildren) {
                    // fast path when the portal happens to be a block root
                    patchBlockChildren(n1.dynamicChildren, n2.dynamicChildren, container, parentComponent, parentSuspense, isSVG);
                }
                else if (!optimized) {
                    patchChildren(n1, n2, target, null, parentComponent, parentSuspense, isSVG);
                }
                // target changed
                if (targetSelector !== (n1.props && n1.props.target)) {
                    const nextTarget = (n2.target = isString(targetSelector)
                        ? hostQuerySelector(targetSelector)
                        : targetSelector);
                    if (nextTarget != null) {
                        // move content
                        if (shapeFlag & 8 /* TEXT_CHILDREN */) {
                            hostSetElementText(target, '');
                            hostSetElementText(nextTarget, children);
                        }
                        else if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                            for (let i = 0; i < children.length; i++) {
                                move(children[i], nextTarget, null, 2 /* REORDER */);
                            }
                        }
                    }
                    else {
                        warn('Invalid Portal target on update:', target, `(${typeof target})`);
                    }
                }
            }
            // insert an empty node as the placeholder for the portal
            processCommentNode(n1, n2, container, anchor);
        }
        function processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) {
            if (n1 == null) {
                if (n2.shapeFlag & 256 /* COMPONENT_KEPT_ALIVE */) {
                    parentComponent.sink.activate(n2, container, anchor);
                }
                else {
                    mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG);
                }
            }
            else {
                const instance = (n2.component = n1.component);
                if (shouldUpdateComponent(n1, n2, parentComponent, optimized)) {
                    if (instance.asyncDep &&
                        !instance.asyncResolved) {
                        // async & still pending - just update props and slots
                        // since the component's reactive effect for render isn't set-up yet
                        {
                            pushWarningContext(n2);
                        }
                        updateComponentPreRender(instance, n2);
                        {
                            popWarningContext();
                        }
                        return;
                    }
                    else {
                        // normal update
                        instance.next = n2;
                        // instance.update is the reactive effect runner.
                        instance.update();
                    }
                }
                else {
                    // no update needed. just copy over properties
                    n2.component = n1.component;
                    n2.el = n1.el;
                }
            }
            if (n2.ref !== null && parentComponent !== null) {
                if (!(n2.shapeFlag & 4 /* STATEFUL_COMPONENT */)) {
                    pushWarningContext(n2);
                    warn(`Functional components do not support "ref" because they do not ` +
                        `have instances.`);
                    popWarningContext();
                }
                setRef(n2.ref, n1 && n1.ref, parentComponent, n2.component.proxy);
            }
        }
        function mountComponent(initialVNode, container, anchor, parentComponent, parentSuspense, isSVG) {
            const instance = (initialVNode.component = createComponentInstance(initialVNode, parentComponent));
            {
                pushWarningContext(initialVNode);
            }
            // inject renderer internals for keepAlive
            if (isKeepAlive(initialVNode)) {
                const sink = instance.sink;
                sink.renderer = internals;
                sink.parentSuspense = parentSuspense;
            }
            // resolve props and slots for setup context
            setupComponent(instance, parentSuspense);
            // setup() is async. This component relies on async logic to be resolved
            // before proceeding
            if (instance.asyncDep) {
                if (!parentSuspense) {
                    warn('async setup() is used without a suspense boundary!');
                    return;
                }
                parentSuspense.registerDep(instance, setupRenderEffect);
                // give it a placeholder
                const placeholder = (instance.subTree = createVNode(Comment));
                processCommentNode(null, placeholder, container, anchor);
                initialVNode.el = placeholder.el;
                return;
            }
            setupRenderEffect(instance, parentSuspense, initialVNode, container, anchor, isSVG);
            {
                popWarningContext();
            }
        }
        function setupRenderEffect(instance, parentSuspense, initialVNode, container, anchor, isSVG) {
            // create reactive effect for rendering
            instance.update = effect(function componentEffect() {
                if (!instance.isMounted) {
                    const subTree = (instance.subTree = renderComponentRoot(instance));
                    // beforeMount hook
                    if (instance.bm !== null) {
                        invokeHooks(instance.bm);
                    }
                    patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);
                    initialVNode.el = subTree.el;
                    // mounted hook
                    if (instance.m !== null) {
                        queuePostRenderEffect(instance.m, parentSuspense);
                    }
                    // activated hook for keep-alive roots.
                    if (instance.a !== null &&
                        instance.vnode.shapeFlag & 128 /* COMPONENT_SHOULD_KEEP_ALIVE */) {
                        queuePostRenderEffect(instance.a, parentSuspense);
                    }
                    instance.isMounted = true;
                }
                else {
                    // updateComponent
                    // This is triggered by mutation of component's own state (next: null)
                    // OR parent calling processComponent (next: HostVNode)
                    const { next } = instance;
                    {
                        pushWarningContext(next || instance.vnode);
                    }
                    if (next !== null) {
                        updateComponentPreRender(instance, next);
                    }
                    const nextTree = renderComponentRoot(instance);
                    const prevTree = instance.subTree;
                    instance.subTree = nextTree;
                    // beforeUpdate hook
                    if (instance.bu !== null) {
                        invokeHooks(instance.bu);
                    }
                    // reset refs
                    // only needed if previous patch had refs
                    if (instance.refs !== EMPTY_OBJ) {
                        instance.refs = {};
                    }
                    patch(prevTree, nextTree, 
                    // parent may have changed if it's in a portal
                    hostParentNode(prevTree.el), 
                    // anchor may have changed if it's in a fragment
                    getNextHostNode(prevTree), instance, parentSuspense, isSVG);
                    instance.vnode.el = nextTree.el;
                    if (next === null) {
                        // self-triggered update. In case of HOC, update parent component
                        // vnode el. HOC is indicated by parent instance's subTree pointing
                        // to child component's vnode
                        updateHOCHostEl(instance, nextTree.el);
                    }
                    // updated hook
                    if (instance.u !== null) {
                        queuePostRenderEffect(instance.u, parentSuspense);
                    }
                    {
                        popWarningContext();
                    }
                }
            }, createDevEffectOptions(instance));
        }
        function updateComponentPreRender(instance, nextVNode) {
            nextVNode.component = instance;
            instance.vnode = nextVNode;
            instance.next = null;
            resolveProps(instance, nextVNode.props, nextVNode.type.props);
            resolveSlots(instance, nextVNode.children);
        }
        function patchChildren(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized = false) {
            const c1 = n1 && n1.children;
            const prevShapeFlag = n1 ? n1.shapeFlag : 0;
            const c2 = n2.children;
            const { patchFlag, shapeFlag } = n2;
            if (patchFlag === -1 /* BAIL */) {
                optimized = false;
            }
            // fast path
            if (patchFlag > 0) {
                if (patchFlag & 128 /* KEYED_FRAGMENT */) {
                    // this could be either fully-keyed or mixed (some keyed some not)
                    // presence of patchFlag means children are guaranteed to be arrays
                    patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
                    return;
                }
                else if (patchFlag & 256 /* UNKEYED_FRAGMENT */) {
                    // unkeyed
                    patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
                    return;
                }
            }
            // children has 3 possibilities: text, array or no children.
            if (shapeFlag & 8 /* TEXT_CHILDREN */) {
                // text children fast path
                if (prevShapeFlag & 16 /* ARRAY_CHILDREN */) {
                    unmountChildren(c1, parentComponent, parentSuspense);
                }
                if (c2 !== c1) {
                    hostSetElementText(container, c2);
                }
            }
            else {
                if (prevShapeFlag & 16 /* ARRAY_CHILDREN */) {
                    // prev children was array
                    if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                        // two arrays, cannot assume anything, do full diff
                        patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
                    }
                    else {
                        // no new children, just unmount old
                        unmountChildren(c1, parentComponent, parentSuspense, true);
                    }
                }
                else {
                    // prev children was text OR null
                    // new children is array OR null
                    if (prevShapeFlag & 8 /* TEXT_CHILDREN */) {
                        hostSetElementText(container, '');
                    }
                    // mount new if array
                    if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                        mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
                    }
                }
            }
        }
        function patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) {
            c1 = c1 || EMPTY_ARR;
            c2 = c2 || EMPTY_ARR;
            const oldLength = c1.length;
            const newLength = c2.length;
            const commonLength = Math.min(oldLength, newLength);
            let i;
            for (i = 0; i < commonLength; i++) {
                const nextChild = (c2[i] = optimized
                    ? cloneIfMounted(c2[i])
                    : normalizeVNode(c2[i]));
                patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, optimized);
            }
            if (oldLength > newLength) {
                // remove old
                unmountChildren(c1, parentComponent, parentSuspense, true, commonLength);
            }
            else {
                // mount new
                mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized, commonLength);
            }
        }
        // can be all-keyed or mixed
        function patchKeyedChildren(c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized) {
            let i = 0;
            const l2 = c2.length;
            let e1 = c1.length - 1; // prev ending index
            let e2 = l2 - 1; // next ending index
            // 1. sync from start
            // (a b) c
            // (a b) d e
            while (i <= e1 && i <= e2) {
                const n1 = c1[i];
                const n2 = (c2[i] = optimized
                    ? cloneIfMounted(c2[i])
                    : normalizeVNode(c2[i]));
                if (isSameVNodeType(n1, n2)) {
                    patch(n1, n2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized);
                }
                else {
                    break;
                }
                i++;
            }
            // 2. sync from end
            // a (b c)
            // d e (b c)
            while (i <= e1 && i <= e2) {
                const n1 = c1[e1];
                const n2 = (c2[e2] = optimized
                    ? cloneIfMounted(c2[e2])
                    : normalizeVNode(c2[e2]));
                if (isSameVNodeType(n1, n2)) {
                    patch(n1, n2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized);
                }
                else {
                    break;
                }
                e1--;
                e2--;
            }
            // 3. common sequence + mount
            // (a b)
            // (a b) c
            // i = 2, e1 = 1, e2 = 2
            // (a b)
            // c (a b)
            // i = 0, e1 = -1, e2 = 0
            if (i > e1) {
                if (i <= e2) {
                    const nextPos = e2 + 1;
                    const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
                    while (i <= e2) {
                        patch(null, (c2[i] = optimized
                            ? cloneIfMounted(c2[i])
                            : normalizeVNode(c2[i])), container, anchor, parentComponent, parentSuspense, isSVG);
                        i++;
                    }
                }
            }
            // 4. common sequence + unmount
            // (a b) c
            // (a b)
            // i = 2, e1 = 2, e2 = 1
            // a (b c)
            // (b c)
            // i = 0, e1 = 0, e2 = -1
            else if (i > e2) {
                while (i <= e1) {
                    unmount(c1[i], parentComponent, parentSuspense, true);
                    i++;
                }
            }
            // 5. unknown sequence
            // [i ... e1 + 1]: a b [c d e] f g
            // [i ... e2 + 1]: a b [e d c h] f g
            // i = 2, e1 = 4, e2 = 5
            else {
                const s1 = i; // prev starting index
                const s2 = i; // next starting index
                // 5.1 build key:index map for newChildren
                const keyToNewIndexMap = new Map();
                for (i = s2; i <= e2; i++) {
                    const nextChild = (c2[i] = optimized
                        ? cloneIfMounted(c2[i])
                        : normalizeVNode(c2[i]));
                    if (nextChild.key != null) {
                        if (keyToNewIndexMap.has(nextChild.key)) {
                            warn(`Duplicate keys found during update:`, JSON.stringify(nextChild.key), `Make sure keys are unique.`);
                        }
                        keyToNewIndexMap.set(nextChild.key, i);
                    }
                }
                // 5.2 loop through old children left to be patched and try to patch
                // matching nodes & remove nodes that are no longer present
                let j;
                let patched = 0;
                const toBePatched = e2 - s2 + 1;
                let moved = false;
                // used to track whether any node has moved
                let maxNewIndexSoFar = 0;
                // works as Map<newIndex, oldIndex>
                // Note that oldIndex is offset by +1
                // and oldIndex = 0 is a special value indicating the new node has
                // no corresponding old node.
                // used for determining longest stable subsequence
                const newIndexToOldIndexMap = new Array(toBePatched);
                for (i = 0; i < toBePatched; i++)
                    newIndexToOldIndexMap[i] = 0;
                for (i = s1; i <= e1; i++) {
                    const prevChild = c1[i];
                    if (patched >= toBePatched) {
                        // all new children have been patched so this can only be a removal
                        unmount(prevChild, parentComponent, parentSuspense, true);
                        continue;
                    }
                    let newIndex;
                    if (prevChild.key != null) {
                        newIndex = keyToNewIndexMap.get(prevChild.key);
                    }
                    else {
                        // key-less node, try to locate a key-less node of the same type
                        for (j = s2; j <= e2; j++) {
                            if (newIndexToOldIndexMap[j - s2] === 0 &&
                                isSameVNodeType(prevChild, c2[j])) {
                                newIndex = j;
                                break;
                            }
                        }
                    }
                    if (newIndex === undefined) {
                        unmount(prevChild, parentComponent, parentSuspense, true);
                    }
                    else {
                        newIndexToOldIndexMap[newIndex - s2] = i + 1;
                        if (newIndex >= maxNewIndexSoFar) {
                            maxNewIndexSoFar = newIndex;
                        }
                        else {
                            moved = true;
                        }
                        patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, optimized);
                        patched++;
                    }
                }
                // 5.3 move and mount
                // generate longest stable subsequence only when nodes have moved
                const increasingNewIndexSequence = moved
                    ? getSequence(newIndexToOldIndexMap)
                    : EMPTY_ARR;
                j = increasingNewIndexSequence.length - 1;
                // looping backwards so that we can use last patched node as anchor
                for (i = toBePatched - 1; i >= 0; i--) {
                    const nextIndex = s2 + i;
                    const nextChild = c2[nextIndex];
                    const anchor = nextIndex + 1 < l2
                        ? c2[nextIndex + 1].el
                        : parentAnchor;
                    if (newIndexToOldIndexMap[i] === 0) {
                        // mount new
                        patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG);
                    }
                    else if (moved) {
                        // move if:
                        // There is no stable subsequence (e.g. a reverse)
                        // OR current node is not among the stable sequence
                        if (j < 0 || i !== increasingNewIndexSequence[j]) {
                            move(nextChild, container, anchor, 2 /* REORDER */);
                        }
                        else {
                            j--;
                        }
                    }
                }
            }
        }
        function move(vnode, container, anchor, type, parentSuspense = null) {
            if (vnode.shapeFlag & 6 /* COMPONENT */) {
                move(vnode.component.subTree, container, anchor, type);
                return;
            }
            if (vnode.shapeFlag & 64 /* SUSPENSE */) {
                vnode.suspense.move(container, anchor, type);
                return;
            }
            if (vnode.type === Fragment) {
                hostInsert(vnode.el, container, anchor);
                const children = vnode.children;
                for (let i = 0; i < children.length; i++) {
                    move(children[i], container, anchor, type);
                }
                hostInsert(vnode.anchor, container, anchor);
            }
            else {
                // Plain element
                const { el, transition, shapeFlag } = vnode;
                const needTransition = type !== 2 /* REORDER */ &&
                    shapeFlag & 1 /* ELEMENT */ &&
                    transition != null;
                if (needTransition) {
                    if (type === 0 /* ENTER */) {
                        transition.beforeEnter(el);
                        hostInsert(el, container, anchor);
                        queuePostRenderEffect(() => transition.enter(el), parentSuspense);
                    }
                    else {
                        const { leave, delayLeave, afterLeave } = transition;
                        const remove = () => hostInsert(el, container, anchor);
                        const performLeave = () => {
                            leave(el, () => {
                                remove();
                                afterLeave && afterLeave();
                            });
                        };
                        if (delayLeave) {
                            delayLeave(el, remove, performLeave);
                        }
                        else {
                            performLeave();
                        }
                    }
                }
                else {
                    hostInsert(el, container, anchor);
                }
            }
        }
        function unmount(vnode, parentComponent, parentSuspense, doRemove) {
            const { props, ref, children, dynamicChildren, shapeFlag } = vnode;
            // unset ref
            if (ref !== null && parentComponent !== null) {
                setRef(ref, null, parentComponent, null);
            }
            if (shapeFlag & 6 /* COMPONENT */) {
                if (shapeFlag & 128 /* COMPONENT_SHOULD_KEEP_ALIVE */) {
                    parentComponent.sink.deactivate(vnode);
                }
                else {
                    unmountComponent(vnode.component, parentSuspense, doRemove);
                }
                return;
            }
            if (shapeFlag & 64 /* SUSPENSE */) {
                vnode.suspense.unmount(parentSuspense, doRemove);
                return;
            }
            if (props != null && props.onVnodeBeforeUnmount != null) {
                invokeDirectiveHook(props.onVnodeBeforeUnmount, parentComponent, vnode);
            }
            if (dynamicChildren != null) {
                // fast path for block nodes: only need to unmount dynamic children.
                unmountChildren(dynamicChildren, parentComponent, parentSuspense);
            }
            else if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                unmountChildren(children, parentComponent, parentSuspense);
            }
            if (doRemove) {
                remove(vnode);
            }
            if (props != null && props.onVnodeUnmounted != null) {
                queuePostRenderEffect(() => {
                    invokeDirectiveHook(props.onVnodeUnmounted, parentComponent, vnode);
                }, parentSuspense);
            }
        }
        function remove(vnode) {
            const { type, el, anchor, transition } = vnode;
            if (type === Fragment) {
                removeFragment(el, anchor);
                return;
            }
            const performRemove = () => {
                hostRemove(el);
                if (transition != null &&
                    !transition.persisted &&
                    transition.afterLeave) {
                    transition.afterLeave();
                }
            };
            if (vnode.shapeFlag & 1 /* ELEMENT */ &&
                transition != null &&
                !transition.persisted) {
                const { leave, delayLeave } = transition;
                const performLeave = () => leave(el, performRemove);
                if (delayLeave) {
                    delayLeave(vnode.el, performRemove, performLeave);
                }
                else {
                    performLeave();
                }
            }
            else {
                performRemove();
            }
        }
        function removeFragment(cur, end) {
            // For fragments, directly remove all contained DOM nodes.
            // (fragment child nodes cannot have transition)
            let next;
            while (cur !== end) {
                next = hostNextSibling(cur);
                hostRemove(cur);
                cur = next;
            }
            hostRemove(end);
        }
        function unmountComponent(instance, parentSuspense, doRemove) {
            const { bum, effects, update, subTree, um, da, isDeactivated } = instance;
            // beforeUnmount hook
            if (bum !== null) {
                invokeHooks(bum);
            }
            if (effects !== null) {
                for (let i = 0; i < effects.length; i++) {
                    stop(effects[i]);
                }
            }
            // update may be null if a component is unmounted before its async
            // setup has resolved.
            if (update !== null) {
                stop(update);
                unmount(subTree, instance, parentSuspense, doRemove);
            }
            // unmounted hook
            if (um !== null) {
                queuePostRenderEffect(um, parentSuspense);
            }
            // deactivated hook
            if (da !== null &&
                !isDeactivated &&
                instance.vnode.shapeFlag & 128 /* COMPONENT_SHOULD_KEEP_ALIVE */) {
                queuePostRenderEffect(da, parentSuspense);
            }
            queuePostFlushCb(() => {
                instance.isUnmounted = true;
            });
            // A component with async dep inside a pending suspense is unmounted before
            // its async dep resolves. This should remove the dep from the suspense, and
            // cause the suspense to resolve immediately if that was the last dep.
            if (parentSuspense !== null &&
                !parentSuspense.isResolved &&
                !parentSuspense.isUnmounted &&
                instance.asyncDep !== null &&
                !instance.asyncResolved) {
                parentSuspense.deps--;
                if (parentSuspense.deps === 0) {
                    parentSuspense.resolve();
                }
            }
        }
        function unmountChildren(children, parentComponent, parentSuspense, doRemove, start = 0) {
            for (let i = start; i < children.length; i++) {
                unmount(children[i], parentComponent, parentSuspense, doRemove);
            }
        }
        function getNextHostNode(vnode) {
            if (vnode.shapeFlag & 6 /* COMPONENT */) {
                return getNextHostNode(vnode.component.subTree);
            }
            if (vnode.shapeFlag & 64 /* SUSPENSE */) {
                return vnode.suspense.next();
            }
            return hostNextSibling((vnode.anchor || vnode.el));
        }
        function setRef(ref, oldRef, parent, value) {
            const refs = parent.refs === EMPTY_OBJ ? (parent.refs = {}) : parent.refs;
            const renderContext = toRaw(parent.renderContext);
            // unset old ref
            if (oldRef !== null && oldRef !== ref) {
                if (isString(oldRef)) {
                    refs[oldRef] = null;
                    const oldSetupRef = renderContext[oldRef];
                    if (isRef(oldSetupRef)) {
                        oldSetupRef.value = null;
                    }
                }
                else if (isRef(oldRef)) {
                    oldRef.value = null;
                }
            }
            if (isString(ref)) {
                const setupRef = renderContext[ref];
                if (isRef(setupRef)) {
                    setupRef.value = value;
                }
                refs[ref] = value;
            }
            else if (isRef(ref)) {
                ref.value = value;
            }
            else if (isFunction(ref)) {
                callWithErrorHandling(ref, parent, 11 /* FUNCTION_REF */, [value, refs]);
            }
            else {
                warn('Invalid template ref type:', value, `(${typeof value})`);
            }
        }
        const render = (vnode, container) => {
            if (vnode == null) {
                if (container._vnode) {
                    unmount(container._vnode, null, null, true);
                }
            }
            else {
                patch(container._vnode || null, vnode, container);
            }
            flushPostFlushCbs();
            container._vnode = vnode;
        };
        return {
            render,
            createApp: createAppAPI(render)
        };
    }
    exports_5("createRenderer", createRenderer);
    // https://en.wikipedia.org/wiki/Longest_increasing_subsequence
    function getSequence(arr) {
        const p = arr.slice();
        const result = [0];
        let i, j, u, v, c;
        const len = arr.length;
        for (i = 0; i < len; i++) {
            const arrI = arr[i];
            if (arrI !== 0) {
                j = result[result.length - 1];
                if (arr[j] < arrI) {
                    p[i] = j;
                    result.push(i);
                    continue;
                }
                u = 0;
                v = result.length - 1;
                while (u < v) {
                    c = ((u + v) / 2) | 0;
                    if (arr[result[c]] < arrI) {
                        u = c + 1;
                    }
                    else {
                        v = c;
                    }
                }
                if (arrI < arr[result[u]]) {
                    if (u > 0) {
                        p[i] = result[u - 1];
                    }
                    result[u] = i;
                }
            }
        }
        u = result.length;
        v = result[u - 1];
        while (u-- > 0) {
            result[u] = v;
            v = p[v];
        }
        return result;
    }
    function useTransitionState() {
        const state = {
            isMounted: false,
            isLeaving: false,
            isUnmounting: false,
            leavingVNodes: new Map()
        };
        onMounted(() => {
            state.isMounted = true;
        });
        onBeforeUnmount(() => {
            state.isUnmounting = true;
        });
        return state;
    }
    exports_5("useTransitionState", useTransitionState);
    function getLeavingNodesForType(state, vnode) {
        const { leavingVNodes } = state;
        let leavingVNodesCache = leavingVNodes.get(vnode.type);
        if (!leavingVNodesCache) {
            leavingVNodesCache = Object.create(null);
            leavingVNodes.set(vnode.type, leavingVNodesCache);
        }
        return leavingVNodesCache;
    }
    // The transition hooks are attached to the vnode as vnode.transition
    // and will be called at appropriate timing in the renderer.
    function resolveTransitionHooks(vnode, { appear, persisted = false, onBeforeEnter, onEnter, onAfterEnter, onEnterCancelled, onBeforeLeave, onLeave, onAfterLeave, onLeaveCancelled }, state, instance) {
        const key = String(vnode.key);
        const leavingVNodesCache = getLeavingNodesForType(state, vnode);
        const callHook = (hook, args) => {
            hook &&
                callWithAsyncErrorHandling(hook, instance, 8 /* TRANSITION_HOOK */, args);
        };
        const hooks = {
            persisted,
            beforeEnter(el) {
                if (!appear && !state.isMounted) {
                    return;
                }
                // for same element (v-show)
                if (el._leaveCb) {
                    el._leaveCb(true /* cancelled */);
                }
                // for toggled element with same key (v-if)
                const leavingVNode = leavingVNodesCache[key];
                if (leavingVNode &&
                    isSameVNodeType(vnode, leavingVNode) &&
                    leavingVNode.el._leaveCb) {
                    // force early removal (not cancelled)
                    leavingVNode.el._leaveCb();
                }
                callHook(onBeforeEnter, [el]);
            },
            enter(el) {
                if (!appear && !state.isMounted) {
                    return;
                }
                let called = false;
                const afterEnter = (el._enterCb = (cancelled) => {
                    if (called)
                        return;
                    called = true;
                    if (cancelled) {
                        callHook(onEnterCancelled, [el]);
                    }
                    else {
                        callHook(onAfterEnter, [el]);
                    }
                    if (hooks.delayedLeave) {
                        hooks.delayedLeave();
                    }
                    el._enterCb = undefined;
                });
                if (onEnter) {
                    onEnter(el, afterEnter);
                }
                else {
                    afterEnter();
                }
            },
            leave(el, remove) {
                const key = String(vnode.key);
                if (el._enterCb) {
                    el._enterCb(true /* cancelled */);
                }
                if (state.isUnmounting) {
                    return remove();
                }
                callHook(onBeforeLeave, [el]);
                let called = false;
                const afterLeave = (el._leaveCb = (cancelled) => {
                    if (called)
                        return;
                    called = true;
                    remove();
                    if (cancelled) {
                        callHook(onLeaveCancelled, [el]);
                    }
                    else {
                        callHook(onAfterLeave, [el]);
                    }
                    el._leaveCb = undefined;
                    if (leavingVNodesCache[key] === vnode) {
                        delete leavingVNodesCache[key];
                    }
                });
                leavingVNodesCache[key] = vnode;
                if (onLeave) {
                    onLeave(el, afterLeave);
                }
                else {
                    afterLeave();
                }
            }
        };
        return hooks;
    }
    exports_5("resolveTransitionHooks", resolveTransitionHooks);
    // the placeholder really only handles one special case: KeepAlive
    // in the case of a KeepAlive in a leave phase we need to return a KeepAlive
    // placeholder with empty content to avoid the KeepAlive instance from being
    // unmounted.
    function emptyPlaceholder(vnode) {
        if (isKeepAlive(vnode)) {
            vnode = cloneVNode(vnode);
            vnode.children = null;
            return vnode;
        }
    }
    function getKeepAliveChild(vnode) {
        return isKeepAlive(vnode)
            ? vnode.children
                ? vnode.children[0]
                : undefined
            : vnode;
    }
    function setTransitionHooks(vnode, hooks) {
        if (vnode.shapeFlag & 6 /* COMPONENT */ && vnode.component) {
            setTransitionHooks(vnode.component.subTree, hooks);
        }
        else {
            vnode.transition = hooks;
        }
    }
    exports_5("setTransitionHooks", setTransitionHooks);
    function getName(comp) {
        return comp.displayName || comp.name;
    }
    function matches(pattern, name) {
        if (isArray(pattern)) {
            return pattern.some((p) => matches(p, name));
        }
        else if (isString(pattern)) {
            return pattern.split(',').indexOf(name) > -1;
        }
        else if (pattern.test) {
            return pattern.test(name);
        }
        /* istanbul ignore next */
        return false;
    }
    function onActivated(hook, target) {
        registerKeepAliveHook(hook, "a" /* ACTIVATED */, target);
    }
    exports_5("onActivated", onActivated);
    function onDeactivated(hook, target) {
        registerKeepAliveHook(hook, "da" /* DEACTIVATED */, target);
    }
    exports_5("onDeactivated", onDeactivated);
    function registerKeepAliveHook(hook, type, target = currentInstance) {
        // cache the deactivate branch check wrapper for injected hooks so the same
        // hook can be properly deduped by the scheduler. "__wdc" stands for "with
        // deactivation check".
        const wrappedHook = hook.__wdc ||
            (hook.__wdc = () => {
                // only fire the hook if the target instance is NOT in a deactivated branch.
                let current = target;
                while (current) {
                    if (current.isDeactivated) {
                        return;
                    }
                    current = current.parent;
                }
                hook();
            });
        injectHook(type, wrappedHook, target);
        // In addition to registering it on the target instance, we walk up the parent
        // chain and register it on all ancestor instances that are keep-alive roots.
        // This avoids the need to walk the entire component tree when invoking these
        // hooks, and more importantly, avoids the need to track child components in
        // arrays.
        if (target) {
            let current = target.parent;
            while (current && current.parent) {
                if (current.parent.type === KeepAliveImpl) {
                    injectToKeepAliveRoot(wrappedHook, type, target, current);
                }
                current = current.parent;
            }
        }
    }
    function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
        injectHook(type, hook, keepAliveRoot, true /* prepend */);
        onUnmounted(() => {
            const hooks = keepAliveRoot[type];
            hooks.splice(hooks.indexOf(hook), 1);
        }, target);
    }
    function injectHook(type, hook, target = currentInstance, prepend = false) {
        if (target) {
            const hooks = target[type] || (target[type] = []);
            // cache the error handling wrapper for injected hooks so the same hook
            // can be properly deduped by the scheduler. "__weh" stands for "with error
            // handling".
            const wrappedHook = hook.__weh ||
                (hook.__weh = (...args) => {
                    if (target.isUnmounted) {
                        return;
                    }
                    // disable tracking inside all lifecycle hooks
                    // since they can potentially be called inside effects.
                    pauseTracking();
                    // Set currentInstance during hook invocation.
                    // This assumes the hook does not synchronously trigger other hooks, which
                    // can only be false when the user does something really funky.
                    setCurrentInstance(target);
                    const res = callWithAsyncErrorHandling(hook, target, type, args);
                    setCurrentInstance(null);
                    resumeTracking();
                    return res;
                });
            if (prepend) {
                hooks.unshift(wrappedHook);
            }
            else {
                hooks.push(wrappedHook);
            }
        }
        else {
            const apiName = `on${capitalize(ErrorTypeStrings[type].replace(/ hook$/, ''))}`;
            warn(`${apiName} is called when there is no active component instance to be ` +
                `associated with. ` +
                `Lifecycle injection APIs can only be used during execution of setup().` +
                (` If you are using async setup(), make sure to register lifecycle ` +
                    `hooks before the first await statement.`));
        }
    }
    exports_5("injectHook", injectHook);
    // implementation
    function watch(effectOrSource, cbOrOptions, options) {
        if (isFunction(cbOrOptions)) {
            // effect callback as 2nd argument - this is a source watcher
            return doWatch(effectOrSource, cbOrOptions, options);
        }
        else {
            // 2nd argument is either missing or an options object
            // - this is a simple effect watcher
            return doWatch(effectOrSource, null, cbOrOptions);
        }
    }
    exports_5("watch", watch);
    function doWatch(source, cb, { lazy, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {
        const instance = currentInstance;
        const suspense = currentSuspense;
        let getter;
        if (isArray(source)) {
            getter = () => source.map(s => isRef(s)
                ? s.value
                : callWithErrorHandling(s, instance, 2 /* WATCH_GETTER */));
        }
        else if (isRef(source)) {
            getter = () => source.value;
        }
        else if (cb) {
            // getter with cb
            getter = () => callWithErrorHandling(source, instance, 2 /* WATCH_GETTER */);
        }
        else {
            // no cb -> simple effect
            getter = () => {
                if (instance && instance.isUnmounted) {
                    return;
                }
                if (cleanup) {
                    cleanup();
                }
                return callWithErrorHandling(source, instance, 3 /* WATCH_CALLBACK */, [registerCleanup]);
            };
        }
        if (deep) {
            const baseGetter = getter;
            getter = () => traverse(baseGetter());
        }
        let cleanup;
        const registerCleanup = (fn) => {
            cleanup = runner.options.onStop = () => {
                callWithErrorHandling(fn, instance, 4 /* WATCH_CLEANUP */);
            };
        };
        let oldValue = isArray(source) ? [] : undefined;
        const applyCb = cb
            ? () => {
                if (instance && instance.isUnmounted) {
                    return;
                }
                const newValue = runner();
                if (deep || hasChanged(newValue, oldValue)) {
                    // cleanup before running cb again
                    if (cleanup) {
                        cleanup();
                    }
                    callWithAsyncErrorHandling(cb, instance, 3 /* WATCH_CALLBACK */, [
                        newValue,
                        oldValue,
                        registerCleanup
                    ]);
                    oldValue = newValue;
                }
            }
            : void 0;
        let scheduler;
        if (flush === 'sync') {
            scheduler = invoke;
        }
        else if (flush === 'pre') {
            scheduler = job => {
                if (!instance || instance.vnode.el != null) {
                    queueJob(job);
                }
                else {
                    // with 'pre' option, the first call must happen before
                    // the component is mounted so it is called synchronously.
                    job();
                }
            };
        }
        else {
            scheduler = job => {
                queuePostRenderEffect(job, suspense);
            };
        }
        const runner = effect(getter, {
            lazy: true,
            // so it runs before component update effects in pre flush mode
            computed: true,
            onTrack,
            onTrigger,
            scheduler: applyCb ? () => scheduler(applyCb) : scheduler
        });
        if (lazy && cb) {
            oldValue = runner();
        }
        else {
            if (lazy && !cb) {
                warn(`watch() lazy option is only respected when using the ` +
                    `watch(getter, callback) signature.`);
            }
            if (applyCb) {
                scheduler(applyCb);
            }
            else {
                scheduler(runner);
            }
        }
        recordEffect(runner);
        return () => {
            stop(runner);
            if (instance) {
                const effects = instance.effects;
                const index = effects.indexOf(runner);
                if (index > -1) {
                    effects.splice(index, 1);
                }
            }
        };
    }
    // this.$watch
    function instanceWatch(source, cb, options) {
        const ctx = this.proxy;
        const getter = isString(source) ? () => ctx[source] : source.bind(ctx);
        const stop = watch(getter, cb.bind(ctx), options);
        onBeforeUnmount(stop, this);
        return stop;
    }
    exports_5("instanceWatch", instanceWatch);
    function traverse(value, seen = new Set()) {
        if (!isObject(value) || seen.has(value)) {
            return;
        }
        seen.add(value);
        if (isArray(value)) {
            for (let i = 0; i < value.length; i++) {
                traverse(value[i], seen);
            }
        }
        else if (value instanceof Map) {
            value.forEach((v, key) => {
                // to register mutation dep for existing keys
                traverse(value.get(key), seen);
            });
        }
        else if (value instanceof Set) {
            value.forEach(v => {
                traverse(v, seen);
            });
        }
        else {
            for (const key in value) {
                traverse(value[key], seen);
            }
        }
        return value;
    }
    function provide(key, value) {
        if (!currentInstance) {
            {
                warn(`provide() can only be used inside setup().`);
            }
        }
        else {
            let provides = currentInstance.provides;
            // by default an instance inherits its parent's provides object
            // but when it needs to provide values of its own, it creates its
            // own provides object using parent provides object as prototype.
            // this way in `inject` we can simply look up injections from direct
            // parent and let the prototype chain do the work.
            const parentProvides = currentInstance.parent && currentInstance.parent.provides;
            if (parentProvides === provides) {
                provides = currentInstance.provides = Object.create(parentProvides);
            }
            // TS doesn't allow symbol as index type
            provides[key] = value;
        }
    }
    exports_5("provide", provide);
    function inject(key, defaultValue) {
        // fallback to `currentRenderingInstance` so that this can be called in
        // a functional component
        const instance = currentInstance || currentRenderingInstance;
        if (instance) {
            const provides = instance.provides;
            if (key in provides) {
                // TS doesn't allow symbol as index type
                return provides[key];
            }
            else if (defaultValue !== undefined) {
                return defaultValue;
            }
            else {
                warn(`injection "${String(key)}" not found.`);
            }
        }
        else {
            warn(`inject() can only be used inside setup() or functional components.`);
        }
    }
    exports_5("inject", inject);
    function createDuplicateChecker() {
        const cache = Object.create(null);
        return (type, key) => {
            if (cache[key]) {
                warn(`${type} property "${key}" is already defined in ${cache[key]}.`);
            }
            else {
                cache[key] = type;
            }
        };
    }
    function applyOptions(instance, options, asMixin = false) {
        const ctx = instance.proxy;
        const { 
        // composition
        mixins, extends: extendsOptions, 
        // state
        props: propsOptions, data: dataOptions, computed: computedOptions, methods, watch: watchOptions, provide: provideOptions, inject: injectOptions, 
        // assets
        components, directives, 
        // lifecycle
        beforeMount, mounted, beforeUpdate, updated, activated, deactivated, beforeUnmount, unmounted, renderTracked, renderTriggered, errorCaptured } = options;
        const renderContext = instance.renderContext === EMPTY_OBJ
            ? (instance.renderContext = {})
            : instance.renderContext;
        const globalMixins = instance.appContext.mixins;
        // call it only during dev
        const checkDuplicateProperties = createDuplicateChecker();
        // applyOptions is called non-as-mixin once per instance
        if (!asMixin) {
            callSyncHook('beforeCreate', options, ctx, globalMixins);
            // global mixins are applied first
            applyMixins(instance, globalMixins);
        }
        // extending a base component...
        if (extendsOptions) {
            applyOptions(instance, extendsOptions, true);
        }
        // local mixins
        if (mixins) {
            applyMixins(instance, mixins);
        }
        if (propsOptions) {
            for (const key in propsOptions) {
                checkDuplicateProperties("Props" /* PROPS */, key);
            }
        }
        // state options
        if (dataOptions) {
            const data = isFunction(dataOptions) ? dataOptions.call(ctx) : dataOptions;
            if (!isObject(data)) {
                warn(`data() should return an object.`);
            }
            else if (instance.data === EMPTY_OBJ) {
                {
                    for (const key in data) {
                        checkDuplicateProperties("Data" /* DATA */, key);
                    }
                }
                instance.data = reactive(data);
            }
            else {
                // existing data: this is a mixin or extends.
                extend(instance.data, data);
            }
        }
        if (computedOptions) {
            for (const key in computedOptions) {
                const opt = computedOptions[key];
                checkDuplicateProperties("Computed" /* COMPUTED */, key);
                if (isFunction(opt)) {
                    renderContext[key] = computed$1(opt.bind(ctx));
                }
                else {
                    const { get, set } = opt;
                    if (isFunction(get)) {
                        renderContext[key] = computed$1({
                            get: get.bind(ctx),
                            set: isFunction(set)
                                ? set.bind(ctx)
                                : () => {
                                    warn(`Computed property "${key}" was assigned to but it has no setter.`);
                                }
                        });
                    }
                    else {
                        warn(`Computed property "${key}" has no getter.`);
                    }
                }
            }
        }
        if (methods) {
            for (const key in methods) {
                const methodHandler = methods[key];
                if (isFunction(methodHandler)) {
                    checkDuplicateProperties("Methods" /* METHODS */, key);
                    renderContext[key] = methodHandler.bind(ctx);
                }
                else {
                    warn(`Method "${key}" has type "${typeof methodHandler}" in the component definition. ` +
                        `Did you reference the function correctly?`);
                }
            }
        }
        if (watchOptions) {
            for (const key in watchOptions) {
                createWatcher(watchOptions[key], renderContext, ctx, key);
            }
        }
        if (provideOptions) {
            const provides = isFunction(provideOptions)
                ? provideOptions.call(ctx)
                : provideOptions;
            for (const key in provides) {
                provide(key, provides[key]);
            }
        }
        if (injectOptions) {
            if (isArray(injectOptions)) {
                for (let i = 0; i < injectOptions.length; i++) {
                    const key = injectOptions[i];
                    checkDuplicateProperties("Inject" /* INJECT */, key);
                    renderContext[key] = inject(key);
                }
            }
            else {
                for (const key in injectOptions) {
                    checkDuplicateProperties("Inject" /* INJECT */, key);
                    const opt = injectOptions[key];
                    if (isObject(opt)) {
                        renderContext[key] = inject(opt.from, opt.default);
                    }
                    else {
                        renderContext[key] = inject(opt);
                    }
                }
            }
        }
        // asset options
        if (components) {
            extend(instance.components, components);
        }
        if (directives) {
            extend(instance.directives, directives);
        }
        // lifecycle options
        if (!asMixin) {
            callSyncHook('created', options, ctx, globalMixins);
        }
        if (beforeMount) {
            onBeforeMount(beforeMount.bind(ctx));
        }
        if (mounted) {
            onMounted(mounted.bind(ctx));
        }
        if (beforeUpdate) {
            onBeforeUpdate(beforeUpdate.bind(ctx));
        }
        if (updated) {
            onUpdated(updated.bind(ctx));
        }
        if (activated) {
            onActivated(activated.bind(ctx));
        }
        if (deactivated) {
            onDeactivated(deactivated.bind(ctx));
        }
        if (errorCaptured) {
            onErrorCaptured(errorCaptured.bind(ctx));
        }
        if (renderTracked) {
            onRenderTracked(renderTracked.bind(ctx));
        }
        if (renderTriggered) {
            onRenderTriggered(renderTriggered.bind(ctx));
        }
        if (beforeUnmount) {
            onBeforeUnmount(beforeUnmount.bind(ctx));
        }
        if (unmounted) {
            onUnmounted(unmounted.bind(ctx));
        }
    }
    function callSyncHook(name, options, ctx, globalMixins) {
        callHookFromMixins(name, globalMixins, ctx);
        const baseHook = options.extends && options.extends[name];
        if (baseHook) {
            baseHook.call(ctx);
        }
        const mixins = options.mixins;
        if (mixins) {
            callHookFromMixins(name, mixins, ctx);
        }
        const selfHook = options[name];
        if (selfHook) {
            selfHook.call(ctx);
        }
    }
    function callHookFromMixins(name, mixins, ctx) {
        for (let i = 0; i < mixins.length; i++) {
            const fn = mixins[i][name];
            if (fn) {
                fn.call(ctx);
            }
        }
    }
    function applyMixins(instance, mixins) {
        for (let i = 0; i < mixins.length; i++) {
            applyOptions(instance, mixins[i], true);
        }
    }
    function createWatcher(raw, renderContext, ctx, key) {
        const getter = () => ctx[key];
        if (isString(raw)) {
            const handler = renderContext[raw];
            if (isFunction(handler)) {
                watch(getter, handler);
            }
            else {
                warn(`Invalid watch handler specified by key "${raw}"`, handler);
            }
        }
        else if (isFunction(raw)) {
            watch(getter, raw.bind(ctx));
        }
        else if (isObject(raw)) {
            if (isArray(raw)) {
                raw.forEach(r => createWatcher(r, renderContext, ctx, key));
            }
            else {
                watch(getter, raw.handler.bind(ctx), raw);
            }
        }
        else {
            warn(`Invalid watch option: "${key}"`);
        }
    }
    function createComponentInstance(vnode, parent) {
        // inherit parent app context - or - if root, adopt from root vnode
        const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
        const instance = {
            vnode,
            parent,
            appContext,
            type: vnode.type,
            root: null,
            next: null,
            subTree: null,
            update: null,
            render: null,
            proxy: null,
            withProxy: null,
            propsProxy: null,
            setupContext: null,
            effects: null,
            provides: parent ? parent.provides : Object.create(appContext.provides),
            accessCache: null,
            renderCache: null,
            // setup context properties
            renderContext: EMPTY_OBJ,
            data: EMPTY_OBJ,
            props: EMPTY_OBJ,
            attrs: EMPTY_OBJ,
            slots: EMPTY_OBJ,
            refs: EMPTY_OBJ,
            // per-instance asset storage (mutable during options resolution)
            components: Object.create(appContext.components),
            directives: Object.create(appContext.directives),
            // async dependency management
            asyncDep: null,
            asyncResult: null,
            asyncResolved: false,
            // user namespace for storing whatever the user assigns to `this`
            // can also be used as a wildcard storage for ad-hoc injections internally
            sink: {},
            // lifecycle hooks
            // not using enums here because it results in computed properties
            isMounted: false,
            isUnmounted: false,
            isDeactivated: false,
            bc: null,
            c: null,
            bm: null,
            m: null,
            bu: null,
            u: null,
            um: null,
            bum: null,
            da: null,
            a: null,
            rtg: null,
            rtc: null,
            ec: null,
            emit: (event, ...args) => {
                const props = instance.vnode.props || EMPTY_OBJ;
                let handler = props[`on${event}`] || props[`on${capitalize(event)}`];
                if (!handler && event.indexOf('update:') === 0) {
                    event = hyphenate(event);
                    handler = props[`on${event}`] || props[`on${capitalize(event)}`];
                }
                if (handler) {
                    const res = callWithAsyncErrorHandling(handler, instance, 6 /* COMPONENT_EVENT_HANDLER */, args);
                    return isArray(res) ? res : [res];
                }
                else {
                    return [];
                }
            }
        };
        instance.root = parent ? parent.root : instance;
        return instance;
    }
    exports_5("createComponentInstance", createComponentInstance);
    function validateComponentName(name, config) {
        const appIsNativeTag = config.isNativeTag || NO;
        if (isBuiltInTag(name) || appIsNativeTag(name)) {
            warn('Do not use built-in or reserved HTML elements as component id: ' + name);
        }
    }
    function setupComponent(instance, parentSuspense) {
        const propsOptions = instance.type.props;
        const { props, children, shapeFlag } = instance.vnode;
        resolveProps(instance, props, propsOptions);
        resolveSlots(instance, children);
        // setup stateful logic
        if (shapeFlag & PublicShapeFlags.STATEFUL_COMPONENT) {
            return setupStatefulComponent(instance, parentSuspense);
        }
    }
    exports_5("setupComponent", setupComponent);
    function setupStatefulComponent(instance, parentSuspense) {
        const Component = instance.type;
        {
            if (Component.name) {
                validateComponentName(Component.name, instance.appContext.config);
            }
            if (Component.components) {
                const names = Object.keys(Component.components);
                for (let i = 0; i < names.length; i++) {
                    validateComponentName(names[i], instance.appContext.config);
                }
            }
            if (Component.directives) {
                const names = Object.keys(Component.directives);
                for (let i = 0; i < names.length; i++) {
                    validateDirectiveName(names[i]);
                }
            }
        }
        // 0. create render proxy property access cache
        instance.accessCache = {};
        // 1. create public instance / render proxy
        instance.proxy = new Proxy(instance, PublicInstanceProxyHandlers);
        // 2. create props proxy
        // the propsProxy is a reactive AND readonly proxy to the actual props.
        // it will be updated in resolveProps() on updates before render
        const propsProxy = (instance.propsProxy = shallowReadonly(instance.props));
        // 3. call setup()
        const { setup } = Component;
        if (setup) {
            const setupContext = (instance.setupContext =
                setup.length > 1 ? createSetupContext(instance) : null);
            currentInstance = instance;
            currentSuspense = parentSuspense;
            const setupResult = callWithErrorHandling(setup, instance, 0 /* SETUP_FUNCTION */, [propsProxy, setupContext]);
            currentInstance = null;
            currentSuspense = null;
            if (isPromise(setupResult)) {
                {
                    // async setup returned Promise.
                    // bail here and wait for re-entry.
                    instance.asyncDep = setupResult;
                }
            }
            else {
                handleSetupResult(instance, setupResult, parentSuspense);
            }
        }
        else {
            finishComponentSetup(instance, parentSuspense);
        }
    }
    function handleSetupResult(instance, setupResult, parentSuspense) {
        if (isFunction(setupResult)) {
            // setup returned an inline render function
            instance.render = setupResult;
        }
        else if (isObject(setupResult)) {
            if (isVNode(setupResult)) {
                warn(`setup() should not return VNodes directly - ` +
                    `return a render function instead.`);
            }
            // setup returned bindings.
            // assuming a render function compiled from template is present.
            instance.renderContext = setupResult;
        }
        else if (setupResult !== undefined) {
            warn(`setup() should return an object. Received: ${setupResult === null ? 'null' : typeof setupResult}`);
        }
        finishComponentSetup(instance, parentSuspense);
    }
    // exported method uses any to avoid d.ts relying on the compiler types.
    function registerRuntimeCompiler(_compile) {
        compile$1 = _compile;
    }
    exports_5("registerRuntimeCompiler", registerRuntimeCompiler);
    function finishComponentSetup(instance, parentSuspense) {
        const Component = instance.type;
        if (!instance.render) {
            if (Component.template && !Component.render) {
                // true ensures `compile` is provided
                Component.render = compile$1(Component.template, {
                    isCustomElement: instance.appContext.config.isCustomElement || NO
                });
                Component.render.isRuntimeCompiled = true;
            }
            if (!Component.render) {
                /* istanbul ignore if */
                {
                    warn(`Component is missing${` template or`} render function.`);
                }
            }
            instance.render = (Component.render || NOOP);
            // for runtime-compiled render functions using `with` blocks, the render
            // proxy used needs a different `has` handler which is more performant and
            // also only allows a whitelist of globals to fallthrough.
            if (instance.render.isRuntimeCompiled) {
                instance.withProxy = new Proxy(instance, runtimeCompiledRenderProxyHandlers);
            }
        }
        // support for 2.x options
        {
            currentInstance = instance;
            currentSuspense = parentSuspense;
            applyOptions(instance, Component);
            currentInstance = null;
            currentSuspense = null;
        }
        if (instance.renderContext === EMPTY_OBJ) {
            instance.renderContext = {};
        }
    }
    function createSetupContext(instance) {
        const context = {
            // attrs & slots are non-reactive, but they need to always expose
            // the latest values (instance.xxx may get replaced during updates) so we
            // need to expose them through a proxy
            attrs: new Proxy(instance, SetupProxyHandlers.attrs),
            slots: new Proxy(instance, SetupProxyHandlers.slots),
            emit: instance.emit
        };
        return Object.freeze(context);
    }
    // record effects created during a component's setup() so that they can be
    // stopped when the component unmounts
    function recordEffect(effect) {
        if (currentInstance) {
            (currentInstance.effects || (currentInstance.effects = [])).push(effect);
        }
    }
    exports_5("recordEffect", recordEffect);
    function computed$1(getterOrOptions) {
        const c = computed(getterOrOptions);
        recordEffect(c.effect);
        return c;
    }
    exports_5("computed", computed$1);
    // implementation, close to no-op
    function defineComponent(options) {
        return isFunction(options) ? { setup: options } : options;
    }
    exports_5("defineComponent", defineComponent);
    // Actual implementation
    function h(type, propsOrChildren, children) {
        if (arguments.length === 2) {
            if (isObject(propsOrChildren) && !isArray(propsOrChildren)) {
                // single vnode without props
                if (isVNode(propsOrChildren)) {
                    return createVNode(type, null, [propsOrChildren]);
                }
                // props without children
                return createVNode(type, propsOrChildren);
            }
            else {
                // omit props
                return createVNode(type, null, propsOrChildren);
            }
        }
        else {
            if (isVNode(children)) {
                children = [children];
            }
            return createVNode(type, propsOrChildren, children);
        }
    }
    exports_5("h", h);
    function useCSSModule(name = '$style') {
        const instance = getCurrentInstance();
        if (!instance) {
            warn(`useCSSModule must be called inside setup()`);
            return EMPTY_OBJ;
        }
        const modules = instance.type.__cssModules;
        if (!modules) {
            warn(`Current instance does not have CSS modules injected.`);
            return EMPTY_OBJ;
        }
        const mod = modules[name];
        if (!mod) {
            warn(`Current instance does not have CSS module named "${name}".`);
            return EMPTY_OBJ;
        }
        return mod;
    }
    exports_5("useCSSModule", useCSSModule);
    function resolveComponent(name) {
        return resolveAsset(COMPONENTS, name);
    }
    exports_5("resolveComponent", resolveComponent);
    function resolveDynamicComponent(component, 
    // Dynamic component resolution has to be called inline due to potential
    // access to scope variables. When called inside slots it will be inside
    // a different component's render cycle, so the owner instance must be passed
    // in explicitly.
    instance) {
        if (!component)
            return;
        if (isString(component)) {
            return resolveAsset(COMPONENTS, component, instance);
        }
        else if (isFunction(component) || isObject(component)) {
            return component;
        }
    }
    exports_5("resolveDynamicComponent", resolveDynamicComponent);
    function resolveDirective(name) {
        return resolveAsset(DIRECTIVES, name);
    }
    exports_5("resolveDirective", resolveDirective);
    function resolveAsset(type, name, instance = currentRenderingInstance ||
        currentInstance) {
        if (instance) {
            let camelized, capitalized;
            const registry = instance[type];
            let res = registry[name] ||
                registry[(camelized = camelize(name))] ||
                registry[(capitalized = capitalize(camelized))];
            if (!res && type === COMPONENTS) {
                const self = instance.type;
                const selfName = self.displayName || self.name;
                if (selfName &&
                    (selfName === name ||
                        selfName === camelized ||
                        selfName === capitalized)) {
                    res = self;
                }
            }
            if (!res) {
                warn(`Failed to resolve ${type.slice(0, -1)}: ${name}`);
            }
            return res;
        }
        else {
            warn(`resolve${capitalize(type.slice(0, -1))} ` +
                `can only be used in render() or setup().`);
        }
    }
    function renderList(source, renderItem) {
        let ret;
        if (isArray(source) || isString(source)) {
            ret = new Array(source.length);
            for (let i = 0, l = source.length; i < l; i++) {
                ret[i] = renderItem(source[i], i);
            }
        }
        else if (typeof source === 'number') {
            ret = new Array(source);
            for (let i = 0; i < source; i++) {
                ret[i] = renderItem(i + 1, i);
            }
        }
        else if (isObject(source)) {
            if (source[Symbol.iterator]) {
                ret = Array.from(source, renderItem);
            }
            else {
                const keys = Object.keys(source);
                ret = new Array(keys.length);
                for (let i = 0, l = keys.length; i < l; i++) {
                    const key = keys[i];
                    ret[i] = renderItem(source[key], key, i);
                }
            }
        }
        else {
            ret = [];
        }
        return ret;
    }
    exports_5("renderList", renderList);
    // For prefixing keys in v-on="obj" with "on"
    function toHandlers(obj) {
        const ret = {};
        if (!isObject(obj)) {
            warn(`v-on with no argument expects an object value.`);
            return ret;
        }
        for (const key in obj) {
            ret[`on${key}`] = obj[key];
        }
        return ret;
    }
    exports_5("toHandlers", toHandlers);
    function renderSlot(slots, name, props = {}, 
    // this is not a user-facing function, so the fallback is always generated by
    // the compiler and guaranteed to be an array
    fallback) {
        const slot = slots[name];
        return (openBlock(),
            createBlock(Fragment, { key: props.key }, slot ? slot(props) : fallback || [], slots._compiled ? 0 : -1 /* BAIL */));
    }
    exports_5("renderSlot", renderSlot);
    function createSlots(slots, dynamicSlots) {
        for (let i = 0; i < dynamicSlots.length; i++) {
            const slot = dynamicSlots[i];
            // array of dynamic slot generated by <template v-for="..." #[...]>
            if (isArray(slot)) {
                for (let j = 0; j < slot.length; j++) {
                    slots[slot[j].name] = slot[j].fn;
                }
            }
            else {
                // conditional single slot generated by <template v-if="..." #foo>
                slots[slot.name] = slot.fn;
            }
        }
        return slots;
    }
    exports_5("createSlots", createSlots);
    // compiler should normalize class + :class bindings on the same element
    // into a single binding ['staticClass', dynamic]
    function patchClass(el, value, isSVG) {
        if (value == null) {
            value = '';
        }
        // directly setting className should be faster than setAttribute in theory
        if (isSVG) {
            el.setAttribute('class', value);
        }
        else {
            // if this is an element during a transition, take the temporary transition
            // classes into account.
            const transitionClasses = el._vtc;
            if (transitionClasses) {
                value = [value, ...transitionClasses].join(' ');
            }
            el.className = value;
        }
    }
    function patchStyle(el, prev, next) {
        const style = el.style;
        if (!next) {
            el.removeAttribute('style');
        }
        else if (isString(next)) {
            style.cssText = next;
        }
        else {
            for (const key in next) {
                setStyle(style, key, next[key]);
            }
            if (prev && !isString(prev)) {
                for (const key in prev) {
                    if (!next[key]) {
                        setStyle(style, key, '');
                    }
                }
            }
        }
    }
    function setStyle(style, name, val) {
        if (name.startsWith('--')) {
            // custom property definition
            style.setProperty(name, val);
        }
        else {
            const prefixed = autoPrefix(style, name);
            if (importantRE.test(val)) {
                // !important
                style.setProperty(hyphenate(prefixed), val.replace(importantRE, ''), 'important');
            }
            else {
                style[prefixed] = val;
            }
        }
    }
    function autoPrefix(style, rawName) {
        const cached = prefixCache[rawName];
        if (cached) {
            return cached;
        }
        let name = camelize$1(rawName);
        if (name !== 'filter' && name in style) {
            return (prefixCache[rawName] = name);
        }
        name = capitalize(name);
        for (let i = 0; i < prefixes.length; i++) {
            const prefixed = prefixes[i] + name;
            if (prefixed in style) {
                return (prefixCache[rawName] = prefixed);
            }
        }
        return rawName;
    }
    function patchAttr(el, key, value) {
        if (value == null) {
            el.removeAttribute(key);
        }
        else {
            el.setAttribute(key, value);
        }
    }
    function patchDOMProp(el, key, value, 
    // the following args are passed only due to potential innerHTML/textContent
    // overriding existing VNodes, in which case the old tree must be properly
    // unmounted.
    prevChildren, parentComponent, parentSuspense, unmountChildren) {
        if ((key === 'innerHTML' || key === 'textContent') && prevChildren != null) {
            unmountChildren(prevChildren, parentComponent, parentSuspense);
            el[key] = value == null ? '' : value;
            return;
        }
        if (key === 'value' && el.tagName !== 'PROGRESS') {
            // store value as _value as well since
            // non-string values will be stringified.
            el._value = value;
            el.value = value == null ? '' : value;
            return;
        }
        if (value === '' && typeof el[key] === 'boolean') {
            // e.g. <select multiple> compiles to { multiple: '' }
            el[key] = true;
        }
        else {
            el[key] = value == null ? '' : value;
        }
    }
    function addEventListener(el, event, handler, options) {
        el.addEventListener(event, handler, options);
    }
    function removeEventListener(el, event, handler, options) {
        el.removeEventListener(event, handler, options);
    }
    function patchEvent(el, name, prevValue, nextValue, instance = null) {
        const prevOptions = prevValue && 'options' in prevValue && prevValue.options;
        const nextOptions = nextValue && 'options' in nextValue && nextValue.options;
        const invoker = prevValue && prevValue.invoker;
        const value = nextValue && 'handler' in nextValue ? nextValue.handler : nextValue;
        if (prevOptions || nextOptions) {
            const prev = prevOptions || EMPTY_OBJ;
            const next = nextOptions || EMPTY_OBJ;
            if (prev.capture !== next.capture ||
                prev.passive !== next.passive ||
                prev.once !== next.once) {
                if (invoker) {
                    removeEventListener(el, name, invoker, prev);
                }
                if (nextValue && value) {
                    const invoker = createInvoker(value, instance);
                    nextValue.invoker = invoker;
                    addEventListener(el, name, invoker, next);
                }
                return;
            }
        }
        if (nextValue && value) {
            if (invoker) {
                prevValue.invoker = null;
                invoker.value = value;
                nextValue.invoker = invoker;
                invoker.lastUpdated = getNow();
            }
            else {
                addEventListener(el, name, createInvoker(value, instance), nextOptions || void 0);
            }
        }
        else if (invoker) {
            removeEventListener(el, name, invoker, prevOptions || void 0);
        }
    }
    function createInvoker(initialValue, instance) {
        const invoker = (e) => {
            // async edge case #6566: inner click event triggers patch, event handler
            // attached to outer element during patch, and triggered again. This
            // happens because browsers fire microtask ticks between event propagation.
            // the solution is simple: we save the timestamp when a handler is attached,
            // and the handler would only fire if the event passed to it was fired
            // AFTER it was attached.
            if (e.timeStamp >= invoker.lastUpdated - 1) {
                callWithAsyncErrorHandling(invoker.value, instance, 5 /* NATIVE_EVENT_HANDLER */, [e]);
            }
        };
        invoker.value = initialValue;
        initialValue.invoker = invoker;
        invoker.lastUpdated = getNow();
        return invoker;
    }
    function patchProp(el, key, nextValue, prevValue, isSVG, prevChildren, parentComponent, parentSuspense, unmountChildren) {
        switch (key) {
            // special
            case 'class':
                patchClass(el, nextValue, isSVG);
                break;
            case 'style':
                patchStyle(el, prevValue, nextValue);
                break;
            case 'modelValue':
            case 'onUpdate:modelValue':
                // Do nothing. This is handled by v-model directives.
                break;
            default:
                if (isOn(key)) {
                    patchEvent(el, key.slice(2).toLowerCase(), prevValue, nextValue, parentComponent);
                }
                else if (!isSVG && key in el) {
                    patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);
                }
                else {
                    // special case for <input v-model type="checkbox"> with
                    // :true-value & :false-value
                    // store value as dom properties since non-string values will be
                    // stringified.
                    if (key === 'true-value') {
                        el._trueValue = nextValue;
                    }
                    else if (key === 'false-value') {
                        el._falseValue = nextValue;
                    }
                    patchAttr(el, key, nextValue);
                }
                break;
        }
    }
    function onCompositionStart(e) {
        e.target.composing = true;
    }
    function onCompositionEnd(e) {
        const target = e.target;
        if (target.composing) {
            target.composing = false;
            trigger$1(target, 'input');
        }
    }
    function trigger$1(el, type) {
        const e = document.createEvent('HTMLEvents');
        e.initEvent(type, true, true);
        el.dispatchEvent(e);
    }
    function toNumber(val) {
        const n = parseFloat(val);
        return isNaN(n) ? val : n;
    }
    function setChecked(el, { value, oldValue }, vnode) {
        el._modelValue = value;
        if (isArray(value)) {
            el.checked = looseIndexOf(value, vnode.props.value) > -1;
        }
        else if (value !== oldValue) {
            el.checked = looseEqual(value, getCheckboxValue(el, true));
        }
    }
    function setSelected(el, value) {
        const isMultiple = el.multiple;
        if (isMultiple && !isArray(value)) {
            warn(`<select multiple v-model> expects an Array value for its binding, ` +
                `but got ${Object.prototype.toString.call(value).slice(8, -1)}.`);
            return;
        }
        for (let i = 0, l = el.options.length; i < l; i++) {
            const option = el.options[i];
            const optionValue = getValue(option);
            if (isMultiple) {
                option.selected = looseIndexOf(value, optionValue) > -1;
            }
            else {
                if (looseEqual(getValue(option), value)) {
                    el.selectedIndex = i;
                    return;
                }
            }
        }
        if (!isMultiple) {
            el.selectedIndex = -1;
        }
    }
    function looseEqual(a, b) {
        if (a === b)
            return true;
        const isObjectA = isObject(a);
        const isObjectB = isObject(b);
        if (isObjectA && isObjectB) {
            try {
                const isArrayA = isArray(a);
                const isArrayB = isArray(b);
                if (isArrayA && isArrayB) {
                    return (a.length === b.length &&
                        a.every((e, i) => looseEqual(e, b[i])));
                }
                else if (a instanceof Date && b instanceof Date) {
                    return a.getTime() === b.getTime();
                }
                else if (!isArrayA && !isArrayB) {
                    const keysA = Object.keys(a);
                    const keysB = Object.keys(b);
                    return (keysA.length === keysB.length &&
                        keysA.every(key => looseEqual(a[key], b[key])));
                }
                else {
                    /* istanbul ignore next */
                    return false;
                }
            }
            catch (e) {
                /* istanbul ignore next */
                return false;
            }
        }
        else if (!isObjectA && !isObjectB) {
            return String(a) === String(b);
        }
        else {
            return false;
        }
    }
    function looseIndexOf(arr, val) {
        return arr.findIndex(item => looseEqual(item, val));
    }
    // retrieve raw value set via :value bindings
    function getValue(el) {
        return '_value' in el ? el._value : el.value;
    }
    // retrieve raw value for true-value and false-value set via :true-value or :false-value bindings
    function getCheckboxValue(el, checked) {
        const key = checked ? '_trueValue' : '_falseValue';
        return key in el ? el[key] : checked;
    }
    function callModelHook(el, binding, vnode, prevVNode, hook) {
        let modelToUse;
        switch (el.tagName) {
            case 'SELECT':
                modelToUse = vModelSelect;
                break;
            case 'TEXTAREA':
                modelToUse = vModelText;
                break;
            default:
                switch (el.type) {
                    case 'checkbox':
                        modelToUse = vModelCheckbox;
                        break;
                    case 'radio':
                        modelToUse = vModelRadio;
                        break;
                    default:
                        modelToUse = vModelText;
                }
        }
        const fn = modelToUse[hook];
        fn && fn(el, binding, vnode, prevVNode);
    }
    function setDisplay(el, value) {
        el.style.display = value ? el._vod : 'none';
    }
    function resolveTransitionProps({ name = 'v', type, css = true, duration, enterFromClass = `${name}-enter-from`, enterActiveClass = `${name}-enter-active`, enterToClass = `${name}-enter-to`, appearFromClass = enterFromClass, appearActiveClass = enterActiveClass, appearToClass = enterToClass, leaveFromClass = `${name}-leave-from`, leaveActiveClass = `${name}-leave-active`, leaveToClass = `${name}-leave-to`, ...baseProps }) {
        if (!css) {
            return baseProps;
        }
        const instance = getCurrentInstance();
        const durations = normalizeDuration(duration);
        const enterDuration = durations && durations[0];
        const leaveDuration = durations && durations[1];
        const { appear, onBeforeEnter, onEnter, onLeave } = baseProps;
        // is appearing
        if (appear && !getCurrentInstance().isMounted) {
            enterFromClass = appearFromClass;
            enterActiveClass = appearActiveClass;
            enterToClass = appearToClass;
        }
        const finishEnter = (el, done) => {
            removeTransitionClass(el, enterToClass);
            removeTransitionClass(el, enterActiveClass);
            done && done();
        };
        const finishLeave = (el, done) => {
            removeTransitionClass(el, leaveToClass);
            removeTransitionClass(el, leaveActiveClass);
            done && done();
        };
        // only needed for user hooks called in nextFrame
        // sync errors are already handled by BaseTransition
        function callHookWithErrorHandling(hook, args) {
            callWithAsyncErrorHandling(hook, instance, 8 /* TRANSITION_HOOK */, args);
        }
        return {
            ...baseProps,
            onBeforeEnter(el) {
                onBeforeEnter && onBeforeEnter(el);
                addTransitionClass(el, enterActiveClass);
                addTransitionClass(el, enterFromClass);
            },
            onEnter(el, done) {
                nextFrame(() => {
                    const resolve = () => finishEnter(el, done);
                    onEnter && callHookWithErrorHandling(onEnter, [el, resolve]);
                    removeTransitionClass(el, enterFromClass);
                    addTransitionClass(el, enterToClass);
                    if (!(onEnter && onEnter.length > 1)) {
                        if (enterDuration) {
                            setTimeout(resolve, enterDuration);
                        }
                        else {
                            whenTransitionEnds(el, type, resolve);
                        }
                    }
                });
            },
            onLeave(el, done) {
                addTransitionClass(el, leaveActiveClass);
                addTransitionClass(el, leaveFromClass);
                nextFrame(() => {
                    const resolve = () => finishLeave(el, done);
                    onLeave && callHookWithErrorHandling(onLeave, [el, resolve]);
                    removeTransitionClass(el, leaveFromClass);
                    addTransitionClass(el, leaveToClass);
                    if (!(onLeave && onLeave.length > 1)) {
                        if (leaveDuration) {
                            setTimeout(resolve, leaveDuration);
                        }
                        else {
                            whenTransitionEnds(el, type, resolve);
                        }
                    }
                });
            },
            onEnterCancelled: finishEnter,
            onLeaveCancelled: finishLeave
        };
    }
    function normalizeDuration(duration) {
        if (duration == null) {
            return null;
        }
        else if (isObject(duration)) {
            return [toNumber$1(duration.enter), toNumber$1(duration.leave)];
        }
        else {
            const n = toNumber$1(duration);
            return [n, n];
        }
    }
    function toNumber$1(val) {
        const res = Number(val || 0);
        validateDuration(res);
        return res;
    }
    function validateDuration(val) {
        if (typeof val !== 'number') {
            warn(`<transition> explicit duration is not a valid number - ` +
                `got ${JSON.stringify(val)}.`);
        }
        else if (isNaN(val)) {
            warn(`<transition> explicit duration is NaN - ` +
                'the duration expression might be incorrect.');
        }
    }
    function addTransitionClass(el, cls) {
        cls.split(/\s+/).forEach(c => c && el.classList.add(c));
        (el._vtc || (el._vtc = new Set())).add(cls);
    }
    function removeTransitionClass(el, cls) {
        cls.split(/\s+/).forEach(c => c && el.classList.remove(c));
        if (el._vtc) {
            el._vtc.delete(cls);
            if (!el._vtc.size) {
                el._vtc = undefined;
            }
        }
    }
    function nextFrame(cb) {
        requestAnimationFrame(() => {
            requestAnimationFrame(cb);
        });
    }
    function whenTransitionEnds(el, expectedType, cb) {
        const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
        if (!type) {
            return cb();
        }
        const endEvent = type + 'end';
        let ended = 0;
        const end = () => {
            el.removeEventListener(endEvent, onEnd);
            cb();
        };
        const onEnd = (e) => {
            if (e.target === el) {
                if (++ended >= propCount) {
                    end();
                }
            }
        };
        setTimeout(() => {
            if (ended < propCount) {
                end();
            }
        }, timeout + 1);
        el.addEventListener(endEvent, onEnd);
    }
    function getTransitionInfo(el, expectedType) {
        const styles = window.getComputedStyle(el);
        // JSDOM may return undefined for transition properties
        const getStyleProperties = (key) => (styles[key] || '').split(', ');
        const transitionDelays = getStyleProperties(TRANSITION$1 + 'Delay');
        const transitionDurations = getStyleProperties(TRANSITION$1 + 'Duration');
        const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
        const animationDelays = getStyleProperties(ANIMATION + 'Delay');
        const animationDurations = getStyleProperties(ANIMATION + 'Duration');
        const animationTimeout = getTimeout(animationDelays, animationDurations);
        let type = null;
        let timeout = 0;
        let propCount = 0;
        /* istanbul ignore if */
        if (expectedType === TRANSITION$1) {
            if (transitionTimeout > 0) {
                type = TRANSITION$1;
                timeout = transitionTimeout;
                propCount = transitionDurations.length;
            }
        }
        else if (expectedType === ANIMATION) {
            if (animationTimeout > 0) {
                type = ANIMATION;
                timeout = animationTimeout;
                propCount = animationDurations.length;
            }
        }
        else {
            timeout = Math.max(transitionTimeout, animationTimeout);
            type =
                timeout > 0
                    ? transitionTimeout > animationTimeout
                        ? TRANSITION$1
                        : ANIMATION
                    : null;
            propCount = type
                ? type === TRANSITION$1
                    ? transitionDurations.length
                    : animationDurations.length
                : 0;
        }
        const hasTransform = type === TRANSITION$1 &&
            /\b(transform|all)(,|$)/.test(styles[TRANSITION$1 + 'Property']);
        return {
            type,
            timeout,
            propCount,
            hasTransform
        };
    }
    function getTimeout(delays, durations) {
        while (delays.length < durations.length) {
            delays = delays.concat(delays);
        }
        return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
    }
    // Old versions of Chromium (below 61.0.3163.100) formats floating pointer
    // numbers in a locale-dependent way, using a comma instead of a dot.
    // If comma is not replaced with a dot, the input will be rounded down
    // (i.e. acting as a floor function) causing unexpected behaviors
    function toMs(s) {
        return Number(s.slice(0, -1).replace(',', '.')) * 1000;
    }
    function callPendingCbs(c) {
        if (c.el._moveCb) {
            c.el._moveCb();
        }
        if (c.el._enterCb) {
            c.el._enterCb();
        }
    }
    function recordPosition(c) {
        newPositionMap.set(c, c.el.getBoundingClientRect());
    }
    function applyTranslation(c) {
        const oldPos = positionMap.get(c);
        const newPos = newPositionMap.get(c);
        const dx = oldPos.left - newPos.left;
        const dy = oldPos.top - newPos.top;
        if (dx || dy) {
            const s = c.el.style;
            s.transform = s.WebkitTransform = `translate(${dx}px,${dy}px)`;
            s.transitionDuration = '0s';
            return c;
        }
    }
    // this is put in a dedicated function to avoid the line from being treeshaken
    function forceReflow() {
        return document.body.offsetHeight;
    }
    function hasCSSTransform(el, root, moveClass) {
        // Detect whether an element with the move class applied has
        // CSS transitions. Since the element may be inside an entering
        // transition at this very moment, we make a clone of it and remove
        // all other transition classes applied to ensure only the move class
        // is applied.
        const clone = el.cloneNode();
        if (el._vtc) {
            el._vtc.forEach(cls => clone.classList.remove(cls));
        }
        clone.classList.add(moveClass);
        clone.style.display = 'none';
        const container = (root.nodeType === 1
            ? root
            : root.parentNode);
        container.appendChild(clone);
        const { hasTransform } = getTransitionInfo(clone);
        container.removeChild(clone);
        return hasTransform;
    }
    function compileToFunction(template, options) {
        if (!isString(template)) {
            if (template.nodeType) {
                template = template.innerHTML;
            }
            else {
                warn(`invalid template option: `, template);
                return NOOP;
            }
        }
        const key = template;
        const cached = compileCache[key];
        if (cached) {
            return cached;
        }
        if (template[0] === '#') {
            const el = document.querySelector(template);
            if (!el) {
                warn(`Template element not found or is empty: ${template}`);
            }
            template = el ? el.innerHTML : ``;
        }
        const { code } = compile(template, {
            hoistStatic: true,
            onError(err) {
                {
                    const message = `Template compilation error: ${err.message}`;
                    const codeFrame = err.loc &&
                        generateCodeFrame(template, err.loc.start.offset, err.loc.end.offset);
                    warn(codeFrame ? `${message}\n${codeFrame}` : message);
                }
            },
            ...options
        });
        const render = new Function('Vue', code)(runtimeDom);
        return (compileCache[key] = render);
    }
    exports_5("compile", compileToFunction);
    return {
        setters: [],
        execute: function () {
            // Patch flags are optimization hints generated by the compiler.
            // when a block with dynamicChildren is encountered during diff, the algorithm
            // enters "optimized mode". In this mode, we know that the vdom is produced by
            // a render function generated by the compiler, so the algorithm only needs to
            // handle updates explicitly marked by these patch flags.
            // runtime object for public consumption
            PublicPatchFlags = {
                TEXT: 1 /* TEXT */,
                CLASS: 2 /* CLASS */,
                STYLE: 4 /* STYLE */,
                PROPS: 8 /* PROPS */,
                NEED_PATCH: 32 /* NEED_PATCH */,
                FULL_PROPS: 16 /* FULL_PROPS */,
                KEYED_FRAGMENT: 128 /* KEYED_FRAGMENT */,
                UNKEYED_FRAGMENT: 256 /* UNKEYED_FRAGMENT */,
                DYNAMIC_SLOTS: 512 /* DYNAMIC_SLOTS */,
                BAIL: -1 /* BAIL */
            };
            // dev only flag -> name mapping
            PatchFlagNames = {
                [1 /* TEXT */]: `TEXT`,
                [2 /* CLASS */]: `CLASS`,
                [4 /* STYLE */]: `STYLE`,
                [8 /* PROPS */]: `PROPS`,
                [32 /* NEED_PATCH */]: `NEED_PATCH`,
                [16 /* FULL_PROPS */]: `FULL_PROPS`,
                [64 /* STABLE_FRAGMENT */]: `STABLE_FRAGMENT`,
                [128 /* KEYED_FRAGMENT */]: `KEYED_FRAGMENT`,
                [256 /* UNKEYED_FRAGMENT */]: `UNKEYED_FRAGMENT`,
                [512 /* DYNAMIC_SLOTS */]: `DYNAMIC_SLOTS`,
                [-1 /* BAIL */]: `BAIL`
            };
            GLOBALS_WHITE_LISTED = 'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +
                'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +
                'Object,Boolean,String,RegExp,Map,Set,JSON,Intl';
            isGloballyWhitelisted = makeMap(GLOBALS_WHITE_LISTED);
            range = 2;
            // These tag configs are shared between compiler-dom and runtime-dom, so they
            // https://developer.mozilla.org/en-US/docs/Web/HTML/Element
            HTML_TAGS = 'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +
                'header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,' +
                'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +
                'data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,' +
                'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +
                'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +
                'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +
                'option,output,progress,select,textarea,details,dialog,menu,menuitem,' +
                'summary,content,element,shadow,template,blockquote,iframe,tfoot';
            // https://developer.mozilla.org/en-US/docs/Web/SVG/Element
            SVG_TAGS = 'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +
                'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +
                'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +
                'feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +
                'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +
                'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +
                'foreignObject,g,hatch,hatchpath,image,line,lineGradient,marker,mask,' +
                'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +
                'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +
                'text,textPath,title,tspan,unknown,use,view';
            VOID_TAGS = 'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';
            isHTMLTag = makeMap(HTML_TAGS);
            isSVGTag = makeMap(SVG_TAGS);
            isVoidTag = makeMap(VOID_TAGS);
            EMPTY_OBJ = Object.freeze({});
            EMPTY_ARR = [];
            NOOP = () => { };
            /**
             * Always return false.
             */
            NO = () => false;
            isOn = (key) => key[0] === 'o' && key[1] === 'n';
            extend = (a, b) => {
                for (const key in b) {
                    a[key] = b[key];
                }
                return a;
            };
            hasOwnProperty = Object.prototype.hasOwnProperty;
            hasOwn = (val, key) => hasOwnProperty.call(val, key);
            isArray = Array.isArray;
            isFunction = (val) => typeof val === 'function';
            isString = (val) => typeof val === 'string';
            isSymbol = (val) => typeof val === 'symbol';
            isObject = (val) => val !== null && typeof val === 'object';
            objectToString = Object.prototype.toString;
            toTypeString = (value) => objectToString.call(value);
            isPlainObject = (val) => toTypeString(val) === '[object Object]';
            isReservedProp = makeMap('key,ref,' +
                'onVnodeBeforeMount,onVnodeMounted,' +
                'onVnodeBeforeUpdate,onVnodeUpdated,' +
                'onVnodeBeforeUnmount,onVnodeUnmounted');
            camelizeRE = /-(\w)/g;
            camelize = cacheStringFunction((str) => {
                return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));
            });
            hyphenateRE = /\B([A-Z])/g;
            hyphenate = cacheStringFunction((str) => {
                return str.replace(hyphenateRE, '-$1').toLowerCase();
            });
            capitalize = cacheStringFunction((str) => {
                return str.charAt(0).toUpperCase() + str.slice(1);
            });
            // compare whether a value has changed, accounting for NaN.
            hasChanged = (value, oldValue) => value !== oldValue && (value === value || oldValue === oldValue);
            errorMessages = {
                // parse errors
                [0 /* ABRUPT_CLOSING_OF_EMPTY_COMMENT */]: 'Illegal comment.',
                [1 /* ABSENCE_OF_DIGITS_IN_NUMERIC_CHARACTER_REFERENCE */]: 'Illegal numeric character reference: invalid character.',
                [2 /* CDATA_IN_HTML_CONTENT */]: 'CDATA section is allowed only in XML context.',
                [3 /* CHARACTER_REFERENCE_OUTSIDE_UNICODE_RANGE */]: 'Illegal numeric character reference: too big.',
                [4 /* CONTROL_CHARACTER_REFERENCE */]: 'Illegal numeric character reference: control character.',
                [5 /* DUPLICATE_ATTRIBUTE */]: 'Duplicate attribute.',
                [6 /* END_TAG_WITH_ATTRIBUTES */]: 'End tag cannot have attributes.',
                [7 /* END_TAG_WITH_TRAILING_SOLIDUS */]: "Illegal '/' in tags.",
                [8 /* EOF_BEFORE_TAG_NAME */]: 'Unexpected EOF in tag.',
                [9 /* EOF_IN_CDATA */]: 'Unexpected EOF in CDATA section.',
                [10 /* EOF_IN_COMMENT */]: 'Unexpected EOF in comment.',
                [11 /* EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */]: 'Unexpected EOF in script.',
                [12 /* EOF_IN_TAG */]: 'Unexpected EOF in tag.',
                [13 /* INCORRECTLY_CLOSED_COMMENT */]: 'Incorrectly closed comment.',
                [14 /* INCORRECTLY_OPENED_COMMENT */]: 'Incorrectly opened comment.',
                [15 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */]: "Illegal tag name. Use '&lt;' to print '<'.",
                [16 /* MISSING_ATTRIBUTE_VALUE */]: 'Attribute value was expected.',
                [17 /* MISSING_END_TAG_NAME */]: 'End tag name was expected.',
                [18 /* MISSING_SEMICOLON_AFTER_CHARACTER_REFERENCE */]: 'Semicolon was expected.',
                [19 /* MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */]: 'Whitespace was expected.',
                [20 /* NESTED_COMMENT */]: "Unexpected '<!--' in comment.",
                [21 /* NONCHARACTER_CHARACTER_REFERENCE */]: 'Illegal numeric character reference: non character.',
                [22 /* NULL_CHARACTER_REFERENCE */]: 'Illegal numeric character reference: null character.',
                [23 /* SURROGATE_CHARACTER_REFERENCE */]: 'Illegal numeric character reference: non-pair surrogate.',
                [24 /* UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */]: 'Attribute name cannot contain U+0022 ("), U+0027 (\'), and U+003C (<).',
                [25 /* UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */]: 'Unquoted attribute value cannot contain U+0022 ("), U+0027 (\'), U+003C (<), U+003D (=), and U+0060 (`).',
                [26 /* UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */]: "Attribute name cannot start with '='.",
                [28 /* UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */]: "'<?' is allowed only in XML context.",
                [29 /* UNEXPECTED_SOLIDUS_IN_TAG */]: "Illegal '/' in tags.",
                [30 /* UNKNOWN_NAMED_CHARACTER_REFERENCE */]: 'Unknown entity name.',
                // Vue-specific parse errors
                [31 /* X_INVALID_END_TAG */]: 'Invalid end tag.',
                [32 /* X_MISSING_END_TAG */]: 'Element is missing end tag.',
                [33 /* X_MISSING_INTERPOLATION_END */]: 'Interpolation end sign was not found.',
                [34 /* X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */]: 'End bracket for dynamic directive argument was not found. ' +
                    'Note that dynamic directive argument cannot contain spaces.',
                // transform errors
                [35 /* X_V_IF_NO_EXPRESSION */]: `v-if/v-else-if is missing expression.`,
                [36 /* X_V_ELSE_NO_ADJACENT_IF */]: `v-else/v-else-if has no adjacent v-if.`,
                [37 /* X_V_FOR_NO_EXPRESSION */]: `v-for is missing expression.`,
                [38 /* X_V_FOR_MALFORMED_EXPRESSION */]: `v-for has invalid expression.`,
                [39 /* X_V_BIND_NO_EXPRESSION */]: `v-bind is missing expression.`,
                [40 /* X_V_ON_NO_EXPRESSION */]: `v-on is missing expression.`,
                [41 /* X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */]: `Unexpected custom directive on <slot> outlet.`,
                [42 /* X_V_SLOT_NAMED_SLOT_ON_COMPONENT */]: `Named v-slot on component. ` +
                    `Named slots should use <template v-slot> syntax nested inside the component.`,
                [43 /* X_V_SLOT_MIXED_SLOT_USAGE */]: `Mixed v-slot usage on both the component and nested <template>.` +
                    `The default slot should also use <template> syntax when there are other ` +
                    `named slots to avoid scope ambiguity.`,
                [44 /* X_V_SLOT_DUPLICATE_SLOT_NAMES */]: `Duplicate slot names found. `,
                [45 /* X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */]: `Extraneous children found when component already has explicitly named ` +
                    `default slot. These children will be ignored.`,
                [46 /* X_V_SLOT_MISPLACED */]: `v-slot can only be used on components or <template> tags.`,
                [47 /* X_V_MODEL_NO_EXPRESSION */]: `v-model is missing expression.`,
                [48 /* X_V_MODEL_MALFORMED_EXPRESSION */]: `v-model value must be a valid JavaScript member expression.`,
                [49 /* X_V_MODEL_ON_SCOPE_VARIABLE */]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,
                [50 /* X_INVALID_EXPRESSION */]: `Invalid JavaScript expression.`,
                // generic errors
                [51 /* X_PREFIX_ID_NOT_SUPPORTED */]: `"prefixIdentifiers" option is not supported in this build of compiler.`,
                [52 /* X_MODULE_MODE_NOT_SUPPORTED */]: `ES module mode is not supported in this build of compiler.`,
                [53 /* X_CACHE_HANDLER_NOT_SUPPORTED */]: `"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.`,
                [54 /* X_SCOPE_ID_NOT_SUPPORTED */]: `"scopeId" option is only supported in module mode.`
            };
            // AST Utilities ---------------------------------------------------------------
            // Some expressions, e.g. sequence and conditional expressions, are never
            // associated with template nodes, so their source locations are just a stub.
            // Container types like CompoundExpression also don't need a real location.
            locStub = {
                source: '',
                start: { line: 1, column: 1, offset: 0 },
                end: { line: 1, column: 1, offset: 0 }
            };
            FRAGMENT = Symbol(`Fragment`);
            PORTAL = Symbol(`Portal`);
            SUSPENSE = Symbol(`Suspense`);
            KEEP_ALIVE = Symbol(`KeepAlive`);
            BASE_TRANSITION = Symbol(`BaseTransition`);
            OPEN_BLOCK = Symbol(`openBlock`);
            CREATE_BLOCK = Symbol(`createBlock`);
            CREATE_VNODE = Symbol(`createVNode`);
            CREATE_COMMENT = Symbol(`createCommentVNode`);
            CREATE_TEXT = Symbol(`createTextVNode`);
            RESOLVE_COMPONENT = Symbol(`resolveComponent`);
            RESOLVE_DYNAMIC_COMPONENT = Symbol(`resolveDynamicComponent`);
            RESOLVE_DIRECTIVE = Symbol(`resolveDirective`);
            WITH_DIRECTIVES = Symbol(`withDirectives`);
            RENDER_LIST = Symbol(`renderList`);
            RENDER_SLOT = Symbol(`renderSlot`);
            CREATE_SLOTS = Symbol(`createSlots`);
            TO_DISPLAY_STRING = Symbol(`toDisplayString`);
            MERGE_PROPS = Symbol(`mergeProps`);
            TO_HANDLERS = Symbol(`toHandlers`);
            CAMELIZE = Symbol(`camelize`);
            SET_BLOCK_TRACKING = Symbol(`setBlockTracking`);
            PUSH_SCOPE_ID = Symbol(`pushScopeId`);
            POP_SCOPE_ID = Symbol(`popScopeId`);
            WITH_SCOPE_ID = Symbol(`withScopeId`);
            // Name mapping for runtime helpers that need to be imported from 'vue' in
            // generated code. Make sure these are correctly exported in the runtime!
            // Using `any` here because TS doesn't allow symbols as index type.
            helperNameMap = {
                [FRAGMENT]: `Fragment`,
                [PORTAL]: `Portal`,
                [SUSPENSE]: `Suspense`,
                [KEEP_ALIVE]: `KeepAlive`,
                [BASE_TRANSITION]: `BaseTransition`,
                [OPEN_BLOCK]: `openBlock`,
                [CREATE_BLOCK]: `createBlock`,
                [CREATE_VNODE]: `createVNode`,
                [CREATE_COMMENT]: `createCommentVNode`,
                [CREATE_TEXT]: `createTextVNode`,
                [RESOLVE_COMPONENT]: `resolveComponent`,
                [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,
                [RESOLVE_DIRECTIVE]: `resolveDirective`,
                [WITH_DIRECTIVES]: `withDirectives`,
                [RENDER_LIST]: `renderList`,
                [RENDER_SLOT]: `renderSlot`,
                [CREATE_SLOTS]: `createSlots`,
                [TO_DISPLAY_STRING]: `toDisplayString`,
                [MERGE_PROPS]: `mergeProps`,
                [TO_HANDLERS]: `toHandlers`,
                [CAMELIZE]: `camelize`,
                [SET_BLOCK_TRACKING]: `setBlockTracking`,
                [PUSH_SCOPE_ID]: `pushScopeId`,
                [POP_SCOPE_ID]: `popScopeId`,
                [WITH_SCOPE_ID]: `withScopeId`
            };
            isBuiltInType = (tag, expected) => tag === expected || tag === hyphenate(expected);
            nonIdentifierRE = /^\d|[^\$\w]/;
            isSimpleIdentifier = (name) => !nonIdentifierRE.test(name);
            memberExpRE = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\[[^\]]+\])*$/;
            isMemberExpression = (path) => memberExpRE.test(path);
            defaultParserOptions = {
                delimiters: [`{{`, `}}`],
                getNamespace: () => 0 /* HTML */,
                getTextMode: () => 0 /* DATA */,
                isVoidTag: NO,
                isPreTag: NO,
                isCustomElement: NO,
                namedCharacterReferences: {
                    'gt;': '>',
                    'lt;': '<',
                    'amp;': '&',
                    'apos;': "'",
                    'quot;': '"'
                },
                maxCRNameLength: 5,
                onError: defaultOnError
            };
            // https://html.spec.whatwg.org/multipage/parsing.html#numeric-character-reference-end-state
            CCR_REPLACEMENTS = {
                0x80: 0x20ac,
                0x82: 0x201a,
                0x83: 0x0192,
                0x84: 0x201e,
                0x85: 0x2026,
                0x86: 0x2020,
                0x87: 0x2021,
                0x88: 0x02c6,
                0x89: 0x2030,
                0x8a: 0x0160,
                0x8b: 0x2039,
                0x8c: 0x0152,
                0x8e: 0x017d,
                0x91: 0x2018,
                0x92: 0x2019,
                0x93: 0x201c,
                0x94: 0x201d,
                0x95: 0x2022,
                0x96: 0x2013,
                0x97: 0x2014,
                0x98: 0x02dc,
                0x99: 0x2122,
                0x9a: 0x0161,
                0x9b: 0x203a,
                0x9c: 0x0153,
                0x9e: 0x017e,
                0x9f: 0x0178
            };
            transformIf = createStructuralDirectiveTransform(/^(if|else|else-if)$/, (node, dir, context) => {
                if (dir.name !== 'else' &&
                    (!dir.exp || !dir.exp.content.trim())) {
                    const loc = dir.exp ? dir.exp.loc : node.loc;
                    context.onError(createCompilerError(35 /* X_V_IF_NO_EXPRESSION */, dir.loc));
                    dir.exp = createSimpleExpression(`true`, false, loc);
                }
                if (dir.name === 'if') {
                    const branch = createIfBranch(node, dir);
                    const codegenNode = createSequenceExpression([
                        createCallExpression(context.helper(OPEN_BLOCK))
                    ]);
                    context.replaceNode({
                        type: 9 /* IF */,
                        loc: node.loc,
                        branches: [branch],
                        codegenNode
                    });
                    // Exit callback. Complete the codegenNode when all children have been
                    // transformed.
                    return () => {
                        codegenNode.expressions.push(createCodegenNodeForBranch(branch, 0, context));
                    };
                }
                else {
                    // locate the adjacent v-if
                    const siblings = context.parent.children;
                    const comments = [];
                    let i = siblings.indexOf(node);
                    while (i-- >= -1) {
                        const sibling = siblings[i];
                        if (sibling && sibling.type === 3 /* COMMENT */) {
                            context.removeNode(sibling);
                            comments.unshift(sibling);
                            continue;
                        }
                        if (sibling && sibling.type === 9 /* IF */) {
                            // move the node to the if node's branches
                            context.removeNode();
                            const branch = createIfBranch(node, dir);
                            if (comments.length) {
                                branch.children = [...comments, ...branch.children];
                            }
                            sibling.branches.push(branch);
                            // since the branch was removed, it will not be traversed.
                            // make sure to traverse here.
                            traverseChildren(branch, context);
                            // make sure to reset currentNode after traversal to indicate this
                            // node has been removed.
                            context.currentNode = null;
                            // attach this branch's codegen node to the v-if root.
                            let parentCondition = sibling.codegenNode
                                .expressions[1];
                            while (true) {
                                if (parentCondition.alternate.type ===
                                    19 /* JS_CONDITIONAL_EXPRESSION */) {
                                    parentCondition = parentCondition.alternate;
                                }
                                else {
                                    parentCondition.alternate = createCodegenNodeForBranch(branch, sibling.branches.length - 1, context);
                                    break;
                                }
                            }
                        }
                        else {
                            context.onError(createCompilerError(36 /* X_V_ELSE_NO_ADJACENT_IF */, node.loc));
                        }
                        break;
                    }
                }
            });
            transformFor = createStructuralDirectiveTransform('for', (node, dir, context) => {
                if (!dir.exp) {
                    context.onError(createCompilerError(37 /* X_V_FOR_NO_EXPRESSION */, dir.loc));
                    return;
                }
                const parseResult = parseForExpression(
                // can only be simple expression because vFor transform is applied
                // before expression transform.
                dir.exp);
                if (!parseResult) {
                    context.onError(createCompilerError(38 /* X_V_FOR_MALFORMED_EXPRESSION */, dir.loc));
                    return;
                }
                const { helper, addIdentifiers, removeIdentifiers, scopes } = context;
                const { source, value, key, index } = parseResult;
                // create the loop render function expression now, and add the
                // iterator on exit after all children have been traversed
                const renderExp = createCallExpression(helper(RENDER_LIST), [source]);
                const keyProp = findProp(node, `key`);
                const fragmentFlag = keyProp
                    ? 128 /* KEYED_FRAGMENT */
                    : 256 /* UNKEYED_FRAGMENT */;
                const codegenNode = createSequenceExpression([
                    // fragment blocks disable tracking since they always diff their children
                    createCallExpression(helper(OPEN_BLOCK), [`false`]),
                    createCallExpression(helper(CREATE_BLOCK), [
                        helper(FRAGMENT),
                        `null`,
                        renderExp,
                        `${fragmentFlag} /* ${PatchFlagNames[fragmentFlag]} */`
                    ])
                ]);
                context.replaceNode({
                    type: 11 /* FOR */,
                    loc: dir.loc,
                    source,
                    valueAlias: value,
                    keyAlias: key,
                    objectIndexAlias: index,
                    children: node.tagType === 3 /* TEMPLATE */ ? node.children : [node],
                    codegenNode
                });
                // bookkeeping
                scopes.vFor++;
                return () => {
                    scopes.vFor--;
                    // finish the codegen now that all children have been traversed
                    let childBlock;
                    const isTemplate = isTemplateNode(node);
                    const slotOutlet = isSlotOutlet(node)
                        ? node
                        : isTemplate &&
                            node.children.length === 1 &&
                            isSlotOutlet(node.children[0])
                            ? node.children[0] // api-extractor somehow fails to infer this
                            : null;
                    const keyProperty = keyProp
                        ? createObjectProperty(`key`, keyProp.type === 6 /* ATTRIBUTE */
                            ? createSimpleExpression(keyProp.value.content, true)
                            : keyProp.exp)
                        : null;
                    if (slotOutlet) {
                        // <slot v-for="..."> or <template v-for="..."><slot/></template>
                        childBlock = slotOutlet.codegenNode;
                        if (isTemplate && keyProperty) {
                            // <template v-for="..." :key="..."><slot/></template>
                            // we need to inject the key to the renderSlot() call.
                            // the props for renderSlot is passed as the 3rd argument.
                            injectProp(childBlock, keyProperty, context);
                        }
                    }
                    else if (isTemplate) {
                        // <template v-for="...">
                        // should generate a fragment block for each loop
                        childBlock = createBlockExpression(createCallExpression(helper(CREATE_BLOCK), [
                            helper(FRAGMENT),
                            keyProperty ? createObjectExpression([keyProperty]) : `null`,
                            node.children,
                            `${64 /* STABLE_FRAGMENT */} /* ${PatchFlagNames[64 /* STABLE_FRAGMENT */]} */`
                        ]), context);
                    }
                    else {
                        // Normal element v-for. Directly use the child's codegenNode
                        // arguments, but replace createVNode() with createBlock()
                        let codegenNode = node.codegenNode;
                        if (codegenNode.callee === WITH_DIRECTIVES) {
                            codegenNode.arguments[0].callee = helper(CREATE_BLOCK);
                        }
                        else {
                            codegenNode.callee = helper(CREATE_BLOCK);
                        }
                        childBlock = createBlockExpression(codegenNode, context);
                    }
                    renderExp.arguments.push(createFunctionExpression(createForLoopParams(parseResult), childBlock, true /* force newline */));
                };
            });
            forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
            // This regex doesn't cover the case if key or index aliases have destructuring,
            // but those do not make sense in the first place, so this works in practice.
            forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
            stripParensRE = /^\(|\)$/g;
            isStaticExp = (p) => p.type === 4 /* SIMPLE_EXPRESSION */ && p.isStatic;
            defaultFallback = createSimpleExpression(`undefined`, false);
            // A NodeTransform that:
            // 1. Tracks scope identifiers for scoped slots so that they don't get prefixed
            //    by transformExpression. This is only applied in non-browser builds with
            //    { prefixIdentifiers: true }.
            // 2. Track v-slot depths so that we know a slot is inside another slot.
            //    Note the exit callback is executed before buildSlots() on the same node,
            //    so only nested slots see positive numbers.
            trackSlotScopes = (node, context) => {
                if (node.type === 1 /* ELEMENT */ &&
                    (node.tagType === 1 /* COMPONENT */ ||
                        node.tagType === 3 /* TEMPLATE */)) {
                    // We are only checking non-empty v-slot here
                    // since we only care about slots that introduce scope variables.
                    const vSlot = findDir(node, 'slot');
                    if (vSlot) {
                        const slotProps = vSlot.exp;
                        context.scopes.vSlot++;
                        return () => {
                            context.scopes.vSlot--;
                        };
                    }
                }
            };
            // some directive transforms (e.g. v-model) may return a symbol for runtime
            // import, which should be used instead of a resolveDirective call.
            directiveImportMap = new WeakMap();
            // generate a JavaScript AST for this element's codegen
            transformElement = (node, context) => {
                if (node.type !== 1 /* ELEMENT */ ||
                    // handled by transformSlotOutlet
                    node.tagType === 2 /* SLOT */ ||
                    // <template v-if/v-for> should have already been replaced
                    // <template v-slot> is handled by buildSlots
                    (node.tagType === 3 /* TEMPLATE */ && node.props.some(isVSlot))) {
                    return;
                }
                // perform the work on exit, after all child expressions have been
                // processed and merged.
                return function postTransformElement() {
                    const { tag, tagType, props } = node;
                    const builtInComponentSymbol = isCoreComponent(tag) || context.isBuiltInComponent(tag);
                    const isComponent = tagType === 1 /* COMPONENT */;
                    let hasProps = props.length > 0;
                    let patchFlag = 0;
                    let runtimeDirectives;
                    let dynamicPropNames;
                    let dynamicComponent;
                    let shouldUseBlock = false;
                    // handle dynamic component
                    const isProp = findProp(node, 'is');
                    if (tag === 'component') {
                        if (isProp) {
                            // static <component is="foo" />
                            if (isProp.type === 6 /* ATTRIBUTE */) {
                                const tag = isProp.value && isProp.value.content;
                                if (tag) {
                                    context.helper(RESOLVE_COMPONENT);
                                    context.components.add(tag);
                                    dynamicComponent = toValidAssetId(tag, `component`);
                                }
                            }
                            // dynamic <component :is="asdf" />
                            else if (isProp.exp) {
                                dynamicComponent = createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), 
                                // _ctx.$ exposes the owner instance of current render function
                                [isProp.exp, context.prefixIdentifiers ? `_ctx.$` : `$`]);
                            }
                        }
                    }
                    let nodeType;
                    if (dynamicComponent) {
                        nodeType = dynamicComponent;
                    }
                    else if (builtInComponentSymbol) {
                        nodeType = context.helper(builtInComponentSymbol);
                    }
                    else if (isComponent) {
                        // user component w/ resolve
                        context.helper(RESOLVE_COMPONENT);
                        context.components.add(tag);
                        nodeType = toValidAssetId(tag, `component`);
                    }
                    else {
                        // plain element
                        nodeType = `"${tag}"`;
                        // <svg> and <foreignObject> must be forced into blocks so that block
                        // updates inside get proper isSVG flag at runtime. (#639, #643)
                        // This is technically web-specific, but splitting the logic out of core
                        // leads to too much unnecessary complexity.
                        shouldUseBlock = tag === 'svg' || tag === 'foreignObject';
                    }
                    const args = [nodeType];
                    // props
                    if (hasProps) {
                        const propsBuildResult = buildProps(node, context, 
                        // skip reserved "is" prop <component is>
                        isProp ? node.props.filter(p => p !== isProp) : node.props);
                        patchFlag = propsBuildResult.patchFlag;
                        dynamicPropNames = propsBuildResult.dynamicPropNames;
                        runtimeDirectives = propsBuildResult.directives;
                        if (!propsBuildResult.props) {
                            hasProps = false;
                        }
                        else {
                            args.push(propsBuildResult.props);
                        }
                    }
                    // children
                    const hasChildren = node.children.length > 0;
                    if (hasChildren) {
                        if (!hasProps) {
                            args.push(`null`);
                        }
                        // Portal & KeepAlive should have normal children instead of slots
                        // Portal is not a real component has dedicated handling in the renderer
                        // KeepAlive should not track its own deps so that it can be used inside
                        // Transition
                        if (isComponent &&
                            builtInComponentSymbol !== PORTAL &&
                            builtInComponentSymbol !== KEEP_ALIVE) {
                            const { slots, hasDynamicSlots } = buildSlots(node, context);
                            args.push(slots);
                            if (hasDynamicSlots) {
                                patchFlag |= 512 /* DYNAMIC_SLOTS */;
                            }
                        }
                        else if (node.children.length === 1) {
                            const child = node.children[0];
                            const type = child.type;
                            // check for dynamic text children
                            const hasDynamicTextChild = type === 5 /* INTERPOLATION */ ||
                                type === 8 /* COMPOUND_EXPRESSION */;
                            if (hasDynamicTextChild && !isStaticNode(child)) {
                                patchFlag |= 1 /* TEXT */;
                            }
                            // pass directly if the only child is a text node
                            // (plain / interpolation / expression)
                            if (hasDynamicTextChild || type === 2 /* TEXT */) {
                                args.push(child);
                            }
                            else {
                                args.push(node.children);
                            }
                        }
                        else {
                            args.push(node.children);
                        }
                    }
                    // patchFlag & dynamicPropNames
                    if (patchFlag !== 0) {
                        if (!hasChildren) {
                            if (!hasProps) {
                                args.push(`null`);
                            }
                            args.push(`null`);
                        }
                        {
                            const flagNames = Object.keys(PatchFlagNames)
                                .map(Number)
                                .filter(n => n > 0 && patchFlag & n)
                                .map(n => PatchFlagNames[n])
                                .join(`, `);
                            args.push(patchFlag + ` /* ${flagNames} */`);
                        }
                        if (dynamicPropNames && dynamicPropNames.length) {
                            args.push(stringifyDynamicPropNames(dynamicPropNames));
                        }
                    }
                    const { loc } = node;
                    const vnode = shouldUseBlock
                        ? createSequenceExpression([
                            createCallExpression(context.helper(OPEN_BLOCK)),
                            createCallExpression(context.helper(CREATE_BLOCK), args, loc)
                        ])
                        : createCallExpression(context.helper(CREATE_VNODE), args, loc);
                    if (runtimeDirectives && runtimeDirectives.length) {
                        node.codegenNode = createCallExpression(context.helper(WITH_DIRECTIVES), [
                            vnode,
                            createArrayExpression(runtimeDirectives.map(dir => buildDirectiveArgs(dir, context)), loc)
                        ], loc);
                    }
                    else {
                        node.codegenNode = vnode;
                    }
                };
            };
            transformSlotOutlet = (node, context) => {
                if (isSlotOutlet(node)) {
                    const { props, children, loc } = node;
                    const $slots = context.prefixIdentifiers ? `_ctx.$slots` : `$slots`;
                    let slotName = `"default"`;
                    // check for <slot name="xxx" OR :name="xxx" />
                    let nameIndex = -1;
                    for (let i = 0; i < props.length; i++) {
                        const prop = props[i];
                        if (prop.type === 6 /* ATTRIBUTE */) {
                            if (prop.name === `name` && prop.value) {
                                // static name="xxx"
                                slotName = JSON.stringify(prop.value.content);
                                nameIndex = i;
                                break;
                            }
                        }
                        else if (prop.name === `bind`) {
                            const { arg, exp } = prop;
                            if (arg &&
                                exp &&
                                arg.type === 4 /* SIMPLE_EXPRESSION */ &&
                                arg.isStatic &&
                                arg.content === `name`) {
                                // dynamic :name="xxx"
                                slotName = exp;
                                nameIndex = i;
                                break;
                            }
                        }
                    }
                    const slotArgs = [$slots, slotName];
                    const propsWithoutName = nameIndex > -1
                        ? props.slice(0, nameIndex).concat(props.slice(nameIndex + 1))
                        : props;
                    let hasProps = propsWithoutName.length > 0;
                    if (hasProps) {
                        const { props: propsExpression, directives } = buildProps(node, context, propsWithoutName);
                        if (directives.length) {
                            context.onError(createCompilerError(41 /* X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */, directives[0].loc));
                        }
                        if (propsExpression) {
                            slotArgs.push(propsExpression);
                        }
                        else {
                            hasProps = false;
                        }
                    }
                    if (children.length) {
                        if (!hasProps) {
                            slotArgs.push(`{}`);
                        }
                        slotArgs.push(children);
                    }
                    node.codegenNode = createCallExpression(context.helper(RENDER_SLOT), slotArgs, loc);
                }
            };
            fnExpRE = /^([\w$_]+|\([^)]*?\))\s*=>|^function(?:\s+[\w$]+)?\s*\(/;
            transformOn = (dir, node, context, augmentor) => {
                const { loc, modifiers, arg } = dir;
                if (!dir.exp && !modifiers.length) {
                    context.onError(createCompilerError(40 /* X_V_ON_NO_EXPRESSION */, loc));
                }
                let eventName;
                if (arg.type === 4 /* SIMPLE_EXPRESSION */) {
                    if (arg.isStatic) {
                        eventName = createSimpleExpression(`on${capitalize(arg.content)}`, true, arg.loc);
                    }
                    else {
                        eventName = createCompoundExpression([`"on" + (`, arg, `)`]);
                    }
                }
                else {
                    // already a compound expression.
                    eventName = arg;
                    eventName.children.unshift(`"on" + (`);
                    eventName.children.push(`)`);
                }
                // handler processing
                let exp = dir.exp;
                let isCacheable = !exp;
                if (exp) {
                    const isMemberExp = isMemberExpression(exp.content);
                    const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content));
                    const hasMultipleStatements = exp.content.includes(`;`);
                    if (isInlineStatement || (isCacheable && isMemberExp)) {
                        // wrap inline statement in a function expression
                        exp = createCompoundExpression([
                            `$event => ${hasMultipleStatements ? `{` : `(`}`,
                            ...(exp.type === 4 /* SIMPLE_EXPRESSION */ ? [exp] : exp.children),
                            hasMultipleStatements ? `}` : `)`
                        ]);
                    }
                }
                let ret = {
                    props: [
                        createObjectProperty(eventName, exp || createSimpleExpression(`() => {}`, false, loc))
                    ],
                    needRuntime: false
                };
                // apply extended compiler augmentor
                if (augmentor) {
                    ret = augmentor(ret);
                }
                if (isCacheable) {
                    // cache handlers so that it's always the same handler being passed down.
                    // this avoids unnecessary re-renders when users use inline handlers on
                    // components.
                    ret.props[0].value = context.cache(ret.props[0].value);
                }
                return ret;
            };
            // v-bind without arg is handled directly in ./transformElements.ts due to it affecting
            // codegen for the entire props object. This transform here is only for v-bind
            // *with* args.
            transformBind = (dir, node, context) => {
                const { exp, modifiers, loc } = dir;
                const arg = dir.arg;
                if (!exp) {
                    context.onError(createCompilerError(39 /* X_V_BIND_NO_EXPRESSION */, loc));
                }
                // .prop is no longer necessary due to new patch behavior
                // .sync is replaced by v-model:arg
                if (modifiers.includes('camel')) {
                    if (arg.type === 4 /* SIMPLE_EXPRESSION */) {
                        if (arg.isStatic) {
                            arg.content = camelize(arg.content);
                        }
                        else {
                            arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`;
                        }
                    }
                    else {
                        arg.children.unshift(`${context.helperString(CAMELIZE)}(`);
                        arg.children.push(`)`);
                    }
                }
                return {
                    props: [
                        createObjectProperty(arg, exp || createSimpleExpression('', true, loc))
                    ],
                    needRuntime: false
                };
            };
            isText$1 = (node) => node.type === 5 /* INTERPOLATION */ || node.type === 2 /* TEXT */;
            // Merge adjacent text nodes and expressions into a single expression
            // e.g. <div>abc {{ d }} {{ e }}</div> should have a single expression node as child.
            transformText = (node, context) => {
                if (node.type === 0 /* ROOT */ ||
                    node.type === 1 /* ELEMENT */ ||
                    node.type === 11 /* FOR */) {
                    // perform the transform on node exit so that all expressions have already
                    // been processed.
                    return () => {
                        const children = node.children;
                        let currentContainer = undefined;
                        let hasText = false;
                        for (let i = 0; i < children.length; i++) {
                            const child = children[i];
                            if (isText$1(child)) {
                                hasText = true;
                                for (let j = i + 1; j < children.length; j++) {
                                    const next = children[j];
                                    if (isText$1(next)) {
                                        if (!currentContainer) {
                                            currentContainer = children[i] = {
                                                type: 8 /* COMPOUND_EXPRESSION */,
                                                loc: child.loc,
                                                children: [child]
                                            };
                                        }
                                        // merge adjacent text node into current
                                        currentContainer.children.push(` + `, next);
                                        children.splice(j, 1);
                                        j--;
                                    }
                                    else {
                                        currentContainer = undefined;
                                        break;
                                    }
                                }
                            }
                        }
                        if (!hasText ||
                            // if this is a plain element with a single text child, leave it
                            // as-is since the runtime has dedicated fast path for this by directly
                            // setting textContent of the element.
                            // for component root it's always normalized anyway.
                            (children.length === 1 &&
                                (node.type === 0 /* ROOT */ ||
                                    (node.type === 1 /* ELEMENT */ &&
                                        node.tagType === 0 /* ELEMENT */)))) {
                            return;
                        }
                        // pre-convert text nodes into createTextVNode(text) calls to avoid
                        // runtime normalization.
                        for (let i = 0; i < children.length; i++) {
                            const child = children[i];
                            if (isText$1(child) || child.type === 8 /* COMPOUND_EXPRESSION */) {
                                const callArgs = [];
                                // createTextVNode defaults to single whitespace, so if it is a
                                // single space the code could be an empty call to save bytes.
                                if (child.type !== 2 /* TEXT */ || child.content !== ' ') {
                                    callArgs.push(child);
                                }
                                // mark dynamic text with flag so it gets patched inside a block
                                if (child.type !== 2 /* TEXT */) {
                                    callArgs.push(`${1 /* TEXT */} /* ${PatchFlagNames[1 /* TEXT */]} */`);
                                }
                                children[i] = {
                                    type: 12 /* TEXT_CALL */,
                                    content: child,
                                    loc: child.loc,
                                    codegenNode: createCallExpression(context.helper(CREATE_TEXT), callArgs)
                                };
                            }
                        }
                    };
                }
            };
            transformOnce = (node, context) => {
                if (node.type === 1 /* ELEMENT */ && findDir(node, 'once', true)) {
                    context.helper(SET_BLOCK_TRACKING);
                    return () => {
                        if (node.codegenNode) {
                            node.codegenNode = context.cache(node.codegenNode, true /* isVNode */);
                        }
                    };
                }
            };
            transformModel = (dir, node, context) => {
                const { exp, arg } = dir;
                if (!exp) {
                    context.onError(createCompilerError(47 /* X_V_MODEL_NO_EXPRESSION */, dir.loc));
                    return createTransformProps();
                }
                const expString = exp.type === 4 /* SIMPLE_EXPRESSION */ ? exp.content : exp.loc.source;
                if (!isMemberExpression(expString)) {
                    context.onError(createCompilerError(48 /* X_V_MODEL_MALFORMED_EXPRESSION */, exp.loc));
                    return createTransformProps();
                }
                const propName = arg ? arg : createSimpleExpression('modelValue', true);
                const eventName = arg
                    ? arg.type === 4 /* SIMPLE_EXPRESSION */ && arg.isStatic
                        ? `onUpdate:${arg.content}`
                        : createCompoundExpression([
                            '"onUpdate:" + ',
                            ...(arg.type === 4 /* SIMPLE_EXPRESSION */ ? [arg] : arg.children)
                        ])
                    : `onUpdate:modelValue`;
                const props = [
                    // modelValue: foo
                    createObjectProperty(propName, dir.exp),
                    // "onUpdate:modelValue": $event => (foo = $event)
                    createObjectProperty(eventName, createCompoundExpression([
                        `$event => (`,
                        ...(exp.type === 4 /* SIMPLE_EXPRESSION */ ? [exp] : exp.children),
                        ` = $event)`
                    ]))
                ];
                // modelModifiers: { foo: true, "bar-baz": true }
                if (dir.modifiers.length && node.tagType === 1 /* COMPONENT */) {
                    const modifiers = dir.modifiers
                        .map(m => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`)
                        .join(`, `);
                    const modifiersKey = arg
                        ? arg.type === 4 /* SIMPLE_EXPRESSION */ && arg.isStatic
                            ? `${arg.content}Modifiers`
                            : createCompoundExpression([
                                ...(arg.type === 4 /* SIMPLE_EXPRESSION */
                                    ? [arg]
                                    : arg.children),
                                ' + "Modifiers"'
                            ])
                        : `modelModifiers`;
                    props.push(createObjectProperty(modifiersKey, createSimpleExpression(`{ ${modifiers} }`, false, dir.loc, true)));
                }
                return createTransformProps(props);
            };
            isRawTextContainer = makeMap('style,iframe,script,noscript', true);
            parserOptionsMinimal = {
                isVoidTag,
                isNativeTag: tag => isHTMLTag(tag) || isSVGTag(tag),
                isPreTag: tag => tag === 'pre',
                // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
                getNamespace(tag, parent) {
                    let ns = parent ? parent.ns : 0 /* HTML */;
                    if (parent && ns === 2 /* MATH_ML */) {
                        if (parent.tag === 'annotation-xml') {
                            if (tag === 'svg') {
                                return 1 /* SVG */;
                            }
                            if (parent.props.some(a => a.type === 6 /* ATTRIBUTE */ &&
                                a.name === 'encoding' &&
                                a.value != null &&
                                (a.value.content === 'text/html' ||
                                    a.value.content === 'application/xhtml+xml'))) {
                                ns = 0 /* HTML */;
                            }
                        }
                        else if (/^m(?:[ions]|text)$/.test(parent.tag) &&
                            tag !== 'mglyph' &&
                            tag !== 'malignmark') {
                            ns = 0 /* HTML */;
                        }
                    }
                    else if (parent && ns === 1 /* SVG */) {
                        if (parent.tag === 'foreignObject' ||
                            parent.tag === 'desc' ||
                            parent.tag === 'title') {
                            ns = 0 /* HTML */;
                        }
                    }
                    if (ns === 0 /* HTML */) {
                        if (tag === 'svg') {
                            return 1 /* SVG */;
                        }
                        if (tag === 'math') {
                            return 2 /* MATH_ML */;
                        }
                    }
                    return ns;
                },
                // https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments
                getTextMode(tag, ns) {
                    if (ns === 0 /* HTML */) {
                        if (tag === 'textarea' || tag === 'title') {
                            return 1 /* RCDATA */;
                        }
                        if (isRawTextContainer(tag)) {
                            return 2 /* RAWTEXT */;
                        }
                    }
                    return 0 /* DATA */;
                }
            };
            // Parse inline CSS strings for static style attributes into an object.
            // This is a NodeTransform since it works on the static `style` attribute and
            // converts it into a dynamic equivalent:
            // style="color: red" -> :style='{ "color": "red" }'
            // It is then processed by `transformElement` and included in the generated
            // props.
            transformStyle = (node, context) => {
                if (node.type === 1 /* ELEMENT */) {
                    node.props.forEach((p, i) => {
                        if (p.type === 6 /* ATTRIBUTE */ && p.name === 'style' && p.value) {
                            // replace p with an expression node
                            const parsed = JSON.stringify(parseInlineCSS(p.value.content));
                            const exp = context.hoist(createSimpleExpression(parsed, false, p.loc));
                            node.props[i] = {
                                type: 7 /* DIRECTIVE */,
                                name: `bind`,
                                arg: createSimpleExpression(`style`, true, p.loc),
                                exp,
                                modifiers: [],
                                loc: p.loc
                            };
                        }
                    });
                }
            };
            listDelimiterRE = /;(?![^(]*\))/g;
            propertyDelimiterRE = /:(.+)/;
            transformCloak = (node, context) => {
                return { props: [], needRuntime: false };
            };
            DOMErrorMessages = {
                [55 /* X_V_HTML_NO_EXPRESSION */]: `v-html is missing expression.`,
                [56 /* X_V_HTML_WITH_CHILDREN */]: `v-html will override element children.`,
                [57 /* X_V_TEXT_NO_EXPRESSION */]: `v-text is missing expression.`,
                [58 /* X_V_TEXT_WITH_CHILDREN */]: `v-text will override element children.`,
                [59 /* X_V_MODEL_ON_INVALID_ELEMENT */]: `v-model can only be used on <input>, <textarea> and <select> elements.`,
                [60 /* X_V_MODEL_ARG_ON_ELEMENT */]: `v-model argument is not supported on plain elements.`,
                [61 /* X_V_MODEL_ON_FILE_INPUT_ELEMENT */]: `v-model cannot used on file inputs since they are read-only. Use a v-on:change listener instead.`,
                [62 /* X_V_SHOW_NO_EXPRESSION */]: `v-show is missing expression.`
            };
            transformVHtml = (dir, node, context) => {
                const { exp, loc } = dir;
                if (!exp) {
                    context.onError(createDOMCompilerError(55 /* X_V_HTML_NO_EXPRESSION */, loc));
                }
                if (node.children.length) {
                    context.onError(createDOMCompilerError(56 /* X_V_HTML_WITH_CHILDREN */, loc));
                    node.children.length = 0;
                }
                return {
                    props: [
                        createObjectProperty(createSimpleExpression(`innerHTML`, true, loc), exp || createSimpleExpression('', true))
                    ],
                    needRuntime: false
                };
            };
            transformVText = (dir, node, context) => {
                const { exp, loc } = dir;
                if (!exp) {
                    context.onError(createDOMCompilerError(57 /* X_V_TEXT_NO_EXPRESSION */, loc));
                }
                if (node.children.length) {
                    context.onError(createDOMCompilerError(58 /* X_V_TEXT_WITH_CHILDREN */, loc));
                    node.children.length = 0;
                }
                return {
                    props: [
                        createObjectProperty(createSimpleExpression(`textContent`, true, loc), exp || createSimpleExpression('', true))
                    ],
                    needRuntime: false
                };
            };
            V_MODEL_RADIO = Symbol(`vModelRadio`);
            V_MODEL_CHECKBOX = Symbol(`vModelCheckbox`);
            V_MODEL_TEXT = Symbol(`vModelText`);
            V_MODEL_SELECT = Symbol(`vModelSelect`);
            V_MODEL_DYNAMIC = Symbol(`vModelDynamic`);
            V_ON_WITH_MODIFIERS = Symbol(`vOnModifiersGuard`);
            V_ON_WITH_KEYS = Symbol(`vOnKeysGuard`);
            V_SHOW = Symbol(`vShow`);
            TRANSITION = Symbol(`Transition`);
            TRANSITION_GROUP = Symbol(`TransitionGroup`);
            registerRuntimeHelpers({
                [V_MODEL_RADIO]: `vModelRadio`,
                [V_MODEL_CHECKBOX]: `vModelCheckbox`,
                [V_MODEL_TEXT]: `vModelText`,
                [V_MODEL_SELECT]: `vModelSelect`,
                [V_MODEL_DYNAMIC]: `vModelDynamic`,
                [V_ON_WITH_MODIFIERS]: `withModifiers`,
                [V_ON_WITH_KEYS]: `withKeys`,
                [V_SHOW]: `vShow`,
                [TRANSITION]: `Transition`,
                [TRANSITION_GROUP]: `TransitionGroup`
            });
            transformModel$1 = (dir, node, context) => {
                const baseResult = transformModel(dir, node, context);
                // base transform has errors
                if (!baseResult.props.length) {
                    return baseResult;
                }
                const { tag, tagType } = node;
                if (tagType === 0 /* ELEMENT */) {
                    if (dir.arg) {
                        context.onError(createDOMCompilerError(60 /* X_V_MODEL_ARG_ON_ELEMENT */, dir.arg.loc));
                    }
                    if (tag === 'input' || tag === 'textarea' || tag === 'select') {
                        let directiveToUse = V_MODEL_TEXT;
                        let isInvalidType = false;
                        if (tag === 'input') {
                            const type = findProp(node, `type`);
                            if (type) {
                                if (type.type === 7 /* DIRECTIVE */) {
                                    // :type="foo"
                                    directiveToUse = V_MODEL_DYNAMIC;
                                }
                                else if (type.value) {
                                    switch (type.value.content) {
                                        case 'radio':
                                            directiveToUse = V_MODEL_RADIO;
                                            break;
                                        case 'checkbox':
                                            directiveToUse = V_MODEL_CHECKBOX;
                                            break;
                                        case 'file':
                                            isInvalidType = true;
                                            context.onError(createDOMCompilerError(61 /* X_V_MODEL_ON_FILE_INPUT_ELEMENT */, dir.loc));
                                            break;
                                    }
                                }
                            }
                        }
                        else if (tag === 'select') {
                            directiveToUse = V_MODEL_SELECT;
                        }
                        // inject runtime directive
                        // by returning the helper symbol via needRuntime
                        // the import will replaced a resolveDirective call.
                        if (!isInvalidType) {
                            baseResult.needRuntime = context.helper(directiveToUse);
                        }
                    }
                    else {
                        context.onError(createDOMCompilerError(59 /* X_V_MODEL_ON_INVALID_ELEMENT */, dir.loc));
                    }
                }
                return baseResult;
            };
            isEventOptionModifier = makeMap(`passive,once,capture`);
            isNonKeyModifier = makeMap(
            // event propagation management
            `stop,prevent,self,` +
                // system modifiers + exact
                `ctrl,shift,alt,meta,exact,` +
                // mouse
                `left,middle,right`);
            isKeyboardEvent = makeMap(`onkeyup,onkeydown,onkeypress`, true);
            generateModifiers = (modifiers) => {
                const keyModifiers = [];
                const nonKeyModifiers = [];
                const eventOptionModifiers = [];
                for (let i = 0; i < modifiers.length; i++) {
                    const modifier = modifiers[i];
                    if (isEventOptionModifier(modifier)) {
                        // eventOptionModifiers: modifiers for addEventListener() options, e.g. .passive & .capture
                        eventOptionModifiers.push(modifier);
                    }
                    else {
                        // runtimeModifiers: modifiers that needs runtime guards
                        if (isNonKeyModifier(modifier)) {
                            nonKeyModifiers.push(modifier);
                        }
                        else {
                            keyModifiers.push(modifier);
                        }
                    }
                }
                return {
                    keyModifiers,
                    nonKeyModifiers,
                    eventOptionModifiers
                };
            };
            transformOn$1 = (dir, node, context) => {
                return transformOn(dir, node, context, baseResult => {
                    const { modifiers } = dir;
                    if (!modifiers.length)
                        return baseResult;
                    let { key, value: handlerExp } = baseResult.props[0];
                    const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = generateModifiers(modifiers);
                    if (nonKeyModifiers.length) {
                        handlerExp = createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [
                            handlerExp,
                            JSON.stringify(nonKeyModifiers)
                        ]);
                    }
                    if (keyModifiers.length &&
                        // if event name is dynamic, always wrap with keys guard
                        (key.type === 8 /* COMPOUND_EXPRESSION */ ||
                            !key.isStatic ||
                            isKeyboardEvent(key.content))) {
                        handlerExp = createCallExpression(context.helper(V_ON_WITH_KEYS), [
                            handlerExp,
                            JSON.stringify(keyModifiers)
                        ]);
                    }
                    if (eventOptionModifiers.length) {
                        handlerExp = createObjectExpression([
                            createObjectProperty('handler', handlerExp),
                            createObjectProperty('options', createObjectExpression(eventOptionModifiers.map(modifier => createObjectProperty(modifier, createSimpleExpression('true', false)))))
                        ]);
                    }
                    return {
                        props: [createObjectProperty(key, handlerExp)],
                        needRuntime: false
                    };
                });
            };
            transformShow = (dir, node, context) => {
                const { exp, loc } = dir;
                if (!exp) {
                    context.onError(createDOMCompilerError(62 /* X_V_SHOW_NO_EXPRESSION */, loc));
                }
                return {
                    props: [],
                    needRuntime: context.helper(V_SHOW)
                };
            };
            parserOptions = parserOptionsMinimal;
            targetMap = new WeakMap();
            effectStack = [];
            ITERATE_KEY = Symbol('iterate');
            shouldTrack = true;
            // global immutability lock
            LOCKED = true;
            builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol)
                .map(key => Symbol[key])
                .filter(isSymbol));
            get = createGetter();
            readonlyGet = createGetter(true);
            shallowReadonlyGet = createGetter(true, true);
            arrayIdentityInstrumentations = {};
            ['includes', 'indexOf', 'lastIndexOf'].forEach(key => {
                arrayIdentityInstrumentations[key] = function (value, ...args) {
                    return toRaw(this)[key](toRaw(value), ...args);
                };
            });
            set = createSetter();
            readonlySet = createSetter(true);
            shallowReadonlySet = createSetter(true, true);
            mutableHandlers = {
                get,
                set,
                deleteProperty,
                has,
                ownKeys
            };
            readonlyHandlers = {
                get: readonlyGet,
                set: readonlySet,
                has,
                ownKeys,
                deleteProperty(target, key) {
                    if (LOCKED) {
                        {
                            console.warn(`Delete operation on key "${String(key)}" failed: target is readonly.`, target);
                        }
                        return true;
                    }
                    else {
                        return deleteProperty(target, key);
                    }
                }
            };
            // Props handlers are special in the sense that it should not unwrap top-level
            // refs (in order to allow refs to be explicitly passed down), but should
            // retain the reactivity of the normal readonly object.
            shallowReadonlyHandlers = {
                ...readonlyHandlers,
                get: shallowReadonlyGet,
                set: shallowReadonlySet
            };
            toReactive = (value) => isObject(value) ? reactive(value) : value;
            toReadonly = (value) => isObject(value) ? readonly(value) : value;
            getProto = (v) => Reflect.getPrototypeOf(v);
            mutableInstrumentations = {
                get(key) {
                    return get$1(this, key, toReactive);
                },
                get size() {
                    return size(this);
                },
                has: has$1,
                add,
                set: set$1,
                delete: deleteEntry,
                clear,
                forEach: createForEach(false)
            };
            readonlyInstrumentations = {
                get(key) {
                    return get$1(this, key, toReadonly);
                },
                get size() {
                    return size(this);
                },
                has: has$1,
                add: createReadonlyMethod(add, "add" /* ADD */),
                set: createReadonlyMethod(set$1, "set" /* SET */),
                delete: createReadonlyMethod(deleteEntry, "delete" /* DELETE */),
                clear: createReadonlyMethod(clear, "clear" /* CLEAR */),
                forEach: createForEach(true)
            };
            iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator];
            iteratorMethods.forEach(method => {
                mutableInstrumentations[method] = createIterableMethod(method, false);
                readonlyInstrumentations[method] = createIterableMethod(method, true);
            });
            mutableCollectionHandlers = {
                get: createInstrumentationGetter(mutableInstrumentations)
            };
            readonlyCollectionHandlers = {
                get: createInstrumentationGetter(readonlyInstrumentations)
            };
            // WeakMaps that store {raw <-> observed} pairs.
            rawToReactive = new WeakMap();
            reactiveToRaw = new WeakMap();
            rawToReadonly = new WeakMap();
            readonlyToRaw = new WeakMap();
            // WeakSets for values that are marked readonly or non-reactive during
            // observable creation.
            readonlyValues = new WeakSet();
            nonReactiveValues = new WeakSet();
            collectionTypes = new Set([Set, Map, WeakMap, WeakSet]);
            isObservableType = makeMap('Object,Array,Map,Set,WeakMap,WeakSet');
            canObserve = (value) => {
                return (!value._isVue &&
                    !value._isVNode &&
                    isObservableType(toRawType(value)) &&
                    !nonReactiveValues.has(value));
            };
            convert = (val) => isObject(val) ? reactive(val) : val;
            ErrorTypeStrings = {
                ["bc" /* BEFORE_CREATE */]: 'beforeCreate hook',
                ["c" /* CREATED */]: 'created hook',
                ["bm" /* BEFORE_MOUNT */]: 'beforeMount hook',
                ["m" /* MOUNTED */]: 'mounted hook',
                ["bu" /* BEFORE_UPDATE */]: 'beforeUpdate hook',
                ["u" /* UPDATED */]: 'updated',
                ["bum" /* BEFORE_UNMOUNT */]: 'beforeUnmount hook',
                ["um" /* UNMOUNTED */]: 'unmounted hook',
                ["a" /* ACTIVATED */]: 'activated hook',
                ["da" /* DEACTIVATED */]: 'deactivated hook',
                ["ec" /* ERROR_CAPTURED */]: 'errorCaptured hook',
                ["rtc" /* RENDER_TRACKED */]: 'renderTracked hook',
                ["rtg" /* RENDER_TRIGGERED */]: 'renderTriggered hook',
                [0 /* SETUP_FUNCTION */]: 'setup function',
                [1 /* RENDER_FUNCTION */]: 'render function',
                [2 /* WATCH_GETTER */]: 'watcher getter',
                [3 /* WATCH_CALLBACK */]: 'watcher callback',
                [4 /* WATCH_CLEANUP */]: 'watcher cleanup function',
                [5 /* NATIVE_EVENT_HANDLER */]: 'native event handler',
                [6 /* COMPONENT_EVENT_HANDLER */]: 'component event handler',
                [7 /* DIRECTIVE_HOOK */]: 'directive hook',
                [8 /* TRANSITION_HOOK */]: 'transition hook',
                [9 /* APP_ERROR_HANDLER */]: 'app errorHandler',
                [10 /* APP_WARN_HANDLER */]: 'app warnHandler',
                [11 /* FUNCTION_REF */]: 'ref function',
                [12 /* SCHEDULER */]: 'scheduler flush. This is likely a Vue internals bug. ' +
                    'Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/vue-next'
            };
            stack = [];
            classifyRE = /(?:^|[-_])(\w)/g;
            classify = (str) => str.replace(classifyRE, c => c.toUpperCase()).replace(/[-_]/g, '');
            // SFC scoped style ID management.
            // These are only used in esm-bundler builds, but since exports cannot be
            // conditional, we can only drop inner implementations in non-bundler builds.
            currentScopeId = null;
            Fragment = Symbol('Fragment');
            exports_5("Fragment", Fragment);
            Portal = Symbol('Portal');
            exports_5("Portal", Portal);
            Text = Symbol('Text');
            exports_5("Text", Text);
            Comment = Symbol('Comment');
            exports_5("Comment", Comment);
            // Since v-if and v-for are the two possible ways node structure can dynamically
            // change, once we consider v-if branches and each v-for fragment a block, we
            // can divide a template into nested blocks, and within each block the node
            // structure would be stable. This allows us to skip most children diffing
            // and only worry about the dynamic nodes (indicated by patch flags).
            blockStack = [];
            currentBlock = null;
            // Whether we should be tracking dynamic child nodes inside a block.
            // Only tracks when this value is > 0
            // We are not using a simple boolean because this value may need to be
            // incremented/decremented by nested usage of v-once (see below)
            shouldTrack$1 = 1;
            handlersRE = /^on|^vnode/;
            queue = [];
            postFlushCbs = [];
            p = Promise.resolve();
            isFlushing = false;
            isFlushPending = false;
            RECURSION_LIMIT = 100;
            dedupe = (cbs) => [...new Set(cbs)];
            // mark the current rendering instance for asset resolution (e.g.
            // resolveComponent, resolveDirective) during render
            currentRenderingInstance = null;
            // dev only flag to track whether $attrs was used during render.
            // If $attrs was used during render then the warning for failed attrs
            // fallthrough can be suppressed.
            accessedAttrs = false;
            normalizationMap = new WeakMap();
            isSimpleType = makeMap('String,Number,Boolean,Function,Symbol');
            normalizeSlotValue = (value) => isArray(value)
                ? value.map(normalizeVNode)
                : [normalizeVNode(value)];
            normalizeSlot = (key, rawSlot) => (props) => {
                if (currentInstance != null) {
                    warn(`Slot "${key}" invoked outside of the render function: ` +
                        `this will not track dependencies used in the slot. ` +
                        `Invoke the slot function inside the render function instead.`);
                }
                return normalizeSlotValue(rawSlot(props));
            };
            /**
            Runtime helper for applying directives to a vnode. Example usage:
            
            const comp = resolveComponent('comp')
            const foo = resolveDirective('foo')
            const bar = resolveDirective('bar')
            
            return withDirectives(h(comp), [
              [foo, this.x],
              [bar, this.y]
            ])
            */
            isBuiltInDirective = makeMap('bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text');
            directiveToVnodeHooksMap = [
                'beforeMount',
                'mounted',
                'beforeUpdate',
                'updated',
                'beforeUnmount',
                'unmounted'
            ].reduce((map, key) => {
                const vnodeKey = `onVnode` + key[0].toUpperCase() + key.slice(1);
                const vnodeHook = (vnode, prevVnode) => {
                    const bindings = vnode.dirs;
                    const prevBindings = prevVnode ? prevVnode.dirs : EMPTY_ARR;
                    for (let i = 0; i < bindings.length; i++) {
                        const binding = bindings[i];
                        const hook = binding.dir[key];
                        if (hook != null) {
                            if (prevVnode != null) {
                                binding.oldValue = prevBindings[i].value;
                            }
                            hook(vnode.el, binding, vnode, prevVnode);
                        }
                    }
                };
                map[key] = [vnodeKey, vnodeHook];
                return map;
            }, {});
            // Suspense exposes a component-like API, and is treated like a component
            // in the compiler, but internally it's a special built-in type that hooks
            // directly into the renderer.
            SuspenseImpl = {
                // In order to make Suspense tree-shakable, we need to avoid importing it
                // directly in the renderer. The renderer checks for the __isSuspense flag
                // on a vnode's type and calls the `process` method, passing in renderer
                // internals.
                __isSuspense: true,
                process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized, 
                // platform-specific impl passed from renderer
                rendererInternals) {
                    if (n1 == null) {
                        mountSuspense(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized, rendererInternals);
                    }
                    else {
                        patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, optimized, rendererInternals);
                    }
                }
            };
            // Force-casted public typing for h and TSX props inference
            Suspense = (SuspenseImpl);
            exports_5("Suspense", Suspense);
            queuePostRenderEffect = queueEffectWithSuspense;
            BaseTransitionImpl = {
                name: `BaseTransition`,
                setup(props, { slots }) {
                    const instance = getCurrentInstance();
                    const state = useTransitionState();
                    return () => {
                        const children = slots.default && slots.default();
                        if (!children || !children.length) {
                            return;
                        }
                        // warn multiple elements
                        if (children.length > 1) {
                            warn('<transition> can only be used on a single element or component. Use ' +
                                '<transition-group> for lists.');
                        }
                        // there's no need to track reactivity for these props so use the raw
                        // props for a bit better perf
                        const rawProps = toRaw(props);
                        const { mode } = rawProps;
                        // check mode
                        if (mode && !['in-out', 'out-in', 'default'].includes(mode)) {
                            warn(`invalid <transition> mode: ${mode}`);
                        }
                        // at this point children has a guaranteed length of 1.
                        const child = children[0];
                        if (state.isLeaving) {
                            return emptyPlaceholder(child);
                        }
                        // in the case of <transition><keep-alive/></transition>, we need to
                        // compare the type of the kept-alive children.
                        const innerChild = getKeepAliveChild(child);
                        if (!innerChild) {
                            return emptyPlaceholder(child);
                        }
                        const enterHooks = (innerChild.transition = resolveTransitionHooks(innerChild, rawProps, state, instance));
                        const oldChild = instance.subTree;
                        const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
                        // handle mode
                        if (oldInnerChild &&
                            oldInnerChild.type !== Comment &&
                            !isSameVNodeType(innerChild, oldInnerChild)) {
                            const prevHooks = oldInnerChild.transition;
                            const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);
                            // update old tree's hooks in case of dynamic transition
                            setTransitionHooks(oldInnerChild, leavingHooks);
                            // switching between different views
                            if (mode === 'out-in') {
                                state.isLeaving = true;
                                // return placeholder node and queue update when leave finishes
                                leavingHooks.afterLeave = () => {
                                    state.isLeaving = false;
                                    instance.update();
                                };
                                return emptyPlaceholder(child);
                            }
                            else if (mode === 'in-out') {
                                delete prevHooks.delayedLeave;
                                leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
                                    const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);
                                    leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
                                    // early removal callback
                                    el._leaveCb = () => {
                                        earlyRemove();
                                        el._leaveCb = undefined;
                                        delete enterHooks.delayedLeave;
                                    };
                                    enterHooks.delayedLeave = delayedLeave;
                                };
                            }
                        }
                        return child;
                    };
                }
            };
            {
                BaseTransitionImpl.props = {
                    mode: String,
                    appear: Boolean,
                    persisted: Boolean,
                    // enter
                    onBeforeEnter: Function,
                    onEnter: Function,
                    onAfterEnter: Function,
                    onEnterCancelled: Function,
                    // leave
                    onBeforeLeave: Function,
                    onLeave: Function,
                    onAfterLeave: Function,
                    onLeaveCancelled: Function
                };
            }
            // export the public type for h/tsx inference
            // also to avoid inline import() in generated d.ts files
            BaseTransition = BaseTransitionImpl;
            exports_5("BaseTransition", BaseTransition);
            isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
            KeepAliveImpl = {
                name: `KeepAlive`,
                // Marker for special handling inside the renderer. We are not using a ===
                // check directly on KeepAlive in the renderer, because importing it directly
                // would prevent it from being tree-shaken.
                __isKeepAlive: true,
                props: {
                    include: [String, RegExp, Array],
                    exclude: [String, RegExp, Array],
                    max: [String, Number]
                },
                setup(props, { slots }) {
                    const cache = new Map();
                    const keys = new Set();
                    let current = null;
                    const instance = getCurrentInstance();
                    // KeepAlive communicates with the instantiated renderer via the "sink"
                    // where the renderer passes in platform-specific functions, and the
                    // KeepAlive instance exposes activate/deactivate implementations.
                    // The whole point of this is to avoid importing KeepAlive directly in the
                    // renderer to facilitate tree-shaking.
                    const sink = instance.sink;
                    const { renderer: { move, unmount: _unmount, options: { createElement } }, parentSuspense } = sink;
                    const storageContainer = createElement('div');
                    sink.activate = (vnode, container, anchor) => {
                        move(vnode, container, anchor, 0 /* ENTER */, parentSuspense);
                        queuePostRenderEffect(() => {
                            const component = vnode.component;
                            component.isDeactivated = false;
                            if (component.a !== null) {
                                invokeHooks(component.a);
                            }
                        }, parentSuspense);
                    };
                    sink.deactivate = (vnode) => {
                        move(vnode, storageContainer, null, 1 /* LEAVE */, parentSuspense);
                        queuePostRenderEffect(() => {
                            const component = vnode.component;
                            if (component.da !== null) {
                                invokeHooks(component.da);
                            }
                            component.isDeactivated = true;
                        }, parentSuspense);
                    };
                    function unmount(vnode) {
                        // reset the shapeFlag so it can be properly unmounted
                        vnode.shapeFlag = 4 /* STATEFUL_COMPONENT */;
                        _unmount(vnode, instance, parentSuspense);
                    }
                    function pruneCache(filter) {
                        cache.forEach((vnode, key) => {
                            const name = getName(vnode.type);
                            if (name && (!filter || !filter(name))) {
                                pruneCacheEntry(key);
                            }
                        });
                    }
                    function pruneCacheEntry(key) {
                        const cached = cache.get(key);
                        if (!current || cached.type !== current.type) {
                            unmount(cached);
                        }
                        else if (current) {
                            // current active instance should no longer be kept-alive.
                            // we can't unmount it now but it might be later, so reset its flag now.
                            current.shapeFlag = 4 /* STATEFUL_COMPONENT */;
                        }
                        cache.delete(key);
                        keys.delete(key);
                    }
                    watch(() => [props.include, props.exclude], ([include, exclude]) => {
                        include && pruneCache(name => matches(include, name));
                        exclude && pruneCache(name => matches(exclude, name));
                    }, { lazy: true });
                    onBeforeUnmount(() => {
                        cache.forEach(unmount);
                    });
                    return () => {
                        if (!slots.default) {
                            return null;
                        }
                        const children = slots.default();
                        let vnode = children[0];
                        if (children.length > 1) {
                            {
                                warn(`KeepAlive should contain exactly one component child.`);
                            }
                            current = null;
                            return children;
                        }
                        else if (!isVNode(vnode) ||
                            !(vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */)) {
                            current = null;
                            return vnode;
                        }
                        const comp = vnode.type;
                        const name = getName(comp);
                        const { include, exclude, max } = props;
                        if ((include && (!name || !matches(include, name))) ||
                            (exclude && name && matches(exclude, name))) {
                            return vnode;
                        }
                        const key = vnode.key == null ? comp : vnode.key;
                        const cached = cache.get(key);
                        // clone vnode if it's reused because we are going to mutate it
                        if (vnode.el) {
                            vnode = cloneVNode(vnode);
                        }
                        cache.set(key, vnode);
                        if (cached) {
                            // copy over mounted state
                            vnode.el = cached.el;
                            vnode.anchor = cached.anchor;
                            vnode.component = cached.component;
                            if (vnode.transition) {
                                // recursively update transition hooks on subTree
                                setTransitionHooks(vnode, vnode.transition);
                            }
                            // avoid vnode being mounted as fresh
                            vnode.shapeFlag |= 256 /* COMPONENT_KEPT_ALIVE */;
                            // make this key the freshest
                            keys.delete(key);
                            keys.add(key);
                        }
                        else {
                            keys.add(key);
                            // prune oldest entry
                            if (max && keys.size > parseInt(max, 10)) {
                                pruneCacheEntry(Array.from(keys)[0]);
                            }
                        }
                        // avoid vnode being unmounted
                        vnode.shapeFlag |= 128 /* COMPONENT_SHOULD_KEEP_ALIVE */;
                        current = vnode;
                        return vnode;
                    };
                }
            };
            // export the public type for h/tsx inference
            // also to avoid inline import() in generated d.ts files
            KeepAlive = KeepAliveImpl;
            exports_5("KeepAlive", KeepAlive);
            createHook = (lifecycle) => (hook, target = currentInstance) => 
            // post-create lifecycle registrations are noops during SSR
            injectHook(lifecycle, hook, target);
            exports_5("createHook", createHook);
            onBeforeMount = createHook("bm" /* BEFORE_MOUNT */);
            exports_5("onBeforeMount", onBeforeMount);
            onMounted = createHook("m" /* MOUNTED */);
            exports_5("onMounted", onMounted);
            onBeforeUpdate = createHook("bu" /* BEFORE_UPDATE */);
            exports_5("onBeforeUpdate", onBeforeUpdate);
            onUpdated = createHook("u" /* UPDATED */);
            exports_5("onUpdated", onUpdated);
            onBeforeUnmount = createHook("bum" /* BEFORE_UNMOUNT */);
            exports_5("onBeforeUnmount", onBeforeUnmount);
            onUnmounted = createHook("um" /* UNMOUNTED */);
            exports_5("onUnmounted", onUnmounted);
            onRenderTriggered = createHook("rtg" /* RENDER_TRIGGERED */);
            exports_5("onRenderTriggered", onRenderTriggered);
            onRenderTracked = createHook("rtc" /* RENDER_TRACKED */);
            exports_5("onRenderTracked", onRenderTracked);
            onErrorCaptured = (hook, target = currentInstance) => {
                injectHook("ec" /* ERROR_CAPTURED */, hook, target);
            };
            exports_5("onErrorCaptured", onErrorCaptured);
            invoke = (fn) => fn();
            publicPropertiesMap = {
                $: i => i,
                $el: i => i.vnode.el,
                $cache: i => i.renderCache || (i.renderCache = []),
                $data: i => i.data,
                $props: i => i.propsProxy,
                $attrs: i => i.attrs,
                $slots: i => i.slots,
                $refs: i => i.refs,
                $parent: i => i.parent,
                $root: i => i.root,
                $emit: i => i.emit,
                $options: i => i.type,
                $forceUpdate: i => () => queueJob(i.update),
                $nextTick: () => nextTick,
                $watch: i => instanceWatch.bind(i)
            };
            unwrapRef = (val) => (isRef(val) ? val.value : val);
            PublicInstanceProxyHandlers = {
                get(target, key) {
                    // fast path for unscopables when using `with` block
                    if (key === Symbol.unscopables) {
                        return;
                    }
                    const { renderContext, data, props, propsProxy, accessCache, type, sink } = target;
                    // data / props / renderContext
                    // This getter gets called for every property access on the render context
                    // during render and is a major hotspot. The most expensive part of this
                    // is the multiple hasOwn() calls. It's much faster to do a simple property
                    // access on a plain object, so we use an accessCache object (with null
                    // prototype) to memoize what access type a key corresponds to.
                    if (key[0] !== '$') {
                        const n = accessCache[key];
                        if (n !== undefined) {
                            switch (n) {
                                case 0 /* DATA */:
                                    return data[key];
                                case 1 /* CONTEXT */:
                                    return unwrapRef(renderContext[key]);
                                case 2 /* PROPS */:
                                    return propsProxy[key];
                                // default: just fallthrough
                            }
                        }
                        else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
                            accessCache[key] = 0 /* DATA */;
                            return data[key];
                        }
                        else if (hasOwn(renderContext, key)) {
                            accessCache[key] = 1 /* CONTEXT */;
                            return unwrapRef(renderContext[key]);
                        }
                        else if (type.props != null) {
                            // only cache other properties when instance has declared (this stable)
                            // props
                            if (hasOwn(props, key)) {
                                accessCache[key] = 2 /* PROPS */;
                                // return the value from propsProxy for ref unwrapping and readonly
                                return propsProxy[key];
                            }
                            else {
                                accessCache[key] = 3 /* OTHER */;
                            }
                        }
                    }
                    // public $xxx properties & user-attached properties (sink)
                    const publicGetter = publicPropertiesMap[key];
                    if (publicGetter != null) {
                        if (key === '$attrs') {
                            markAttrsAccessed();
                        }
                        return publicGetter(target);
                    }
                    else if (hasOwn(sink, key)) {
                        return sink[key];
                    }
                    else if (currentRenderingInstance != null) {
                        warn(`Property ${JSON.stringify(key)} was accessed during render ` +
                            `but is not defined on instance.`);
                    }
                },
                has(target, key) {
                    const { data, accessCache, renderContext, type, sink } = target;
                    return (accessCache[key] !== undefined ||
                        (data !== EMPTY_OBJ && hasOwn(data, key)) ||
                        hasOwn(renderContext, key) ||
                        (type.props != null && hasOwn(type.props, key)) ||
                        hasOwn(publicPropertiesMap, key) ||
                        hasOwn(sink, key));
                },
                set(target, key, value) {
                    const { data, renderContext } = target;
                    if (data !== EMPTY_OBJ && hasOwn(data, key)) {
                        data[key] = value;
                    }
                    else if (hasOwn(renderContext, key)) {
                        const oldValue = renderContext[key];
                        value = toRaw(value);
                        if (isRef(oldValue) && !isRef(value)) {
                            oldValue.value = value;
                        }
                        else {
                            renderContext[key] = value;
                        }
                    }
                    else if (key[0] === '$' && key.slice(1) in target) {
                        warn(`Attempting to mutate public property "${key}". ` +
                            `Properties starting with $ are reserved and readonly.`, target);
                        return false;
                    }
                    else if (key in target.props) {
                        warn(`Attempting to mutate prop "${key}". Props are readonly.`, target);
                        return false;
                    }
                    else {
                        target.sink[key] = value;
                    }
                    return true;
                }
            };
            runtimeCompiledRenderProxyHandlers = {
                ...PublicInstanceProxyHandlers,
                has(_target, key) {
                    return key[0] !== '_' && !isGloballyWhitelisted(key);
                }
            };
            emptyAppContext = createAppContext();
            currentInstance = null;
            currentSuspense = null;
            getCurrentInstance = () => currentInstance || currentRenderingInstance;
            exports_5("getCurrentInstance", getCurrentInstance);
            setCurrentInstance = (instance) => {
                currentInstance = instance;
            };
            isBuiltInTag = makeMap('slot,component');
            // used to identify a setup context proxy
            SetupProxySymbol = Symbol();
            SetupProxyHandlers = {};
            ['attrs', 'slots'].forEach((type) => {
                SetupProxyHandlers[type] = {
                    get: (instance, key) => {
                        {
                            markAttrsAccessed();
                        }
                        return instance[type][key];
                    },
                    has: (instance, key) => key === SetupProxySymbol || key in instance[type],
                    ownKeys: instance => Reflect.ownKeys(instance[type]),
                    // this is necessary for ownKeys to work properly
                    getOwnPropertyDescriptor: (instance, key) => Reflect.getOwnPropertyDescriptor(instance[type], key),
                    set: () => false,
                    deleteProperty: () => false
                };
            });
            // For runtime consumption
            PublicShapeFlags = {
                ELEMENT: 1 /* ELEMENT */,
                FUNCTIONAL_COMPONENT: 2 /* FUNCTIONAL_COMPONENT */,
                STATEFUL_COMPONENT: 4 /* STATEFUL_COMPONENT */,
                TEXT_CHILDREN: 8 /* TEXT_CHILDREN */,
                ARRAY_CHILDREN: 16 /* ARRAY_CHILDREN */,
                SLOTS_CHILDREN: 32 /* SLOTS_CHILDREN */,
                SUSPENSE: 64 /* SUSPENSE */,
                COMPONENT_SHOULD_KEEP_ALIVE: 128 /* COMPONENT_SHOULD_KEEP_ALIVE */,
                COMPONENT_KEPT_ALIVE: 256 /* COMPONENT_KEPT_ALIVE */,
                COMPONENT: 6 /* COMPONENT */
            };
            exports_5("ShapeFlags", PublicShapeFlags);
            COMPONENTS = 'components';
            DIRECTIVES = 'directives';
            // Public API ------------------------------------------------------------------
            version = "3.0.0-alpha.4";
            exports_5("version", version);
            PatchFlags = PublicPatchFlags;
            exports_5("PatchFlags", PatchFlags);
            toDisplayString$1 = toDisplayString;
            exports_5("toDisplayString", toDisplayString$1);
            capitalize$1 = capitalize;
            exports_5("capitalize", capitalize$1);
            camelize$1 = camelize;
            exports_5("camelize", camelize$1);
            doc = (typeof document !== 'undefined' ? document : null);
            svgNS = 'http://www.w3.org/2000/svg';
            nodeOps = {
                insert: (child, parent, anchor) => {
                    if (anchor != null) {
                        parent.insertBefore(child, anchor);
                    }
                    else {
                        parent.appendChild(child);
                    }
                },
                remove: (child) => {
                    const parent = child.parentNode;
                    if (parent != null) {
                        parent.removeChild(child);
                    }
                },
                createElement: (tag, isSVG) => isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag),
                createText: (text) => doc.createTextNode(text),
                createComment: (text) => doc.createComment(text),
                setText: (node, text) => {
                    node.nodeValue = text;
                },
                setElementText: (el, text) => {
                    el.textContent = text;
                },
                parentNode: (node) => node.parentNode,
                nextSibling: (node) => node.nextSibling,
                querySelector: (selector) => doc.querySelector(selector),
                setScopeId(el, id) {
                    el.setAttribute(id, '');
                }
            };
            importantRE = /\s*!important$/;
            prefixes = ['Webkit', 'Moz', 'ms'];
            prefixCache = {};
            // Async edge case fix requires storing an event listener's attach timestamp.
            _getNow = Date.now;
            // Determine what event timestamp the browser is using. Annoyingly, the
            // timestamp can either be hi-res ( relative to page load) or low-res
            // (relative to UNIX epoch), so in order to compare time we have to use the
            // same timestamp type when saving the flush timestamp.
            if (typeof document !== 'undefined' &&
                _getNow() > document.createEvent('Event').timeStamp) {
                // if the low-res timestamp which is bigger than the event timestamp
                // (which is evaluated AFTER) it means the event is using a hi-res timestamp,
                // and we need to use the hi-res version for event listeners as well.
                _getNow = () => performance.now();
            }
            // To avoid the overhead of repeatedly calling performance.now(), we cache
            // and use the same timestamp for all event listeners attached in the same tick.
            cachedNow = 0;
            p$1 = Promise.resolve();
            reset = () => {
                cachedNow = 0;
            };
            getNow = () => cachedNow || (p$1.then(reset), (cachedNow = _getNow()));
            getModelAssigner = (vnode) => vnode.props['onUpdate:modelValue'];
            // We are exporting the v-model runtime directly as vnode hooks so that it can
            // be tree-shaken in case v-model is never used.
            vModelText = {
                beforeMount(el, { value, modifiers: { lazy, trim, number } }, vnode) {
                    el.value = value;
                    const assign = getModelAssigner(vnode);
                    const castToNumber = number || el.type === 'number';
                    addEventListener(el, lazy ? 'change' : 'input', () => {
                        let domValue = el.value;
                        if (trim) {
                            domValue = domValue.trim();
                        }
                        else if (castToNumber) {
                            domValue = toNumber(domValue);
                        }
                        assign(domValue);
                    });
                    if (trim) {
                        addEventListener(el, 'change', () => {
                            el.value = el.value.trim();
                        });
                    }
                    if (!lazy) {
                        addEventListener(el, 'compositionstart', onCompositionStart);
                        addEventListener(el, 'compositionend', onCompositionEnd);
                        // Safari < 10.2 & UIWebView doesn't fire compositionend when
                        // switching focus before confirming composition choice
                        // this also fixes the issue where some browsers e.g. iOS Chrome
                        // fires "change" instead of "input" on autocomplete.
                        addEventListener(el, 'change', onCompositionEnd);
                    }
                },
                beforeUpdate(el, { value, oldValue, modifiers: { trim, number } }) {
                    if (value === oldValue) {
                        return;
                    }
                    if (document.activeElement === el) {
                        if (trim && el.value.trim() === value) {
                            return;
                        }
                        if ((number || el.type === 'number') && toNumber(el.value) === value) {
                            return;
                        }
                    }
                    el.value = value;
                }
            };
            exports_5("vModelText", vModelText);
            vModelCheckbox = {
                beforeMount(el, binding, vnode) {
                    setChecked(el, binding, vnode);
                    const assign = getModelAssigner(vnode);
                    addEventListener(el, 'change', () => {
                        const modelValue = el._modelValue;
                        const elementValue = getValue(el);
                        const checked = el.checked;
                        if (isArray(modelValue)) {
                            const index = looseIndexOf(modelValue, elementValue);
                            const found = index !== -1;
                            if (checked && !found) {
                                assign(modelValue.concat(elementValue));
                            }
                            else if (!checked && found) {
                                const filtered = [...modelValue];
                                filtered.splice(index, 1);
                                assign(filtered);
                            }
                        }
                        else {
                            assign(getCheckboxValue(el, checked));
                        }
                    });
                },
                beforeUpdate: setChecked
            };
            exports_5("vModelCheckbox", vModelCheckbox);
            vModelRadio = {
                beforeMount(el, { value }, vnode) {
                    el.checked = looseEqual(value, vnode.props.value);
                    const assign = getModelAssigner(vnode);
                    addEventListener(el, 'change', () => {
                        assign(getValue(el));
                    });
                },
                beforeUpdate(el, { value, oldValue }, vnode) {
                    if (value !== oldValue) {
                        el.checked = looseEqual(value, vnode.props.value);
                    }
                }
            };
            exports_5("vModelRadio", vModelRadio);
            vModelSelect = {
                // use mounted & updated because <select> relies on its children <option>s.
                mounted(el, { value }, vnode) {
                    setSelected(el, value);
                    const assign = getModelAssigner(vnode);
                    addEventListener(el, 'change', () => {
                        const selectedVal = Array.prototype.filter
                            .call(el.options, (o) => o.selected)
                            .map(getValue);
                        assign(el.multiple ? selectedVal : selectedVal[0]);
                    });
                },
                updated(el, { value }) {
                    setSelected(el, value);
                }
            };
            exports_5("vModelSelect", vModelSelect);
            vModelDynamic = {
                beforeMount(el, binding, vnode) {
                    callModelHook(el, binding, vnode, null, 'beforeMount');
                },
                mounted(el, binding, vnode) {
                    callModelHook(el, binding, vnode, null, 'mounted');
                },
                beforeUpdate(el, binding, vnode, prevVNode) {
                    callModelHook(el, binding, vnode, prevVNode, 'beforeUpdate');
                },
                updated(el, binding, vnode, prevVNode) {
                    callModelHook(el, binding, vnode, prevVNode, 'updated');
                }
            };
            exports_5("vModelDynamic", vModelDynamic);
            systemModifiers = ['ctrl', 'shift', 'alt', 'meta'];
            modifierGuards = {
                stop: e => e.stopPropagation(),
                prevent: e => e.preventDefault(),
                self: e => e.target !== e.currentTarget,
                ctrl: e => !e.ctrlKey,
                shift: e => !e.shiftKey,
                alt: e => !e.altKey,
                meta: e => !e.metaKey,
                left: e => 'button' in e && e.button !== 0,
                middle: e => 'button' in e && e.button !== 1,
                right: e => 'button' in e && e.button !== 2,
                exact: (e, modifiers) => systemModifiers.some(m => e[`${m}Key`] && !modifiers.includes(m))
            };
            withModifiers = (fn, modifiers) => {
                return (event) => {
                    for (let i = 0; i < modifiers.length; i++) {
                        const guard = modifierGuards[modifiers[i]];
                        if (guard && guard(event, modifiers))
                            return;
                    }
                    return fn(event);
                };
            };
            exports_5("withModifiers", withModifiers);
            // Kept for 2.x compat.
            // Note: IE11 compat for `spacebar` and `del` is removed for now.
            keyNames = {
                esc: 'escape',
                space: ' ',
                up: 'arrow-up',
                left: 'arrow-left',
                right: 'arrow-right',
                down: 'arrow-down',
                delete: 'backspace'
            };
            withKeys = (fn, modifiers) => {
                return (event) => {
                    if (!('key' in event))
                        return;
                    const eventKey = hyphenate(event.key);
                    if (
                    // None of the provided key modifiers match the current event key
                    !modifiers.some(k => k === eventKey || keyNames[k] === eventKey)) {
                        return;
                    }
                    return fn(event);
                };
            };
            exports_5("withKeys", withKeys);
            vShow = {
                beforeMount(el, { value }, { transition }) {
                    el._vod = el.style.display === 'none' ? '' : el.style.display;
                    if (transition && value) {
                        transition.beforeEnter(el);
                    }
                    else {
                        setDisplay(el, value);
                    }
                },
                mounted(el, { value }, { transition }) {
                    if (transition && value) {
                        transition.enter(el);
                    }
                },
                updated(el, { value, oldValue }, { transition }) {
                    if (!value === !oldValue)
                        return;
                    if (transition) {
                        if (value) {
                            transition.beforeEnter(el);
                            setDisplay(el, true);
                            transition.enter(el);
                        }
                        else {
                            transition.leave(el, () => {
                                setDisplay(el, false);
                            });
                        }
                    }
                    else {
                        setDisplay(el, value);
                    }
                },
                beforeUnmount(el) {
                    setDisplay(el, true);
                }
            };
            exports_5("vShow", vShow);
            TRANSITION$1 = 'transition';
            ANIMATION = 'animation';
            // DOM Transition is a higher-order-component based on the platform-agnostic
            // base Transition component, with DOM-specific logic.
            Transition = (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots);
            exports_5("Transition", Transition);
            TransitionPropsValidators = {
                ...BaseTransition.props,
                name: String,
                type: String,
                css: {
                    type: Boolean,
                    default: true
                },
                duration: Object,
                enterFromClass: String,
                enterActiveClass: String,
                enterToClass: String,
                appearFromClass: String,
                appearActiveClass: String,
                appearToClass: String,
                leaveFromClass: String,
                leaveActiveClass: String,
                leaveToClass: String
            };
            {
                Transition.props = TransitionPropsValidators;
            }
            positionMap = new WeakMap();
            newPositionMap = new WeakMap();
            TransitionGroupImpl = {
                setup(props, { slots }) {
                    const instance = getCurrentInstance();
                    const state = useTransitionState();
                    let prevChildren;
                    let children;
                    let hasMove = null;
                    onUpdated(() => {
                        // children is guaranteed to exist after initial render
                        if (!prevChildren.length) {
                            return;
                        }
                        const moveClass = props.moveClass || `${props.name || 'v'}-move`;
                        // Check if move transition is needed. This check is cached per-instance.
                        hasMove =
                            hasMove === null
                                ? (hasMove = hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass))
                                : hasMove;
                        if (!hasMove) {
                            return;
                        }
                        // we divide the work into three loops to avoid mixing DOM reads and writes
                        // in each iteration - which helps prevent layout thrashing.
                        prevChildren.forEach(callPendingCbs);
                        prevChildren.forEach(recordPosition);
                        const movedChildren = prevChildren.filter(applyTranslation);
                        // force reflow to put everything in position
                        forceReflow();
                        movedChildren.forEach(c => {
                            const el = c.el;
                            const style = el.style;
                            addTransitionClass(el, moveClass);
                            style.transform = style.WebkitTransform = style.transitionDuration = '';
                            const cb = (el._moveCb = (e) => {
                                if (e && e.target !== el) {
                                    return;
                                }
                                if (!e || /transform$/.test(e.propertyName)) {
                                    el.removeEventListener('transitionend', cb);
                                    el._moveCb = null;
                                    removeTransitionClass(el, moveClass);
                                }
                            });
                            el.addEventListener('transitionend', cb);
                        });
                    });
                    return () => {
                        const rawProps = toRaw(props);
                        const cssTransitionProps = resolveTransitionProps(rawProps);
                        const tag = rawProps.tag || Fragment;
                        prevChildren = children;
                        children = slots.default ? slots.default() : [];
                        // handle fragment children case, e.g. v-for
                        if (children.length === 1 && children[0].type === Fragment) {
                            children = children[0].children;
                        }
                        for (let i = 0; i < children.length; i++) {
                            const child = children[i];
                            if (child.key != null) {
                                setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance));
                            }
                            else {
                                warn(`<TransitionGroup> children must be keyed.`);
                            }
                        }
                        if (prevChildren) {
                            for (let i = 0; i < prevChildren.length; i++) {
                                const child = prevChildren[i];
                                setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance));
                                positionMap.set(child, child.el.getBoundingClientRect());
                            }
                        }
                        return createVNode(tag, null, children);
                    };
                }
            };
            TransitionGroup = TransitionGroupImpl;
            exports_5("TransitionGroup", TransitionGroup);
            {
                const props = (TransitionGroup.props = {
                    ...TransitionPropsValidators,
                    tag: String,
                    moveClass: String
                });
                delete props.mode;
            }
            _a = createRenderer({
                patchProp,
                ...nodeOps
            }), baseRender = _a.render, baseCreateApp = _a.createApp;
            // use explicit type casts here to avoid import() calls in rolled-up d.ts
            render = baseRender;
            exports_5("render", render);
            createApp = (...args) => {
                const app = baseCreateApp(...args);
                {
                    // Inject `isNativeTag`
                    // this is used for component name validation (dev only)
                    Object.defineProperty(app.config, 'isNativeTag', {
                        value: (tag) => isHTMLTag(tag) || isSVGTag(tag),
                        writable: false
                    });
                }
                const { mount } = app;
                app.mount = (container) => {
                    if (isString(container)) {
                        container = document.querySelector(container);
                        if (!container) {
                            warn(`Failed to mount app: mount target selector returned null.`);
                            return;
                        }
                    }
                    const component = app._component;
                    if (!isFunction(component) &&
                        !component.render &&
                        !component.template) {
                        component.template = container.innerHTML;
                    }
                    // clear content before mounting
                    container.innerHTML = '';
                    return mount(container);
                };
                return app;
            };
            exports_5("createApp", createApp);
            runtimeDom = Object.freeze({
                __proto__: null,
                render: render,
                createApp: createApp,
                vModelText: vModelText,
                vModelCheckbox: vModelCheckbox,
                vModelRadio: vModelRadio,
                vModelSelect: vModelSelect,
                vModelDynamic: vModelDynamic,
                withModifiers: withModifiers,
                withKeys: withKeys,
                vShow: vShow,
                Transition: Transition,
                TransitionGroup: TransitionGroup,
                version: version,
                PatchFlags: PatchFlags,
                toDisplayString: toDisplayString$1,
                capitalize: capitalize$1,
                camelize: camelize$1,
                nextTick: nextTick,
                defineComponent: defineComponent,
                getCurrentInstance: getCurrentInstance,
                h: h,
                createVNode: createVNode,
                cloneVNode: cloneVNode,
                mergeProps: mergeProps,
                openBlock: openBlock,
                createBlock: createBlock,
                Text: Text,
                Comment: Comment,
                Fragment: Fragment,
                Portal: Portal,
                Suspense: Suspense,
                KeepAlive: KeepAlive,
                BaseTransition: BaseTransition,
                ShapeFlags: PublicShapeFlags,
                useCSSModule: useCSSModule,
                createRenderer: createRenderer,
                warn: warn,
                handleError: handleError,
                callWithErrorHandling: callWithErrorHandling,
                callWithAsyncErrorHandling: callWithAsyncErrorHandling,
                useTransitionState: useTransitionState,
                resolveTransitionHooks: resolveTransitionHooks,
                setTransitionHooks: setTransitionHooks,
                withDirectives: withDirectives,
                resolveComponent: resolveComponent,
                resolveDirective: resolveDirective,
                resolveDynamicComponent: resolveDynamicComponent,
                renderList: renderList,
                toHandlers: toHandlers,
                renderSlot: renderSlot,
                createSlots: createSlots,
                pushScopeId: pushScopeId,
                popScopeId: popScopeId,
                withScopeId: withScopeId,
                setBlockTracking: setBlockTracking,
                createTextVNode: createTextVNode,
                createCommentVNode: createCommentVNode,
                registerRuntimeCompiler: registerRuntimeCompiler,
                createComponentInstance: createComponentInstance,
                setupComponent: setupComponent,
                recordEffect: recordEffect,
                computed: computed$1,
                ref: ref,
                isRef: isRef,
                toRefs: toRefs,
                reactive: reactive,
                isReactive: isReactive,
                readonly: readonly,
                isReadonly: isReadonly,
                toRaw: toRaw,
                markReadonly: markReadonly,
                markNonReactive: markNonReactive,
                effect: effect,
                watch: watch,
                instanceWatch: instanceWatch,
                injectHook: injectHook,
                createHook: createHook,
                onBeforeMount: onBeforeMount,
                onMounted: onMounted,
                onBeforeUpdate: onBeforeUpdate,
                onUpdated: onUpdated,
                onBeforeUnmount: onBeforeUnmount,
                onUnmounted: onUnmounted,
                onRenderTriggered: onRenderTriggered,
                onRenderTracked: onRenderTracked,
                onErrorCaptured: onErrorCaptured,
                onActivated: onActivated,
                onDeactivated: onDeactivated,
                provide: provide,
                inject: inject
            });
            {
                console[console.info ? 'info' : 'log'](`You are running a development build of Vue.\n` +
                    `Make sure to use the production build (*.prod.js) when deploying for production.`);
            }
            // This entry is the "full-build" that includes both the runtime
            compileCache = Object.create(null);
            registerRuntimeCompiler(compileToFunction);
        }
    };
});
System.register("http://localhost:5501/src/deps/vue", ["https://unpkg.com/vue@3.0.0-alpha.4/dist/vue.esm"], function (exports_6, context_6) {
    "use strict";
    var __moduleName = context_6 && context_6.id;
    function exportStar_1(m) {
        var exports = {};
        for (var n in m) {
            if (n !== "default") exports[n] = m[n];
        }
        exports_6(exports);
    }
    return {
        setters: [
            function (vue_esm_js_1_1) {
                exportStar_1(vue_esm_js_1_1);
            }
        ],
        execute: function () {
        }
    };
});
/*
 * anime.js v3.1.0
 * (c) 2019 Julian Garnier
 * Released under the MIT license
 * animejs.com
 */
System.register("https://unpkg.com/animejs@3.1.0/lib/anime.es", [], function (exports_7, context_7) {
    "use strict";
    var defaultInstanceSettings, defaultTweenSettings, validTransforms, cache, is, bezier, penner, setProgressValue, instanceID, activeInstances, pausedInstances, raf, engine;
    var __moduleName = context_7 && context_7.id;
    // Utils
    function minMax(val, min, max) {
        return Math.min(Math.max(val, min), max);
    }
    function stringContains(str, text) {
        return str.indexOf(text) > -1;
    }
    function applyArguments(func, args) {
        return func.apply(null, args);
    }
    // Easings
    function parseEasingParameters(string) {
        var match = /\(([^)]+)\)/.exec(string);
        return match ? match[1].split(',').map(function (p) { return parseFloat(p); }) : [];
    }
    // Spring solver inspired by Webkit Copyright  2016 Apple Inc. All rights reserved. https://webkit.org/demos/spring/spring.js
    function spring(string, duration) {
        var params = parseEasingParameters(string);
        var mass = minMax(is.und(params[0]) ? 1 : params[0], .1, 100);
        var stiffness = minMax(is.und(params[1]) ? 100 : params[1], .1, 100);
        var damping = minMax(is.und(params[2]) ? 10 : params[2], .1, 100);
        var velocity = minMax(is.und(params[3]) ? 0 : params[3], .1, 100);
        var w0 = Math.sqrt(stiffness / mass);
        var zeta = damping / (2 * Math.sqrt(stiffness * mass));
        var wd = zeta < 1 ? w0 * Math.sqrt(1 - zeta * zeta) : 0;
        var a = 1;
        var b = zeta < 1 ? (zeta * w0 + -velocity) / wd : -velocity + w0;
        function solver(t) {
            var progress = duration ? (duration * t) / 1000 : t;
            if (zeta < 1) {
                progress = Math.exp(-progress * zeta * w0) * (a * Math.cos(wd * progress) + b * Math.sin(wd * progress));
            }
            else {
                progress = (a + b * progress) * Math.exp(-progress * w0);
            }
            if (t === 0 || t === 1) {
                return t;
            }
            return 1 - progress;
        }
        function getDuration() {
            var cached = cache.springs[string];
            if (cached) {
                return cached;
            }
            var frame = 1 / 6;
            var elapsed = 0;
            var rest = 0;
            while (true) {
                elapsed += frame;
                if (solver(elapsed) === 1) {
                    rest++;
                    if (rest >= 16) {
                        break;
                    }
                }
                else {
                    rest = 0;
                }
            }
            var duration = elapsed * frame * 1000;
            cache.springs[string] = duration;
            return duration;
        }
        return duration ? solver : getDuration;
    }
    // Basic steps easing implementation https://developer.mozilla.org/fr/docs/Web/CSS/transition-timing-function
    function steps(steps) {
        if (steps === void 0)
            steps = 10;
        return function (t) { return Math.round(t * steps) * (1 / steps); };
    }
    function parseEasings(easing, duration) {
        if (is.fnc(easing)) {
            return easing;
        }
        var name = easing.split('(')[0];
        var ease = penner[name];
        var args = parseEasingParameters(easing);
        switch (name) {
            case 'spring': return spring(easing, duration);
            case 'cubicBezier': return applyArguments(bezier, args);
            case 'steps': return applyArguments(steps, args);
            default: return applyArguments(ease, args);
        }
    }
    // Strings
    function selectString(str) {
        try {
            var nodes = document.querySelectorAll(str);
            return nodes;
        }
        catch (e) {
            return;
        }
    }
    // Arrays
    function filterArray(arr, callback) {
        var len = arr.length;
        var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
        var result = [];
        for (var i = 0; i < len; i++) {
            if (i in arr) {
                var val = arr[i];
                if (callback.call(thisArg, val, i, arr)) {
                    result.push(val);
                }
            }
        }
        return result;
    }
    function flattenArray(arr) {
        return arr.reduce(function (a, b) { return a.concat(is.arr(b) ? flattenArray(b) : b); }, []);
    }
    function toArray(o) {
        if (is.arr(o)) {
            return o;
        }
        if (is.str(o)) {
            o = selectString(o) || o;
        }
        if (o instanceof NodeList || o instanceof HTMLCollection) {
            return [].slice.call(o);
        }
        return [o];
    }
    function arrayContains(arr, val) {
        return arr.some(function (a) { return a === val; });
    }
    // Objects
    function cloneObject(o) {
        var clone = {};
        for (var p in o) {
            clone[p] = o[p];
        }
        return clone;
    }
    function replaceObjectProps(o1, o2) {
        var o = cloneObject(o1);
        for (var p in o1) {
            o[p] = o2.hasOwnProperty(p) ? o2[p] : o1[p];
        }
        return o;
    }
    function mergeObjects(o1, o2) {
        var o = cloneObject(o1);
        for (var p in o2) {
            o[p] = is.und(o1[p]) ? o2[p] : o1[p];
        }
        return o;
    }
    // Colors
    function rgbToRgba(rgbValue) {
        var rgb = /rgb\((\d+,\s*[\d]+,\s*[\d]+)\)/g.exec(rgbValue);
        return rgb ? ("rgba(" + (rgb[1]) + ",1)") : rgbValue;
    }
    function hexToRgba(hexValue) {
        var rgx = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
        var hex = hexValue.replace(rgx, function (m, r, g, b) { return r + r + g + g + b + b; });
        var rgb = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        var r = parseInt(rgb[1], 16);
        var g = parseInt(rgb[2], 16);
        var b = parseInt(rgb[3], 16);
        return ("rgba(" + r + "," + g + "," + b + ",1)");
    }
    function hslToRgba(hslValue) {
        var hsl = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(hslValue) || /hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g.exec(hslValue);
        var h = parseInt(hsl[1], 10) / 360;
        var s = parseInt(hsl[2], 10) / 100;
        var l = parseInt(hsl[3], 10) / 100;
        var a = hsl[4] || 1;
        function hue2rgb(p, q, t) {
            if (t < 0) {
                t += 1;
            }
            if (t > 1) {
                t -= 1;
            }
            if (t < 1 / 6) {
                return p + (q - p) * 6 * t;
            }
            if (t < 1 / 2) {
                return q;
            }
            if (t < 2 / 3) {
                return p + (q - p) * (2 / 3 - t) * 6;
            }
            return p;
        }
        var r, g, b;
        if (s == 0) {
            r = g = b = l;
        }
        else {
            var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            var p = 2 * l - q;
            r = hue2rgb(p, q, h + 1 / 3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1 / 3);
        }
        return ("rgba(" + (r * 255) + "," + (g * 255) + "," + (b * 255) + "," + a + ")");
    }
    function colorToRgb(val) {
        if (is.rgb(val)) {
            return rgbToRgba(val);
        }
        if (is.hex(val)) {
            return hexToRgba(val);
        }
        if (is.hsl(val)) {
            return hslToRgba(val);
        }
    }
    // Units
    function getUnit(val) {
        var split = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/.exec(val);
        if (split) {
            return split[1];
        }
    }
    function getTransformUnit(propName) {
        if (stringContains(propName, 'translate') || propName === 'perspective') {
            return 'px';
        }
        if (stringContains(propName, 'rotate') || stringContains(propName, 'skew')) {
            return 'deg';
        }
    }
    // Values
    function getFunctionValue(val, animatable) {
        if (!is.fnc(val)) {
            return val;
        }
        return val(animatable.target, animatable.id, animatable.total);
    }
    function getAttribute(el, prop) {
        return el.getAttribute(prop);
    }
    function convertPxToUnit(el, value, unit) {
        var valueUnit = getUnit(value);
        if (arrayContains([unit, 'deg', 'rad', 'turn'], valueUnit)) {
            return value;
        }
        var cached = cache.CSS[value + unit];
        if (!is.und(cached)) {
            return cached;
        }
        var baseline = 100;
        var tempEl = document.createElement(el.tagName);
        var parentEl = (el.parentNode && (el.parentNode !== document)) ? el.parentNode : document.body;
        parentEl.appendChild(tempEl);
        tempEl.style.position = 'absolute';
        tempEl.style.width = baseline + unit;
        var factor = baseline / tempEl.offsetWidth;
        parentEl.removeChild(tempEl);
        var convertedUnit = factor * parseFloat(value);
        cache.CSS[value + unit] = convertedUnit;
        return convertedUnit;
    }
    function getCSSValue(el, prop, unit) {
        if (prop in el.style) {
            var uppercasePropName = prop.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
            var value = el.style[prop] || getComputedStyle(el).getPropertyValue(uppercasePropName) || '0';
            return unit ? convertPxToUnit(el, value, unit) : value;
        }
    }
    function getAnimationType(el, prop) {
        if (is.dom(el) && !is.inp(el) && (getAttribute(el, prop) || (is.svg(el) && el[prop]))) {
            return 'attribute';
        }
        if (is.dom(el) && arrayContains(validTransforms, prop)) {
            return 'transform';
        }
        if (is.dom(el) && (prop !== 'transform' && getCSSValue(el, prop))) {
            return 'css';
        }
        if (el[prop] != null) {
            return 'object';
        }
    }
    function getElementTransforms(el) {
        if (!is.dom(el)) {
            return;
        }
        var str = el.style.transform || '';
        var reg = /(\w+)\(([^)]*)\)/g;
        var transforms = new Map();
        var m;
        while (m = reg.exec(str)) {
            transforms.set(m[1], m[2]);
        }
        return transforms;
    }
    function getTransformValue(el, propName, animatable, unit) {
        var defaultVal = stringContains(propName, 'scale') ? 1 : 0 + getTransformUnit(propName);
        var value = getElementTransforms(el).get(propName) || defaultVal;
        if (animatable) {
            animatable.transforms.list.set(propName, value);
            animatable.transforms['last'] = propName;
        }
        return unit ? convertPxToUnit(el, value, unit) : value;
    }
    function getOriginalTargetValue(target, propName, unit, animatable) {
        switch (getAnimationType(target, propName)) {
            case 'transform': return getTransformValue(target, propName, animatable, unit);
            case 'css': return getCSSValue(target, propName, unit);
            case 'attribute': return getAttribute(target, propName);
            default: return target[propName] || 0;
        }
    }
    function getRelativeValue(to, from) {
        var operator = /^(\*=|\+=|-=)/.exec(to);
        if (!operator) {
            return to;
        }
        var u = getUnit(to) || 0;
        var x = parseFloat(from);
        var y = parseFloat(to.replace(operator[0], ''));
        switch (operator[0][0]) {
            case '+': return x + y + u;
            case '-': return x - y + u;
            case '*': return x * y + u;
        }
    }
    function validateValue(val, unit) {
        if (is.col(val)) {
            return colorToRgb(val);
        }
        if (/\s/g.test(val)) {
            return val;
        }
        var originalUnit = getUnit(val);
        var unitLess = originalUnit ? val.substr(0, val.length - originalUnit.length) : val;
        if (unit) {
            return unitLess + unit;
        }
        return unitLess;
    }
    // getTotalLength() equivalent for circle, rect, polyline, polygon and line shapes
    // adapted from https://gist.github.com/SebLambla/3e0550c496c236709744
    function getDistance(p1, p2) {
        return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
    }
    function getCircleLength(el) {
        return Math.PI * 2 * getAttribute(el, 'r');
    }
    function getRectLength(el) {
        return (getAttribute(el, 'width') * 2) + (getAttribute(el, 'height') * 2);
    }
    function getLineLength(el) {
        return getDistance({ x: getAttribute(el, 'x1'), y: getAttribute(el, 'y1') }, { x: getAttribute(el, 'x2'), y: getAttribute(el, 'y2') });
    }
    function getPolylineLength(el) {
        var points = el.points;
        var totalLength = 0;
        var previousPos;
        for (var i = 0; i < points.numberOfItems; i++) {
            var currentPos = points.getItem(i);
            if (i > 0) {
                totalLength += getDistance(previousPos, currentPos);
            }
            previousPos = currentPos;
        }
        return totalLength;
    }
    function getPolygonLength(el) {
        var points = el.points;
        return getPolylineLength(el) + getDistance(points.getItem(points.numberOfItems - 1), points.getItem(0));
    }
    // Path animation
    function getTotalLength(el) {
        if (el.getTotalLength) {
            return el.getTotalLength();
        }
        switch (el.tagName.toLowerCase()) {
            case 'circle': return getCircleLength(el);
            case 'rect': return getRectLength(el);
            case 'line': return getLineLength(el);
            case 'polyline': return getPolylineLength(el);
            case 'polygon': return getPolygonLength(el);
        }
    }
    function setDashoffset(el) {
        var pathLength = getTotalLength(el);
        el.setAttribute('stroke-dasharray', pathLength);
        return pathLength;
    }
    // Motion path
    function getParentSvgEl(el) {
        var parentEl = el.parentNode;
        while (is.svg(parentEl)) {
            if (!is.svg(parentEl.parentNode)) {
                break;
            }
            parentEl = parentEl.parentNode;
        }
        return parentEl;
    }
    function getParentSvg(pathEl, svgData) {
        var svg = svgData || {};
        var parentSvgEl = svg.el || getParentSvgEl(pathEl);
        var rect = parentSvgEl.getBoundingClientRect();
        var viewBoxAttr = getAttribute(parentSvgEl, 'viewBox');
        var width = rect.width;
        var height = rect.height;
        var viewBox = svg.viewBox || (viewBoxAttr ? viewBoxAttr.split(' ') : [0, 0, width, height]);
        return {
            el: parentSvgEl,
            viewBox: viewBox,
            x: viewBox[0] / 1,
            y: viewBox[1] / 1,
            w: width / viewBox[2],
            h: height / viewBox[3]
        };
    }
    function getPath(path, percent) {
        var pathEl = is.str(path) ? selectString(path)[0] : path;
        var p = percent || 100;
        return function (property) {
            return {
                property: property,
                el: pathEl,
                svg: getParentSvg(pathEl),
                totalLength: getTotalLength(pathEl) * (p / 100)
            };
        };
    }
    function getPathProgress(path, progress) {
        function point(offset) {
            if (offset === void 0)
                offset = 0;
            var l = progress + offset >= 1 ? progress + offset : 0;
            return path.el.getPointAtLength(l);
        }
        var svg = getParentSvg(path.el, path.svg);
        var p = point();
        var p0 = point(-1);
        var p1 = point(+1);
        switch (path.property) {
            case 'x': return (p.x - svg.x) * svg.w;
            case 'y': return (p.y - svg.y) * svg.h;
            case 'angle': return Math.atan2(p1.y - p0.y, p1.x - p0.x) * 180 / Math.PI;
        }
    }
    // Decompose value
    function decomposeValue(val, unit) {
        // const rgx = /-?\d*\.?\d+/g; // handles basic numbers
        // const rgx = /[+-]?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/g; // handles exponents notation
        var rgx = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/g; // handles exponents notation
        var value = validateValue((is.pth(val) ? val.totalLength : val), unit) + '';
        return {
            original: value,
            numbers: value.match(rgx) ? value.match(rgx).map(Number) : [0],
            strings: (is.str(val) || unit) ? value.split(rgx) : []
        };
    }
    // Animatables
    function parseTargets(targets) {
        var targetsArray = targets ? (flattenArray(is.arr(targets) ? targets.map(toArray) : toArray(targets))) : [];
        return filterArray(targetsArray, function (item, pos, self) { return self.indexOf(item) === pos; });
    }
    function getAnimatables(targets) {
        var parsed = parseTargets(targets);
        return parsed.map(function (t, i) {
            return { target: t, id: i, total: parsed.length, transforms: { list: getElementTransforms(t) } };
        });
    }
    // Properties
    function normalizePropertyTweens(prop, tweenSettings) {
        var settings = cloneObject(tweenSettings);
        // Override duration if easing is a spring
        if (/^spring/.test(settings.easing)) {
            settings.duration = spring(settings.easing);
        }
        if (is.arr(prop)) {
            var l = prop.length;
            var isFromTo = (l === 2 && !is.obj(prop[0]));
            if (!isFromTo) {
                // Duration divided by the number of tweens
                if (!is.fnc(tweenSettings.duration)) {
                    settings.duration = tweenSettings.duration / l;
                }
            }
            else {
                // Transform [from, to] values shorthand to a valid tween value
                prop = { value: prop };
            }
        }
        var propArray = is.arr(prop) ? prop : [prop];
        return propArray.map(function (v, i) {
            var obj = (is.obj(v) && !is.pth(v)) ? v : { value: v };
            // Default delay value should only be applied to the first tween
            if (is.und(obj.delay)) {
                obj.delay = !i ? tweenSettings.delay : 0;
            }
            // Default endDelay value should only be applied to the last tween
            if (is.und(obj.endDelay)) {
                obj.endDelay = i === propArray.length - 1 ? tweenSettings.endDelay : 0;
            }
            return obj;
        }).map(function (k) { return mergeObjects(k, settings); });
    }
    function flattenKeyframes(keyframes) {
        var propertyNames = filterArray(flattenArray(keyframes.map(function (key) { return Object.keys(key); })), function (p) { return is.key(p); })
            .reduce(function (a, b) { if (a.indexOf(b) < 0) {
            a.push(b);
        } return a; }, []);
        var properties = {};
        var loop = function (i) {
            var propName = propertyNames[i];
            properties[propName] = keyframes.map(function (key) {
                var newKey = {};
                for (var p in key) {
                    if (is.key(p)) {
                        if (p == propName) {
                            newKey.value = key[p];
                        }
                    }
                    else {
                        newKey[p] = key[p];
                    }
                }
                return newKey;
            });
        };
        for (var i = 0; i < propertyNames.length; i++)
            loop(i);
        return properties;
    }
    function getProperties(tweenSettings, params) {
        var properties = [];
        var keyframes = params.keyframes;
        if (keyframes) {
            params = mergeObjects(flattenKeyframes(keyframes), params);
        }
        for (var p in params) {
            if (is.key(p)) {
                properties.push({
                    name: p,
                    tweens: normalizePropertyTweens(params[p], tweenSettings)
                });
            }
        }
        return properties;
    }
    // Tweens
    function normalizeTweenValues(tween, animatable) {
        var t = {};
        for (var p in tween) {
            var value = getFunctionValue(tween[p], animatable);
            if (is.arr(value)) {
                value = value.map(function (v) { return getFunctionValue(v, animatable); });
                if (value.length === 1) {
                    value = value[0];
                }
            }
            t[p] = value;
        }
        t.duration = parseFloat(t.duration);
        t.delay = parseFloat(t.delay);
        return t;
    }
    function normalizeTweens(prop, animatable) {
        var previousTween;
        return prop.tweens.map(function (t) {
            var tween = normalizeTweenValues(t, animatable);
            var tweenValue = tween.value;
            var to = is.arr(tweenValue) ? tweenValue[1] : tweenValue;
            var toUnit = getUnit(to);
            var originalValue = getOriginalTargetValue(animatable.target, prop.name, toUnit, animatable);
            var previousValue = previousTween ? previousTween.to.original : originalValue;
            var from = is.arr(tweenValue) ? tweenValue[0] : previousValue;
            var fromUnit = getUnit(from) || getUnit(originalValue);
            var unit = toUnit || fromUnit;
            if (is.und(to)) {
                to = previousValue;
            }
            tween.from = decomposeValue(from, unit);
            tween.to = decomposeValue(getRelativeValue(to, from), unit);
            tween.start = previousTween ? previousTween.end : 0;
            tween.end = tween.start + tween.delay + tween.duration + tween.endDelay;
            tween.easing = parseEasings(tween.easing, tween.duration);
            tween.isPath = is.pth(tweenValue);
            tween.isColor = is.col(tween.from.original);
            if (tween.isColor) {
                tween.round = 1;
            }
            previousTween = tween;
            return tween;
        });
    }
    // Set Value helper
    function setTargetsValue(targets, properties) {
        var animatables = getAnimatables(targets);
        animatables.forEach(function (animatable) {
            for (var property in properties) {
                var value = getFunctionValue(properties[property], animatable);
                var target = animatable.target;
                var valueUnit = getUnit(value);
                var originalValue = getOriginalTargetValue(target, property, valueUnit, animatable);
                var unit = valueUnit || getUnit(originalValue);
                var to = getRelativeValue(validateValue(value, unit), originalValue);
                var animType = getAnimationType(target, property);
                setProgressValue[animType](target, property, to, animatable.transforms, true);
            }
        });
    }
    // Animations
    function createAnimation(animatable, prop) {
        var animType = getAnimationType(animatable.target, prop.name);
        if (animType) {
            var tweens = normalizeTweens(prop, animatable);
            var lastTween = tweens[tweens.length - 1];
            return {
                type: animType,
                property: prop.name,
                animatable: animatable,
                tweens: tweens,
                duration: lastTween.end,
                delay: tweens[0].delay,
                endDelay: lastTween.endDelay
            };
        }
    }
    function getAnimations(animatables, properties) {
        return filterArray(flattenArray(animatables.map(function (animatable) {
            return properties.map(function (prop) {
                return createAnimation(animatable, prop);
            });
        })), function (a) { return !is.und(a); });
    }
    // Create Instance
    function getInstanceTimings(animations, tweenSettings) {
        var animLength = animations.length;
        var getTlOffset = function (anim) { return anim.timelineOffset ? anim.timelineOffset : 0; };
        var timings = {};
        timings.duration = animLength ? Math.max.apply(Math, animations.map(function (anim) { return getTlOffset(anim) + anim.duration; })) : tweenSettings.duration;
        timings.delay = animLength ? Math.min.apply(Math, animations.map(function (anim) { return getTlOffset(anim) + anim.delay; })) : tweenSettings.delay;
        timings.endDelay = animLength ? timings.duration - Math.max.apply(Math, animations.map(function (anim) { return getTlOffset(anim) + anim.duration - anim.endDelay; })) : tweenSettings.endDelay;
        return timings;
    }
    function createNewInstance(params) {
        var instanceSettings = replaceObjectProps(defaultInstanceSettings, params);
        var tweenSettings = replaceObjectProps(defaultTweenSettings, params);
        var properties = getProperties(tweenSettings, params);
        var animatables = getAnimatables(params.targets);
        var animations = getAnimations(animatables, properties);
        var timings = getInstanceTimings(animations, tweenSettings);
        var id = instanceID;
        instanceID++;
        return mergeObjects(instanceSettings, {
            id: id,
            children: [],
            animatables: animatables,
            animations: animations,
            duration: timings.duration,
            delay: timings.delay,
            endDelay: timings.endDelay
        });
    }
    function handleVisibilityChange() {
        if (document.hidden) {
            activeInstances.forEach(function (ins) { return ins.pause(); });
            pausedInstances = activeInstances.slice(0);
            anime.running = activeInstances = [];
        }
        else {
            pausedInstances.forEach(function (ins) { return ins.play(); });
        }
    }
    // Public Instance
    function anime(params) {
        if (params === void 0)
            params = {};
        var startTime = 0, lastTime = 0, now = 0;
        var children, childrenLength = 0;
        var resolve = null;
        function makePromise(instance) {
            var promise = window.Promise && new Promise(function (_resolve) { return resolve = _resolve; });
            instance.finished = promise;
            return promise;
        }
        var instance = createNewInstance(params);
        var promise = makePromise(instance);
        function toggleInstanceDirection() {
            var direction = instance.direction;
            if (direction !== 'alternate') {
                instance.direction = direction !== 'normal' ? 'normal' : 'reverse';
            }
            instance.reversed = !instance.reversed;
            children.forEach(function (child) { return child.reversed = instance.reversed; });
        }
        function adjustTime(time) {
            return instance.reversed ? instance.duration - time : time;
        }
        function resetTime() {
            startTime = 0;
            lastTime = adjustTime(instance.currentTime) * (1 / anime.speed);
        }
        function seekChild(time, child) {
            if (child) {
                child.seek(time - child.timelineOffset);
            }
        }
        function syncInstanceChildren(time) {
            if (!instance.reversePlayback) {
                for (var i = 0; i < childrenLength; i++) {
                    seekChild(time, children[i]);
                }
            }
            else {
                for (var i$1 = childrenLength; i$1--;) {
                    seekChild(time, children[i$1]);
                }
            }
        }
        function setAnimationsProgress(insTime) {
            var i = 0;
            var animations = instance.animations;
            var animationsLength = animations.length;
            while (i < animationsLength) {
                var anim = animations[i];
                var animatable = anim.animatable;
                var tweens = anim.tweens;
                var tweenLength = tweens.length - 1;
                var tween = tweens[tweenLength];
                // Only check for keyframes if there is more than one tween
                if (tweenLength) {
                    tween = filterArray(tweens, function (t) { return (insTime < t.end); })[0] || tween;
                }
                var elapsed = minMax(insTime - tween.start - tween.delay, 0, tween.duration) / tween.duration;
                var eased = isNaN(elapsed) ? 1 : tween.easing(elapsed);
                var strings = tween.to.strings;
                var round = tween.round;
                var numbers = [];
                var toNumbersLength = tween.to.numbers.length;
                var progress = (void 0);
                for (var n = 0; n < toNumbersLength; n++) {
                    var value = (void 0);
                    var toNumber = tween.to.numbers[n];
                    var fromNumber = tween.from.numbers[n] || 0;
                    if (!tween.isPath) {
                        value = fromNumber + (eased * (toNumber - fromNumber));
                    }
                    else {
                        value = getPathProgress(tween.value, eased * toNumber);
                    }
                    if (round) {
                        if (!(tween.isColor && n > 2)) {
                            value = Math.round(value * round) / round;
                        }
                    }
                    numbers.push(value);
                }
                // Manual Array.reduce for better performances
                var stringsLength = strings.length;
                if (!stringsLength) {
                    progress = numbers[0];
                }
                else {
                    progress = strings[0];
                    for (var s = 0; s < stringsLength; s++) {
                        var a = strings[s];
                        var b = strings[s + 1];
                        var n$1 = numbers[s];
                        if (!isNaN(n$1)) {
                            if (!b) {
                                progress += n$1 + ' ';
                            }
                            else {
                                progress += n$1 + b;
                            }
                        }
                    }
                }
                setProgressValue[anim.type](animatable.target, anim.property, progress, animatable.transforms);
                anim.currentValue = progress;
                i++;
            }
        }
        function setCallback(cb) {
            if (instance[cb] && !instance.passThrough) {
                instance[cb](instance);
            }
        }
        function countIteration() {
            if (instance.remaining && instance.remaining !== true) {
                instance.remaining--;
            }
        }
        function setInstanceProgress(engineTime) {
            var insDuration = instance.duration;
            var insDelay = instance.delay;
            var insEndDelay = insDuration - instance.endDelay;
            var insTime = adjustTime(engineTime);
            instance.progress = minMax((insTime / insDuration) * 100, 0, 100);
            instance.reversePlayback = insTime < instance.currentTime;
            if (children) {
                syncInstanceChildren(insTime);
            }
            if (!instance.began && instance.currentTime > 0) {
                instance.began = true;
                setCallback('begin');
            }
            if (!instance.loopBegan && instance.currentTime > 0) {
                instance.loopBegan = true;
                setCallback('loopBegin');
            }
            if (insTime <= insDelay && instance.currentTime !== 0) {
                setAnimationsProgress(0);
            }
            if ((insTime >= insEndDelay && instance.currentTime !== insDuration) || !insDuration) {
                setAnimationsProgress(insDuration);
            }
            if (insTime > insDelay && insTime < insEndDelay) {
                if (!instance.changeBegan) {
                    instance.changeBegan = true;
                    instance.changeCompleted = false;
                    setCallback('changeBegin');
                }
                setCallback('change');
                setAnimationsProgress(insTime);
            }
            else {
                if (instance.changeBegan) {
                    instance.changeCompleted = true;
                    instance.changeBegan = false;
                    setCallback('changeComplete');
                }
            }
            instance.currentTime = minMax(insTime, 0, insDuration);
            if (instance.began) {
                setCallback('update');
            }
            if (engineTime >= insDuration) {
                lastTime = 0;
                countIteration();
                if (!instance.remaining) {
                    instance.paused = true;
                    if (!instance.completed) {
                        instance.completed = true;
                        setCallback('loopComplete');
                        setCallback('complete');
                        if (!instance.passThrough && 'Promise' in window) {
                            resolve();
                            promise = makePromise(instance);
                        }
                    }
                }
                else {
                    startTime = now;
                    setCallback('loopComplete');
                    instance.loopBegan = false;
                    if (instance.direction === 'alternate') {
                        toggleInstanceDirection();
                    }
                }
            }
        }
        instance.reset = function () {
            var direction = instance.direction;
            instance.passThrough = false;
            instance.currentTime = 0;
            instance.progress = 0;
            instance.paused = true;
            instance.began = false;
            instance.loopBegan = false;
            instance.changeBegan = false;
            instance.completed = false;
            instance.changeCompleted = false;
            instance.reversePlayback = false;
            instance.reversed = direction === 'reverse';
            instance.remaining = instance.loop;
            children = instance.children;
            childrenLength = children.length;
            for (var i = childrenLength; i--;) {
                instance.children[i].reset();
            }
            if (instance.reversed && instance.loop !== true || (direction === 'alternate' && instance.loop === 1)) {
                instance.remaining++;
            }
            setAnimationsProgress(instance.reversed ? instance.duration : 0);
        };
        // Set Value helper
        instance.set = function (targets, properties) {
            setTargetsValue(targets, properties);
            return instance;
        };
        instance.tick = function (t) {
            now = t;
            if (!startTime) {
                startTime = now;
            }
            setInstanceProgress((now + (lastTime - startTime)) * anime.speed);
        };
        instance.seek = function (time) {
            setInstanceProgress(adjustTime(time));
        };
        instance.pause = function () {
            instance.paused = true;
            resetTime();
        };
        instance.play = function () {
            if (!instance.paused) {
                return;
            }
            if (instance.completed) {
                instance.reset();
            }
            instance.paused = false;
            activeInstances.push(instance);
            resetTime();
            if (!raf) {
                engine();
            }
        };
        instance.reverse = function () {
            toggleInstanceDirection();
            resetTime();
        };
        instance.restart = function () {
            instance.reset();
            instance.play();
        };
        instance.reset();
        if (instance.autoplay) {
            instance.play();
        }
        return instance;
    }
    // Remove targets from animation
    function removeTargetsFromAnimations(targetsArray, animations) {
        for (var a = animations.length; a--;) {
            if (arrayContains(targetsArray, animations[a].animatable.target)) {
                animations.splice(a, 1);
            }
        }
    }
    function removeTargets(targets) {
        var targetsArray = parseTargets(targets);
        for (var i = activeInstances.length; i--;) {
            var instance = activeInstances[i];
            var animations = instance.animations;
            var children = instance.children;
            removeTargetsFromAnimations(targetsArray, animations);
            for (var c = children.length; c--;) {
                var child = children[c];
                var childAnimations = child.animations;
                removeTargetsFromAnimations(targetsArray, childAnimations);
                if (!childAnimations.length && !child.children.length) {
                    children.splice(c, 1);
                }
            }
            if (!animations.length && !children.length) {
                instance.pause();
            }
        }
    }
    // Stagger helpers
    function stagger(val, params) {
        if (params === void 0)
            params = {};
        var direction = params.direction || 'normal';
        var easing = params.easing ? parseEasings(params.easing) : null;
        var grid = params.grid;
        var axis = params.axis;
        var fromIndex = params.from || 0;
        var fromFirst = fromIndex === 'first';
        var fromCenter = fromIndex === 'center';
        var fromLast = fromIndex === 'last';
        var isRange = is.arr(val);
        var val1 = isRange ? parseFloat(val[0]) : parseFloat(val);
        var val2 = isRange ? parseFloat(val[1]) : 0;
        var unit = getUnit(isRange ? val[1] : val) || 0;
        var start = params.start || 0 + (isRange ? val1 : 0);
        var values = [];
        var maxValue = 0;
        return function (el, i, t) {
            if (fromFirst) {
                fromIndex = 0;
            }
            if (fromCenter) {
                fromIndex = (t - 1) / 2;
            }
            if (fromLast) {
                fromIndex = t - 1;
            }
            if (!values.length) {
                for (var index = 0; index < t; index++) {
                    if (!grid) {
                        values.push(Math.abs(fromIndex - index));
                    }
                    else {
                        var fromX = !fromCenter ? fromIndex % grid[0] : (grid[0] - 1) / 2;
                        var fromY = !fromCenter ? Math.floor(fromIndex / grid[0]) : (grid[1] - 1) / 2;
                        var toX = index % grid[0];
                        var toY = Math.floor(index / grid[0]);
                        var distanceX = fromX - toX;
                        var distanceY = fromY - toY;
                        var value = Math.sqrt(distanceX * distanceX + distanceY * distanceY);
                        if (axis === 'x') {
                            value = -distanceX;
                        }
                        if (axis === 'y') {
                            value = -distanceY;
                        }
                        values.push(value);
                    }
                    maxValue = Math.max.apply(Math, values);
                }
                if (easing) {
                    values = values.map(function (val) { return easing(val / maxValue) * maxValue; });
                }
                if (direction === 'reverse') {
                    values = values.map(function (val) { return axis ? (val < 0) ? val * -1 : -val : Math.abs(maxValue - val); });
                }
            }
            var spacing = isRange ? (val2 - val1) / maxValue : val1;
            return start + (spacing * (Math.round(values[i] * 100) / 100)) + unit;
        };
    }
    // Timeline
    function timeline(params) {
        if (params === void 0)
            params = {};
        var tl = anime(params);
        tl.duration = 0;
        tl.add = function (instanceParams, timelineOffset) {
            var tlIndex = activeInstances.indexOf(tl);
            var children = tl.children;
            if (tlIndex > -1) {
                activeInstances.splice(tlIndex, 1);
            }
            function passThrough(ins) { ins.passThrough = true; }
            for (var i = 0; i < children.length; i++) {
                passThrough(children[i]);
            }
            var insParams = mergeObjects(instanceParams, replaceObjectProps(defaultTweenSettings, params));
            insParams.targets = insParams.targets || params.targets;
            var tlDuration = tl.duration;
            insParams.autoplay = false;
            insParams.direction = tl.direction;
            insParams.timelineOffset = is.und(timelineOffset) ? tlDuration : getRelativeValue(timelineOffset, tlDuration);
            passThrough(tl);
            tl.seek(insParams.timelineOffset);
            var ins = anime(insParams);
            passThrough(ins);
            children.push(ins);
            var timings = getInstanceTimings(children, params);
            tl.delay = timings.delay;
            tl.endDelay = timings.endDelay;
            tl.duration = timings.duration;
            tl.seek(0);
            tl.reset();
            if (tl.autoplay) {
                tl.play();
            }
            return tl;
        };
        return tl;
    }
    return {
        setters: [],
        execute: function () {
            // Defaults
            defaultInstanceSettings = {
                update: null,
                begin: null,
                loopBegin: null,
                changeBegin: null,
                change: null,
                changeComplete: null,
                loopComplete: null,
                complete: null,
                loop: 1,
                direction: 'normal',
                autoplay: true,
                timelineOffset: 0
            };
            defaultTweenSettings = {
                duration: 1000,
                delay: 0,
                endDelay: 0,
                easing: 'easeOutElastic(1, .5)',
                round: 0
            };
            validTransforms = ['translateX', 'translateY', 'translateZ', 'rotate', 'rotateX', 'rotateY', 'rotateZ', 'scale', 'scaleX', 'scaleY', 'scaleZ', 'skew', 'skewX', 'skewY', 'perspective'];
            // Caching
            cache = {
                CSS: {},
                springs: {}
            };
            is = {
                arr: function (a) { return Array.isArray(a); },
                obj: function (a) { return stringContains(Object.prototype.toString.call(a), 'Object'); },
                pth: function (a) { return is.obj(a) && a.hasOwnProperty('totalLength'); },
                svg: function (a) { return a instanceof SVGElement; },
                inp: function (a) { return a instanceof HTMLInputElement; },
                dom: function (a) { return a.nodeType || is.svg(a); },
                str: function (a) { return typeof a === 'string'; },
                fnc: function (a) { return typeof a === 'function'; },
                und: function (a) { return typeof a === 'undefined'; },
                hex: function (a) { return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(a); },
                rgb: function (a) { return /^rgb/.test(a); },
                hsl: function (a) { return /^hsl/.test(a); },
                col: function (a) { return (is.hex(a) || is.rgb(a) || is.hsl(a)); },
                key: function (a) { return !defaultInstanceSettings.hasOwnProperty(a) && !defaultTweenSettings.hasOwnProperty(a) && a !== 'targets' && a !== 'keyframes'; }
            };
            // BezierEasing https://github.com/gre/bezier-easing
            bezier = (function () {
                var kSplineTableSize = 11;
                var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);
                function A(aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1; }
                function B(aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1; }
                function C(aA1) { return 3.0 * aA1; }
                function calcBezier(aT, aA1, aA2) { return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT; }
                function getSlope(aT, aA1, aA2) { return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1); }
                function binarySubdivide(aX, aA, aB, mX1, mX2) {
                    var currentX, currentT, i = 0;
                    do {
                        currentT = aA + (aB - aA) / 2.0;
                        currentX = calcBezier(currentT, mX1, mX2) - aX;
                        if (currentX > 0.0) {
                            aB = currentT;
                        }
                        else {
                            aA = currentT;
                        }
                    } while (Math.abs(currentX) > 0.0000001 && ++i < 10);
                    return currentT;
                }
                function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
                    for (var i = 0; i < 4; ++i) {
                        var currentSlope = getSlope(aGuessT, mX1, mX2);
                        if (currentSlope === 0.0) {
                            return aGuessT;
                        }
                        var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
                        aGuessT -= currentX / currentSlope;
                    }
                    return aGuessT;
                }
                function bezier(mX1, mY1, mX2, mY2) {
                    if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {
                        return;
                    }
                    var sampleValues = new Float32Array(kSplineTableSize);
                    if (mX1 !== mY1 || mX2 !== mY2) {
                        for (var i = 0; i < kSplineTableSize; ++i) {
                            sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
                        }
                    }
                    function getTForX(aX) {
                        var intervalStart = 0;
                        var currentSample = 1;
                        var lastSample = kSplineTableSize - 1;
                        for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
                            intervalStart += kSampleStepSize;
                        }
                        --currentSample;
                        var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
                        var guessForT = intervalStart + dist * kSampleStepSize;
                        var initialSlope = getSlope(guessForT, mX1, mX2);
                        if (initialSlope >= 0.001) {
                            return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
                        }
                        else if (initialSlope === 0.0) {
                            return guessForT;
                        }
                        else {
                            return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
                        }
                    }
                    return function (x) {
                        if (mX1 === mY1 && mX2 === mY2) {
                            return x;
                        }
                        if (x === 0 || x === 1) {
                            return x;
                        }
                        return calcBezier(getTForX(x), mY1, mY2);
                    };
                }
                return bezier;
            })();
            penner = (function () {
                // Based on jQuery UI's implemenation of easing equations from Robert Penner (http://www.robertpenner.com/easing)
                var eases = { linear: function () { return function (t) { return t; }; } };
                var functionEasings = {
                    Sine: function () { return function (t) { return 1 - Math.cos(t * Math.PI / 2); }; },
                    Circ: function () { return function (t) { return 1 - Math.sqrt(1 - t * t); }; },
                    Back: function () { return function (t) { return t * t * (3 * t - 2); }; },
                    Bounce: function () {
                        return function (t) {
                            var pow2, b = 4;
                            while (t < ((pow2 = Math.pow(2, --b)) - 1) / 11) { }
                            return 1 / Math.pow(4, 3 - b) - 7.5625 * Math.pow((pow2 * 3 - 2) / 22 - t, 2);
                        };
                    },
                    Elastic: function (amplitude, period) {
                        if (amplitude === void 0)
                            amplitude = 1;
                        if (period === void 0)
                            period = .5;
                        var a = minMax(amplitude, 1, 10);
                        var p = minMax(period, .1, 2);
                        return function (t) {
                            return (t === 0 || t === 1) ? t :
                                -a * Math.pow(2, 10 * (t - 1)) * Math.sin((((t - 1) - (p / (Math.PI * 2) * Math.asin(1 / a))) * (Math.PI * 2)) / p);
                        };
                    }
                };
                var baseEasings = ['Quad', 'Cubic', 'Quart', 'Quint', 'Expo'];
                baseEasings.forEach(function (name, i) {
                    functionEasings[name] = function () { return function (t) { return Math.pow(t, i + 2); }; };
                });
                Object.keys(functionEasings).forEach(function (name) {
                    var easeIn = functionEasings[name];
                    eases['easeIn' + name] = easeIn;
                    eases['easeOut' + name] = function (a, b) { return function (t) { return 1 - easeIn(a, b)(1 - t); }; };
                    eases['easeInOut' + name] = function (a, b) {
                        return function (t) {
                            return t < 0.5 ? easeIn(a, b)(t * 2) / 2 :
                                1 - easeIn(a, b)(t * -2 + 2) / 2;
                        };
                    };
                });
                return eases;
            })();
            // Tween progress
            setProgressValue = {
                css: function (t, p, v) { return t.style[p] = v; },
                attribute: function (t, p, v) { return t.setAttribute(p, v); },
                object: function (t, p, v) { return t[p] = v; },
                transform: function (t, p, v, transforms, manual) {
                    transforms.list.set(p, v);
                    if (p === transforms.last || manual) {
                        var str = '';
                        transforms.list.forEach(function (value, prop) { str += prop + "(" + value + ") "; });
                        t.style.transform = str;
                    }
                }
            };
            instanceID = 0;
            // Core
            activeInstances = [];
            pausedInstances = [];
            engine = (function () {
                function play() {
                    raf = requestAnimationFrame(step);
                }
                function step(t) {
                    var activeInstancesLength = activeInstances.length;
                    if (activeInstancesLength) {
                        var i = 0;
                        while (i < activeInstancesLength) {
                            var activeInstance = activeInstances[i];
                            if (!activeInstance.paused) {
                                activeInstance.tick(t);
                            }
                            else {
                                var instanceIndex = activeInstances.indexOf(activeInstance);
                                if (instanceIndex > -1) {
                                    activeInstances.splice(instanceIndex, 1);
                                    activeInstancesLength = activeInstances.length;
                                }
                            }
                            i++;
                        }
                        play();
                    }
                    else {
                        raf = cancelAnimationFrame(raf);
                    }
                }
                return play;
            })();
            if (typeof document !== 'undefined') {
                document.addEventListener('visibilitychange', handleVisibilityChange);
            }
            anime.version = '3.1.0';
            anime.speed = 1;
            anime.running = activeInstances;
            anime.remove = removeTargets;
            anime.get = getOriginalTargetValue;
            anime.set = setTargetsValue;
            anime.convertPx = convertPxToUnit;
            anime.path = getPath;
            anime.setDashoffset = setDashoffset;
            anime.stagger = stagger;
            anime.timeline = timeline;
            anime.easing = parseEasings;
            anime.penner = penner;
            anime.random = function (min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; };
            exports_7("default", anime);
        }
    };
});
System.register("http://localhost:5501/src/deps/anime", ["https://unpkg.com/animejs@3.1.0/lib/anime.es"], function (exports_8, context_8) {
    "use strict";
    var animeModule, anime;
    var __moduleName = context_8 && context_8.id;
    return {
        setters: [
            function (animeModule_1) {
                animeModule = animeModule_1;
            }
        ],
        execute: function () {
            anime = animeModule.default;
            exports_8("default", anime);
        }
    };
});
System.register("http://localhost:5501/src/internals/dynamic", [], function (exports_9, context_9) {
    "use strict";
    var dynamicProps;
    var __moduleName = context_9 && context_9.id;
    return {
        setters: [],
        execute: function () {
            exports_9("dynamicProps", dynamicProps = {
                from: {
                    default: 0,
                    type: [String, Number]
                },
                to: {
                    default: 360,
                    type: [String, Number]
                },
                step: {
                    default: 1,
                    type: [String, Number]
                },
                integer: {
                    default: false,
                    type: [Boolean, String]
                },
                set: { default: "" }
            });
        }
    };
});
System.register("http://localhost:5501/src/components/FAnimate", ["http://localhost:5501/src/deps/vue", "http://localhost:5501/src/deps/anime", "http://localhost:5501/fachwerk", "http://localhost:5501/src/internals/dynamic"], function (exports_10, context_10) {
    "use strict";
    var vue_js_1, anime_js_1, fachwerk_js_1, dynamic_js_1, FAnimate;
    var __moduleName = context_10 && context_10.id;
    return {
        setters: [
            function (vue_js_1_1) {
                vue_js_1 = vue_js_1_1;
            },
            function (anime_js_1_1) {
                anime_js_1 = anime_js_1_1;
            },
            function (fachwerk_js_1_1) {
                fachwerk_js_1 = fachwerk_js_1_1;
            },
            function (dynamic_js_1_1) {
                dynamic_js_1 = dynamic_js_1_1;
            }
        ],
        execute: function () {
            exports_10("FAnimate", FAnimate = {
                props: {
                    ...dynamic_js_1.dynamicProps,
                    duration: { default: 5000, type: [String, Number] },
                    easing: { default: "linear", type: String },
                    direction: { default: "alternate", type: String }
                },
                setup(props, { emit }) {
                    const progress = vue_js_1.ref(0);
                    anime_js_1.default({
                        targets: progress,
                        value: [props.from, props.to],
                        duration: props.duration,
                        easing: props.easing,
                        direction: props.direction,
                        loop: true
                    });
                    vue_js_1.watch(progress, progress => {
                        const currentProgress = props.integer ? Math.floor(progress) : progress;
                        emit("value", currentProgress);
                        if (props.set) {
                            fachwerk_js_1.set(props.set, currentProgress);
                        }
                    });
                    return () => null;
                }
            });
        }
    };
});
System.register("http://localhost:5501/src/internals/content", [], function (exports_11, context_11) {
    "use strict";
    var cleanColumns, parseMeta, parsePage, parseContent, slideGridStyle;
    var __moduleName = context_11 && context_11.id;
    return {
        setters: [],
        execute: function () {
            exports_11("cleanColumns", cleanColumns = content => {
                const pattern = /(\|[0-9\s]+\r?\n)/g;
                return content.replace(pattern, "");
            });
            parseMeta = row => {
                const meta = row
                    .replace(/\|/g, "")
                    .split(": ")
                    .map(s => s.trim());
                return meta;
            };
            exports_11("parsePage", parsePage = page => {
                let meta = [];
                const metaPattern = /(\|\s(.*?):\s+(.*)\r?\n)/g;
                const metaMatch = page.match(metaPattern);
                if (metaMatch && metaMatch.length) {
                    meta = metaMatch.map(parseMeta);
                    page = page.replace(metaPattern, "");
                }
                const pattern = /(\|[0-9\s]+\r?\n)/g;
                const match = page.match(pattern);
                if (match) {
                    const rowCount = match.length;
                    const cols = match.map(m => {
                        return m
                            .trim()
                            .replace(/\|/g, "")
                            .split(/\s+/)
                            .filter(m => m && !m.match(/\s+/));
                    });
                    const colCount = cols[0].length;
                    const areas = cols
                        .map(m => `'${m.map(m => `a${m}`).join(" ")}'`)
                        .join("\n");
                    const content = page.split(/\r?\n-\r?\n/).map(c => c.replace(pattern, ""));
                    return Object.assign({ rowCount, colCount, areas, content }, ...meta);
                }
                else {
                    const content = page.split(/\r?\n-\r?\n/);
                    return Object.assign({
                        rowCount: 1,
                        colCount: content.length,
                        areas: `'${content.map((_, i) => `a${i + 1}`).join(" ")}'`,
                        content: content
                    }, ...meta);
                }
            });
            exports_11("parseContent", parseContent = document => {
                return document.split(/\r?\n---\r?\n/).map(parsePage);
            });
            exports_11("slideGridStyle", slideGridStyle = slide => {
                return {
                    gridTemplateColumns: slide.cols
                        ? slide.cols
                        : "repeat(" + slide.colCount + ", 1fr)",
                    gridTemplateRows: slide.rows
                        ? slide.rows
                        : slide.rowCount > 1
                            ? "repeat(" + (slide.rowCount - 1) + ", auto) 1fr"
                            : "1fr",
                    gridTemplateAreas: slide.areas,
                    gridGap: slide.gap ? slide.gap : "var(--base3)"
                };
            });
        }
    };
});
System.register("http://localhost:5501/src/internals/coordinates", ["http://localhost:5501/src/utils/index"], function (exports_12, context_12) {
    "use strict";
    var index_js_1, normalizeDefault, normalizeScale, normalizeThreeRotation, coordsTextToArray, coordsNumberToArray, coordsArrayToArray, coordsObjectToArray, parseCoords, test_parseCoords_null, test_parseCoords_empty_string, test_parseCoords_empty_string_to_scale, test_parseCoords_empty_space, test_parseCoords_empty_array, test_parseCoords_empty_array_array, test_parseCoords_empty_array_2_array, test_parseCoords_empty_array_number_0, test_parseCoords_empty_array_number_0_empty_array, test_parseCoords_array_number_0_0, test_parseCoords_array_number_0_string_0, test_parseCoords_object_empty, test_parseCoords_array_object_empty, test_parseCoords_array_object_object_empty, test_parseCoords_everything_empty, test_parseCoords_string_empty, test_parseCoords_string_empty_to_scale, test_parseCoords_string_0, test_parseCoords_string_0_to_scale, test_parseCoords_string_1, test_parseCoords_string_1_1, test_parseCoords_string_1_1_a_spaced, test_parseCoords_string_1_1_a_1_spaced, test_parseCoords_string_1_and_1, test_parseCoords_string_1_and_1_in_array, test_parseCoords_string_1_1_and_1_1_in_array, test_parseCoords_string_1_and_1_spaced, test_parseCoords_string_1_1_and_1_1, test_parseCoords_string_1_1_1, test_parseCoords_string_1_1_1_1, test_parseCoords_string_1_1_1_and_1_1_1, test_parseCoords_string_1_1_1_1_and_1_1_1_1, test_parseCoords_number_0, test_parseCoords_number_1, test_parseCoords_number_2, test_parseCoords_number_1_to_scale, test_parseCoords_number_2_to_scale, test_parseCoords_number_01, test_parseCoords_number_1_in_array, test_parseCoords_number_1_in_array_array, test_parseCoords_number_1_1_in_array, test_parseCoords_number_1_1_in_array_array, test_parseCoords_array_number_1_1_1_in_array, test_parseCoords_number_1_1_1_in_array_array, test_parseCoords_number_1_1_1_1_in_array_array, test_parseCoords_array_number_1_1_1, test_parseCoords_array_number_1_1_1_1, test_parseCoords_object_0, test_parseCoords_object_string_1, test_parseCoords_object_number_1, test_parseCoords_object_number_1_1, test_parseCoords_object_number_1_1_1, test_parseCoords_object_number_1_1_1_gibberish, test_parseCoords_object_number_01, test_parseCoords_object_number_1_in_array, test_parseCoords_object_number_1_1_in_array, test_parseCoords_object_number_1_1_1_in_array, test_parseCoords_object_number_1_1_1_1_in_array, test_parseCoords_object_everything_in_array, test_parseCoords_array_number_1_1_1_in_array_array, test_parseCoords_array_array_number_string_1_1, test_parseCoords_array_1_sting_1, test_parseCoords_array_1_number_1, test_parseCoords_array_1_object_1;
    var __moduleName = context_12 && context_12.id;
    return {
        setters: [
            function (index_js_1_1) {
                index_js_1 = index_js_1_1;
            }
        ],
        execute: function () {
            exports_12("normalizeDefault", normalizeDefault = arr => {
                return index_js_1.padArrayRight(arr || [], 3, 0).map(value => index_js_1.toNumber(value));
            });
            exports_12("normalizeScale", normalizeScale = arr => {
                if (arr === null || arr.length === 0) {
                    return [1, 1, 1];
                }
                if (arr.length == 1) {
                    return [arr[0], arr[0], arr[0]];
                }
                return index_js_1.padArrayRight(arr || [], 3, 1).map(value => index_js_1.toNumber(value));
            });
            exports_12("normalizeThreeRotation", normalizeThreeRotation = arr => {
                if (arr === null) {
                    return [[0, 0, 0]];
                }
                if (arr.length == 1) {
                    return [0, 0, arr[0]];
                }
                if (arr.length == 2) {
                    return [arr[0], arr[1], 0];
                }
                return [arr[0], arr[1], arr[2]];
            });
            exports_12("coordsTextToArray", coordsTextToArray = (text, normalizer) => {
                if (text.trim().length === 0) {
                    return [normalizer(null)];
                }
                return text
                    .split(",")
                    .map(t => t
                    .trim()
                    .replace(/\s+/g, " ")
                    .split(" ")
                    .map(value => index_js_1.toNumber(value)))
                    .map(normalizer);
            });
            exports_12("coordsNumberToArray", coordsNumberToArray = (number, normalizer) => {
                return [normalizer([number])];
            });
            exports_12("coordsArrayToArray", coordsArrayToArray = (arr, normalizer) => {
                const containsArrays = arr.length && arr.filter(a => index_js_1.isArray(a)).length;
                const coords = arr.map(a => {
                    if (index_js_1.isArray(a)) {
                        return normalizer(a);
                    }
                    if (index_js_1.isString(a)) {
                        if (a.split(/\s+/g).length > 1) {
                            return coordsTextToArray(a, normalizer)[0];
                        }
                        return containsArrays ? normalizer([a]) : index_js_1.toNumber(a);
                    }
                    if (index_js_1.isNumber(a)) {
                        return containsArrays ? normalizer([a]) : a;
                    }
                    if (index_js_1.isObject(a)) {
                        return coordsObjectToArray(a, normalizer)[0];
                    }
                    if (index_js_1.isBoolean(a)) {
                        return containsArrays ? normalizer([0]) : 0;
                    }
                    if (index_js_1.isNull(a)) {
                        return containsArrays ? normalizer([0]) : 0;
                    }
                    return a;
                });
                if (index_js_1.isArray(coords[0])) {
                    return coords;
                }
                return [normalizer(coords)];
            });
            exports_12("coordsObjectToArray", coordsObjectToArray = (obj, normalizer = normalizeDefault) => {
                if (obj.hasOwnProperty("x") &&
                    obj.hasOwnProperty("y") &&
                    obj.hasOwnProperty("z")) {
                    return [normalizer([obj.x, obj.y, obj.z])];
                }
                if (obj.hasOwnProperty("x") &&
                    obj.hasOwnProperty("y") &&
                    !obj.hasOwnProperty("z")) {
                    return [normalizer([obj.x, obj.y, 0])];
                }
                if (obj.hasOwnProperty("x") &&
                    !obj.hasOwnProperty("y") &&
                    obj.hasOwnProperty("z")) {
                    return [normalizer([obj.x, 0, obj.z])];
                }
                if (!obj.hasOwnProperty("x") &&
                    obj.hasOwnProperty("y") &&
                    obj.hasOwnProperty("z")) {
                    return [normalizer([obj.x, 0, obj.z])];
                }
                if (obj.hasOwnProperty("x") &&
                    !obj.hasOwnProperty("y") &&
                    !obj.hasOwnProperty("z")) {
                    return [normalizer([obj.x, 0, 0])];
                }
                if (!obj.hasOwnProperty("x") &&
                    obj.hasOwnProperty("y") &&
                    !obj.hasOwnProperty("z")) {
                    return [normalizer([0, obj.y, 0])];
                }
                if (!obj.hasOwnProperty("x") &&
                    !obj.hasOwnProperty("y") &&
                    obj.hasOwnProperty("z")) {
                    return [normalizer([0, 0, obj.z])];
                }
                return [normalizer([])];
            });
            exports_12("parseCoords", parseCoords = (c, normalizer = normalizeDefault) => {
                if (index_js_1.isNull(c)) {
                    return coordsTextToArray("", normalizer);
                }
                if (index_js_1.isString(c)) {
                    return coordsTextToArray(c, normalizer);
                }
                if (index_js_1.isNumber(c)) {
                    return coordsNumberToArray(c, normalizer);
                }
                if (index_js_1.isArray(c)) {
                    return coordsArrayToArray(c, normalizer);
                }
                if (index_js_1.isObject(c)) {
                    return coordsObjectToArray(c, normalizer);
                }
                return null;
            });
            // Empty tests
            exports_12("test_parseCoords_null", test_parseCoords_null = () => {
                return [parseCoords(null), [[0, 0, 0]]];
            });
            exports_12("test_parseCoords_empty_string", test_parseCoords_empty_string = () => {
                return [parseCoords(""), [[0, 0, 0]]];
            });
            exports_12("test_parseCoords_empty_string_to_scale", test_parseCoords_empty_string_to_scale = () => {
                return [parseCoords("", normalizeScale), [[1, 1, 1]]];
            });
            exports_12("test_parseCoords_empty_space", test_parseCoords_empty_space = () => {
                return [[[0, 0, 0]], parseCoords("       ")];
            });
            exports_12("test_parseCoords_empty_array", test_parseCoords_empty_array = () => {
                return [parseCoords([]), [[0, 0, 0]]];
            });
            exports_12("test_parseCoords_empty_array_array", test_parseCoords_empty_array_array = () => {
                return [parseCoords([[]]), [[0, 0, 0]]];
            });
            exports_12("test_parseCoords_empty_array_2_array", test_parseCoords_empty_array_2_array = () => {
                return [
                    parseCoords([[], []]),
                    [
                        [0, 0, 0],
                        [0, 0, 0]
                    ]
                ];
            });
            exports_12("test_parseCoords_empty_array_number_0", test_parseCoords_empty_array_number_0 = () => {
                return [parseCoords([0]), [[0, 0, 0]]];
            });
            exports_12("test_parseCoords_empty_array_number_0_empty_array", test_parseCoords_empty_array_number_0_empty_array = () => {
                return [
                    parseCoords([0, []]),
                    [
                        [0, 0, 0],
                        [0, 0, 0]
                    ]
                ];
            });
            exports_12("test_parseCoords_array_number_0_0", test_parseCoords_array_number_0_0 = () => {
                return [parseCoords([0, 0]), [[0, 0, 0]]];
            });
            exports_12("test_parseCoords_array_number_0_string_0", test_parseCoords_array_number_0_string_0 = () => {
                return [parseCoords([0, "0"]), [[0, 0, 0]]];
            });
            exports_12("test_parseCoords_object_empty", test_parseCoords_object_empty = () => {
                return [parseCoords({}), [[0, 0, 0]]];
            });
            exports_12("test_parseCoords_array_object_empty", test_parseCoords_array_object_empty = () => {
                return [parseCoords([{}]), [[0, 0, 0]]];
            });
            exports_12("test_parseCoords_array_object_object_empty", test_parseCoords_array_object_object_empty = () => {
                return [
                    parseCoords([{}, {}]),
                    [
                        [0, 0, 0],
                        [0, 0, 0]
                    ]
                ];
            });
            exports_12("test_parseCoords_everything_empty", test_parseCoords_everything_empty = () => {
                return [
                    parseCoords(["0", 0, [], {}]),
                    [
                        [0, 0, 0],
                        [0, 0, 0],
                        [0, 0, 0],
                        [0, 0, 0]
                    ]
                ];
            });
            // Strings
            exports_12("test_parseCoords_string_empty", test_parseCoords_string_empty = () => {
                return [parseCoords(" "), [[0, 0, 0]]];
            });
            exports_12("test_parseCoords_string_empty_to_scale", test_parseCoords_string_empty_to_scale = () => {
                return [parseCoords(" ", normalizeScale), [[1, 1, 1]]];
            });
            exports_12("test_parseCoords_string_0", test_parseCoords_string_0 = () => {
                return [parseCoords("0"), [[0, 0, 0]]];
            });
            exports_12("test_parseCoords_string_0_to_scale", test_parseCoords_string_0_to_scale = () => {
                return [parseCoords("0", normalizeScale), [[0, 0, 0]]];
            });
            exports_12("test_parseCoords_string_1", test_parseCoords_string_1 = () => {
                return [parseCoords("1"), [[1, 0, 0]]];
            });
            exports_12("test_parseCoords_string_1_1", test_parseCoords_string_1_1 = () => {
                return [parseCoords("1 1"), [[1, 1, 0]]];
            });
            exports_12("test_parseCoords_string_1_1_a_spaced", test_parseCoords_string_1_1_a_spaced = () => {
                return [parseCoords("1  1        a"), [[1, 1, 0]]];
            });
            exports_12("test_parseCoords_string_1_1_a_1_spaced", test_parseCoords_string_1_1_a_1_spaced = () => {
                return [parseCoords("1  1        a 1"), [[1, 1, 0]]];
            });
            exports_12("test_parseCoords_string_1_and_1", test_parseCoords_string_1_and_1 = () => {
                return [
                    parseCoords("1,1"),
                    [
                        [1, 0, 0],
                        [1, 0, 0]
                    ]
                ];
            });
            exports_12("test_parseCoords_string_1_and_1_in_array", test_parseCoords_string_1_and_1_in_array = () => {
                return [parseCoords(["1", "1"]), [[1, 1, 0]]];
            });
            exports_12("test_parseCoords_string_1_1_and_1_1_in_array", test_parseCoords_string_1_1_and_1_1_in_array = () => {
                return [
                    parseCoords(["1 1", "1 1"]),
                    [
                        [1, 1, 0],
                        [1, 1, 0]
                    ]
                ];
            });
            exports_12("test_parseCoords_string_1_and_1_spaced", test_parseCoords_string_1_and_1_spaced = () => {
                return [
                    parseCoords("1 ,   1"),
                    [
                        [1, 0, 0],
                        [1, 0, 0]
                    ]
                ];
            });
            exports_12("test_parseCoords_string_1_1_and_1_1", test_parseCoords_string_1_1_and_1_1 = () => {
                return [
                    parseCoords("1 1, 1 1"),
                    [
                        [1, 1, 0],
                        [1, 1, 0]
                    ]
                ];
            });
            exports_12("test_parseCoords_string_1_1_1", test_parseCoords_string_1_1_1 = () => {
                return [parseCoords("1 1 1"), [[1, 1, 1]]];
            });
            exports_12("test_parseCoords_string_1_1_1_1", test_parseCoords_string_1_1_1_1 = () => {
                return [parseCoords("1 1 1 1"), [[1, 1, 1]]];
            });
            exports_12("test_parseCoords_string_1_1_1_and_1_1_1", test_parseCoords_string_1_1_1_and_1_1_1 = () => {
                return [
                    parseCoords("1 1 1, 1 1 1"),
                    [
                        [1, 1, 1],
                        [1, 1, 1]
                    ]
                ];
            });
            exports_12("test_parseCoords_string_1_1_1_1_and_1_1_1_1", test_parseCoords_string_1_1_1_1_and_1_1_1_1 = () => {
                return [parseCoords("1 1 1 1, 1 1 1 1")[([1, 1, 1], [1, 1, 1])]];
            });
            // Test numbers
            exports_12("test_parseCoords_number_0", test_parseCoords_number_0 = () => {
                return [parseCoords(0), [[0, 0, 0]]];
            });
            exports_12("test_parseCoords_number_1", test_parseCoords_number_1 = () => {
                return [parseCoords(1), [[1, 0, 0]]];
            });
            exports_12("test_parseCoords_number_2", test_parseCoords_number_2 = () => {
                return [parseCoords(2), [[2, 0, 0]]];
            });
            exports_12("test_parseCoords_number_1_to_scale", test_parseCoords_number_1_to_scale = () => {
                return [parseCoords(1, normalizeScale), [[1, 1, 1]]];
            });
            exports_12("test_parseCoords_number_2_to_scale", test_parseCoords_number_2_to_scale = () => {
                return [parseCoords(2, normalizeScale), [[2, 2, 2]]];
            });
            exports_12("test_parseCoords_number_01", test_parseCoords_number_01 = () => {
                return [parseCoords(0.1), [[0.1, 0, 0]]];
            });
            exports_12("test_parseCoords_number_1_in_array", test_parseCoords_number_1_in_array = () => {
                return [parseCoords([1]), [[1, 0, 0]]];
            });
            exports_12("test_parseCoords_number_1_in_array_array", test_parseCoords_number_1_in_array_array = () => {
                return [parseCoords([[1]]), [[1, 0, 0]]];
            });
            exports_12("test_parseCoords_number_1_1_in_array", test_parseCoords_number_1_1_in_array = () => {
                return [parseCoords([1, 1]), [[1, 1, 0]]];
            });
            exports_12("test_parseCoords_number_1_1_in_array_array", test_parseCoords_number_1_1_in_array_array = () => {
                return [parseCoords([[1, 1]]), [[1, 1, 0]]];
            });
            exports_12("test_parseCoords_array_number_1_1_1_in_array", test_parseCoords_array_number_1_1_1_in_array = () => {
                return [parseCoords([1, 1, 1]), [[1, 1, 1]]];
            });
            exports_12("test_parseCoords_number_1_1_1_in_array_array", test_parseCoords_number_1_1_1_in_array_array = () => {
                return [parseCoords([[1, 1, 1]]), [[1, 1, 1]]];
            });
            exports_12("test_parseCoords_number_1_1_1_1_in_array_array", test_parseCoords_number_1_1_1_1_in_array_array = () => {
                return [parseCoords([[1, 1, 1, 1]]), [[1, 1, 1]]];
            });
            exports_12("test_parseCoords_array_number_1_1_1", test_parseCoords_array_number_1_1_1 = () => {
                return [parseCoords([1, 1, 1]), [[1, 1, 1]]];
            });
            exports_12("test_parseCoords_array_number_1_1_1_1", test_parseCoords_array_number_1_1_1_1 = () => {
                return [parseCoords([1, 1, 1, 1]), [[1, 1, 1]]];
            });
            // Test objects
            exports_12("test_parseCoords_object_0", test_parseCoords_object_0 = () => {
                return [parseCoords({ x: 0 }), [[0, 0, 0]]];
            });
            exports_12("test_parseCoords_object_string_1", test_parseCoords_object_string_1 = () => {
                return [parseCoords({ x: "1" }), [[1, 0, 0]]];
            });
            exports_12("test_parseCoords_object_number_1", test_parseCoords_object_number_1 = () => {
                return [parseCoords({ x: "1" }), [[1, 0, 0]]];
            });
            exports_12("test_parseCoords_object_number_1_1", test_parseCoords_object_number_1_1 = () => {
                return [parseCoords({ x: 1, y: 1 }), [[1, 1, 0]]];
            });
            exports_12("test_parseCoords_object_number_1_1_1", test_parseCoords_object_number_1_1_1 = () => {
                return [parseCoords({ x: 1, y: 1, z: 1 }), [[1, 1, 1]]];
            });
            exports_12("test_parseCoords_object_number_1_1_1_gibberish", test_parseCoords_object_number_1_1_1_gibberish = () => {
                return [parseCoords({ x: 1, y: 1, z: 1, a: 1 }), [[1, 1, 1]]];
            });
            exports_12("test_parseCoords_object_number_01", test_parseCoords_object_number_01 = () => {
                return [parseCoords({ x: "0.1" }), [[0.1, 0, 0]]];
            });
            exports_12("test_parseCoords_object_number_1_in_array", test_parseCoords_object_number_1_in_array = () => {
                return [parseCoords([{ x: 1 }]), [[1, 0, 0]]];
            });
            exports_12("test_parseCoords_object_number_1_1_in_array", test_parseCoords_object_number_1_1_in_array = () => {
                return [
                    parseCoords([{ x: 1 }, { x: 1 }]),
                    [
                        [1, 0, 0],
                        [1, 0, 0]
                    ]
                ];
            });
            exports_12("test_parseCoords_object_number_1_1_1_in_array", test_parseCoords_object_number_1_1_1_in_array = () => {
                return [
                    parseCoords([{ x: 1 }, { x: 1 }, { x: 1 }]),
                    [
                        [1, 0, 0],
                        [1, 0, 0],
                        [1, 0, 0]
                    ]
                ];
            });
            exports_12("test_parseCoords_object_number_1_1_1_1_in_array", test_parseCoords_object_number_1_1_1_1_in_array = () => {
                return [
                    parseCoords([{ x: 1 }, { x: 1 }, { x: 1 }, { x: 1 }]),
                    [
                        [1, 0, 0],
                        [1, 0, 0],
                        [1, 0, 0],
                        [1, 0, 0]
                    ]
                ];
            });
            exports_12("test_parseCoords_object_everything_in_array", test_parseCoords_object_everything_in_array = () => {
                return [
                    parseCoords([
                        { x: 1, y: "1", z: false },
                        { x: 1, y: 1, z: null, a: 1 }
                    ]),
                    [
                        [1, 1, 0],
                        [1, 1, 0]
                    ]
                ];
            });
            exports_12("test_parseCoords_array_number_1_1_1_in_array_array", test_parseCoords_array_number_1_1_1_in_array_array = () => {
                return [parseCoords([[1, 1, 1]]), [[1, 1, 1]]];
            });
            // Mixed coordinate values
            exports_12("test_parseCoords_array_array_number_string_1_1", test_parseCoords_array_array_number_string_1_1 = () => {
                return [parseCoords([[1, "1"]]), [[1, 1, 0]]];
            });
            exports_12("test_parseCoords_array_1_sting_1", test_parseCoords_array_1_sting_1 = () => {
                return [
                    parseCoords([[1], "1"]),
                    [
                        [1, 0, 0],
                        [1, 0, 0]
                    ]
                ];
            });
            exports_12("test_parseCoords_array_1_number_1", test_parseCoords_array_1_number_1 = () => {
                return [
                    parseCoords([[1], 1]),
                    [
                        [1, 0, 0],
                        [1, 0, 0]
                    ]
                ];
            });
            exports_12("test_parseCoords_array_1_object_1", test_parseCoords_array_1_object_1 = () => {
                return [
                    parseCoords([[1], { x: 1 }]),
                    [
                        [1, 0, 0],
                        [1, 0, 0]
                    ]
                ];
            });
        }
    };
});
System.register("http://localhost:5501/src/internals/size", ["http://localhost:5501/src/deps/vue", "http://localhost:5501/fachwerk"], function (exports_13, context_13) {
    "use strict";
    var vue_js_2, fachwerk_js_2, sizeProps, useSize;
    var __moduleName = context_13 && context_13.id;
    return {
        setters: [
            function (vue_js_2_1) {
                vue_js_2 = vue_js_2_1;
            },
            function (fachwerk_js_2_1) {
                fachwerk_js_2 = fachwerk_js_2_1;
            }
        ],
        execute: function () {
            exports_13("sizeProps", sizeProps = {
                width: { default: 300, type: [String, Number] },
                height: { default: 300, type: [String, Number] }
            });
            exports_13("useSize", useSize = props => {
                const width = vue_js_2.computed(() => fachwerk_js_2.toNumber(props.width));
                const height = vue_js_2.computed(() => fachwerk_js_2.toNumber(props.height));
                const viewBox = vue_js_2.computed(() => `0 0 ${props.width} ${props.height}`);
                return { width, height, viewBox };
            });
        }
    };
});
// Polyfills
System.register("https://unpkg.com/three@0.113.2/build/three.module", [], function (exports_14, context_14) {
    "use strict";
    var REVISION, MOUSE, TOUCH, CullFaceNone, CullFaceBack, CullFaceFront, CullFaceFrontBack, FrontFaceDirectionCW, FrontFaceDirectionCCW, BasicShadowMap, PCFShadowMap, PCFSoftShadowMap, VSMShadowMap, FrontSide, BackSide, DoubleSide, FlatShading, SmoothShading, NoColors, FaceColors, VertexColors, NoBlending, NormalBlending, AdditiveBlending, SubtractiveBlending, MultiplyBlending, CustomBlending, AddEquation, SubtractEquation, ReverseSubtractEquation, MinEquation, MaxEquation, ZeroFactor, OneFactor, SrcColorFactor, OneMinusSrcColorFactor, SrcAlphaFactor, OneMinusSrcAlphaFactor, DstAlphaFactor, OneMinusDstAlphaFactor, DstColorFactor, OneMinusDstColorFactor, SrcAlphaSaturateFactor, NeverDepth, AlwaysDepth, LessDepth, LessEqualDepth, EqualDepth, GreaterEqualDepth, GreaterDepth, NotEqualDepth, MultiplyOperation, MixOperation, AddOperation, NoToneMapping, LinearToneMapping, ReinhardToneMapping, Uncharted2ToneMapping, CineonToneMapping, ACESFilmicToneMapping, UVMapping, CubeReflectionMapping, CubeRefractionMapping, EquirectangularReflectionMapping, EquirectangularRefractionMapping, SphericalReflectionMapping, CubeUVReflectionMapping, CubeUVRefractionMapping, RepeatWrapping, ClampToEdgeWrapping, MirroredRepeatWrapping, NearestFilter, NearestMipmapNearestFilter, NearestMipMapNearestFilter, NearestMipmapLinearFilter, NearestMipMapLinearFilter, LinearFilter, LinearMipmapNearestFilter, LinearMipMapNearestFilter, LinearMipmapLinearFilter, LinearMipMapLinearFilter, UnsignedByteType, ByteType, ShortType, UnsignedShortType, IntType, UnsignedIntType, FloatType, HalfFloatType, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedShort565Type, UnsignedInt248Type, AlphaFormat, RGBFormat, RGBAFormat, LuminanceFormat, LuminanceAlphaFormat, RGBEFormat, DepthFormat, DepthStencilFormat, RedFormat, RedIntegerFormat, RGFormat, RGIntegerFormat, RGBIntegerFormat, RGBAIntegerFormat, RGB_S3TC_DXT1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGB_PVRTC_4BPPV1_Format, RGB_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_PVRTC_2BPPV1_Format, RGB_ETC1_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_10x10_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, LoopOnce, LoopRepeat, LoopPingPong, InterpolateDiscrete, InterpolateLinear, InterpolateSmooth, ZeroCurvatureEnding, ZeroSlopeEnding, WrapAroundEnding, TrianglesDrawMode, TriangleStripDrawMode, TriangleFanDrawMode, LinearEncoding, sRGBEncoding, GammaEncoding, RGBEEncoding, LogLuvEncoding, RGBM7Encoding, RGBM16Encoding, RGBDEncoding, BasicDepthPacking, RGBADepthPacking, TangentSpaceNormalMap, ObjectSpaceNormalMap, ZeroStencilOp, KeepStencilOp, ReplaceStencilOp, IncrementStencilOp, DecrementStencilOp, IncrementWrapStencilOp, DecrementWrapStencilOp, InvertStencilOp, NeverStencilFunc, LessStencilFunc, EqualStencilFunc, LessEqualStencilFunc, GreaterStencilFunc, NotEqualStencilFunc, GreaterEqualStencilFunc, AlwaysStencilFunc, StaticDrawUsage, DynamicDrawUsage, StreamDrawUsage, StaticReadUsage, DynamicReadUsage, StreamReadUsage, StaticCopyUsage, DynamicCopyUsage, StreamCopyUsage, _lut, i, MathUtils, _canvas, ImageUtils, textureId, _vector, _quaternion, _v1, _m1, _zero, _one, _x, _y, _z, _matrix, _quaternion$1, _object3DId, _v1$1, _q1, _m1$1, _target, _position, _scale, _quaternion$2, _xAxis, _yAxis, _zAxis, _addedEvent, _removedEvent, _points, _vector$1, _box, _v0, _v1$2, _v2, _f0, _f1, _f2, _center, _extents, _triangleNormal, _testAxis, _box$1, _vector$2, _segCenter, _segDir, _diff, _edge1, _edge2, _normal, _vector1, _vector2, _normalMatrix, _v0$1, _v1$3, _v2$1, _v3, _vab, _vac, _vbc, _vap, _vbp, _vcp, _colorKeywords, _hslA, _hslB, materialId, _vector$3, _bufferGeometryId, _m1$2, _obj, _offset, _box$2, _boxMorphTargets, _vector$4, _inverseMatrix, _ray, _sphere, _vA, _vB, _vC, _tempA, _tempB, _tempC, _morphA, _morphB, _morphC, _uvA, _uvB, _uvC, _intersectionPoint, _intersectionPointWorld, _geometryId, _m1$3, _obj$1, _offset$1, BoxGeometry, BoxBufferGeometry, UniformsUtils, default_vertex, default_fragment, fov, aspect, _sphere$1, _vector$5, UniformsLib, alphamap_fragment, alphamap_pars_fragment, alphatest_fragment, aomap_fragment, aomap_pars_fragment, begin_vertex, beginnormal_vertex, bsdfs, bumpmap_pars_fragment, clipping_planes_fragment, clipping_planes_pars_fragment, clipping_planes_pars_vertex, clipping_planes_vertex, color_fragment, color_pars_fragment, color_pars_vertex, color_vertex, common, cube_uv_reflection_fragment, defaultnormal_vertex, displacementmap_pars_vertex, displacementmap_vertex, emissivemap_fragment, emissivemap_pars_fragment, encodings_fragment, encodings_pars_fragment, envmap_fragment, envmap_common_pars_fragment, envmap_pars_fragment, envmap_pars_vertex, envmap_vertex, fog_vertex, fog_pars_vertex, fog_fragment, fog_pars_fragment, gradientmap_pars_fragment, lightmap_fragment, lightmap_pars_fragment, lights_lambert_vertex, lights_pars_begin, envmap_physical_pars_fragment, lights_toon_fragment, lights_toon_pars_fragment, lights_phong_fragment, lights_phong_pars_fragment, lights_physical_fragment, lights_physical_pars_fragment, lights_fragment_begin, lights_fragment_maps, lights_fragment_end, logdepthbuf_fragment, logdepthbuf_pars_fragment, logdepthbuf_pars_vertex, logdepthbuf_vertex, map_fragment, map_pars_fragment, map_particle_fragment, map_particle_pars_fragment, metalnessmap_fragment, metalnessmap_pars_fragment, morphnormal_vertex, morphtarget_pars_vertex, morphtarget_vertex, normal_fragment_begin, normal_fragment_maps, normalmap_pars_fragment, clearcoat_normal_fragment_begin, clearcoat_normal_fragment_maps, clearcoat_normalmap_pars_fragment, packing, premultiplied_alpha_fragment, project_vertex, dithering_fragment, dithering_pars_fragment, roughnessmap_fragment, roughnessmap_pars_fragment, shadowmap_pars_fragment, shadowmap_pars_vertex, shadowmap_vertex, shadowmask_pars_fragment, skinbase_vertex, skinning_pars_vertex, skinning_vertex, skinnormal_vertex, specularmap_fragment, specularmap_pars_fragment, tonemapping_fragment, tonemapping_pars_fragment, uv_pars_fragment, uv_pars_vertex, uv_vertex, uv2_pars_fragment, uv2_pars_vertex, uv2_vertex, worldpos_vertex, background_frag, background_vert, cube_frag, cube_vert, depth_frag, depth_vert, distanceRGBA_frag, distanceRGBA_vert, equirect_frag, equirect_vert, linedashed_frag, linedashed_vert, meshbasic_frag, meshbasic_vert, meshlambert_frag, meshlambert_vert, meshmatcap_frag, meshmatcap_vert, meshtoon_frag, meshtoon_vert, meshphong_frag, meshphong_vert, meshphysical_frag, meshphysical_vert, normal_frag, normal_vert, points_frag, points_vert, shadow_frag, shadow_vert, sprite_frag, sprite_vert, ShaderChunk, ShaderLib, emptyTexture, emptyTexture2dArray, emptyTexture3d, emptyCubeTexture, arrayCacheF32, arrayCacheI32, mat4array, mat3array, mat2array, RePathPart, programIdCount, includePattern, loopPattern, nextVersion, vsm_frag, vsm_vert, _vector$6, _geometry, _intersectPoint, _worldScale, _mvPosition, _alignedPosition, _rotatedPosition, _viewWorldMatrix, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, _v1$4, _v2$2, _offsetMatrix, _identityMatrix, _instanceLocalMatrix, _instanceWorldMatrix, _instanceIntersects, _mesh, _start, _end, _inverseMatrix$1, _ray$1, _sphere$2, _start$1, _end$1, _inverseMatrix$2, _ray$2, _sphere$3, _position$1, Earcut, ShapeUtils, WorldUVGenerator, Geometries, Materials, AnimationUtils, Cache, DefaultLoadingManager, loading, tmp, px, py, pz, Curves, LoaderUtils, TYPED_ARRAYS, TEXTURE_MAPPING, TEXTURE_WRAPPING, TEXTURE_FILTER, _context, AudioContext, _eyeRight, _eyeLeft, _position$2, _quaternion$3, _scale$1, _orientation, _position$3, _quaternion$4, _scale$2, _orientation$1, _RESERVED_CHARS_RE, _reservedRe, _wordChar, _wordCharOrDot, _directoryRe, _nodeRe, _objectRe, _propertyRe, _trackRe, _supportedObjectNames, _vector$7, _startP, _startEnd, _vector$8, _vector$9, _boneMatrix, _matrixWorldInv, _vector$a, _color1, _color2, _v1$5, _v2$3, _v3$1, _vector$b, _camera, _box$3, _axis, _lineGeometry, _coneGeometry, LOD_MIN, LOD_MAX, SIZE_MAX, EXTRA_LOD_SIGMA, TOTAL_LODS, MAX_SAMPLES, ENCODINGS, _flatCamera, _blurMaterial, _equirectShader, _cubemapShader, _a, _lodPlanes, _sizeLods, _sigmas, _pingPongRenderTarget, _renderer, _oldTarget, PHI, INV_PHI, _axisDirections, LineStrip, LinePieces, GeometryUtils, SceneUtils;
    var __moduleName = context_14 && context_14.id;
    /**
     * https://github.com/mrdoob/eventdispatcher.js/
     */
    function EventDispatcher() { }
    exports_14("EventDispatcher", EventDispatcher);
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author philogb / http://blog.thejit.org/
     * @author egraether / http://egraether.com/
     * @author zz85 / http://www.lab4games.net/zz85/blog
     */
    function Vector2(x, y) {
        this.x = x || 0;
        this.y = y || 0;
    }
    exports_14("Vector2", Vector2);
    /**
     * @author alteredq / http://alteredqualia.com/
     * @author WestLangley / http://github.com/WestLangley
     * @author bhouston / http://clara.io
     * @author tschw
     */
    function Matrix3() {
        this.elements = [
            1, 0, 0,
            0, 1, 0,
            0, 0, 1
        ];
        if (arguments.length > 0) {
            console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');
        }
    }
    exports_14("Matrix3", Matrix3);
    function Texture(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
        Object.defineProperty(this, 'id', { value: textureId++ });
        this.uuid = MathUtils.generateUUID();
        this.name = '';
        this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
        this.mipmaps = [];
        this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;
        this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;
        this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;
        this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
        this.minFilter = minFilter !== undefined ? minFilter : LinearMipmapLinearFilter;
        this.anisotropy = anisotropy !== undefined ? anisotropy : 1;
        this.format = format !== undefined ? format : RGBAFormat;
        this.internalFormat = null;
        this.type = type !== undefined ? type : UnsignedByteType;
        this.offset = new Vector2(0, 0);
        this.repeat = new Vector2(1, 1);
        this.center = new Vector2(0, 0);
        this.rotation = 0;
        this.matrixAutoUpdate = true;
        this.matrix = new Matrix3();
        this.generateMipmaps = true;
        this.premultiplyAlpha = false;
        this.flipY = true;
        this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
        // Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
        //
        // Also changing the encoding after already used by a Material will not automatically make the Material
        // update. You need to explicitly call Material.needsUpdate to trigger it to recompile.
        this.encoding = encoding !== undefined ? encoding : LinearEncoding;
        this.version = 0;
        this.onUpdate = null;
    }
    exports_14("Texture", Texture);
    /**
     * @author supereggbert / http://www.paulbrunt.co.uk/
     * @author philogb / http://blog.thejit.org/
     * @author mikael emtinger / http://gomo.se/
     * @author egraether / http://egraether.com/
     * @author WestLangley / http://github.com/WestLangley
     */
    function Vector4(x, y, z, w) {
        this.x = x || 0;
        this.y = y || 0;
        this.z = z || 0;
        this.w = (w !== undefined) ? w : 1;
    }
    exports_14("Vector4", Vector4);
    /**
     * @author szimek / https://github.com/szimek/
     * @author alteredq / http://alteredqualia.com/
     * @author Marius Kintel / https://github.com/kintel
     */
    /*
     In options, we can specify:
     * Texture parameters for an auto-generated target texture
     * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
    */
    function WebGLRenderTarget(width, height, options) {
        this.width = width;
        this.height = height;
        this.scissor = new Vector4(0, 0, width, height);
        this.scissorTest = false;
        this.viewport = new Vector4(0, 0, width, height);
        options = options || {};
        this.texture = new Texture(undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
        this.texture.image = {};
        this.texture.image.width = width;
        this.texture.image.height = height;
        this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
        this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;
        this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
        this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
        this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;
    }
    exports_14("WebGLRenderTarget", WebGLRenderTarget);
    /**
     * @author Mugen87 / https://github.com/Mugen87
     * @author Matt DesLauriers / @mattdesl
     */
    function WebGLMultisampleRenderTarget(width, height, options) {
        WebGLRenderTarget.call(this, width, height, options);
        this.samples = 4;
    }
    exports_14("WebGLMultisampleRenderTarget", WebGLMultisampleRenderTarget);
    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     * @author WestLangley / http://github.com/WestLangley
     * @author bhouston / http://clara.io
     */
    function Quaternion(x, y, z, w) {
        this._x = x || 0;
        this._y = y || 0;
        this._z = z || 0;
        this._w = (w !== undefined) ? w : 1;
    }
    exports_14("Quaternion", Quaternion);
    function Vector3(x, y, z) {
        this.x = x || 0;
        this.y = y || 0;
        this.z = z || 0;
    }
    exports_14("Vector3", Vector3);
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author supereggbert / http://www.paulbrunt.co.uk/
     * @author philogb / http://blog.thejit.org/
     * @author jordi_ros / http://plattsoft.com
     * @author D1plo1d / http://github.com/D1plo1d
     * @author alteredq / http://alteredqualia.com/
     * @author mikael emtinger / http://gomo.se/
     * @author timknip / http://www.floorplanner.com/
     * @author bhouston / http://clara.io
     * @author WestLangley / http://github.com/WestLangley
     */
    function Matrix4() {
        this.elements = [
            1, 0, 0, 0,
            0, 1, 0, 0,
            0, 0, 1, 0,
            0, 0, 0, 1
        ];
        if (arguments.length > 0) {
            console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');
        }
    }
    exports_14("Matrix4", Matrix4);
    function Euler(x, y, z, order) {
        this._x = x || 0;
        this._y = y || 0;
        this._z = z || 0;
        this._order = order || Euler.DefaultOrder;
    }
    exports_14("Euler", Euler);
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    function Layers() {
        this.mask = 1 | 0;
    }
    exports_14("Layers", Layers);
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     * @author WestLangley / http://github.com/WestLangley
     * @author elephantatwork / www.elephantatwork.ch
     */
    function Object3D() {
        Object.defineProperty(this, 'id', { value: _object3DId++ });
        this.uuid = MathUtils.generateUUID();
        this.name = '';
        this.type = 'Object3D';
        this.parent = null;
        this.children = [];
        this.up = Object3D.DefaultUp.clone();
        var position = new Vector3();
        var rotation = new Euler();
        var quaternion = new Quaternion();
        var scale = new Vector3(1, 1, 1);
        function onRotationChange() {
            quaternion.setFromEuler(rotation, false);
        }
        function onQuaternionChange() {
            rotation.setFromQuaternion(quaternion, undefined, false);
        }
        rotation._onChange(onRotationChange);
        quaternion._onChange(onQuaternionChange);
        Object.defineProperties(this, {
            position: {
                configurable: true,
                enumerable: true,
                value: position
            },
            rotation: {
                configurable: true,
                enumerable: true,
                value: rotation
            },
            quaternion: {
                configurable: true,
                enumerable: true,
                value: quaternion
            },
            scale: {
                configurable: true,
                enumerable: true,
                value: scale
            },
            modelViewMatrix: {
                value: new Matrix4()
            },
            normalMatrix: {
                value: new Matrix3()
            }
        });
        this.matrix = new Matrix4();
        this.matrixWorld = new Matrix4();
        this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
        this.matrixWorldNeedsUpdate = false;
        this.layers = new Layers();
        this.visible = true;
        this.castShadow = false;
        this.receiveShadow = false;
        this.frustumCulled = true;
        this.renderOrder = 0;
        this.userData = {};
    }
    exports_14("Object3D", Object3D);
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    function Scene() {
        Object3D.call(this);
        this.type = 'Scene';
        this.background = null;
        this.environment = null;
        this.fog = null;
        this.overrideMaterial = null;
        this.autoUpdate = true; // checked by the renderer
        if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
            __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', { detail: this })); // eslint-disable-line no-undef
        }
    }
    exports_14("Scene", Scene);
    /**
     * @author bhouston / http://clara.io
     * @author WestLangley / http://github.com/WestLangley
     */
    function Box3(min, max) {
        this.min = (min !== undefined) ? min : new Vector3(+Infinity, +Infinity, +Infinity);
        this.max = (max !== undefined) ? max : new Vector3(-Infinity, -Infinity, -Infinity);
    }
    exports_14("Box3", Box3);
    function satForAxes(axes, v0, v1, v2, extents) {
        var i, j;
        for (i = 0, j = axes.length - 3; i <= j; i += 3) {
            _testAxis.fromArray(axes, i);
            // project the aabb onto the seperating axis
            var r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
            // project all 3 vertices of the triangle onto the seperating axis
            var p0 = v0.dot(_testAxis);
            var p1 = v1.dot(_testAxis);
            var p2 = v2.dot(_testAxis);
            // actual test, basically see if either of the most extreme of the triangle points intersects r
            if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
                // points of the projected triangle are outside the projected half-length of the aabb
                // the axis is seperating and we can exit
                return false;
            }
        }
        return true;
    }
    /**
     * @author bhouston / http://clara.io
     * @author mrdoob / http://mrdoob.com/
     */
    function Sphere(center, radius) {
        this.center = (center !== undefined) ? center : new Vector3();
        this.radius = (radius !== undefined) ? radius : 0;
    }
    exports_14("Sphere", Sphere);
    /**
     * @author bhouston / http://clara.io
     */
    function Ray(origin, direction) {
        this.origin = (origin !== undefined) ? origin : new Vector3();
        this.direction = (direction !== undefined) ? direction : new Vector3(0, 0, -1);
    }
    exports_14("Ray", Ray);
    function Plane(normal, constant) {
        // normal is assumed to be normalized
        this.normal = (normal !== undefined) ? normal : new Vector3(1, 0, 0);
        this.constant = (constant !== undefined) ? constant : 0;
    }
    exports_14("Plane", Plane);
    function Triangle(a, b, c) {
        this.a = (a !== undefined) ? a : new Vector3();
        this.b = (b !== undefined) ? b : new Vector3();
        this.c = (c !== undefined) ? c : new Vector3();
    }
    exports_14("Triangle", Triangle);
    function Color(r, g, b) {
        if (g === undefined && b === undefined) {
            // r is THREE.Color, hex or string
            return this.set(r);
        }
        return this.setRGB(r, g, b);
    }
    exports_14("Color", Color);
    function hue2rgb(p, q, t) {
        if (t < 0)
            t += 1;
        if (t > 1)
            t -= 1;
        if (t < 1 / 6)
            return p + (q - p) * 6 * t;
        if (t < 1 / 2)
            return q;
        if (t < 2 / 3)
            return p + (q - p) * 6 * (2 / 3 - t);
        return p;
    }
    function SRGBToLinear(c) {
        return (c < 0.04045) ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
    }
    function LinearToSRGB(c) {
        return (c < 0.0031308) ? c * 12.92 : 1.055 * (Math.pow(c, 0.41666)) - 0.055;
    }
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */
    function Face3(a, b, c, normal, color, materialIndex) {
        this.a = a;
        this.b = b;
        this.c = c;
        this.normal = (normal && normal.isVector3) ? normal : new Vector3();
        this.vertexNormals = Array.isArray(normal) ? normal : [];
        this.color = (color && color.isColor) ? color : new Color();
        this.vertexColors = Array.isArray(color) ? color : [];
        this.materialIndex = materialIndex !== undefined ? materialIndex : 0;
    }
    exports_14("Face3", Face3);
    function Material() {
        Object.defineProperty(this, 'id', { value: materialId++ });
        this.uuid = MathUtils.generateUUID();
        this.name = '';
        this.type = 'Material';
        this.fog = true;
        this.blending = NormalBlending;
        this.side = FrontSide;
        this.flatShading = false;
        this.vertexTangents = false;
        this.vertexColors = NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors
        this.opacity = 1;
        this.transparent = false;
        this.blendSrc = SrcAlphaFactor;
        this.blendDst = OneMinusSrcAlphaFactor;
        this.blendEquation = AddEquation;
        this.blendSrcAlpha = null;
        this.blendDstAlpha = null;
        this.blendEquationAlpha = null;
        this.depthFunc = LessEqualDepth;
        this.depthTest = true;
        this.depthWrite = true;
        this.stencilWriteMask = 0xff;
        this.stencilFunc = AlwaysStencilFunc;
        this.stencilRef = 0;
        this.stencilFuncMask = 0xff;
        this.stencilFail = KeepStencilOp;
        this.stencilZFail = KeepStencilOp;
        this.stencilZPass = KeepStencilOp;
        this.stencilWrite = false;
        this.clippingPlanes = null;
        this.clipIntersection = false;
        this.clipShadows = false;
        this.shadowSide = null;
        this.colorWrite = true;
        this.precision = null; // override the renderer's default precision for this material
        this.polygonOffset = false;
        this.polygonOffsetFactor = 0;
        this.polygonOffsetUnits = 0;
        this.dithering = false;
        this.alphaTest = 0;
        this.premultipliedAlpha = false;
        this.visible = true;
        this.toneMapped = true;
        this.userData = {};
        this.version = 0;
    }
    exports_14("Material", Material);
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  color: <hex>,
     *  opacity: <float>,
     *  map: new THREE.Texture( <Image> ),
     *
     *  lightMap: new THREE.Texture( <Image> ),
     *  lightMapIntensity: <float>
     *
     *  aoMap: new THREE.Texture( <Image> ),
     *  aoMapIntensity: <float>
     *
     *  specularMap: new THREE.Texture( <Image> ),
     *
     *  alphaMap: new THREE.Texture( <Image> ),
     *
     *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
     *  combine: THREE.Multiply,
     *  reflectivity: <float>,
     *  refractionRatio: <float>,
     *
     *  depthTest: <bool>,
     *  depthWrite: <bool>,
     *
     *  wireframe: <boolean>,
     *  wireframeLinewidth: <float>,
     *
     *  skinning: <bool>,
     *  morphTargets: <bool>
     * }
     */
    function MeshBasicMaterial(parameters) {
        Material.call(this);
        this.type = 'MeshBasicMaterial';
        this.color = new Color(0xffffff); // emissive
        this.map = null;
        this.lightMap = null;
        this.lightMapIntensity = 1.0;
        this.aoMap = null;
        this.aoMapIntensity = 1.0;
        this.specularMap = null;
        this.alphaMap = null;
        this.envMap = null;
        this.combine = MultiplyOperation;
        this.reflectivity = 1;
        this.refractionRatio = 0.98;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = 'round';
        this.wireframeLinejoin = 'round';
        this.skinning = false;
        this.morphTargets = false;
        this.setValues(parameters);
    }
    exports_14("MeshBasicMaterial", MeshBasicMaterial);
    function BufferAttribute(array, itemSize, normalized) {
        if (Array.isArray(array)) {
            throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
        }
        this.name = '';
        this.array = array;
        this.itemSize = itemSize;
        this.count = array !== undefined ? array.length / itemSize : 0;
        this.normalized = normalized === true;
        this.usage = StaticDrawUsage;
        this.updateRange = { offset: 0, count: -1 };
        this.version = 0;
    }
    exports_14("BufferAttribute", BufferAttribute);
    //
    function Int8BufferAttribute(array, itemSize, normalized) {
        BufferAttribute.call(this, new Int8Array(array), itemSize, normalized);
    }
    exports_14("Int8BufferAttribute", Int8BufferAttribute);
    function Uint8BufferAttribute(array, itemSize, normalized) {
        BufferAttribute.call(this, new Uint8Array(array), itemSize, normalized);
    }
    exports_14("Uint8BufferAttribute", Uint8BufferAttribute);
    function Uint8ClampedBufferAttribute(array, itemSize, normalized) {
        BufferAttribute.call(this, new Uint8ClampedArray(array), itemSize, normalized);
    }
    exports_14("Uint8ClampedBufferAttribute", Uint8ClampedBufferAttribute);
    function Int16BufferAttribute(array, itemSize, normalized) {
        BufferAttribute.call(this, new Int16Array(array), itemSize, normalized);
    }
    exports_14("Int16BufferAttribute", Int16BufferAttribute);
    function Uint16BufferAttribute(array, itemSize, normalized) {
        BufferAttribute.call(this, new Uint16Array(array), itemSize, normalized);
    }
    exports_14("Uint16BufferAttribute", Uint16BufferAttribute);
    function Int32BufferAttribute(array, itemSize, normalized) {
        BufferAttribute.call(this, new Int32Array(array), itemSize, normalized);
    }
    exports_14("Int32BufferAttribute", Int32BufferAttribute);
    function Uint32BufferAttribute(array, itemSize, normalized) {
        BufferAttribute.call(this, new Uint32Array(array), itemSize, normalized);
    }
    exports_14("Uint32BufferAttribute", Uint32BufferAttribute);
    function Float32BufferAttribute(array, itemSize, normalized) {
        BufferAttribute.call(this, new Float32Array(array), itemSize, normalized);
    }
    exports_14("Float32BufferAttribute", Float32BufferAttribute);
    function Float64BufferAttribute(array, itemSize, normalized) {
        BufferAttribute.call(this, new Float64Array(array), itemSize, normalized);
    }
    exports_14("Float64BufferAttribute", Float64BufferAttribute);
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    function DirectGeometry() {
        this.vertices = [];
        this.normals = [];
        this.colors = [];
        this.uvs = [];
        this.uvs2 = [];
        this.groups = [];
        this.morphTargets = {};
        this.skinWeights = [];
        this.skinIndices = [];
        // this.lineDistances = [];
        this.boundingBox = null;
        this.boundingSphere = null;
        // update flags
        this.verticesNeedUpdate = false;
        this.normalsNeedUpdate = false;
        this.colorsNeedUpdate = false;
        this.uvsNeedUpdate = false;
        this.groupsNeedUpdate = false;
    }
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    function arrayMax(array) {
        if (array.length === 0)
            return -Infinity;
        var max = array[0];
        for (var i = 1, l = array.length; i < l; ++i) {
            if (array[i] > max)
                max = array[i];
        }
        return max;
    }
    function BufferGeometry() {
        Object.defineProperty(this, 'id', { value: _bufferGeometryId += 2 });
        this.uuid = MathUtils.generateUUID();
        this.name = '';
        this.type = 'BufferGeometry';
        this.index = null;
        this.attributes = {};
        this.morphAttributes = {};
        this.morphTargetsRelative = false;
        this.groups = [];
        this.boundingBox = null;
        this.boundingSphere = null;
        this.drawRange = { start: 0, count: Infinity };
        this.userData = {};
    }
    exports_14("BufferGeometry", BufferGeometry);
    function Mesh(geometry, material) {
        Object3D.call(this);
        this.type = 'Mesh';
        this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
        this.material = material !== undefined ? material : new MeshBasicMaterial();
        this.updateMorphTargets();
    }
    exports_14("Mesh", Mesh);
    function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
        var intersect;
        if (material.side === BackSide) {
            intersect = ray.intersectTriangle(pC, pB, pA, true, point);
        }
        else {
            intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);
        }
        if (intersect === null)
            return null;
        _intersectionPointWorld.copy(point);
        _intersectionPointWorld.applyMatrix4(object.matrixWorld);
        var distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
        if (distance < raycaster.near || distance > raycaster.far)
            return null;
        return {
            distance: distance,
            point: _intersectionPointWorld.clone(),
            object: object
        };
    }
    function checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c) {
        _vA.fromBufferAttribute(position, a);
        _vB.fromBufferAttribute(position, b);
        _vC.fromBufferAttribute(position, c);
        var morphInfluences = object.morphTargetInfluences;
        if (material.morphTargets && morphPosition && morphInfluences) {
            _morphA.set(0, 0, 0);
            _morphB.set(0, 0, 0);
            _morphC.set(0, 0, 0);
            for (var i = 0, il = morphPosition.length; i < il; i++) {
                var influence = morphInfluences[i];
                var morphAttribute = morphPosition[i];
                if (influence === 0)
                    continue;
                _tempA.fromBufferAttribute(morphAttribute, a);
                _tempB.fromBufferAttribute(morphAttribute, b);
                _tempC.fromBufferAttribute(morphAttribute, c);
                if (morphTargetsRelative) {
                    _morphA.addScaledVector(_tempA, influence);
                    _morphB.addScaledVector(_tempB, influence);
                    _morphC.addScaledVector(_tempC, influence);
                }
                else {
                    _morphA.addScaledVector(_tempA.sub(_vA), influence);
                    _morphB.addScaledVector(_tempB.sub(_vB), influence);
                    _morphC.addScaledVector(_tempC.sub(_vC), influence);
                }
            }
            _vA.add(_morphA);
            _vB.add(_morphB);
            _vC.add(_morphC);
        }
        var intersection = checkIntersection(object, material, raycaster, ray, _vA, _vB, _vC, _intersectionPoint);
        if (intersection) {
            if (uv) {
                _uvA.fromBufferAttribute(uv, a);
                _uvB.fromBufferAttribute(uv, b);
                _uvC.fromBufferAttribute(uv, c);
                intersection.uv = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());
            }
            if (uv2) {
                _uvA.fromBufferAttribute(uv2, a);
                _uvB.fromBufferAttribute(uv2, b);
                _uvC.fromBufferAttribute(uv2, c);
                intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());
            }
            var face = new Face3(a, b, c);
            Triangle.getNormal(_vA, _vB, _vC, face.normal);
            intersection.face = face;
        }
        return intersection;
    }
    function Geometry() {
        Object.defineProperty(this, 'id', { value: _geometryId += 2 });
        this.uuid = MathUtils.generateUUID();
        this.name = '';
        this.type = 'Geometry';
        this.vertices = [];
        this.colors = [];
        this.faces = [];
        this.faceVertexUvs = [[]];
        this.morphTargets = [];
        this.morphNormals = [];
        this.skinWeights = [];
        this.skinIndices = [];
        this.lineDistances = [];
        this.boundingBox = null;
        this.boundingSphere = null;
        // update flags
        this.elementsNeedUpdate = false;
        this.verticesNeedUpdate = false;
        this.uvsNeedUpdate = false;
        this.normalsNeedUpdate = false;
        this.colorsNeedUpdate = false;
        this.lineDistancesNeedUpdate = false;
        this.groupsNeedUpdate = false;
    }
    exports_14("Geometry", Geometry);
    /**
     * Uniform Utilities
     */
    function cloneUniforms(src) {
        var dst = {};
        for (var u in src) {
            dst[u] = {};
            for (var p in src[u]) {
                var property = src[u][p];
                if (property && (property.isColor ||
                    property.isMatrix3 || property.isMatrix4 ||
                    property.isVector2 || property.isVector3 || property.isVector4 ||
                    property.isTexture)) {
                    dst[u][p] = property.clone();
                }
                else if (Array.isArray(property)) {
                    dst[u][p] = property.slice();
                }
                else {
                    dst[u][p] = property;
                }
            }
        }
        return dst;
    }
    function mergeUniforms(uniforms) {
        var merged = {};
        for (var u = 0; u < uniforms.length; u++) {
            var tmp = cloneUniforms(uniforms[u]);
            for (var p in tmp) {
                merged[p] = tmp[p];
            }
        }
        return merged;
    }
    /**
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  defines: { "label" : "value" },
     *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
     *
     *  fragmentShader: <string>,
     *  vertexShader: <string>,
     *
     *  wireframe: <boolean>,
     *  wireframeLinewidth: <float>,
     *
     *  lights: <bool>,
     *
     *  skinning: <bool>,
     *  morphTargets: <bool>,
     *  morphNormals: <bool>
     * }
     */
    function ShaderMaterial(parameters) {
        Material.call(this);
        this.type = 'ShaderMaterial';
        this.defines = {};
        this.uniforms = {};
        this.vertexShader = default_vertex;
        this.fragmentShader = default_fragment;
        this.linewidth = 1;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.fog = false; // set to use scene fog
        this.lights = false; // set to use scene lights
        this.clipping = false; // set to use user-defined clipping planes
        this.skinning = false; // set to use skinning attribute streams
        this.morphTargets = false; // set to use morph targets
        this.morphNormals = false; // set to use morph normals
        this.extensions = {
            derivatives: false,
            fragDepth: false,
            drawBuffers: false,
            shaderTextureLOD: false // set to use shader texture LOD
        };
        // When rendered geometry doesn't include these attributes but the material does,
        // use these default values in WebGL. This avoids errors when buffer data is missing.
        this.defaultAttributeValues = {
            'color': [1, 1, 1],
            'uv': [0, 0],
            'uv2': [0, 0]
        };
        this.index0AttributeName = undefined;
        this.uniformsNeedUpdate = false;
        if (parameters !== undefined) {
            if (parameters.attributes !== undefined) {
                console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');
            }
            this.setValues(parameters);
        }
    }
    exports_14("ShaderMaterial", ShaderMaterial);
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author mikael emtinger / http://gomo.se/
     * @author WestLangley / http://github.com/WestLangley
    */
    function Camera() {
        Object3D.call(this);
        this.type = 'Camera';
        this.matrixWorldInverse = new Matrix4();
        this.projectionMatrix = new Matrix4();
        this.projectionMatrixInverse = new Matrix4();
    }
    exports_14("Camera", Camera);
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author greggman / http://games.greggman.com/
     * @author zz85 / http://www.lab4games.net/zz85/blog
     * @author tschw
     */
    function PerspectiveCamera(fov, aspect, near, far) {
        Camera.call(this);
        this.type = 'PerspectiveCamera';
        this.fov = fov !== undefined ? fov : 50;
        this.zoom = 1;
        this.near = near !== undefined ? near : 0.1;
        this.far = far !== undefined ? far : 2000;
        this.focus = 10;
        this.aspect = aspect !== undefined ? aspect : 1;
        this.view = null;
        this.filmGauge = 35; // width of the film (default in millimeters)
        this.filmOffset = 0; // horizontal film offset (same unit as gauge)
        this.updateProjectionMatrix();
    }
    exports_14("PerspectiveCamera", PerspectiveCamera);
    function CubeCamera(near, far, cubeResolution, options) {
        Object3D.call(this);
        this.type = 'CubeCamera';
        var cameraPX = new PerspectiveCamera(fov, aspect, near, far);
        cameraPX.up.set(0, -1, 0);
        cameraPX.lookAt(new Vector3(1, 0, 0));
        this.add(cameraPX);
        var cameraNX = new PerspectiveCamera(fov, aspect, near, far);
        cameraNX.up.set(0, -1, 0);
        cameraNX.lookAt(new Vector3(-1, 0, 0));
        this.add(cameraNX);
        var cameraPY = new PerspectiveCamera(fov, aspect, near, far);
        cameraPY.up.set(0, 0, 1);
        cameraPY.lookAt(new Vector3(0, 1, 0));
        this.add(cameraPY);
        var cameraNY = new PerspectiveCamera(fov, aspect, near, far);
        cameraNY.up.set(0, 0, -1);
        cameraNY.lookAt(new Vector3(0, -1, 0));
        this.add(cameraNY);
        var cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
        cameraPZ.up.set(0, -1, 0);
        cameraPZ.lookAt(new Vector3(0, 0, 1));
        this.add(cameraPZ);
        var cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
        cameraNZ.up.set(0, -1, 0);
        cameraNZ.lookAt(new Vector3(0, 0, -1));
        this.add(cameraNZ);
        options = options || { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter };
        this.renderTarget = new WebGLCubeRenderTarget(cubeResolution, options);
        this.renderTarget.texture.name = "CubeCamera";
        this.update = function (renderer, scene) {
            if (this.parent === null)
                this.updateMatrixWorld();
            var currentRenderTarget = renderer.getRenderTarget();
            var renderTarget = this.renderTarget;
            var generateMipmaps = renderTarget.texture.generateMipmaps;
            renderTarget.texture.generateMipmaps = false;
            renderer.setRenderTarget(renderTarget, 0);
            renderer.render(scene, cameraPX);
            renderer.setRenderTarget(renderTarget, 1);
            renderer.render(scene, cameraNX);
            renderer.setRenderTarget(renderTarget, 2);
            renderer.render(scene, cameraPY);
            renderer.setRenderTarget(renderTarget, 3);
            renderer.render(scene, cameraNY);
            renderer.setRenderTarget(renderTarget, 4);
            renderer.render(scene, cameraPZ);
            renderTarget.texture.generateMipmaps = generateMipmaps;
            renderer.setRenderTarget(renderTarget, 5);
            renderer.render(scene, cameraNZ);
            renderer.setRenderTarget(currentRenderTarget);
        };
        this.clear = function (renderer, color, depth, stencil) {
            var currentRenderTarget = renderer.getRenderTarget();
            var renderTarget = this.renderTarget;
            for (var i = 0; i < 6; i++) {
                renderer.setRenderTarget(renderTarget, i);
                renderer.clear(color, depth, stencil);
            }
            renderer.setRenderTarget(currentRenderTarget);
        };
    }
    exports_14("CubeCamera", CubeCamera);
    /**
     * @author alteredq / http://alteredqualia.com
     * @author WestLangley / http://github.com/WestLangley
     */
    function WebGLCubeRenderTarget(size, options, dummy) {
        if (Number.isInteger(options)) {
            console.warn('THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )');
            options = dummy;
        }
        WebGLRenderTarget.call(this, size, size, options);
    }
    exports_14("WebGLCubeRenderTarget", WebGLCubeRenderTarget);
    /**
     * @author alteredq / http://alteredqualia.com/
     */
    function DataTexture(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
        Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
        this.image = { data: data || null, width: width || 1, height: height || 1 };
        this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
        this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
        this.generateMipmaps = false;
        this.flipY = false;
        this.unpackAlignment = 1;
        this.needsUpdate = true;
    }
    exports_14("DataTexture", DataTexture);
    function Frustum(p0, p1, p2, p3, p4, p5) {
        this.planes = [
            (p0 !== undefined) ? p0 : new Plane(),
            (p1 !== undefined) ? p1 : new Plane(),
            (p2 !== undefined) ? p2 : new Plane(),
            (p3 !== undefined) ? p3 : new Plane(),
            (p4 !== undefined) ? p4 : new Plane(),
            (p5 !== undefined) ? p5 : new Plane()
        ];
    }
    exports_14("Frustum", Frustum);
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    function WebGLAnimation() {
        var context = null;
        var isAnimating = false;
        var animationLoop = null;
        function onAnimationFrame(time, frame) {
            if (isAnimating === false)
                return;
            animationLoop(time, frame);
            context.requestAnimationFrame(onAnimationFrame);
        }
        return {
            start: function () {
                if (isAnimating === true)
                    return;
                if (animationLoop === null)
                    return;
                context.requestAnimationFrame(onAnimationFrame);
                isAnimating = true;
            },
            stop: function () {
                isAnimating = false;
            },
            setAnimationLoop: function (callback) {
                animationLoop = callback;
            },
            setContext: function (value) {
                context = value;
            }
        };
    }
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    function WebGLAttributes(gl, capabilities) {
        var isWebGL2 = capabilities.isWebGL2;
        var buffers = new WeakMap();
        function createBuffer(attribute, bufferType) {
            var array = attribute.array;
            var usage = attribute.usage;
            var buffer = gl.createBuffer();
            gl.bindBuffer(bufferType, buffer);
            gl.bufferData(bufferType, array, usage);
            attribute.onUploadCallback();
            var type = 5126;
            if (array instanceof Float32Array) {
                type = 5126;
            }
            else if (array instanceof Float64Array) {
                console.warn('THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.');
            }
            else if (array instanceof Uint16Array) {
                type = 5123;
            }
            else if (array instanceof Int16Array) {
                type = 5122;
            }
            else if (array instanceof Uint32Array) {
                type = 5125;
            }
            else if (array instanceof Int32Array) {
                type = 5124;
            }
            else if (array instanceof Int8Array) {
                type = 5120;
            }
            else if (array instanceof Uint8Array) {
                type = 5121;
            }
            return {
                buffer: buffer,
                type: type,
                bytesPerElement: array.BYTES_PER_ELEMENT,
                version: attribute.version
            };
        }
        function updateBuffer(buffer, attribute, bufferType) {
            var array = attribute.array;
            var updateRange = attribute.updateRange;
            gl.bindBuffer(bufferType, buffer);
            if (updateRange.count === -1) {
                // Not using update ranges
                gl.bufferSubData(bufferType, 0, array);
            }
            else {
                if (isWebGL2) {
                    gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);
                }
                else {
                    gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
                }
                updateRange.count = -1; // reset range
            }
        }
        //
        function get(attribute) {
            if (attribute.isInterleavedBufferAttribute)
                attribute = attribute.data;
            return buffers.get(attribute);
        }
        function remove(attribute) {
            if (attribute.isInterleavedBufferAttribute)
                attribute = attribute.data;
            var data = buffers.get(attribute);
            if (data) {
                gl.deleteBuffer(data.buffer);
                buffers.delete(attribute);
            }
        }
        function update(attribute, bufferType) {
            if (attribute.isInterleavedBufferAttribute)
                attribute = attribute.data;
            var data = buffers.get(attribute);
            if (data === undefined) {
                buffers.set(attribute, createBuffer(attribute, bufferType));
            }
            else if (data.version < attribute.version) {
                updateBuffer(data.buffer, attribute, bufferType);
                data.version = attribute.version;
            }
        }
        return {
            get: get,
            remove: remove,
            update: update
        };
    }
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author Mugen87 / https://github.com/Mugen87
     */
    // PlaneGeometry
    function PlaneGeometry(width, height, widthSegments, heightSegments) {
        Geometry.call(this);
        this.type = 'PlaneGeometry';
        this.parameters = {
            width: width,
            height: height,
            widthSegments: widthSegments,
            heightSegments: heightSegments
        };
        this.fromBufferGeometry(new PlaneBufferGeometry(width, height, widthSegments, heightSegments));
        this.mergeVertices();
    }
    exports_14("PlaneGeometry", PlaneGeometry);
    // PlaneBufferGeometry
    function PlaneBufferGeometry(width, height, widthSegments, heightSegments) {
        BufferGeometry.call(this);
        this.type = 'PlaneBufferGeometry';
        this.parameters = {
            width: width,
            height: height,
            widthSegments: widthSegments,
            heightSegments: heightSegments
        };
        width = width || 1;
        height = height || 1;
        var width_half = width / 2;
        var height_half = height / 2;
        var gridX = Math.floor(widthSegments) || 1;
        var gridY = Math.floor(heightSegments) || 1;
        var gridX1 = gridX + 1;
        var gridY1 = gridY + 1;
        var segment_width = width / gridX;
        var segment_height = height / gridY;
        var ix, iy;
        // buffers
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
        // generate vertices, normals and uvs
        for (iy = 0; iy < gridY1; iy++) {
            var y = iy * segment_height - height_half;
            for (ix = 0; ix < gridX1; ix++) {
                var x = ix * segment_width - width_half;
                vertices.push(x, -y, 0);
                normals.push(0, 0, 1);
                uvs.push(ix / gridX);
                uvs.push(1 - (iy / gridY));
            }
        }
        // indices
        for (iy = 0; iy < gridY; iy++) {
            for (ix = 0; ix < gridX; ix++) {
                var a = ix + gridX1 * iy;
                var b = ix + gridX1 * (iy + 1);
                var c = (ix + 1) + gridX1 * (iy + 1);
                var d = (ix + 1) + gridX1 * iy;
                // faces
                indices.push(a, b, d);
                indices.push(b, c, d);
            }
        }
        // build geometry
        this.setIndex(indices);
        this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
        this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
    }
    exports_14("PlaneBufferGeometry", PlaneBufferGeometry);
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    function WebGLBackground(renderer, state, objects, premultipliedAlpha) {
        var clearColor = new Color(0x000000);
        var clearAlpha = 0;
        var planeMesh;
        var boxMesh;
        var currentBackground = null;
        var currentBackgroundVersion = 0;
        var currentTonemapping = null;
        function render(renderList, scene, camera, forceClear) {
            var background = scene.background;
            // Ignore background in AR
            // TODO: Reconsider this.
            var xr = renderer.xr;
            var session = xr.getSession && xr.getSession();
            if (session && session.environmentBlendMode === 'additive') {
                background = null;
            }
            if (background === null) {
                setClear(clearColor, clearAlpha);
            }
            else if (background && background.isColor) {
                setClear(background, 1);
                forceClear = true;
            }
            if (renderer.autoClear || forceClear) {
                renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
            }
            if (background && (background.isCubeTexture || background.isWebGLCubeRenderTarget || background.mapping === CubeUVReflectionMapping)) {
                if (boxMesh === undefined) {
                    boxMesh = new Mesh(new BoxBufferGeometry(1, 1, 1), new ShaderMaterial({
                        type: 'BackgroundCubeMaterial',
                        uniforms: cloneUniforms(ShaderLib.cube.uniforms),
                        vertexShader: ShaderLib.cube.vertexShader,
                        fragmentShader: ShaderLib.cube.fragmentShader,
                        side: BackSide,
                        depthTest: false,
                        depthWrite: false,
                        fog: false
                    }));
                    boxMesh.geometry.deleteAttribute('normal');
                    boxMesh.geometry.deleteAttribute('uv');
                    boxMesh.onBeforeRender = function (renderer, scene, camera) {
                        this.matrixWorld.copyPosition(camera.matrixWorld);
                    };
                    // enable code injection for non-built-in material
                    Object.defineProperty(boxMesh.material, 'envMap', {
                        get: function () {
                            return this.uniforms.envMap.value;
                        }
                    });
                    objects.update(boxMesh);
                }
                var texture = background.isWebGLCubeRenderTarget ? background.texture : background;
                boxMesh.material.uniforms.envMap.value = texture;
                boxMesh.material.uniforms.flipEnvMap.value = texture.isCubeTexture ? -1 : 1;
                if (currentBackground !== background ||
                    currentBackgroundVersion !== texture.version ||
                    currentTonemapping !== renderer.toneMapping) {
                    boxMesh.material.needsUpdate = true;
                    currentBackground = background;
                    currentBackgroundVersion = texture.version;
                    currentTonemapping = renderer.toneMapping;
                }
                // push to the pre-sorted opaque render list
                renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
            }
            else if (background && background.isTexture) {
                if (planeMesh === undefined) {
                    planeMesh = new Mesh(new PlaneBufferGeometry(2, 2), new ShaderMaterial({
                        type: 'BackgroundMaterial',
                        uniforms: cloneUniforms(ShaderLib.background.uniforms),
                        vertexShader: ShaderLib.background.vertexShader,
                        fragmentShader: ShaderLib.background.fragmentShader,
                        side: FrontSide,
                        depthTest: false,
                        depthWrite: false,
                        fog: false
                    }));
                    planeMesh.geometry.deleteAttribute('normal');
                    // enable code injection for non-built-in material
                    Object.defineProperty(planeMesh.material, 'map', {
                        get: function () {
                            return this.uniforms.t2D.value;
                        }
                    });
                    objects.update(planeMesh);
                }
                planeMesh.material.uniforms.t2D.value = background;
                if (background.matrixAutoUpdate === true) {
                    background.updateMatrix();
                }
                planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
                if (currentBackground !== background ||
                    currentBackgroundVersion !== background.version ||
                    currentTonemapping !== renderer.toneMapping) {
                    planeMesh.material.needsUpdate = true;
                    currentBackground = background;
                    currentBackgroundVersion = background.version;
                    currentTonemapping = renderer.toneMapping;
                }
                // push to the pre-sorted opaque render list
                renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
            }
        }
        function setClear(color, alpha) {
            state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);
        }
        return {
            getClearColor: function () {
                return clearColor;
            },
            setClearColor: function (color, alpha) {
                clearColor.set(color);
                clearAlpha = alpha !== undefined ? alpha : 1;
                setClear(clearColor, clearAlpha);
            },
            getClearAlpha: function () {
                return clearAlpha;
            },
            setClearAlpha: function (alpha) {
                clearAlpha = alpha;
                setClear(clearColor, clearAlpha);
            },
            render: render
        };
    }
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    function WebGLBufferRenderer(gl, extensions, info, capabilities) {
        var isWebGL2 = capabilities.isWebGL2;
        var mode;
        function setMode(value) {
            mode = value;
        }
        function render(start, count) {
            gl.drawArrays(mode, start, count);
            info.update(count, mode);
        }
        function renderInstances(geometry, start, count, primcount) {
            if (primcount === 0)
                return;
            var extension, methodName;
            if (isWebGL2) {
                extension = gl;
                methodName = 'drawArraysInstanced';
            }
            else {
                extension = extensions.get('ANGLE_instanced_arrays');
                methodName = 'drawArraysInstancedANGLE';
                if (extension === null) {
                    console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
                    return;
                }
            }
            extension[methodName](mode, start, count, primcount);
            info.update(count, mode, primcount);
        }
        //
        this.setMode = setMode;
        this.render = render;
        this.renderInstances = renderInstances;
    }
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    function WebGLCapabilities(gl, extensions, parameters) {
        var maxAnisotropy;
        function getMaxAnisotropy() {
            if (maxAnisotropy !== undefined)
                return maxAnisotropy;
            var extension = extensions.get('EXT_texture_filter_anisotropic');
            if (extension !== null) {
                maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
            }
            else {
                maxAnisotropy = 0;
            }
            return maxAnisotropy;
        }
        function getMaxPrecision(precision) {
            if (precision === 'highp') {
                if (gl.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
                    gl.getShaderPrecisionFormat(35632, 36338).precision > 0) {
                    return 'highp';
                }
                precision = 'mediump';
            }
            if (precision === 'mediump') {
                if (gl.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
                    gl.getShaderPrecisionFormat(35632, 36337).precision > 0) {
                    return 'mediump';
                }
            }
            return 'lowp';
        }
        /* eslint-disable no-undef */
        var isWebGL2 = (typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext) ||
            (typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext);
        /* eslint-enable no-undef */
        var precision = parameters.precision !== undefined ? parameters.precision : 'highp';
        var maxPrecision = getMaxPrecision(precision);
        if (maxPrecision !== precision) {
            console.warn('THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.');
            precision = maxPrecision;
        }
        var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
        var maxTextures = gl.getParameter(34930);
        var maxVertexTextures = gl.getParameter(35660);
        var maxTextureSize = gl.getParameter(3379);
        var maxCubemapSize = gl.getParameter(34076);
        var maxAttributes = gl.getParameter(34921);
        var maxVertexUniforms = gl.getParameter(36347);
        var maxVaryings = gl.getParameter(36348);
        var maxFragmentUniforms = gl.getParameter(36349);
        var vertexTextures = maxVertexTextures > 0;
        var floatFragmentTextures = isWebGL2 || !!extensions.get('OES_texture_float');
        var floatVertexTextures = vertexTextures && floatFragmentTextures;
        var maxSamples = isWebGL2 ? gl.getParameter(36183) : 0;
        return {
            isWebGL2: isWebGL2,
            getMaxAnisotropy: getMaxAnisotropy,
            getMaxPrecision: getMaxPrecision,
            precision: precision,
            logarithmicDepthBuffer: logarithmicDepthBuffer,
            maxTextures: maxTextures,
            maxVertexTextures: maxVertexTextures,
            maxTextureSize: maxTextureSize,
            maxCubemapSize: maxCubemapSize,
            maxAttributes: maxAttributes,
            maxVertexUniforms: maxVertexUniforms,
            maxVaryings: maxVaryings,
            maxFragmentUniforms: maxFragmentUniforms,
            vertexTextures: vertexTextures,
            floatFragmentTextures: floatFragmentTextures,
            floatVertexTextures: floatVertexTextures,
            maxSamples: maxSamples
        };
    }
    /**
     * @author tschw
     */
    function WebGLClipping() {
        var scope = this, globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false, plane = new Plane(), viewNormalMatrix = new Matrix3(), uniform = { value: null, needsUpdate: false };
        this.uniform = uniform;
        this.numPlanes = 0;
        this.numIntersection = 0;
        this.init = function (planes, enableLocalClipping, camera) {
            var enabled = planes.length !== 0 ||
                enableLocalClipping ||
                // enable state of previous frame - the clipping code has to
                // run another frame in order to reset the state:
                numGlobalPlanes !== 0 ||
                localClippingEnabled;
            localClippingEnabled = enableLocalClipping;
            globalState = projectPlanes(planes, camera, 0);
            numGlobalPlanes = planes.length;
            return enabled;
        };
        this.beginShadows = function () {
            renderingShadows = true;
            projectPlanes(null);
        };
        this.endShadows = function () {
            renderingShadows = false;
            resetGlobalState();
        };
        this.setState = function (planes, clipIntersection, clipShadows, camera, cache, fromCache) {
            if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
                // there's no local clipping
                if (renderingShadows) {
                    // there's no global clipping
                    projectPlanes(null);
                }
                else {
                    resetGlobalState();
                }
            }
            else {
                var nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4, dstArray = cache.clippingState || null;
                uniform.value = dstArray; // ensure unique state
                dstArray = projectPlanes(planes, camera, lGlobal, fromCache);
                for (var i = 0; i !== lGlobal; ++i) {
                    dstArray[i] = globalState[i];
                }
                cache.clippingState = dstArray;
                this.numIntersection = clipIntersection ? this.numPlanes : 0;
                this.numPlanes += nGlobal;
            }
        };
        function resetGlobalState() {
            if (uniform.value !== globalState) {
                uniform.value = globalState;
                uniform.needsUpdate = numGlobalPlanes > 0;
            }
            scope.numPlanes = numGlobalPlanes;
            scope.numIntersection = 0;
        }
        function projectPlanes(planes, camera, dstOffset, skipTransform) {
            var nPlanes = planes !== null ? planes.length : 0, dstArray = null;
            if (nPlanes !== 0) {
                dstArray = uniform.value;
                if (skipTransform !== true || dstArray === null) {
                    var flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
                    viewNormalMatrix.getNormalMatrix(viewMatrix);
                    if (dstArray === null || dstArray.length < flatSize) {
                        dstArray = new Float32Array(flatSize);
                    }
                    for (var i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
                        plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);
                        plane.normal.toArray(dstArray, i4);
                        dstArray[i4 + 3] = plane.constant;
                    }
                }
                uniform.value = dstArray;
                uniform.needsUpdate = true;
            }
            scope.numPlanes = nPlanes;
            return dstArray;
        }
    }
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    function WebGLExtensions(gl) {
        var extensions = {};
        return {
            get: function (name) {
                if (extensions[name] !== undefined) {
                    return extensions[name];
                }
                var extension;
                switch (name) {
                    case 'WEBGL_depth_texture':
                        extension = gl.getExtension('WEBGL_depth_texture') || gl.getExtension('MOZ_WEBGL_depth_texture') || gl.getExtension('WEBKIT_WEBGL_depth_texture');
                        break;
                    case 'EXT_texture_filter_anisotropic':
                        extension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
                        break;
                    case 'WEBGL_compressed_texture_s3tc':
                        extension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
                        break;
                    case 'WEBGL_compressed_texture_pvrtc':
                        extension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
                        break;
                    default:
                        extension = gl.getExtension(name);
                }
                if (extension === null) {
                    console.warn('THREE.WebGLRenderer: ' + name + ' extension not supported.');
                }
                extensions[name] = extension;
                return extension;
            }
        };
    }
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    function WebGLGeometries(gl, attributes, info) {
        var geometries = new WeakMap();
        var wireframeAttributes = new WeakMap();
        function onGeometryDispose(event) {
            var geometry = event.target;
            var buffergeometry = geometries.get(geometry);
            if (buffergeometry.index !== null) {
                attributes.remove(buffergeometry.index);
            }
            for (var name in buffergeometry.attributes) {
                attributes.remove(buffergeometry.attributes[name]);
            }
            geometry.removeEventListener('dispose', onGeometryDispose);
            geometries.delete(geometry);
            var attribute = wireframeAttributes.get(buffergeometry);
            if (attribute) {
                attributes.remove(attribute);
                wireframeAttributes.delete(buffergeometry);
            }
            //
            info.memory.geometries--;
        }
        function get(object, geometry) {
            var buffergeometry = geometries.get(geometry);
            if (buffergeometry)
                return buffergeometry;
            geometry.addEventListener('dispose', onGeometryDispose);
            if (geometry.isBufferGeometry) {
                buffergeometry = geometry;
            }
            else if (geometry.isGeometry) {
                if (geometry._bufferGeometry === undefined) {
                    geometry._bufferGeometry = new BufferGeometry().setFromObject(object);
                }
                buffergeometry = geometry._bufferGeometry;
            }
            geometries.set(geometry, buffergeometry);
            info.memory.geometries++;
            return buffergeometry;
        }
        function update(geometry) {
            var index = geometry.index;
            var geometryAttributes = geometry.attributes;
            if (index !== null) {
                attributes.update(index, 34963);
            }
            for (var name in geometryAttributes) {
                attributes.update(geometryAttributes[name], 34962);
            }
            // morph targets
            var morphAttributes = geometry.morphAttributes;
            for (var name in morphAttributes) {
                var array = morphAttributes[name];
                for (var i = 0, l = array.length; i < l; i++) {
                    attributes.update(array[i], 34962);
                }
            }
        }
        function updateWireframeAttribute(geometry) {
            var indices = [];
            var geometryIndex = geometry.index;
            var geometryPosition = geometry.attributes.position;
            var version = 0;
            if (geometryIndex !== null) {
                var array = geometryIndex.array;
                version = geometryIndex.version;
                for (var i = 0, l = array.length; i < l; i += 3) {
                    var a = array[i + 0];
                    var b = array[i + 1];
                    var c = array[i + 2];
                    indices.push(a, b, b, c, c, a);
                }
            }
            else {
                var array = geometryPosition.array;
                version = geometryPosition.version;
                for (var i = 0, l = (array.length / 3) - 1; i < l; i += 3) {
                    var a = i + 0;
                    var b = i + 1;
                    var c = i + 2;
                    indices.push(a, b, b, c, c, a);
                }
            }
            var attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
            attribute.version = version;
            attributes.update(attribute, 34963);
            //
            var previousAttribute = wireframeAttributes.get(geometry);
            if (previousAttribute)
                attributes.remove(previousAttribute);
            //
            wireframeAttributes.set(geometry, attribute);
        }
        function getWireframeAttribute(geometry) {
            var currentAttribute = wireframeAttributes.get(geometry);
            if (currentAttribute) {
                var geometryIndex = geometry.index;
                if (geometryIndex !== null) {
                    // if the attribute is obsolete, create a new one
                    if (currentAttribute.version < geometryIndex.version) {
                        updateWireframeAttribute(geometry);
                    }
                }
            }
            else {
                updateWireframeAttribute(geometry);
            }
            return wireframeAttributes.get(geometry);
        }
        return {
            get: get,
            update: update,
            getWireframeAttribute: getWireframeAttribute
        };
    }
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
        var isWebGL2 = capabilities.isWebGL2;
        var mode;
        function setMode(value) {
            mode = value;
        }
        var type, bytesPerElement;
        function setIndex(value) {
            type = value.type;
            bytesPerElement = value.bytesPerElement;
        }
        function render(start, count) {
            gl.drawElements(mode, count, type, start * bytesPerElement);
            info.update(count, mode);
        }
        function renderInstances(geometry, start, count, primcount) {
            if (primcount === 0)
                return;
            var extension, methodName;
            if (isWebGL2) {
                extension = gl;
                methodName = 'drawElementsInstanced';
            }
            else {
                extension = extensions.get('ANGLE_instanced_arrays');
                methodName = 'drawElementsInstancedANGLE';
                if (extension === null) {
                    console.error('THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
                    return;
                }
            }
            extension[methodName](mode, count, type, start * bytesPerElement, primcount);
            info.update(count, mode, primcount);
        }
        //
        this.setMode = setMode;
        this.setIndex = setIndex;
        this.render = render;
        this.renderInstances = renderInstances;
    }
    /**
     * @author Mugen87 / https://github.com/Mugen87
     */
    function WebGLInfo(gl) {
        var memory = {
            geometries: 0,
            textures: 0
        };
        var render = {
            frame: 0,
            calls: 0,
            triangles: 0,
            points: 0,
            lines: 0
        };
        function update(count, mode, instanceCount) {
            instanceCount = instanceCount || 1;
            render.calls++;
            switch (mode) {
                case 4:
                    render.triangles += instanceCount * (count / 3);
                    break;
                case 1:
                    render.lines += instanceCount * (count / 2);
                    break;
                case 3:
                    render.lines += instanceCount * (count - 1);
                    break;
                case 2:
                    render.lines += instanceCount * count;
                    break;
                case 0:
                    render.points += instanceCount * count;
                    break;
                default:
                    console.error('THREE.WebGLInfo: Unknown draw mode:', mode);
                    break;
            }
        }
        function reset() {
            render.frame++;
            render.calls = 0;
            render.triangles = 0;
            render.points = 0;
            render.lines = 0;
        }
        return {
            memory: memory,
            render: render,
            programs: null,
            autoReset: true,
            reset: reset,
            update: update
        };
    }
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    function absNumericalSort(a, b) {
        return Math.abs(b[1]) - Math.abs(a[1]);
    }
    function WebGLMorphtargets(gl) {
        var influencesList = {};
        var morphInfluences = new Float32Array(8);
        function update(object, geometry, material, program) {
            var objectInfluences = object.morphTargetInfluences;
            // When object doesn't have morph target influences defined, we treat it as a 0-length array
            // This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences
            var length = objectInfluences === undefined ? 0 : objectInfluences.length;
            var influences = influencesList[geometry.id];
            if (influences === undefined) {
                // initialise list
                influences = [];
                for (var i = 0; i < length; i++) {
                    influences[i] = [i, 0];
                }
                influencesList[geometry.id] = influences;
            }
            var morphTargets = material.morphTargets && geometry.morphAttributes.position;
            var morphNormals = material.morphNormals && geometry.morphAttributes.normal;
            // Remove current morphAttributes
            for (var i = 0; i < length; i++) {
                var influence = influences[i];
                if (influence[1] !== 0) {
                    if (morphTargets)
                        geometry.deleteAttribute('morphTarget' + i);
                    if (morphNormals)
                        geometry.deleteAttribute('morphNormal' + i);
                }
            }
            // Collect influences
            for (var i = 0; i < length; i++) {
                var influence = influences[i];
                influence[0] = i;
                influence[1] = objectInfluences[i];
            }
            influences.sort(absNumericalSort);
            // Add morphAttributes
            var morphInfluencesSum = 0;
            for (var i = 0; i < 8; i++) {
                var influence = influences[i];
                if (influence) {
                    var index = influence[0];
                    var value = influence[1];
                    if (value) {
                        if (morphTargets)
                            geometry.setAttribute('morphTarget' + i, morphTargets[index]);
                        if (morphNormals)
                            geometry.setAttribute('morphNormal' + i, morphNormals[index]);
                        morphInfluences[i] = value;
                        morphInfluencesSum += value;
                        continue;
                    }
                }
                morphInfluences[i] = 0;
            }
            // GLSL shader uses formula baseinfluence * base + sum(target * influence)
            // This allows us to switch between absolute morphs and relative morphs without changing shader code
            // When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)
            var morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
            program.getUniforms().setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence);
            program.getUniforms().setValue(gl, 'morphTargetInfluences', morphInfluences);
        }
        return {
            update: update
        };
    }
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    function WebGLObjects(gl, geometries, attributes, info) {
        var updateList = {};
        function update(object) {
            var frame = info.render.frame;
            var geometry = object.geometry;
            var buffergeometry = geometries.get(object, geometry);
            // Update once per frame
            if (updateList[buffergeometry.id] !== frame) {
                if (geometry.isGeometry) {
                    buffergeometry.updateFromObject(object);
                }
                geometries.update(buffergeometry);
                updateList[buffergeometry.id] = frame;
            }
            if (object.isInstancedMesh) {
                attributes.update(object.instanceMatrix, 34962);
            }
            return buffergeometry;
        }
        function dispose() {
            updateList = {};
        }
        return {
            update: update,
            dispose: dispose
        };
    }
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    function CubeTexture(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
        images = images !== undefined ? images : [];
        mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
        format = format !== undefined ? format : RGBFormat;
        Texture.call(this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
        this.flipY = false;
    }
    exports_14("CubeTexture", CubeTexture);
    /**
     * @author Takahiro https://github.com/takahirox
     */
    function DataTexture2DArray(data, width, height, depth) {
        Texture.call(this, null);
        this.image = { data: data || null, width: width || 1, height: height || 1, depth: depth || 1 };
        this.magFilter = NearestFilter;
        this.minFilter = NearestFilter;
        this.wrapR = ClampToEdgeWrapping;
        this.generateMipmaps = false;
        this.flipY = false;
        this.needsUpdate = true;
    }
    exports_14("DataTexture2DArray", DataTexture2DArray);
    /**
     * @author Artur Trzesiok
     */
    function DataTexture3D(data, width, height, depth) {
        // We're going to add .setXXX() methods for setting properties later.
        // Users can still set in DataTexture3D directly.
        //
        //	var texture = new THREE.DataTexture3D( data, width, height, depth );
        // 	texture.anisotropy = 16;
        //
        // See #14839
        Texture.call(this, null);
        this.image = { data: data || null, width: width || 1, height: height || 1, depth: depth || 1 };
        this.magFilter = NearestFilter;
        this.minFilter = NearestFilter;
        this.wrapR = ClampToEdgeWrapping;
        this.generateMipmaps = false;
        this.flipY = false;
        this.needsUpdate = true;
    }
    exports_14("DataTexture3D", DataTexture3D);
    // Flattening for arrays of vectors and matrices
    function flatten(array, nBlocks, blockSize) {
        var firstElem = array[0];
        if (firstElem <= 0 || firstElem > 0)
            return array;
        // unoptimized: ! isNaN( firstElem )
        // see http://jacksondunstan.com/articles/983
        var n = nBlocks * blockSize, r = arrayCacheF32[n];
        if (r === undefined) {
            r = new Float32Array(n);
            arrayCacheF32[n] = r;
        }
        if (nBlocks !== 0) {
            firstElem.toArray(r, 0);
            for (var i = 1, offset = 0; i !== nBlocks; ++i) {
                offset += blockSize;
                array[i].toArray(r, offset);
            }
        }
        return r;
    }
    function arraysEqual(a, b) {
        if (a.length !== b.length)
            return false;
        for (var i = 0, l = a.length; i < l; i++) {
            if (a[i] !== b[i])
                return false;
        }
        return true;
    }
    function copyArray(a, b) {
        for (var i = 0, l = b.length; i < l; i++) {
            a[i] = b[i];
        }
    }
    // Texture unit allocation
    function allocTexUnits(textures, n) {
        var r = arrayCacheI32[n];
        if (r === undefined) {
            r = new Int32Array(n);
            arrayCacheI32[n] = r;
        }
        for (var i = 0; i !== n; ++i)
            r[i] = textures.allocateTextureUnit();
        return r;
    }
    // --- Setters ---
    // Note: Defining these methods externally, because they come in a bunch
    // and this way their names minify.
    // Single scalar
    function setValueV1f(gl, v) {
        var cache = this.cache;
        if (cache[0] === v)
            return;
        gl.uniform1f(this.addr, v);
        cache[0] = v;
    }
    // Single float vector (from flat array or THREE.VectorN)
    function setValueV2f(gl, v) {
        var cache = this.cache;
        if (v.x !== undefined) {
            if (cache[0] !== v.x || cache[1] !== v.y) {
                gl.uniform2f(this.addr, v.x, v.y);
                cache[0] = v.x;
                cache[1] = v.y;
            }
        }
        else {
            if (arraysEqual(cache, v))
                return;
            gl.uniform2fv(this.addr, v);
            copyArray(cache, v);
        }
    }
    function setValueV3f(gl, v) {
        var cache = this.cache;
        if (v.x !== undefined) {
            if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
                gl.uniform3f(this.addr, v.x, v.y, v.z);
                cache[0] = v.x;
                cache[1] = v.y;
                cache[2] = v.z;
            }
        }
        else if (v.r !== undefined) {
            if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
                gl.uniform3f(this.addr, v.r, v.g, v.b);
                cache[0] = v.r;
                cache[1] = v.g;
                cache[2] = v.b;
            }
        }
        else {
            if (arraysEqual(cache, v))
                return;
            gl.uniform3fv(this.addr, v);
            copyArray(cache, v);
        }
    }
    function setValueV4f(gl, v) {
        var cache = this.cache;
        if (v.x !== undefined) {
            if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
                gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
                cache[0] = v.x;
                cache[1] = v.y;
                cache[2] = v.z;
                cache[3] = v.w;
            }
        }
        else {
            if (arraysEqual(cache, v))
                return;
            gl.uniform4fv(this.addr, v);
            copyArray(cache, v);
        }
    }
    // Single matrix (from flat array or MatrixN)
    function setValueM2(gl, v) {
        var cache = this.cache;
        var elements = v.elements;
        if (elements === undefined) {
            if (arraysEqual(cache, v))
                return;
            gl.uniformMatrix2fv(this.addr, false, v);
            copyArray(cache, v);
        }
        else {
            if (arraysEqual(cache, elements))
                return;
            mat2array.set(elements);
            gl.uniformMatrix2fv(this.addr, false, mat2array);
            copyArray(cache, elements);
        }
    }
    function setValueM3(gl, v) {
        var cache = this.cache;
        var elements = v.elements;
        if (elements === undefined) {
            if (arraysEqual(cache, v))
                return;
            gl.uniformMatrix3fv(this.addr, false, v);
            copyArray(cache, v);
        }
        else {
            if (arraysEqual(cache, elements))
                return;
            mat3array.set(elements);
            gl.uniformMatrix3fv(this.addr, false, mat3array);
            copyArray(cache, elements);
        }
    }
    function setValueM4(gl, v) {
        var cache = this.cache;
        var elements = v.elements;
        if (elements === undefined) {
            if (arraysEqual(cache, v))
                return;
            gl.uniformMatrix4fv(this.addr, false, v);
            copyArray(cache, v);
        }
        else {
            if (arraysEqual(cache, elements))
                return;
            mat4array.set(elements);
            gl.uniformMatrix4fv(this.addr, false, mat4array);
            copyArray(cache, elements);
        }
    }
    // Single texture (2D / Cube)
    function setValueT1(gl, v, textures) {
        var cache = this.cache;
        var unit = textures.allocateTextureUnit();
        if (cache[0] !== unit) {
            gl.uniform1i(this.addr, unit);
            cache[0] = unit;
        }
        textures.safeSetTexture2D(v || emptyTexture, unit);
    }
    function setValueT2DArray1(gl, v, textures) {
        var cache = this.cache;
        var unit = textures.allocateTextureUnit();
        if (cache[0] !== unit) {
            gl.uniform1i(this.addr, unit);
            cache[0] = unit;
        }
        textures.setTexture2DArray(v || emptyTexture2dArray, unit);
    }
    function setValueT3D1(gl, v, textures) {
        var cache = this.cache;
        var unit = textures.allocateTextureUnit();
        if (cache[0] !== unit) {
            gl.uniform1i(this.addr, unit);
            cache[0] = unit;
        }
        textures.setTexture3D(v || emptyTexture3d, unit);
    }
    function setValueT6(gl, v, textures) {
        var cache = this.cache;
        var unit = textures.allocateTextureUnit();
        if (cache[0] !== unit) {
            gl.uniform1i(this.addr, unit);
            cache[0] = unit;
        }
        textures.safeSetTextureCube(v || emptyCubeTexture, unit);
    }
    // Integer / Boolean vectors or arrays thereof (always flat arrays)
    function setValueV1i(gl, v) {
        var cache = this.cache;
        if (cache[0] === v)
            return;
        gl.uniform1i(this.addr, v);
        cache[0] = v;
    }
    function setValueV2i(gl, v) {
        var cache = this.cache;
        if (arraysEqual(cache, v))
            return;
        gl.uniform2iv(this.addr, v);
        copyArray(cache, v);
    }
    function setValueV3i(gl, v) {
        var cache = this.cache;
        if (arraysEqual(cache, v))
            return;
        gl.uniform3iv(this.addr, v);
        copyArray(cache, v);
    }
    function setValueV4i(gl, v) {
        var cache = this.cache;
        if (arraysEqual(cache, v))
            return;
        gl.uniform4iv(this.addr, v);
        copyArray(cache, v);
    }
    // uint
    function setValueV1ui(gl, v) {
        var cache = this.cache;
        if (cache[0] === v)
            return;
        gl.uniform1ui(this.addr, v);
        cache[0] = v;
    }
    // Helper to pick the right setter for the singular case
    function getSingularSetter(type) {
        switch (type) {
            case 0x1406: return setValueV1f; // FLOAT
            case 0x8b50: return setValueV2f; // _VEC2
            case 0x8b51: return setValueV3f; // _VEC3
            case 0x8b52: return setValueV4f; // _VEC4
            case 0x8b5a: return setValueM2; // _MAT2
            case 0x8b5b: return setValueM3; // _MAT3
            case 0x8b5c: return setValueM4; // _MAT4
            case 0x1404:
            case 0x8b56: return setValueV1i; // INT, BOOL
            case 0x8b53:
            case 0x8b57: return setValueV2i; // _VEC2
            case 0x8b54:
            case 0x8b58: return setValueV3i; // _VEC3
            case 0x8b55:
            case 0x8b59: return setValueV4i; // _VEC4
            case 0x1405: return setValueV1ui; // UINT
            case 0x8b5e: // SAMPLER_2D
            case 0x8d66: // SAMPLER_EXTERNAL_OES
            case 0x8dca: // INT_SAMPLER_2D
            case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
            case 0x8b62: // SAMPLER_2D_SHADOW
                return setValueT1;
            case 0x8b5f: // SAMPLER_3D
            case 0x8dcb: // INT_SAMPLER_3D
            case 0x8dd3: // UNSIGNED_INT_SAMPLER_3D
                return setValueT3D1;
            case 0x8b60: // SAMPLER_CUBE
            case 0x8dcc: // INT_SAMPLER_CUBE
            case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
            case 0x8dc5: // SAMPLER_CUBE_SHADOW
                return setValueT6;
            case 0x8dc1: // SAMPLER_2D_ARRAY
            case 0x8dcf: // INT_SAMPLER_2D_ARRAY
            case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
            case 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW
                return setValueT2DArray1;
        }
    }
    // Array of scalars
    function setValueV1fArray(gl, v) {
        gl.uniform1fv(this.addr, v);
    }
    // Integer / Boolean vectors or arrays thereof (always flat arrays)
    function setValueV1iArray(gl, v) {
        gl.uniform1iv(this.addr, v);
    }
    function setValueV2iArray(gl, v) {
        gl.uniform2iv(this.addr, v);
    }
    function setValueV3iArray(gl, v) {
        gl.uniform3iv(this.addr, v);
    }
    function setValueV4iArray(gl, v) {
        gl.uniform4iv(this.addr, v);
    }
    // Array of vectors (flat or from THREE classes)
    function setValueV2fArray(gl, v) {
        var data = flatten(v, this.size, 2);
        gl.uniform2fv(this.addr, data);
    }
    function setValueV3fArray(gl, v) {
        var data = flatten(v, this.size, 3);
        gl.uniform3fv(this.addr, data);
    }
    function setValueV4fArray(gl, v) {
        var data = flatten(v, this.size, 4);
        gl.uniform4fv(this.addr, data);
    }
    // Array of matrices (flat or from THREE clases)
    function setValueM2Array(gl, v) {
        var data = flatten(v, this.size, 4);
        gl.uniformMatrix2fv(this.addr, false, data);
    }
    function setValueM3Array(gl, v) {
        var data = flatten(v, this.size, 9);
        gl.uniformMatrix3fv(this.addr, false, data);
    }
    function setValueM4Array(gl, v) {
        var data = flatten(v, this.size, 16);
        gl.uniformMatrix4fv(this.addr, false, data);
    }
    // Array of textures (2D / Cube)
    function setValueT1Array(gl, v, textures) {
        var n = v.length;
        var units = allocTexUnits(textures, n);
        gl.uniform1iv(this.addr, units);
        for (var i = 0; i !== n; ++i) {
            textures.safeSetTexture2D(v[i] || emptyTexture, units[i]);
        }
    }
    function setValueT6Array(gl, v, textures) {
        var n = v.length;
        var units = allocTexUnits(textures, n);
        gl.uniform1iv(this.addr, units);
        for (var i = 0; i !== n; ++i) {
            textures.safeSetTextureCube(v[i] || emptyCubeTexture, units[i]);
        }
    }
    // Helper to pick the right setter for a pure (bottom-level) array
    function getPureArraySetter(type) {
        switch (type) {
            case 0x1406: return setValueV1fArray; // FLOAT
            case 0x8b50: return setValueV2fArray; // _VEC2
            case 0x8b51: return setValueV3fArray; // _VEC3
            case 0x8b52: return setValueV4fArray; // _VEC4
            case 0x8b5a: return setValueM2Array; // _MAT2
            case 0x8b5b: return setValueM3Array; // _MAT3
            case 0x8b5c: return setValueM4Array; // _MAT4
            case 0x1404:
            case 0x8b56: return setValueV1iArray; // INT, BOOL
            case 0x8b53:
            case 0x8b57: return setValueV2iArray; // _VEC2
            case 0x8b54:
            case 0x8b58: return setValueV3iArray; // _VEC3
            case 0x8b55:
            case 0x8b59: return setValueV4iArray; // _VEC4
            case 0x8b5e: // SAMPLER_2D
            case 0x8d66: // SAMPLER_EXTERNAL_OES
            case 0x8dca: // INT_SAMPLER_2D
            case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
            case 0x8b62: // SAMPLER_2D_SHADOW
                return setValueT1Array;
            case 0x8b60: // SAMPLER_CUBE
            case 0x8dcc: // INT_SAMPLER_CUBE
            case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
            case 0x8dc5: // SAMPLER_CUBE_SHADOW
                return setValueT6Array;
        }
    }
    // --- Uniform Classes ---
    function SingleUniform(id, activeInfo, addr) {
        this.id = id;
        this.addr = addr;
        this.cache = [];
        this.setValue = getSingularSetter(activeInfo.type);
        // this.path = activeInfo.name; // DEBUG
    }
    function PureArrayUniform(id, activeInfo, addr) {
        this.id = id;
        this.addr = addr;
        this.cache = [];
        this.size = activeInfo.size;
        this.setValue = getPureArraySetter(activeInfo.type);
        // this.path = activeInfo.name; // DEBUG
    }
    function StructuredUniform(id) {
        this.id = id;
        this.seq = [];
        this.map = {};
    }
    // extracts
    // 	- the identifier (member name or array index)
    //  - followed by an optional right bracket (found when array index)
    //  - followed by an optional left bracket or dot (type of subscript)
    //
    // Note: These portions can be read in a non-overlapping fashion and
    // allow straightforward parsing of the hierarchy that WebGL encodes
    // in the uniform names.
    function addUniform(container, uniformObject) {
        container.seq.push(uniformObject);
        container.map[uniformObject.id] = uniformObject;
    }
    function parseUniform(activeInfo, addr, container) {
        var path = activeInfo.name, pathLength = path.length;
        // reset RegExp object, because of the early exit of a previous run
        RePathPart.lastIndex = 0;
        while (true) {
            var match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex, id = match[1], idIsIndex = match[2] === ']', subscript = match[3];
            if (idIsIndex)
                id = id | 0; // convert to integer
            if (subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength) {
                // bare name or "pure" bottom-level array "[0]" suffix
                addUniform(container, subscript === undefined ?
                    new SingleUniform(id, activeInfo, addr) :
                    new PureArrayUniform(id, activeInfo, addr));
                break;
            }
            else {
                // step into inner node / create it in case it doesn't exist
                var map = container.map, next = map[id];
                if (next === undefined) {
                    next = new StructuredUniform(id);
                    addUniform(container, next);
                }
                container = next;
            }
        }
    }
    // Root Container
    function WebGLUniforms(gl, program) {
        this.seq = [];
        this.map = {};
        var n = gl.getProgramParameter(program, 35718);
        for (var i = 0; i < n; ++i) {
            var info = gl.getActiveUniform(program, i), addr = gl.getUniformLocation(program, info.name);
            parseUniform(info, addr, this);
        }
    }
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    function WebGLShader(gl, type, string) {
        var shader = gl.createShader(type);
        gl.shaderSource(shader, string);
        gl.compileShader(shader);
        return shader;
    }
    function addLineNumbers(string) {
        var lines = string.split('\n');
        for (var i = 0; i < lines.length; i++) {
            lines[i] = (i + 1) + ': ' + lines[i];
        }
        return lines.join('\n');
    }
    function getEncodingComponents(encoding) {
        switch (encoding) {
            case LinearEncoding:
                return ['Linear', '( value )'];
            case sRGBEncoding:
                return ['sRGB', '( value )'];
            case RGBEEncoding:
                return ['RGBE', '( value )'];
            case RGBM7Encoding:
                return ['RGBM', '( value, 7.0 )'];
            case RGBM16Encoding:
                return ['RGBM', '( value, 16.0 )'];
            case RGBDEncoding:
                return ['RGBD', '( value, 256.0 )'];
            case GammaEncoding:
                return ['Gamma', '( value, float( GAMMA_FACTOR ) )'];
            case LogLuvEncoding:
                return ['LogLuv', '( value )'];
            default:
                throw new Error('unsupported encoding: ' + encoding);
        }
    }
    function getShaderErrors(gl, shader, type) {
        var status = gl.getShaderParameter(shader, 35713);
        var log = gl.getShaderInfoLog(shader).trim();
        if (status && log === '')
            return '';
        // --enable-privileged-webgl-extension
        // console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );
        var source = gl.getShaderSource(shader);
        return 'THREE.WebGLShader: gl.getShaderInfoLog() ' + type + '\n' + log + addLineNumbers(source);
    }
    function getTexelDecodingFunction(functionName, encoding) {
        var components = getEncodingComponents(encoding);
        return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[0] + 'ToLinear' + components[1] + '; }';
    }
    function getTexelEncodingFunction(functionName, encoding) {
        var components = getEncodingComponents(encoding);
        return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[0] + components[1] + '; }';
    }
    function getToneMappingFunction(functionName, toneMapping) {
        var toneMappingName;
        switch (toneMapping) {
            case LinearToneMapping:
                toneMappingName = 'Linear';
                break;
            case ReinhardToneMapping:
                toneMappingName = 'Reinhard';
                break;
            case Uncharted2ToneMapping:
                toneMappingName = 'Uncharted2';
                break;
            case CineonToneMapping:
                toneMappingName = 'OptimizedCineon';
                break;
            case ACESFilmicToneMapping:
                toneMappingName = 'ACESFilmic';
                break;
            default:
                throw new Error('unsupported toneMapping: ' + toneMapping);
        }
        return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';
    }
    function generateExtensions(parameters) {
        var chunks = [
            (parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical') ? '#extension GL_OES_standard_derivatives : enable' : '',
            (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '',
            (parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers) ? '#extension GL_EXT_draw_buffers : require' : '',
            (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''
        ];
        return chunks.filter(filterEmptyLine).join('\n');
    }
    function generateDefines(defines) {
        var chunks = [];
        for (var name in defines) {
            var value = defines[name];
            if (value === false)
                continue;
            chunks.push('#define ' + name + ' ' + value);
        }
        return chunks.join('\n');
    }
    function fetchAttributeLocations(gl, program) {
        var attributes = {};
        var n = gl.getProgramParameter(program, 35721);
        for (var i = 0; i < n; i++) {
            var info = gl.getActiveAttrib(program, i);
            var name = info.name;
            // console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );
            attributes[name] = gl.getAttribLocation(program, name);
        }
        return attributes;
    }
    function filterEmptyLine(string) {
        return string !== '';
    }
    function replaceLightNums(string, parameters) {
        return string
            .replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights)
            .replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights)
            .replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights)
            .replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights)
            .replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights)
            .replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows)
            .replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows)
            .replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
    }
    function replaceClippingPlaneNums(string, parameters) {
        return string
            .replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes)
            .replace(/UNION_CLIPPING_PLANES/g, (parameters.numClippingPlanes - parameters.numClipIntersection));
    }
    function resolveIncludes(string) {
        return string.replace(includePattern, includeReplacer);
    }
    function includeReplacer(match, include) {
        var string = ShaderChunk[include];
        if (string === undefined) {
            throw new Error('Can not resolve #include <' + include + '>');
        }
        return resolveIncludes(string);
    }
    function unrollLoops(string) {
        return string.replace(loopPattern, loopReplacer);
    }
    function loopReplacer(match, start, end, snippet) {
        var string = '';
        for (var i = parseInt(start); i < parseInt(end); i++) {
            string += snippet
                .replace(/\[ i \]/g, '[ ' + i + ' ]')
                .replace(/UNROLLED_LOOP_INDEX/g, i);
        }
        return string;
    }
    //
    function generatePrecision(parameters) {
        var precisionstring = "precision " + parameters.precision + " float;\nprecision " + parameters.precision + " int;";
        if (parameters.precision === "highp") {
            precisionstring += "\n#define HIGH_PRECISION";
        }
        else if (parameters.precision === "mediump") {
            precisionstring += "\n#define MEDIUM_PRECISION";
        }
        else if (parameters.precision === "lowp") {
            precisionstring += "\n#define LOW_PRECISION";
        }
        return precisionstring;
    }
    function generateShadowMapTypeDefine(parameters) {
        var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';
        if (parameters.shadowMapType === PCFShadowMap) {
            shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
        }
        else if (parameters.shadowMapType === PCFSoftShadowMap) {
            shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
        }
        else if (parameters.shadowMapType === VSMShadowMap) {
            shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';
        }
        return shadowMapTypeDefine;
    }
    function generateEnvMapTypeDefine(parameters) {
        var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
        if (parameters.envMap) {
            switch (parameters.envMapMode) {
                case CubeReflectionMapping:
                case CubeRefractionMapping:
                    envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
                    break;
                case CubeUVReflectionMapping:
                case CubeUVRefractionMapping:
                    envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
                    break;
                case EquirectangularReflectionMapping:
                case EquirectangularRefractionMapping:
                    envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
                    break;
                case SphericalReflectionMapping:
                    envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
                    break;
            }
        }
        return envMapTypeDefine;
    }
    function generateEnvMapModeDefine(parameters) {
        var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
        if (parameters.envMap) {
            switch (parameters.envMapMode) {
                case CubeRefractionMapping:
                case EquirectangularRefractionMapping:
                    envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
                    break;
            }
        }
        return envMapModeDefine;
    }
    function generateEnvMapBlendingDefine(parameters) {
        var envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';
        if (parameters.envMap) {
            switch (parameters.combine) {
                case MultiplyOperation:
                    envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
                    break;
                case MixOperation:
                    envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
                    break;
                case AddOperation:
                    envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
                    break;
            }
        }
        return envMapBlendingDefine;
    }
    function WebGLProgram(renderer, cacheKey, parameters) {
        var gl = renderer.getContext();
        var defines = parameters.defines;
        var vertexShader = parameters.vertexShader;
        var fragmentShader = parameters.fragmentShader;
        var shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
        var envMapTypeDefine = generateEnvMapTypeDefine(parameters);
        var envMapModeDefine = generateEnvMapModeDefine(parameters);
        var envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
        var gammaFactorDefine = (renderer.gammaFactor > 0) ? renderer.gammaFactor : 1.0;
        var customExtensions = parameters.isWebGL2 ? '' : generateExtensions(parameters);
        var customDefines = generateDefines(defines);
        var program = gl.createProgram();
        var prefixVertex, prefixFragment;
        var numMultiviewViews = parameters.numMultiviewViews;
        if (parameters.isRawShaderMaterial) {
            prefixVertex = [
                customDefines
            ].filter(filterEmptyLine).join('\n');
            if (prefixVertex.length > 0) {
                prefixVertex += '\n';
            }
            prefixFragment = [
                customExtensions,
                customDefines
            ].filter(filterEmptyLine).join('\n');
            if (prefixFragment.length > 0) {
                prefixFragment += '\n';
            }
        }
        else {
            prefixVertex = [
                generatePrecision(parameters),
                '#define SHADER_NAME ' + parameters.shaderName,
                customDefines,
                parameters.instancing ? '#define USE_INSTANCING' : '',
                parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',
                '#define GAMMA_FACTOR ' + gammaFactorDefine,
                '#define MAX_BONES ' + parameters.maxBones,
                (parameters.useFog && parameters.fog) ? '#define USE_FOG' : '',
                (parameters.useFog && parameters.fogExp2) ? '#define FOG_EXP2' : '',
                parameters.map ? '#define USE_MAP' : '',
                parameters.envMap ? '#define USE_ENVMAP' : '',
                parameters.envMap ? '#define ' + envMapModeDefine : '',
                parameters.lightMap ? '#define USE_LIGHTMAP' : '',
                parameters.aoMap ? '#define USE_AOMAP' : '',
                parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
                parameters.bumpMap ? '#define USE_BUMPMAP' : '',
                parameters.normalMap ? '#define USE_NORMALMAP' : '',
                (parameters.normalMap && parameters.objectSpaceNormalMap) ? '#define OBJECTSPACE_NORMALMAP' : '',
                (parameters.normalMap && parameters.tangentSpaceNormalMap) ? '#define TANGENTSPACE_NORMALMAP' : '',
                parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
                parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
                parameters.specularMap ? '#define USE_SPECULARMAP' : '',
                parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
                parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
                parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
                parameters.vertexTangents ? '#define USE_TANGENT' : '',
                parameters.vertexColors ? '#define USE_COLOR' : '',
                parameters.vertexUvs ? '#define USE_UV' : '',
                parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',
                parameters.flatShading ? '#define FLAT_SHADED' : '',
                parameters.skinning ? '#define USE_SKINNING' : '',
                parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',
                parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
                parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
                parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
                parameters.flipSided ? '#define FLIP_SIDED' : '',
                parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
                parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
                parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
                parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
                (parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth) ? '#define USE_LOGDEPTHBUF_EXT' : '',
                'uniform mat4 modelMatrix;',
                'uniform mat4 modelViewMatrix;',
                'uniform mat4 projectionMatrix;',
                'uniform mat4 viewMatrix;',
                'uniform mat3 normalMatrix;',
                'uniform vec3 cameraPosition;',
                'uniform bool isOrthographic;',
                '#ifdef USE_INSTANCING',
                ' attribute mat4 instanceMatrix;',
                '#endif',
                'attribute vec3 position;',
                'attribute vec3 normal;',
                'attribute vec2 uv;',
                '#ifdef USE_TANGENT',
                '	attribute vec4 tangent;',
                '#endif',
                '#ifdef USE_COLOR',
                '	attribute vec3 color;',
                '#endif',
                '#ifdef USE_MORPHTARGETS',
                '	attribute vec3 morphTarget0;',
                '	attribute vec3 morphTarget1;',
                '	attribute vec3 morphTarget2;',
                '	attribute vec3 morphTarget3;',
                '	#ifdef USE_MORPHNORMALS',
                '		attribute vec3 morphNormal0;',
                '		attribute vec3 morphNormal1;',
                '		attribute vec3 morphNormal2;',
                '		attribute vec3 morphNormal3;',
                '	#else',
                '		attribute vec3 morphTarget4;',
                '		attribute vec3 morphTarget5;',
                '		attribute vec3 morphTarget6;',
                '		attribute vec3 morphTarget7;',
                '	#endif',
                '#endif',
                '#ifdef USE_SKINNING',
                '	attribute vec4 skinIndex;',
                '	attribute vec4 skinWeight;',
                '#endif',
                '\n'
            ].filter(filterEmptyLine).join('\n');
            prefixFragment = [
                customExtensions,
                generatePrecision(parameters),
                '#define SHADER_NAME ' + parameters.shaderName,
                customDefines,
                parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest + (parameters.alphaTest % 1 ? '' : '.0') : '',
                '#define GAMMA_FACTOR ' + gammaFactorDefine,
                (parameters.useFog && parameters.fog) ? '#define USE_FOG' : '',
                (parameters.useFog && parameters.fogExp2) ? '#define FOG_EXP2' : '',
                parameters.map ? '#define USE_MAP' : '',
                parameters.matcap ? '#define USE_MATCAP' : '',
                parameters.envMap ? '#define USE_ENVMAP' : '',
                parameters.envMap ? '#define ' + envMapTypeDefine : '',
                parameters.envMap ? '#define ' + envMapModeDefine : '',
                parameters.envMap ? '#define ' + envMapBlendingDefine : '',
                parameters.lightMap ? '#define USE_LIGHTMAP' : '',
                parameters.aoMap ? '#define USE_AOMAP' : '',
                parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
                parameters.bumpMap ? '#define USE_BUMPMAP' : '',
                parameters.normalMap ? '#define USE_NORMALMAP' : '',
                (parameters.normalMap && parameters.objectSpaceNormalMap) ? '#define OBJECTSPACE_NORMALMAP' : '',
                (parameters.normalMap && parameters.tangentSpaceNormalMap) ? '#define TANGENTSPACE_NORMALMAP' : '',
                parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
                parameters.specularMap ? '#define USE_SPECULARMAP' : '',
                parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
                parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
                parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
                parameters.sheen ? '#define USE_SHEEN' : '',
                parameters.vertexTangents ? '#define USE_TANGENT' : '',
                parameters.vertexColors ? '#define USE_COLOR' : '',
                parameters.vertexUvs ? '#define USE_UV' : '',
                parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',
                parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',
                parameters.flatShading ? '#define FLAT_SHADED' : '',
                parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
                parameters.flipSided ? '#define FLIP_SIDED' : '',
                parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
                parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
                parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',
                parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',
                parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
                (parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth) ? '#define USE_LOGDEPTHBUF_EXT' : '',
                ((parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod) ? '#define TEXTURE_LOD_EXT' : '',
                'uniform mat4 viewMatrix;',
                'uniform vec3 cameraPosition;',
                'uniform bool isOrthographic;',
                (parameters.toneMapping !== NoToneMapping) ? '#define TONE_MAPPING' : '',
                (parameters.toneMapping !== NoToneMapping) ? ShaderChunk['tonemapping_pars_fragment'] : '',
                (parameters.toneMapping !== NoToneMapping) ? getToneMappingFunction('toneMapping', parameters.toneMapping) : '',
                parameters.dithering ? '#define DITHERING' : '',
                (parameters.outputEncoding || parameters.mapEncoding || parameters.matcapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding || parameters.lightMapEncoding) ?
                    ShaderChunk['encodings_pars_fragment'] : '',
                parameters.mapEncoding ? getTexelDecodingFunction('mapTexelToLinear', parameters.mapEncoding) : '',
                parameters.matcapEncoding ? getTexelDecodingFunction('matcapTexelToLinear', parameters.matcapEncoding) : '',
                parameters.envMapEncoding ? getTexelDecodingFunction('envMapTexelToLinear', parameters.envMapEncoding) : '',
                parameters.emissiveMapEncoding ? getTexelDecodingFunction('emissiveMapTexelToLinear', parameters.emissiveMapEncoding) : '',
                parameters.lightMapEncoding ? getTexelDecodingFunction('lightMapTexelToLinear', parameters.lightMapEncoding) : '',
                parameters.outputEncoding ? getTexelEncodingFunction('linearToOutputTexel', parameters.outputEncoding) : '',
                parameters.depthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '',
                '\n'
            ].filter(filterEmptyLine).join('\n');
        }
        vertexShader = resolveIncludes(vertexShader);
        vertexShader = replaceLightNums(vertexShader, parameters);
        vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
        fragmentShader = resolveIncludes(fragmentShader);
        fragmentShader = replaceLightNums(fragmentShader, parameters);
        fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
        vertexShader = unrollLoops(vertexShader);
        fragmentShader = unrollLoops(fragmentShader);
        if (parameters.isWebGL2 && !parameters.isRawShaderMaterial) {
            var isGLSL3ShaderMaterial = false;
            var versionRegex = /^\s*#version\s+300\s+es\s*\n/;
            if (parameters.isShaderMaterial &&
                vertexShader.match(versionRegex) !== null &&
                fragmentShader.match(versionRegex) !== null) {
                isGLSL3ShaderMaterial = true;
                vertexShader = vertexShader.replace(versionRegex, '');
                fragmentShader = fragmentShader.replace(versionRegex, '');
            }
            // GLSL 3.0 conversion
            prefixVertex = [
                '#version 300 es\n',
                '#define attribute in',
                '#define varying out',
                '#define texture2D texture'
            ].join('\n') + '\n' + prefixVertex;
            prefixFragment = [
                '#version 300 es\n',
                '#define varying in',
                isGLSL3ShaderMaterial ? '' : 'out highp vec4 pc_fragColor;',
                isGLSL3ShaderMaterial ? '' : '#define gl_FragColor pc_fragColor',
                '#define gl_FragDepthEXT gl_FragDepth',
                '#define texture2D texture',
                '#define textureCube texture',
                '#define texture2DProj textureProj',
                '#define texture2DLodEXT textureLod',
                '#define texture2DProjLodEXT textureProjLod',
                '#define textureCubeLodEXT textureLod',
                '#define texture2DGradEXT textureGrad',
                '#define texture2DProjGradEXT textureProjGrad',
                '#define textureCubeGradEXT textureGrad'
            ].join('\n') + '\n' + prefixFragment;
            // Multiview
            if (numMultiviewViews > 0) {
                prefixVertex = prefixVertex.replace('#version 300 es\n', [
                    '#version 300 es\n',
                    '#extension GL_OVR_multiview2 : require',
                    'layout(num_views = ' + numMultiviewViews + ') in;',
                    '#define VIEW_ID gl_ViewID_OVR'
                ].join('\n'));
                prefixVertex = prefixVertex.replace([
                    'uniform mat4 modelViewMatrix;',
                    'uniform mat4 projectionMatrix;',
                    'uniform mat4 viewMatrix;',
                    'uniform mat3 normalMatrix;'
                ].join('\n'), [
                    'uniform mat4 modelViewMatrices[' + numMultiviewViews + '];',
                    'uniform mat4 projectionMatrices[' + numMultiviewViews + '];',
                    'uniform mat4 viewMatrices[' + numMultiviewViews + '];',
                    'uniform mat3 normalMatrices[' + numMultiviewViews + '];',
                    '#define modelViewMatrix modelViewMatrices[VIEW_ID]',
                    '#define projectionMatrix projectionMatrices[VIEW_ID]',
                    '#define viewMatrix viewMatrices[VIEW_ID]',
                    '#define normalMatrix normalMatrices[VIEW_ID]'
                ].join('\n'));
                prefixFragment = prefixFragment.replace('#version 300 es\n', [
                    '#version 300 es\n',
                    '#extension GL_OVR_multiview2 : require',
                    '#define VIEW_ID gl_ViewID_OVR'
                ].join('\n'));
                prefixFragment = prefixFragment.replace('uniform mat4 viewMatrix;', [
                    'uniform mat4 viewMatrices[' + numMultiviewViews + '];',
                    '#define viewMatrix viewMatrices[VIEW_ID]'
                ].join('\n'));
            }
        }
        var vertexGlsl = prefixVertex + vertexShader;
        var fragmentGlsl = prefixFragment + fragmentShader;
        // console.log( '*VERTEX*', vertexGlsl );
        // console.log( '*FRAGMENT*', fragmentGlsl );
        var glVertexShader = WebGLShader(gl, 35633, vertexGlsl);
        var glFragmentShader = WebGLShader(gl, 35632, fragmentGlsl);
        gl.attachShader(program, glVertexShader);
        gl.attachShader(program, glFragmentShader);
        // Force a particular attribute to index 0.
        if (parameters.index0AttributeName !== undefined) {
            gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
        }
        else if (parameters.morphTargets === true) {
            // programs with morphTargets displace position out of attribute 0
            gl.bindAttribLocation(program, 0, 'position');
        }
        gl.linkProgram(program);
        // check for link errors
        if (renderer.debug.checkShaderErrors) {
            var programLog = gl.getProgramInfoLog(program).trim();
            var vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
            var fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
            var runnable = true;
            var haveDiagnostics = true;
            if (gl.getProgramParameter(program, 35714) === false) {
                runnable = false;
                var vertexErrors = getShaderErrors(gl, glVertexShader, 'vertex');
                var fragmentErrors = getShaderErrors(gl, glFragmentShader, 'fragment');
                console.error('THREE.WebGLProgram: shader error: ', gl.getError(), '35715', gl.getProgramParameter(program, 35715), 'gl.getProgramInfoLog', programLog, vertexErrors, fragmentErrors);
            }
            else if (programLog !== '') {
                console.warn('THREE.WebGLProgram: gl.getProgramInfoLog()', programLog);
            }
            else if (vertexLog === '' || fragmentLog === '') {
                haveDiagnostics = false;
            }
            if (haveDiagnostics) {
                this.diagnostics = {
                    runnable: runnable,
                    programLog: programLog,
                    vertexShader: {
                        log: vertexLog,
                        prefix: prefixVertex
                    },
                    fragmentShader: {
                        log: fragmentLog,
                        prefix: prefixFragment
                    }
                };
            }
        }
        // clean up
        gl.deleteShader(glVertexShader);
        gl.deleteShader(glFragmentShader);
        // set up caching for uniform locations
        var cachedUniforms;
        this.getUniforms = function () {
            if (cachedUniforms === undefined) {
                cachedUniforms = new WebGLUniforms(gl, program);
            }
            return cachedUniforms;
        };
        // set up caching for attribute locations
        var cachedAttributes;
        this.getAttributes = function () {
            if (cachedAttributes === undefined) {
                cachedAttributes = fetchAttributeLocations(gl, program);
            }
            return cachedAttributes;
        };
        // free resource
        this.destroy = function () {
            gl.deleteProgram(program);
            this.program = undefined;
        };
        //
        this.name = parameters.shaderName;
        this.id = programIdCount++;
        this.cacheKey = cacheKey;
        this.usedTimes = 1;
        this.program = program;
        this.vertexShader = glVertexShader;
        this.fragmentShader = glFragmentShader;
        this.numMultiviewViews = numMultiviewViews;
        return this;
    }
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    function WebGLPrograms(renderer, extensions, capabilities) {
        var programs = [];
        var isWebGL2 = capabilities.isWebGL2;
        var logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
        var floatVertexTextures = capabilities.floatVertexTextures;
        var precision = capabilities.precision;
        var maxVertexUniforms = capabilities.maxVertexUniforms;
        var vertexTextures = capabilities.vertexTextures;
        var shaderIDs = {
            MeshDepthMaterial: 'depth',
            MeshDistanceMaterial: 'distanceRGBA',
            MeshNormalMaterial: 'normal',
            MeshBasicMaterial: 'basic',
            MeshLambertMaterial: 'lambert',
            MeshPhongMaterial: 'phong',
            MeshToonMaterial: 'toon',
            MeshStandardMaterial: 'physical',
            MeshPhysicalMaterial: 'physical',
            MeshMatcapMaterial: 'matcap',
            LineBasicMaterial: 'basic',
            LineDashedMaterial: 'dashed',
            PointsMaterial: 'points',
            ShadowMaterial: 'shadow',
            SpriteMaterial: 'sprite'
        };
        var parameterNames = [
            "precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "numMultiviewViews",
            "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV",
            "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatNormalMap", "displacementMap", "specularMap",
            "roughnessMap", "metalnessMap", "gradientMap",
            "alphaMap", "combine", "vertexColors", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2",
            "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",
            "maxBones", "useVertexTexture", "morphTargets", "morphNormals",
            "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha",
            "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights",
            "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows",
            "shadowMapEnabled", "shadowMapType", "toneMapping", 'physicallyCorrectLights',
            "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering",
            "sheen"
        ];
        function getShaderObject(material, shaderID) {
            var shaderobject;
            if (shaderID) {
                var shader = ShaderLib[shaderID];
                shaderobject = {
                    name: material.type,
                    uniforms: UniformsUtils.clone(shader.uniforms),
                    vertexShader: shader.vertexShader,
                    fragmentShader: shader.fragmentShader
                };
            }
            else {
                shaderobject = {
                    name: material.type,
                    uniforms: material.uniforms,
                    vertexShader: material.vertexShader,
                    fragmentShader: material.fragmentShader
                };
            }
            return shaderobject;
        }
        function allocateBones(object) {
            var skeleton = object.skeleton;
            var bones = skeleton.bones;
            if (floatVertexTextures) {
                return 1024;
            }
            else {
                // default for when object is not specified
                // ( for example when prebuilding shader to be used with multiple objects )
                //
                //  - leave some extra space for other uniforms
                //  - limit here is ANGLE's 254 max uniform vectors
                //    (up to 54 should be safe)
                var nVertexUniforms = maxVertexUniforms;
                var nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
                var maxBones = Math.min(nVertexMatrices, bones.length);
                if (maxBones < bones.length) {
                    console.warn('THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.');
                    return 0;
                }
                return maxBones;
            }
        }
        function getTextureEncodingFromMap(map) {
            var encoding;
            if (!map) {
                encoding = LinearEncoding;
            }
            else if (map.isTexture) {
                encoding = map.encoding;
            }
            else if (map.isWebGLRenderTarget) {
                console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");
                encoding = map.texture.encoding;
            }
            return encoding;
        }
        this.getParameters = function (material, lights, shadows, scene, nClipPlanes, nClipIntersection, object) {
            var fog = scene.fog;
            var environment = material.isMeshStandardMaterial ? scene.environment : null;
            var envMap = material.envMap || environment;
            var shaderID = shaderIDs[material.type];
            // heuristics to create shader parameters according to lights in the scene
            // (not to blow over maxLights budget)
            var maxBones = object.isSkinnedMesh ? allocateBones(object) : 0;
            if (material.precision !== null) {
                precision = capabilities.getMaxPrecision(material.precision);
                if (precision !== material.precision) {
                    console.warn('THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.');
                }
            }
            var shaderobject = getShaderObject(material, shaderID);
            material.onBeforeCompile(shaderobject, renderer);
            var currentRenderTarget = renderer.getRenderTarget();
            var numMultiviewViews = currentRenderTarget && currentRenderTarget.isWebGLMultiviewRenderTarget ? currentRenderTarget.numViews : 0;
            var parameters = {
                isWebGL2: isWebGL2,
                shaderID: shaderID,
                shaderName: shaderobject.name,
                uniforms: shaderobject.uniforms,
                vertexShader: shaderobject.vertexShader,
                fragmentShader: shaderobject.fragmentShader,
                defines: material.defines,
                isRawShaderMaterial: material.isRawShaderMaterial,
                isShaderMaterial: material.isShaderMaterial,
                precision: precision,
                instancing: object.isInstancedMesh === true,
                supportsVertexTextures: vertexTextures,
                numMultiviewViews: numMultiviewViews,
                outputEncoding: (currentRenderTarget !== null) ? getTextureEncodingFromMap(currentRenderTarget.texture) : renderer.outputEncoding,
                map: !!material.map,
                mapEncoding: getTextureEncodingFromMap(material.map),
                matcap: !!material.matcap,
                matcapEncoding: getTextureEncodingFromMap(material.matcap),
                envMap: !!envMap,
                envMapMode: envMap && envMap.mapping,
                envMapEncoding: getTextureEncodingFromMap(envMap),
                envMapCubeUV: (!!envMap) && ((envMap.mapping === CubeUVReflectionMapping) || (envMap.mapping === CubeUVRefractionMapping)),
                lightMap: !!material.lightMap,
                lightMapEncoding: getTextureEncodingFromMap(material.lightMap),
                aoMap: !!material.aoMap,
                emissiveMap: !!material.emissiveMap,
                emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap),
                bumpMap: !!material.bumpMap,
                normalMap: !!material.normalMap,
                objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
                tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
                clearcoatNormalMap: !!material.clearcoatNormalMap,
                displacementMap: !!material.displacementMap,
                roughnessMap: !!material.roughnessMap,
                metalnessMap: !!material.metalnessMap,
                specularMap: !!material.specularMap,
                alphaMap: !!material.alphaMap,
                gradientMap: !!material.gradientMap,
                sheen: !!material.sheen,
                combine: material.combine,
                vertexTangents: (material.normalMap && material.vertexTangents),
                vertexColors: material.vertexColors,
                vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || !!material.displacementMap,
                uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap) && !!material.displacementMap,
                fog: !!fog,
                useFog: material.fog,
                fogExp2: (fog && fog.isFogExp2),
                flatShading: material.flatShading,
                sizeAttenuation: material.sizeAttenuation,
                logarithmicDepthBuffer: logarithmicDepthBuffer,
                skinning: material.skinning && maxBones > 0,
                maxBones: maxBones,
                useVertexTexture: floatVertexTextures,
                morphTargets: material.morphTargets,
                morphNormals: material.morphNormals,
                maxMorphTargets: renderer.maxMorphTargets,
                maxMorphNormals: renderer.maxMorphNormals,
                numDirLights: lights.directional.length,
                numPointLights: lights.point.length,
                numSpotLights: lights.spot.length,
                numRectAreaLights: lights.rectArea.length,
                numHemiLights: lights.hemi.length,
                numDirLightShadows: lights.directionalShadowMap.length,
                numPointLightShadows: lights.pointShadowMap.length,
                numSpotLightShadows: lights.spotShadowMap.length,
                numClippingPlanes: nClipPlanes,
                numClipIntersection: nClipIntersection,
                dithering: material.dithering,
                shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
                shadowMapType: renderer.shadowMap.type,
                toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
                physicallyCorrectLights: renderer.physicallyCorrectLights,
                premultipliedAlpha: material.premultipliedAlpha,
                alphaTest: material.alphaTest,
                doubleSided: material.side === DoubleSide,
                flipSided: material.side === BackSide,
                depthPacking: (material.depthPacking !== undefined) ? material.depthPacking : false,
                index0AttributeName: material.index0AttributeName,
                extensionDerivatives: material.extensions && material.extensions.derivatives,
                extensionFragDepth: material.extensions && material.extensions.frawbuffers,
                extensionDrawbuffers: material.extensions && material.extensions.drawbuffers,
                extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,
                rendererExtensionFragDepth: isWebGL2 || extensions.get('EXT_frag_depth') !== null,
                rendererExtensionDrawBuffers: isWebGL2 || extensions.get('WEBGL_draw_buffers') !== null,
                rendererExtensionShaderTextureLod: isWebGL2 || extensions.get('EXT_shader_texture_lod') !== null,
                onBeforeCompile: material.onBeforeCompile
            };
            return parameters;
        };
        this.getProgramCacheKey = function (parameters) {
            var array = [];
            if (parameters.shaderID) {
                array.push(parameters.shaderID);
            }
            else {
                array.push(parameters.fragmentShader);
                array.push(parameters.vertexShader);
            }
            if (parameters.defines !== undefined) {
                for (var name in parameters.defines) {
                    array.push(name);
                    array.push(parameters.defines[name]);
                }
            }
            if (parameters.isRawShaderMaterial === undefined) {
                for (var i = 0; i < parameterNames.length; i++) {
                    array.push(parameters[parameterNames[i]]);
                }
                array.push(renderer.outputEncoding);
                array.push(renderer.gammaFactor);
            }
            array.push(parameters.onBeforeCompile.toString());
            return array.join();
        };
        this.acquireProgram = function (parameters, cacheKey) {
            var program;
            // Check if code has been already compiled
            for (var p = 0, pl = programs.length; p < pl; p++) {
                var preexistingProgram = programs[p];
                if (preexistingProgram.cacheKey === cacheKey) {
                    program = preexistingProgram;
                    ++program.usedTimes;
                    break;
                }
            }
            if (program === undefined) {
                program = new WebGLProgram(renderer, cacheKey, parameters);
                programs.push(program);
            }
            return program;
        };
        this.releaseProgram = function (program) {
            if (--program.usedTimes === 0) {
                // Remove from unordered set
                var i = programs.indexOf(program);
                programs[i] = programs[programs.length - 1];
                programs.pop();
                // Free WebGL resources
                program.destroy();
            }
        };
        // Exposed for resource monitoring & error feedback via renderer.info:
        this.programs = programs;
    }
    /**
     * @author fordacious / fordacious.github.io
     */
    function WebGLProperties() {
        var properties = new WeakMap();
        function get(object) {
            var map = properties.get(object);
            if (map === undefined) {
                map = {};
                properties.set(object, map);
            }
            return map;
        }
        function remove(object) {
            properties.delete(object);
        }
        function update(object, key, value) {
            properties.get(object)[key] = value;
        }
        function dispose() {
            properties = new WeakMap();
        }
        return {
            get: get,
            remove: remove,
            update: update,
            dispose: dispose
        };
    }
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    function painterSortStable(a, b) {
        if (a.groupOrder !== b.groupOrder) {
            return a.groupOrder - b.groupOrder;
        }
        else if (a.renderOrder !== b.renderOrder) {
            return a.renderOrder - b.renderOrder;
        }
        else if (a.program !== b.program) {
            return a.program.id - b.program.id;
        }
        else if (a.material.id !== b.material.id) {
            return a.material.id - b.material.id;
        }
        else if (a.z !== b.z) {
            return a.z - b.z;
        }
        else {
            return a.id - b.id;
        }
    }
    function reversePainterSortStable(a, b) {
        if (a.groupOrder !== b.groupOrder) {
            return a.groupOrder - b.groupOrder;
        }
        else if (a.renderOrder !== b.renderOrder) {
            return a.renderOrder - b.renderOrder;
        }
        else if (a.z !== b.z) {
            return b.z - a.z;
        }
        else {
            return a.id - b.id;
        }
    }
    function WebGLRenderList() {
        var renderItems = [];
        var renderItemsIndex = 0;
        var opaque = [];
        var transparent = [];
        var defaultProgram = { id: -1 };
        function init() {
            renderItemsIndex = 0;
            opaque.length = 0;
            transparent.length = 0;
        }
        function getNextRenderItem(object, geometry, material, groupOrder, z, group) {
            var renderItem = renderItems[renderItemsIndex];
            if (renderItem === undefined) {
                renderItem = {
                    id: object.id,
                    object: object,
                    geometry: geometry,
                    material: material,
                    program: material.program || defaultProgram,
                    groupOrder: groupOrder,
                    renderOrder: object.renderOrder,
                    z: z,
                    group: group
                };
                renderItems[renderItemsIndex] = renderItem;
            }
            else {
                renderItem.id = object.id;
                renderItem.object = object;
                renderItem.geometry = geometry;
                renderItem.material = material;
                renderItem.program = material.program || defaultProgram;
                renderItem.groupOrder = groupOrder;
                renderItem.renderOrder = object.renderOrder;
                renderItem.z = z;
                renderItem.group = group;
            }
            renderItemsIndex++;
            return renderItem;
        }
        function push(object, geometry, material, groupOrder, z, group) {
            var renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
            (material.transparent === true ? transparent : opaque).push(renderItem);
        }
        function unshift(object, geometry, material, groupOrder, z, group) {
            var renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
            (material.transparent === true ? transparent : opaque).unshift(renderItem);
        }
        function sort(customOpaqueSort, customTransparentSort) {
            if (opaque.length > 1)
                opaque.sort(customOpaqueSort || painterSortStable);
            if (transparent.length > 1)
                transparent.sort(customTransparentSort || reversePainterSortStable);
        }
        return {
            opaque: opaque,
            transparent: transparent,
            init: init,
            push: push,
            unshift: unshift,
            sort: sort
        };
    }
    function WebGLRenderLists() {
        var lists = new WeakMap();
        function onSceneDispose(event) {
            var scene = event.target;
            scene.removeEventListener('dispose', onSceneDispose);
            lists.delete(scene);
        }
        function get(scene, camera) {
            var cameras = lists.get(scene);
            var list;
            if (cameras === undefined) {
                list = new WebGLRenderList();
                lists.set(scene, new WeakMap());
                lists.get(scene).set(camera, list);
                scene.addEventListener('dispose', onSceneDispose);
            }
            else {
                list = cameras.get(camera);
                if (list === undefined) {
                    list = new WebGLRenderList();
                    cameras.set(camera, list);
                }
            }
            return list;
        }
        function dispose() {
            lists = new WeakMap();
        }
        return {
            get: get,
            dispose: dispose
        };
    }
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    function UniformsCache() {
        var lights = {};
        return {
            get: function (light) {
                if (lights[light.id] !== undefined) {
                    return lights[light.id];
                }
                var uniforms;
                switch (light.type) {
                    case 'DirectionalLight':
                        uniforms = {
                            direction: new Vector3(),
                            color: new Color(),
                            shadow: false,
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new Vector2()
                        };
                        break;
                    case 'SpotLight':
                        uniforms = {
                            position: new Vector3(),
                            direction: new Vector3(),
                            color: new Color(),
                            distance: 0,
                            coneCos: 0,
                            penumbraCos: 0,
                            decay: 0,
                            shadow: false,
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new Vector2()
                        };
                        break;
                    case 'PointLight':
                        uniforms = {
                            position: new Vector3(),
                            color: new Color(),
                            distance: 0,
                            decay: 0,
                            shadow: false,
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new Vector2(),
                            shadowCameraNear: 1,
                            shadowCameraFar: 1000
                        };
                        break;
                    case 'HemisphereLight':
                        uniforms = {
                            direction: new Vector3(),
                            skyColor: new Color(),
                            groundColor: new Color()
                        };
                        break;
                    case 'RectAreaLight':
                        uniforms = {
                            color: new Color(),
                            position: new Vector3(),
                            halfWidth: new Vector3(),
                            halfHeight: new Vector3()
                            // TODO (abelnation): set RectAreaLight shadow uniforms
                        };
                        break;
                }
                lights[light.id] = uniforms;
                return uniforms;
            }
        };
    }
    function shadowCastingLightsFirst(lightA, lightB) {
        return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);
    }
    function WebGLLights() {
        var cache = new UniformsCache();
        var state = {
            version: 0,
            hash: {
                directionalLength: -1,
                pointLength: -1,
                spotLength: -1,
                rectAreaLength: -1,
                hemiLength: -1,
                numDirectionalShadows: -1,
                numPointShadows: -1,
                numSpotShadows: -1,
            },
            ambient: [0, 0, 0],
            probe: [],
            directional: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotShadowMap: [],
            spotShadowMatrix: [],
            rectArea: [],
            point: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: [],
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1
        };
        for (var i = 0; i < 9; i++)
            state.probe.push(new Vector3());
        var vector3 = new Vector3();
        var matrix4 = new Matrix4();
        var matrix42 = new Matrix4();
        function setup(lights, shadows, camera) {
            var r = 0, g = 0, b = 0;
            for (var i = 0; i < 9; i++)
                state.probe[i].set(0, 0, 0);
            var directionalLength = 0;
            var pointLength = 0;
            var spotLength = 0;
            var rectAreaLength = 0;
            var hemiLength = 0;
            var numDirectionalShadows = 0;
            var numPointShadows = 0;
            var numSpotShadows = 0;
            var viewMatrix = camera.matrixWorldInverse;
            lights.sort(shadowCastingLightsFirst);
            for (var i = 0, l = lights.length; i < l; i++) {
                var light = lights[i];
                var color = light.color;
                var intensity = light.intensity;
                var distance = light.distance;
                var shadowMap = (light.shadow && light.shadow.map) ? light.shadow.map.texture : null;
                if (light.isAmbientLight) {
                    r += color.r * intensity;
                    g += color.g * intensity;
                    b += color.b * intensity;
                }
                else if (light.isLightProbe) {
                    for (var j = 0; j < 9; j++) {
                        state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
                    }
                }
                else if (light.isDirectionalLight) {
                    var uniforms = cache.get(light);
                    uniforms.color.copy(light.color).multiplyScalar(light.intensity);
                    uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                    vector3.setFromMatrixPosition(light.target.matrixWorld);
                    uniforms.direction.sub(vector3);
                    uniforms.direction.transformDirection(viewMatrix);
                    uniforms.shadow = light.castShadow;
                    if (light.castShadow) {
                        var shadow = light.shadow;
                        uniforms.shadowBias = shadow.bias;
                        uniforms.shadowRadius = shadow.radius;
                        uniforms.shadowMapSize = shadow.mapSize;
                        state.directionalShadowMap[directionalLength] = shadowMap;
                        state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
                        numDirectionalShadows++;
                    }
                    state.directional[directionalLength] = uniforms;
                    directionalLength++;
                }
                else if (light.isSpotLight) {
                    var uniforms = cache.get(light);
                    uniforms.position.setFromMatrixPosition(light.matrixWorld);
                    uniforms.position.applyMatrix4(viewMatrix);
                    uniforms.color.copy(color).multiplyScalar(intensity);
                    uniforms.distance = distance;
                    uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                    vector3.setFromMatrixPosition(light.target.matrixWorld);
                    uniforms.direction.sub(vector3);
                    uniforms.direction.transformDirection(viewMatrix);
                    uniforms.coneCos = Math.cos(light.angle);
                    uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
                    uniforms.decay = light.decay;
                    uniforms.shadow = light.castShadow;
                    if (light.castShadow) {
                        var shadow = light.shadow;
                        uniforms.shadowBias = shadow.bias;
                        uniforms.shadowRadius = shadow.radius;
                        uniforms.shadowMapSize = shadow.mapSize;
                        state.spotShadowMap[spotLength] = shadowMap;
                        state.spotShadowMatrix[spotLength] = light.shadow.matrix;
                        numSpotShadows++;
                    }
                    state.spot[spotLength] = uniforms;
                    spotLength++;
                }
                else if (light.isRectAreaLight) {
                    var uniforms = cache.get(light);
                    // (a) intensity is the total visible light emitted
                    //uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );
                    // (b) intensity is the brightness of the light
                    uniforms.color.copy(color).multiplyScalar(intensity);
                    uniforms.position.setFromMatrixPosition(light.matrixWorld);
                    uniforms.position.applyMatrix4(viewMatrix);
                    // extract local rotation of light to derive width/height half vectors
                    matrix42.identity();
                    matrix4.copy(light.matrixWorld);
                    matrix4.premultiply(viewMatrix);
                    matrix42.extractRotation(matrix4);
                    uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);
                    uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);
                    uniforms.halfWidth.applyMatrix4(matrix42);
                    uniforms.halfHeight.applyMatrix4(matrix42);
                    // TODO (abelnation): RectAreaLight distance?
                    // uniforms.distance = distance;
                    state.rectArea[rectAreaLength] = uniforms;
                    rectAreaLength++;
                }
                else if (light.isPointLight) {
                    var uniforms = cache.get(light);
                    uniforms.position.setFromMatrixPosition(light.matrixWorld);
                    uniforms.position.applyMatrix4(viewMatrix);
                    uniforms.color.copy(light.color).multiplyScalar(light.intensity);
                    uniforms.distance = light.distance;
                    uniforms.decay = light.decay;
                    uniforms.shadow = light.castShadow;
                    if (light.castShadow) {
                        var shadow = light.shadow;
                        uniforms.shadowBias = shadow.bias;
                        uniforms.shadowRadius = shadow.radius;
                        uniforms.shadowMapSize = shadow.mapSize;
                        uniforms.shadowCameraNear = shadow.camera.near;
                        uniforms.shadowCameraFar = shadow.camera.far;
                        state.pointShadowMap[pointLength] = shadowMap;
                        state.pointShadowMatrix[pointLength] = light.shadow.matrix;
                        numPointShadows++;
                    }
                    state.point[pointLength] = uniforms;
                    pointLength++;
                }
                else if (light.isHemisphereLight) {
                    var uniforms = cache.get(light);
                    uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                    uniforms.direction.transformDirection(viewMatrix);
                    uniforms.direction.normalize();
                    uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
                    uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);
                    state.hemi[hemiLength] = uniforms;
                    hemiLength++;
                }
            }
            state.ambient[0] = r;
            state.ambient[1] = g;
            state.ambient[2] = b;
            var hash = state.hash;
            if (hash.directionalLength !== directionalLength ||
                hash.pointLength !== pointLength ||
                hash.spotLength !== spotLength ||
                hash.rectAreaLength !== rectAreaLength ||
                hash.hemiLength !== hemiLength ||
                hash.numDirectionalShadows !== numDirectionalShadows ||
                hash.numPointShadows !== numPointShadows ||
                hash.numSpotShadows !== numSpotShadows) {
                state.directional.length = directionalLength;
                state.spot.length = spotLength;
                state.rectArea.length = rectAreaLength;
                state.point.length = pointLength;
                state.hemi.length = hemiLength;
                state.directionalShadowMap.length = numDirectionalShadows;
                state.pointShadowMap.length = numPointShadows;
                state.spotShadowMap.length = numSpotShadows;
                state.directionalShadowMatrix.length = numDirectionalShadows;
                state.pointShadowMatrix.length = numPointShadows;
                state.spotShadowMatrix.length = numSpotShadows;
                hash.directionalLength = directionalLength;
                hash.pointLength = pointLength;
                hash.spotLength = spotLength;
                hash.rectAreaLength = rectAreaLength;
                hash.hemiLength = hemiLength;
                hash.numDirectionalShadows = numDirectionalShadows;
                hash.numPointShadows = numPointShadows;
                hash.numSpotShadows = numSpotShadows;
                state.version = nextVersion++;
            }
        }
        return {
            setup: setup,
            state: state
        };
    }
    /**
     * @author Mugen87 / https://github.com/Mugen87
     */
    function WebGLRenderState() {
        var lights = new WebGLLights();
        var lightsArray = [];
        var shadowsArray = [];
        function init() {
            lightsArray.length = 0;
            shadowsArray.length = 0;
        }
        function pushLight(light) {
            lightsArray.push(light);
        }
        function pushShadow(shadowLight) {
            shadowsArray.push(shadowLight);
        }
        function setupLights(camera) {
            lights.setup(lightsArray, shadowsArray, camera);
        }
        var state = {
            lightsArray: lightsArray,
            shadowsArray: shadowsArray,
            lights: lights
        };
        return {
            init: init,
            state: state,
            setupLights: setupLights,
            pushLight: pushLight,
            pushShadow: pushShadow
        };
    }
    function WebGLRenderStates() {
        var renderStates = new WeakMap();
        function onSceneDispose(event) {
            var scene = event.target;
            scene.removeEventListener('dispose', onSceneDispose);
            renderStates.delete(scene);
        }
        function get(scene, camera) {
            var renderState;
            if (renderStates.has(scene) === false) {
                renderState = new WebGLRenderState();
                renderStates.set(scene, new WeakMap());
                renderStates.get(scene).set(camera, renderState);
                scene.addEventListener('dispose', onSceneDispose);
            }
            else {
                if (renderStates.get(scene).has(camera) === false) {
                    renderState = new WebGLRenderState();
                    renderStates.get(scene).set(camera, renderState);
                }
                else {
                    renderState = renderStates.get(scene).get(camera);
                }
            }
            return renderState;
        }
        function dispose() {
            renderStates = new WeakMap();
        }
        return {
            get: get,
            dispose: dispose
        };
    }
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     * @author bhouston / https://clara.io
     * @author WestLangley / http://github.com/WestLangley
     *
     * parameters = {
     *
     *  opacity: <float>,
     *
     *  map: new THREE.Texture( <Image> ),
     *
     *  alphaMap: new THREE.Texture( <Image> ),
     *
     *  displacementMap: new THREE.Texture( <Image> ),
     *  displacementScale: <float>,
     *  displacementBias: <float>,
     *
     *  wireframe: <boolean>,
     *  wireframeLinewidth: <float>
     * }
     */
    function MeshDepthMaterial(parameters) {
        Material.call(this);
        this.type = 'MeshDepthMaterial';
        this.depthPacking = BasicDepthPacking;
        this.skinning = false;
        this.morphTargets = false;
        this.map = null;
        this.alphaMap = null;
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.fog = false;
        this.setValues(parameters);
    }
    exports_14("MeshDepthMaterial", MeshDepthMaterial);
    /**
     * @author WestLangley / http://github.com/WestLangley
     *
     * parameters = {
     *
     *  referencePosition: <float>,
     *  nearDistance: <float>,
     *  farDistance: <float>,
     *
     *  skinning: <bool>,
     *  morphTargets: <bool>,
     *
     *  map: new THREE.Texture( <Image> ),
     *
     *  alphaMap: new THREE.Texture( <Image> ),
     *
     *  displacementMap: new THREE.Texture( <Image> ),
     *  displacementScale: <float>,
     *  displacementBias: <float>
     *
     * }
     */
    function MeshDistanceMaterial(parameters) {
        Material.call(this);
        this.type = 'MeshDistanceMaterial';
        this.referencePosition = new Vector3();
        this.nearDistance = 1;
        this.farDistance = 1000;
        this.skinning = false;
        this.morphTargets = false;
        this.map = null;
        this.alphaMap = null;
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.fog = false;
        this.setValues(parameters);
    }
    exports_14("MeshDistanceMaterial", MeshDistanceMaterial);
    /**
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     */
    function WebGLShadowMap(_renderer, _objects, maxTextureSize) {
        var _frustum = new Frustum(), _shadowMapSize = new Vector2(), _viewportSize = new Vector2(), _viewport = new Vector4(), _depthMaterials = [], _distanceMaterials = [], _materialCache = {};
        var shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };
        var shadowMaterialVertical = new ShaderMaterial({
            defines: {
                SAMPLE_RATE: 2.0 / 8.0,
                HALF_SAMPLE_RATE: 1.0 / 8.0
            },
            uniforms: {
                shadow_pass: { value: null },
                resolution: { value: new Vector2() },
                radius: { value: 4.0 }
            },
            vertexShader: vsm_vert,
            fragmentShader: vsm_frag
        });
        var shadowMaterialHorizonal = shadowMaterialVertical.clone();
        shadowMaterialHorizonal.defines.HORIZONAL_PASS = 1;
        var fullScreenTri = new BufferGeometry();
        fullScreenTri.setAttribute("position", new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
        var fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
        var scope = this;
        this.enabled = false;
        this.autoUpdate = true;
        this.needsUpdate = false;
        this.type = PCFShadowMap;
        this.render = function (lights, scene, camera) {
            if (scope.enabled === false)
                return;
            if (scope.autoUpdate === false && scope.needsUpdate === false)
                return;
            if (lights.length === 0)
                return;
            var currentRenderTarget = _renderer.getRenderTarget();
            var activeCubeFace = _renderer.getActiveCubeFace();
            var activeMipmapLevel = _renderer.getActiveMipmapLevel();
            var _state = _renderer.state;
            // Set GL state for depth map.
            _state.setBlending(NoBlending);
            _state.buffers.color.setClear(1, 1, 1, 1);
            _state.buffers.depth.setTest(true);
            _state.setScissorTest(false);
            // render depth map
            for (var i = 0, il = lights.length; i < il; i++) {
                var light = lights[i];
                var shadow = light.shadow;
                if (shadow === undefined) {
                    console.warn('THREE.WebGLShadowMap:', light, 'has no shadow.');
                    continue;
                }
                _shadowMapSize.copy(shadow.mapSize);
                var shadowFrameExtents = shadow.getFrameExtents();
                _shadowMapSize.multiply(shadowFrameExtents);
                _viewportSize.copy(shadow.mapSize);
                if (_shadowMapSize.x > maxTextureSize || _shadowMapSize.y > maxTextureSize) {
                    console.warn('THREE.WebGLShadowMap:', light, 'has shadow exceeding max texture size, reducing');
                    if (_shadowMapSize.x > maxTextureSize) {
                        _viewportSize.x = Math.floor(maxTextureSize / shadowFrameExtents.x);
                        _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
                        shadow.mapSize.x = _viewportSize.x;
                    }
                    if (_shadowMapSize.y > maxTextureSize) {
                        _viewportSize.y = Math.floor(maxTextureSize / shadowFrameExtents.y);
                        _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
                        shadow.mapSize.y = _viewportSize.y;
                    }
                }
                if (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {
                    var pars = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat };
                    shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
                    shadow.map.texture.name = light.name + ".shadowMap";
                    shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
                    shadow.camera.updateProjectionMatrix();
                }
                if (shadow.map === null) {
                    var pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };
                    shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
                    shadow.map.texture.name = light.name + ".shadowMap";
                    shadow.camera.updateProjectionMatrix();
                }
                _renderer.setRenderTarget(shadow.map);
                _renderer.clear();
                var viewportCount = shadow.getViewportCount();
                for (var vp = 0; vp < viewportCount; vp++) {
                    var viewport = shadow.getViewport(vp);
                    _viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);
                    _state.viewport(_viewport);
                    shadow.updateMatrices(light, vp);
                    _frustum = shadow.getFrustum();
                    renderObject(scene, camera, shadow.camera, light, this.type);
                }
                // do blur pass for VSM
                if (!shadow.isPointLightShadow && this.type === VSMShadowMap) {
                    VSMPass(shadow, camera);
                }
            }
            scope.needsUpdate = false;
            _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
        };
        function VSMPass(shadow, camera) {
            var geometry = _objects.update(fullScreenMesh);
            // vertical pass
            shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
            shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
            shadowMaterialVertical.uniforms.radius.value = shadow.radius;
            _renderer.setRenderTarget(shadow.mapPass);
            _renderer.clear();
            _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);
            // horizonal pass
            shadowMaterialHorizonal.uniforms.shadow_pass.value = shadow.mapPass.texture;
            shadowMaterialHorizonal.uniforms.resolution.value = shadow.mapSize;
            shadowMaterialHorizonal.uniforms.radius.value = shadow.radius;
            _renderer.setRenderTarget(shadow.map);
            _renderer.clear();
            _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizonal, fullScreenMesh, null);
        }
        function getDepthMaterialVariant(useMorphing, useSkinning, useInstancing) {
            var index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;
            var material = _depthMaterials[index];
            if (material === undefined) {
                material = new MeshDepthMaterial({
                    depthPacking: RGBADepthPacking,
                    morphTargets: useMorphing,
                    skinning: useSkinning
                });
                _depthMaterials[index] = material;
            }
            return material;
        }
        function getDistanceMaterialVariant(useMorphing, useSkinning, useInstancing) {
            var index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;
            var material = _distanceMaterials[index];
            if (material === undefined) {
                material = new MeshDistanceMaterial({
                    morphTargets: useMorphing,
                    skinning: useSkinning
                });
                _distanceMaterials[index] = material;
            }
            return material;
        }
        function getDepthMaterial(object, material, light, shadowCameraNear, shadowCameraFar, type) {
            var geometry = object.geometry;
            var result = null;
            var getMaterialVariant = getDepthMaterialVariant;
            var customMaterial = object.customDepthMaterial;
            if (light.isPointLight === true) {
                getMaterialVariant = getDistanceMaterialVariant;
                customMaterial = object.customDistanceMaterial;
            }
            if (customMaterial === undefined) {
                var useMorphing = false;
                if (material.morphTargets === true) {
                    if (geometry.isBufferGeometry === true) {
                        useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;
                    }
                    else if (geometry.isGeometry === true) {
                        useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;
                    }
                }
                var useSkinning = false;
                if (object.isSkinnedMesh === true) {
                    if (material.skinning === true) {
                        useSkinning = true;
                    }
                    else {
                        console.warn('THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object);
                    }
                }
                var useInstancing = object.isInstancedMesh === true;
                result = getMaterialVariant(useMorphing, useSkinning, useInstancing);
            }
            else {
                result = customMaterial;
            }
            if (_renderer.localClippingEnabled &&
                material.clipShadows === true &&
                material.clippingPlanes.length !== 0) {
                // in this case we need a unique material instance reflecting the
                // appropriate state
                var keyA = result.uuid, keyB = material.uuid;
                var materialsForVariant = _materialCache[keyA];
                if (materialsForVariant === undefined) {
                    materialsForVariant = {};
                    _materialCache[keyA] = materialsForVariant;
                }
                var cachedMaterial = materialsForVariant[keyB];
                if (cachedMaterial === undefined) {
                    cachedMaterial = result.clone();
                    materialsForVariant[keyB] = cachedMaterial;
                }
                result = cachedMaterial;
            }
            result.visible = material.visible;
            result.wireframe = material.wireframe;
            if (type === VSMShadowMap) {
                result.side = (material.shadowSide !== null) ? material.shadowSide : material.side;
            }
            else {
                result.side = (material.shadowSide !== null) ? material.shadowSide : shadowSide[material.side];
            }
            result.clipShadows = material.clipShadows;
            result.clippingPlanes = material.clippingPlanes;
            result.clipIntersection = material.clipIntersection;
            result.wireframeLinewidth = material.wireframeLinewidth;
            result.linewidth = material.linewidth;
            if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
                result.referencePosition.setFromMatrixPosition(light.matrixWorld);
                result.nearDistance = shadowCameraNear;
                result.farDistance = shadowCameraFar;
            }
            return result;
        }
        function renderObject(object, camera, shadowCamera, light, type) {
            if (object.visible === false)
                return;
            var visible = object.layers.test(camera.layers);
            if (visible && (object.isMesh || object.isLine || object.isPoints)) {
                if ((object.castShadow || (object.receiveShadow && type === VSMShadowMap)) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
                    object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
                    var geometry = _objects.update(object);
                    var material = object.material;
                    if (Array.isArray(material)) {
                        var groups = geometry.groups;
                        for (var k = 0, kl = groups.length; k < kl; k++) {
                            var group = groups[k];
                            var groupMaterial = material[group.materialIndex];
                            if (groupMaterial && groupMaterial.visible) {
                                var depthMaterial = getDepthMaterial(object, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);
                                _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
                            }
                        }
                    }
                    else if (material.visible) {
                        var depthMaterial = getDepthMaterial(object, material, light, shadowCamera.near, shadowCamera.far, type);
                        _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
                    }
                }
            }
            var children = object.children;
            for (var i = 0, l = children.length; i < l; i++) {
                renderObject(children[i], camera, shadowCamera, light, type);
            }
        }
    }
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    function WebGLState(gl, extensions, capabilities) {
        var isWebGL2 = capabilities.isWebGL2;
        function ColorBuffer() {
            var locked = false;
            var color = new Vector4();
            var currentColorMask = null;
            var currentColorClear = new Vector4(0, 0, 0, 0);
            return {
                setMask: function (colorMask) {
                    if (currentColorMask !== colorMask && !locked) {
                        gl.colorMask(colorMask, colorMask, colorMask, colorMask);
                        currentColorMask = colorMask;
                    }
                },
                setLocked: function (lock) {
                    locked = lock;
                },
                setClear: function (r, g, b, a, premultipliedAlpha) {
                    if (premultipliedAlpha === true) {
                        r *= a;
                        g *= a;
                        b *= a;
                    }
                    color.set(r, g, b, a);
                    if (currentColorClear.equals(color) === false) {
                        gl.clearColor(r, g, b, a);
                        currentColorClear.copy(color);
                    }
                },
                reset: function () {
                    locked = false;
                    currentColorMask = null;
                    currentColorClear.set(-1, 0, 0, 0); // set to invalid state
                }
            };
        }
        function DepthBuffer() {
            var locked = false;
            var currentDepthMask = null;
            var currentDepthFunc = null;
            var currentDepthClear = null;
            return {
                setTest: function (depthTest) {
                    if (depthTest) {
                        enable(2929);
                    }
                    else {
                        disable(2929);
                    }
                },
                setMask: function (depthMask) {
                    if (currentDepthMask !== depthMask && !locked) {
                        gl.depthMask(depthMask);
                        currentDepthMask = depthMask;
                    }
                },
                setFunc: function (depthFunc) {
                    if (currentDepthFunc !== depthFunc) {
                        if (depthFunc) {
                            switch (depthFunc) {
                                case NeverDepth:
                                    gl.depthFunc(512);
                                    break;
                                case AlwaysDepth:
                                    gl.depthFunc(519);
                                    break;
                                case LessDepth:
                                    gl.depthFunc(513);
                                    break;
                                case LessEqualDepth:
                                    gl.depthFunc(515);
                                    break;
                                case EqualDepth:
                                    gl.depthFunc(514);
                                    break;
                                case GreaterEqualDepth:
                                    gl.depthFunc(518);
                                    break;
                                case GreaterDepth:
                                    gl.depthFunc(516);
                                    break;
                                case NotEqualDepth:
                                    gl.depthFunc(517);
                                    break;
                                default:
                                    gl.depthFunc(515);
                            }
                        }
                        else {
                            gl.depthFunc(515);
                        }
                        currentDepthFunc = depthFunc;
                    }
                },
                setLocked: function (lock) {
                    locked = lock;
                },
                setClear: function (depth) {
                    if (currentDepthClear !== depth) {
                        gl.clearDepth(depth);
                        currentDepthClear = depth;
                    }
                },
                reset: function () {
                    locked = false;
                    currentDepthMask = null;
                    currentDepthFunc = null;
                    currentDepthClear = null;
                }
            };
        }
        function StencilBuffer() {
            var locked = false;
            var currentStencilMask = null;
            var currentStencilFunc = null;
            var currentStencilRef = null;
            var currentStencilFuncMask = null;
            var currentStencilFail = null;
            var currentStencilZFail = null;
            var currentStencilZPass = null;
            var currentStencilClear = null;
            return {
                setTest: function (stencilTest) {
                    if (!locked) {
                        if (stencilTest) {
                            enable(2960);
                        }
                        else {
                            disable(2960);
                        }
                    }
                },
                setMask: function (stencilMask) {
                    if (currentStencilMask !== stencilMask && !locked) {
                        gl.stencilMask(stencilMask);
                        currentStencilMask = stencilMask;
                    }
                },
                setFunc: function (stencilFunc, stencilRef, stencilMask) {
                    if (currentStencilFunc !== stencilFunc ||
                        currentStencilRef !== stencilRef ||
                        currentStencilFuncMask !== stencilMask) {
                        gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
                        currentStencilFunc = stencilFunc;
                        currentStencilRef = stencilRef;
                        currentStencilFuncMask = stencilMask;
                    }
                },
                setOp: function (stencilFail, stencilZFail, stencilZPass) {
                    if (currentStencilFail !== stencilFail ||
                        currentStencilZFail !== stencilZFail ||
                        currentStencilZPass !== stencilZPass) {
                        gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
                        currentStencilFail = stencilFail;
                        currentStencilZFail = stencilZFail;
                        currentStencilZPass = stencilZPass;
                    }
                },
                setLocked: function (lock) {
                    locked = lock;
                },
                setClear: function (stencil) {
                    if (currentStencilClear !== stencil) {
                        gl.clearStencil(stencil);
                        currentStencilClear = stencil;
                    }
                },
                reset: function () {
                    locked = false;
                    currentStencilMask = null;
                    currentStencilFunc = null;
                    currentStencilRef = null;
                    currentStencilFuncMask = null;
                    currentStencilFail = null;
                    currentStencilZFail = null;
                    currentStencilZPass = null;
                    currentStencilClear = null;
                }
            };
        }
        //
        var colorBuffer = new ColorBuffer();
        var depthBuffer = new DepthBuffer();
        var stencilBuffer = new StencilBuffer();
        var maxVertexAttributes = gl.getParameter(34921);
        var newAttributes = new Uint8Array(maxVertexAttributes);
        var enabledAttributes = new Uint8Array(maxVertexAttributes);
        var attributeDivisors = new Uint8Array(maxVertexAttributes);
        var enabledCapabilities = {};
        var currentProgram = null;
        var currentBlendingEnabled = null;
        var currentBlending = null;
        var currentBlendEquation = null;
        var currentBlendSrc = null;
        var currentBlendDst = null;
        var currentBlendEquationAlpha = null;
        var currentBlendSrcAlpha = null;
        var currentBlendDstAlpha = null;
        var currentPremultipledAlpha = false;
        var currentFlipSided = null;
        var currentCullFace = null;
        var currentLineWidth = null;
        var currentPolygonOffsetFactor = null;
        var currentPolygonOffsetUnits = null;
        var maxTextures = gl.getParameter(35661);
        var lineWidthAvailable = false;
        var version = 0;
        var glVersion = gl.getParameter(7938);
        if (glVersion.indexOf('WebGL') !== -1) {
            version = parseFloat(/^WebGL\ ([0-9])/.exec(glVersion)[1]);
            lineWidthAvailable = (version >= 1.0);
        }
        else if (glVersion.indexOf('OpenGL ES') !== -1) {
            version = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(glVersion)[1]);
            lineWidthAvailable = (version >= 2.0);
        }
        var currentTextureSlot = null;
        var currentBoundTextures = {};
        var currentScissor = new Vector4();
        var currentViewport = new Vector4();
        function createTexture(type, target, count) {
            var data = new Uint8Array(4); // 4 is required to match default unpack alignment of 4.
            var texture = gl.createTexture();
            gl.bindTexture(type, texture);
            gl.texParameteri(type, 10241, 9728);
            gl.texParameteri(type, 10240, 9728);
            for (var i = 0; i < count; i++) {
                gl.texImage2D(target + i, 0, 6408, 1, 1, 0, 6408, 5121, data);
            }
            return texture;
        }
        var emptyTextures = {};
        emptyTextures[3553] = createTexture(3553, 3553, 1);
        emptyTextures[34067] = createTexture(34067, 34069, 6);
        // init
        colorBuffer.setClear(0, 0, 0, 1);
        depthBuffer.setClear(1);
        stencilBuffer.setClear(0);
        enable(2929);
        depthBuffer.setFunc(LessEqualDepth);
        setFlipSided(false);
        setCullFace(CullFaceBack);
        enable(2884);
        setBlending(NoBlending);
        //
        function initAttributes() {
            for (var i = 0, l = newAttributes.length; i < l; i++) {
                newAttributes[i] = 0;
            }
        }
        function enableAttribute(attribute) {
            enableAttributeAndDivisor(attribute, 0);
        }
        function enableAttributeAndDivisor(attribute, meshPerAttribute) {
            newAttributes[attribute] = 1;
            if (enabledAttributes[attribute] === 0) {
                gl.enableVertexAttribArray(attribute);
                enabledAttributes[attribute] = 1;
            }
            if (attributeDivisors[attribute] !== meshPerAttribute) {
                var extension = isWebGL2 ? gl : extensions.get('ANGLE_instanced_arrays');
                extension[isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE'](attribute, meshPerAttribute);
                attributeDivisors[attribute] = meshPerAttribute;
            }
        }
        function disableUnusedAttributes() {
            for (var i = 0, l = enabledAttributes.length; i !== l; ++i) {
                if (enabledAttributes[i] !== newAttributes[i]) {
                    gl.disableVertexAttribArray(i);
                    enabledAttributes[i] = 0;
                }
            }
        }
        function enable(id) {
            if (enabledCapabilities[id] !== true) {
                gl.enable(id);
                enabledCapabilities[id] = true;
            }
        }
        function disable(id) {
            if (enabledCapabilities[id] !== false) {
                gl.disable(id);
                enabledCapabilities[id] = false;
            }
        }
        function useProgram(program) {
            if (currentProgram !== program) {
                gl.useProgram(program);
                currentProgram = program;
                return true;
            }
            return false;
        }
        var equationToGL = {
            [AddEquation]: 32774,
            [SubtractEquation]: 32778,
            [ReverseSubtractEquation]: 32779
        };
        if (isWebGL2) {
            equationToGL[MinEquation] = 32775;
            equationToGL[MaxEquation] = 32776;
        }
        else {
            var extension = extensions.get('EXT_blend_minmax');
            if (extension !== null) {
                equationToGL[MinEquation] = extension.MIN_EXT;
                equationToGL[MaxEquation] = extension.MAX_EXT;
            }
        }
        var factorToGL = {
            [ZeroFactor]: 0,
            [OneFactor]: 1,
            [SrcColorFactor]: 768,
            [SrcAlphaFactor]: 770,
            [SrcAlphaSaturateFactor]: 776,
            [DstColorFactor]: 774,
            [DstAlphaFactor]: 772,
            [OneMinusSrcColorFactor]: 769,
            [OneMinusSrcAlphaFactor]: 771,
            [OneMinusDstColorFactor]: 775,
            [OneMinusDstAlphaFactor]: 773
        };
        function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
            if (blending === NoBlending) {
                if (currentBlendingEnabled) {
                    disable(3042);
                    currentBlendingEnabled = false;
                }
                return;
            }
            if (!currentBlendingEnabled) {
                enable(3042);
                currentBlendingEnabled = true;
            }
            if (blending !== CustomBlending) {
                if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
                    if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
                        gl.blendEquation(32774);
                        currentBlendEquation = AddEquation;
                        currentBlendEquationAlpha = AddEquation;
                    }
                    if (premultipliedAlpha) {
                        switch (blending) {
                            case NormalBlending:
                                gl.blendFuncSeparate(1, 771, 1, 771);
                                break;
                            case AdditiveBlending:
                                gl.blendFunc(1, 1);
                                break;
                            case SubtractiveBlending:
                                gl.blendFuncSeparate(0, 0, 769, 771);
                                break;
                            case MultiplyBlending:
                                gl.blendFuncSeparate(0, 768, 0, 770);
                                break;
                            default:
                                console.error('THREE.WebGLState: Invalid blending: ', blending);
                                break;
                        }
                    }
                    else {
                        switch (blending) {
                            case NormalBlending:
                                gl.blendFuncSeparate(770, 771, 1, 771);
                                break;
                            case AdditiveBlending:
                                gl.blendFunc(770, 1);
                                break;
                            case SubtractiveBlending:
                                gl.blendFunc(0, 769);
                                break;
                            case MultiplyBlending:
                                gl.blendFunc(0, 768);
                                break;
                            default:
                                console.error('THREE.WebGLState: Invalid blending: ', blending);
                                break;
                        }
                    }
                    currentBlendSrc = null;
                    currentBlendDst = null;
                    currentBlendSrcAlpha = null;
                    currentBlendDstAlpha = null;
                    currentBlending = blending;
                    currentPremultipledAlpha = premultipliedAlpha;
                }
                return;
            }
            // custom blending
            blendEquationAlpha = blendEquationAlpha || blendEquation;
            blendSrcAlpha = blendSrcAlpha || blendSrc;
            blendDstAlpha = blendDstAlpha || blendDst;
            if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
                gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
                currentBlendEquation = blendEquation;
                currentBlendEquationAlpha = blendEquationAlpha;
            }
            if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
                gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
                currentBlendSrc = blendSrc;
                currentBlendDst = blendDst;
                currentBlendSrcAlpha = blendSrcAlpha;
                currentBlendDstAlpha = blendDstAlpha;
            }
            currentBlending = blending;
            currentPremultipledAlpha = null;
        }
        function setMaterial(material, frontFaceCW) {
            material.side === DoubleSide
                ? disable(2884)
                : enable(2884);
            var flipSided = (material.side === BackSide);
            if (frontFaceCW)
                flipSided = !flipSided;
            setFlipSided(flipSided);
            (material.blending === NormalBlending && material.transparent === false)
                ? setBlending(NoBlending)
                : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
            depthBuffer.setFunc(material.depthFunc);
            depthBuffer.setTest(material.depthTest);
            depthBuffer.setMask(material.depthWrite);
            colorBuffer.setMask(material.colorWrite);
            var stencilWrite = material.stencilWrite;
            stencilBuffer.setTest(stencilWrite);
            if (stencilWrite) {
                stencilBuffer.setMask(material.stencilWriteMask);
                stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
                stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
            }
            setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
        }
        //
        function setFlipSided(flipSided) {
            if (currentFlipSided !== flipSided) {
                if (flipSided) {
                    gl.frontFace(2304);
                }
                else {
                    gl.frontFace(2305);
                }
                currentFlipSided = flipSided;
            }
        }
        function setCullFace(cullFace) {
            if (cullFace !== CullFaceNone) {
                enable(2884);
                if (cullFace !== currentCullFace) {
                    if (cullFace === CullFaceBack) {
                        gl.cullFace(1029);
                    }
                    else if (cullFace === CullFaceFront) {
                        gl.cullFace(1028);
                    }
                    else {
                        gl.cullFace(1032);
                    }
                }
            }
            else {
                disable(2884);
            }
            currentCullFace = cullFace;
        }
        function setLineWidth(width) {
            if (width !== currentLineWidth) {
                if (lineWidthAvailable)
                    gl.lineWidth(width);
                currentLineWidth = width;
            }
        }
        function setPolygonOffset(polygonOffset, factor, units) {
            if (polygonOffset) {
                enable(32823);
                if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
                    gl.polygonOffset(factor, units);
                    currentPolygonOffsetFactor = factor;
                    currentPolygonOffsetUnits = units;
                }
            }
            else {
                disable(32823);
            }
        }
        function setScissorTest(scissorTest) {
            if (scissorTest) {
                enable(3089);
            }
            else {
                disable(3089);
            }
        }
        // texture
        function activeTexture(webglSlot) {
            if (webglSlot === undefined)
                webglSlot = 33984 + maxTextures - 1;
            if (currentTextureSlot !== webglSlot) {
                gl.activeTexture(webglSlot);
                currentTextureSlot = webglSlot;
            }
        }
        function bindTexture(webglType, webglTexture) {
            if (currentTextureSlot === null) {
                activeTexture();
            }
            var boundTexture = currentBoundTextures[currentTextureSlot];
            if (boundTexture === undefined) {
                boundTexture = { type: undefined, texture: undefined };
                currentBoundTextures[currentTextureSlot] = boundTexture;
            }
            if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
                gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
                boundTexture.type = webglType;
                boundTexture.texture = webglTexture;
            }
        }
        function unbindTexture() {
            var boundTexture = currentBoundTextures[currentTextureSlot];
            if (boundTexture !== undefined && boundTexture.type !== undefined) {
                gl.bindTexture(boundTexture.type, null);
                boundTexture.type = undefined;
                boundTexture.texture = undefined;
            }
        }
        function compressedTexImage2D() {
            try {
                gl.compressedTexImage2D.apply(gl, arguments);
            }
            catch (error) {
                console.error('THREE.WebGLState:', error);
            }
        }
        function texImage2D() {
            try {
                gl.texImage2D.apply(gl, arguments);
            }
            catch (error) {
                console.error('THREE.WebGLState:', error);
            }
        }
        function texImage3D() {
            try {
                gl.texImage3D.apply(gl, arguments);
            }
            catch (error) {
                console.error('THREE.WebGLState:', error);
            }
        }
        //
        function scissor(scissor) {
            if (currentScissor.equals(scissor) === false) {
                gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);
                currentScissor.copy(scissor);
            }
        }
        function viewport(viewport) {
            if (currentViewport.equals(viewport) === false) {
                gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w);
                currentViewport.copy(viewport);
            }
        }
        //
        function reset() {
            for (var i = 0; i < enabledAttributes.length; i++) {
                if (enabledAttributes[i] === 1) {
                    gl.disableVertexAttribArray(i);
                    enabledAttributes[i] = 0;
                }
            }
            enabledCapabilities = {};
            currentTextureSlot = null;
            currentBoundTextures = {};
            currentProgram = null;
            currentBlending = null;
            currentFlipSided = null;
            currentCullFace = null;
            colorBuffer.reset();
            depthBuffer.reset();
            stencilBuffer.reset();
        }
        return {
            buffers: {
                color: colorBuffer,
                depth: depthBuffer,
                stencil: stencilBuffer
            },
            initAttributes: initAttributes,
            enableAttribute: enableAttribute,
            enableAttributeAndDivisor: enableAttributeAndDivisor,
            disableUnusedAttributes: disableUnusedAttributes,
            enable: enable,
            disable: disable,
            useProgram: useProgram,
            setBlending: setBlending,
            setMaterial: setMaterial,
            setFlipSided: setFlipSided,
            setCullFace: setCullFace,
            setLineWidth: setLineWidth,
            setPolygonOffset: setPolygonOffset,
            setScissorTest: setScissorTest,
            activeTexture: activeTexture,
            bindTexture: bindTexture,
            unbindTexture: unbindTexture,
            compressedTexImage2D: compressedTexImage2D,
            texImage2D: texImage2D,
            texImage3D: texImage3D,
            scissor: scissor,
            viewport: viewport,
            reset: reset
        };
    }
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
        var isWebGL2 = capabilities.isWebGL2;
        var maxTextures = capabilities.maxTextures;
        var maxCubemapSize = capabilities.maxCubemapSize;
        var maxTextureSize = capabilities.maxTextureSize;
        var maxSamples = capabilities.maxSamples;
        var _videoTextures = new WeakMap();
        var _canvas;
        // cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
        // also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
        // Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).
        var useOffscreenCanvas = false;
        try {
            useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined'
                && (new OffscreenCanvas(1, 1).getContext("2d")) !== null;
        }
        catch (err) {
            // Ignore any errors
        }
        function createCanvas(width, height) {
            // Use OffscreenCanvas when available. Specially needed in web workers
            return useOffscreenCanvas ?
                new OffscreenCanvas(width, height) :
                document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
        }
        function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
            var scale = 1;
            // handle case if texture exceeds max size
            if (image.width > maxSize || image.height > maxSize) {
                scale = maxSize / Math.max(image.width, image.height);
            }
            // only perform resize if necessary
            if (scale < 1 || needsPowerOfTwo === true) {
                // only perform resize for certain image types
                if ((typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement) ||
                    (typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement) ||
                    (typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap)) {
                    var floor = needsPowerOfTwo ? MathUtils.floorPowerOfTwo : Math.floor;
                    var width = floor(scale * image.width);
                    var height = floor(scale * image.height);
                    if (_canvas === undefined)
                        _canvas = createCanvas(width, height);
                    // cube textures can't reuse the same canvas
                    var canvas = needsNewCanvas ? createCanvas(width, height) : _canvas;
                    canvas.width = width;
                    canvas.height = height;
                    var context = canvas.getContext('2d');
                    context.drawImage(image, 0, 0, width, height);
                    console.warn('THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').');
                    return canvas;
                }
                else {
                    if ('data' in image) {
                        console.warn('THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').');
                    }
                    return image;
                }
            }
            return image;
        }
        function isPowerOfTwo(image) {
            return MathUtils.isPowerOfTwo(image.width) && MathUtils.isPowerOfTwo(image.height);
        }
        function textureNeedsPowerOfTwo(texture) {
            if (isWebGL2)
                return false;
            return (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) ||
                (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter);
        }
        function textureNeedsGenerateMipmaps(texture, supportsMips) {
            return texture.generateMipmaps && supportsMips &&
                texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
        }
        function generateMipmap(target, texture, width, height) {
            _gl.generateMipmap(target);
            var textureProperties = properties.get(texture);
            // Note: Math.log( x ) * Math.LOG2E used instead of Math.log2( x ) which is not supported by IE11
            textureProperties.__maxMipLevel = Math.log(Math.max(width, height)) * Math.LOG2E;
        }
        function getInternalFormat(internalFormatName, glFormat, glType) {
            if (isWebGL2 === false)
                return glFormat;
            if (internalFormatName !== null) {
                if (_gl[internalFormatName] !== undefined)
                    return _gl[internalFormatName];
                console.warn('THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'');
            }
            var internalFormat = glFormat;
            if (glFormat === 6403) {
                if (glType === 5126)
                    internalFormat = 33326;
                if (glType === 5131)
                    internalFormat = 33325;
                if (glType === 5121)
                    internalFormat = 33321;
            }
            if (glFormat === 6407) {
                if (glType === 5126)
                    internalFormat = 34837;
                if (glType === 5131)
                    internalFormat = 34843;
                if (glType === 5121)
                    internalFormat = 32849;
            }
            if (glFormat === 6408) {
                if (glType === 5126)
                    internalFormat = 34836;
                if (glType === 5131)
                    internalFormat = 34842;
                if (glType === 5121)
                    internalFormat = 32856;
            }
            if (internalFormat === 33325 || internalFormat === 33326 ||
                internalFormat === 34842 || internalFormat === 34836) {
                extensions.get('EXT_color_buffer_float');
            }
            else if (internalFormat === 34843 || internalFormat === 34837) {
                console.warn('THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead.');
            }
            return internalFormat;
        }
        // Fallback filters for non-power-of-2 textures
        function filterFallback(f) {
            if (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) {
                return 9728;
            }
            return 9729;
        }
        //
        function onTextureDispose(event) {
            var texture = event.target;
            texture.removeEventListener('dispose', onTextureDispose);
            deallocateTexture(texture);
            if (texture.isVideoTexture) {
                _videoTextures.delete(texture);
            }
            info.memory.textures--;
        }
        function onRenderTargetDispose(event) {
            var renderTarget = event.target;
            renderTarget.removeEventListener('dispose', onRenderTargetDispose);
            deallocateRenderTarget(renderTarget);
            info.memory.textures--;
        }
        //
        function deallocateTexture(texture) {
            var textureProperties = properties.get(texture);
            if (textureProperties.__webglInit === undefined)
                return;
            _gl.deleteTexture(textureProperties.__webglTexture);
            properties.remove(texture);
        }
        function deallocateRenderTarget(renderTarget) {
            var renderTargetProperties = properties.get(renderTarget);
            var textureProperties = properties.get(renderTarget.texture);
            if (!renderTarget)
                return;
            if (textureProperties.__webglTexture !== undefined) {
                _gl.deleteTexture(textureProperties.__webglTexture);
            }
            if (renderTarget.depthTexture) {
                renderTarget.depthTexture.dispose();
            }
            if (renderTarget.isWebGLCubeRenderTarget) {
                for (var i = 0; i < 6; i++) {
                    _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);
                    if (renderTargetProperties.__webglDepthbuffer)
                        _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
                }
            }
            else {
                _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
                if (renderTargetProperties.__webglDepthbuffer)
                    _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
            }
            if (renderTarget.isWebGLMultiviewRenderTarget) {
                _gl.deleteTexture(renderTargetProperties.__webglColorTexture);
                _gl.deleteTexture(renderTargetProperties.__webglDepthStencilTexture);
                info.memory.textures -= 2;
                for (var i = 0, il = renderTargetProperties.__webglViewFramebuffers.length; i < il; i++) {
                    _gl.deleteFramebuffer(renderTargetProperties.__webglViewFramebuffers[i]);
                }
            }
            properties.remove(renderTarget.texture);
            properties.remove(renderTarget);
        }
        //
        var textureUnits = 0;
        function resetTextureUnits() {
            textureUnits = 0;
        }
        function allocateTextureUnit() {
            var textureUnit = textureUnits;
            if (textureUnit >= maxTextures) {
                console.warn('THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures);
            }
            textureUnits += 1;
            return textureUnit;
        }
        //
        function setTexture2D(texture, slot) {
            var textureProperties = properties.get(texture);
            if (texture.isVideoTexture)
                updateVideoTexture(texture);
            if (texture.version > 0 && textureProperties.__version !== texture.version) {
                var image = texture.image;
                if (image === undefined) {
                    console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined');
                }
                else if (image.complete === false) {
                    console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete');
                }
                else {
                    uploadTexture(textureProperties, texture, slot);
                    return;
                }
            }
            state.activeTexture(33984 + slot);
            state.bindTexture(3553, textureProperties.__webglTexture);
        }
        function setTexture2DArray(texture, slot) {
            var textureProperties = properties.get(texture);
            if (texture.version > 0 && textureProperties.__version !== texture.version) {
                uploadTexture(textureProperties, texture, slot);
                return;
            }
            state.activeTexture(33984 + slot);
            state.bindTexture(35866, textureProperties.__webglTexture);
        }
        function setTexture3D(texture, slot) {
            var textureProperties = properties.get(texture);
            if (texture.version > 0 && textureProperties.__version !== texture.version) {
                uploadTexture(textureProperties, texture, slot);
                return;
            }
            state.activeTexture(33984 + slot);
            state.bindTexture(32879, textureProperties.__webglTexture);
        }
        function setTextureCube(texture, slot) {
            if (texture.image.length !== 6)
                return;
            var textureProperties = properties.get(texture);
            if (texture.version > 0 && textureProperties.__version !== texture.version) {
                initTexture(textureProperties, texture);
                state.activeTexture(33984 + slot);
                state.bindTexture(34067, textureProperties.__webglTexture);
                _gl.pixelStorei(37440, texture.flipY);
                var isCompressed = (texture && (texture.isCompressedTexture || texture.image[0].isCompressedTexture));
                var isDataTexture = (texture.image[0] && texture.image[0].isDataTexture);
                var cubeImage = [];
                for (var i = 0; i < 6; i++) {
                    if (!isCompressed && !isDataTexture) {
                        cubeImage[i] = resizeImage(texture.image[i], false, true, maxCubemapSize);
                    }
                    else {
                        cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
                    }
                }
                var image = cubeImage[0], supportsMips = isPowerOfTwo(image) || isWebGL2, glFormat = utils.convert(texture.format), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
                setTextureParameters(34067, texture, supportsMips);
                var mipmaps;
                if (isCompressed) {
                    for (var i = 0; i < 6; i++) {
                        mipmaps = cubeImage[i].mipmaps;
                        for (var j = 0; j < mipmaps.length; j++) {
                            var mipmap = mipmaps[j];
                            if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
                                if (glFormat !== null) {
                                    state.compressedTexImage2D(34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                                }
                                else {
                                    console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()');
                                }
                            }
                            else {
                                state.texImage2D(34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                            }
                        }
                    }
                    textureProperties.__maxMipLevel = mipmaps.length - 1;
                }
                else {
                    mipmaps = texture.mipmaps;
                    for (var i = 0; i < 6; i++) {
                        if (isDataTexture) {
                            state.texImage2D(34069 + i, 0, glInternalFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);
                            for (var j = 0; j < mipmaps.length; j++) {
                                var mipmap = mipmaps[j];
                                var mipmapImage = mipmap.image[i].image;
                                state.texImage2D(34069 + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
                            }
                        }
                        else {
                            state.texImage2D(34069 + i, 0, glInternalFormat, glFormat, glType, cubeImage[i]);
                            for (var j = 0; j < mipmaps.length; j++) {
                                var mipmap = mipmaps[j];
                                state.texImage2D(34069 + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i]);
                            }
                        }
                    }
                    textureProperties.__maxMipLevel = mipmaps.length;
                }
                if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
                    // We assume images for cube map have the same size.
                    generateMipmap(34067, texture, image.width, image.height);
                }
                textureProperties.__version = texture.version;
                if (texture.onUpdate)
                    texture.onUpdate(texture);
            }
            else {
                state.activeTexture(33984 + slot);
                state.bindTexture(34067, textureProperties.__webglTexture);
            }
        }
        function setTextureCubeDynamic(texture, slot) {
            state.activeTexture(33984 + slot);
            state.bindTexture(34067, properties.get(texture).__webglTexture);
        }
        var wrappingToGL = {
            [RepeatWrapping]: 10497,
            [ClampToEdgeWrapping]: 33071,
            [MirroredRepeatWrapping]: 33648
        };
        var filterToGL = {
            [NearestFilter]: 9728,
            [NearestMipmapNearestFilter]: 9984,
            [NearestMipmapLinearFilter]: 9986,
            [LinearFilter]: 9729,
            [LinearMipmapNearestFilter]: 9985,
            [LinearMipmapLinearFilter]: 9987
        };
        function setTextureParameters(textureType, texture, supportsMips) {
            if (supportsMips) {
                _gl.texParameteri(textureType, 10242, wrappingToGL[texture.wrapS]);
                _gl.texParameteri(textureType, 10243, wrappingToGL[texture.wrapT]);
                if (textureType === 32879 || textureType === 35866) {
                    _gl.texParameteri(textureType, 32882, wrappingToGL[texture.wrapR]);
                }
                _gl.texParameteri(textureType, 10240, filterToGL[texture.magFilter]);
                _gl.texParameteri(textureType, 10241, filterToGL[texture.minFilter]);
            }
            else {
                _gl.texParameteri(textureType, 10242, 33071);
                _gl.texParameteri(textureType, 10243, 33071);
                if (textureType === 32879 || textureType === 35866) {
                    _gl.texParameteri(textureType, 32882, 33071);
                }
                if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
                    console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.');
                }
                _gl.texParameteri(textureType, 10240, filterFallback(texture.magFilter));
                _gl.texParameteri(textureType, 10241, filterFallback(texture.minFilter));
                if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
                    console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.');
                }
            }
            var extension = extensions.get('EXT_texture_filter_anisotropic');
            if (extension) {
                if (texture.type === FloatType && extensions.get('OES_texture_float_linear') === null)
                    return;
                if (texture.type === HalfFloatType && (isWebGL2 || extensions.get('OES_texture_half_float_linear')) === null)
                    return;
                if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
                    _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
                    properties.get(texture).__currentAnisotropy = texture.anisotropy;
                }
            }
        }
        function initTexture(textureProperties, texture) {
            if (textureProperties.__webglInit === undefined) {
                textureProperties.__webglInit = true;
                texture.addEventListener('dispose', onTextureDispose);
                textureProperties.__webglTexture = _gl.createTexture();
                info.memory.textures++;
            }
        }
        function uploadTexture(textureProperties, texture, slot) {
            var textureType = 3553;
            if (texture.isDataTexture2DArray)
                textureType = 35866;
            if (texture.isDataTexture3D)
                textureType = 32879;
            initTexture(textureProperties, texture);
            state.activeTexture(33984 + slot);
            state.bindTexture(textureType, textureProperties.__webglTexture);
            _gl.pixelStorei(37440, texture.flipY);
            _gl.pixelStorei(37441, texture.premultiplyAlpha);
            _gl.pixelStorei(3317, texture.unpackAlignment);
            var needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo(texture.image) === false;
            var image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
            var supportsMips = isPowerOfTwo(image) || isWebGL2, glFormat = utils.convert(texture.format), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
            setTextureParameters(textureType, texture, supportsMips);
            var mipmap, mipmaps = texture.mipmaps;
            if (texture.isDepthTexture) {
                // populate depth texture with dummy data
                glInternalFormat = 6402;
                if (texture.type === FloatType) {
                    if (isWebGL2 === false)
                        throw new Error('Float Depth Texture only supported in WebGL2.0');
                    glInternalFormat = 36012;
                }
                else if (isWebGL2) {
                    // WebGL 2.0 requires signed internalformat for glTexImage2D
                    glInternalFormat = 33189;
                }
                if (texture.format === DepthFormat && glInternalFormat === 6402) {
                    // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
                    // DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
                    // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
                    if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
                        console.warn('THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.');
                        texture.type = UnsignedShortType;
                        glType = utils.convert(texture.type);
                    }
                }
                // Depth stencil textures need the DEPTH_STENCIL internal format
                // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
                if (texture.format === DepthStencilFormat) {
                    glInternalFormat = 34041;
                    // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
                    // DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
                    // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
                    if (texture.type !== UnsignedInt248Type) {
                        console.warn('THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.');
                        texture.type = UnsignedInt248Type;
                        glType = utils.convert(texture.type);
                    }
                }
                state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
            }
            else if (texture.isDataTexture) {
                // use manually created mipmaps if available
                // if there are no manual mipmaps
                // set 0 level mipmap and then use GL to generate other mipmap levels
                if (mipmaps.length > 0 && supportsMips) {
                    for (var i = 0, il = mipmaps.length; i < il; i++) {
                        mipmap = mipmaps[i];
                        state.texImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                    }
                    texture.generateMipmaps = false;
                    textureProperties.__maxMipLevel = mipmaps.length - 1;
                }
                else {
                    state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
                    textureProperties.__maxMipLevel = 0;
                }
            }
            else if (texture.isCompressedTexture) {
                for (var i = 0, il = mipmaps.length; i < il; i++) {
                    mipmap = mipmaps[i];
                    if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
                        if (glFormat !== null) {
                            state.compressedTexImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                        }
                        else {
                            console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');
                        }
                    }
                    else {
                        state.texImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                    }
                }
                textureProperties.__maxMipLevel = mipmaps.length - 1;
            }
            else if (texture.isDataTexture2DArray) {
                state.texImage3D(35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
                textureProperties.__maxMipLevel = 0;
            }
            else if (texture.isDataTexture3D) {
                state.texImage3D(32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
                textureProperties.__maxMipLevel = 0;
            }
            else {
                // regular Texture (image, video, canvas)
                // use manually created mipmaps if available
                // if there are no manual mipmaps
                // set 0 level mipmap and then use GL to generate other mipmap levels
                if (mipmaps.length > 0 && supportsMips) {
                    for (var i = 0, il = mipmaps.length; i < il; i++) {
                        mipmap = mipmaps[i];
                        state.texImage2D(3553, i, glInternalFormat, glFormat, glType, mipmap);
                    }
                    texture.generateMipmaps = false;
                    textureProperties.__maxMipLevel = mipmaps.length - 1;
                }
                else {
                    state.texImage2D(3553, 0, glInternalFormat, glFormat, glType, image);
                    textureProperties.__maxMipLevel = 0;
                }
            }
            if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
                generateMipmap(textureType, texture, image.width, image.height);
            }
            textureProperties.__version = texture.version;
            if (texture.onUpdate)
                texture.onUpdate(texture);
        }
        // Render targets
        // Setup storage for target texture and bind it to correct framebuffer
        function setupFrameBufferTexture(framebuffer, renderTarget, attachment, textureTarget) {
            var glFormat = utils.convert(renderTarget.texture.format);
            var glType = utils.convert(renderTarget.texture.type);
            var glInternalFormat = getInternalFormat(renderTarget.texture.internalFormat, glFormat, glType);
            state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
            _gl.bindFramebuffer(36160, framebuffer);
            _gl.framebufferTexture2D(36160, attachment, textureTarget, properties.get(renderTarget.texture).__webglTexture, 0);
            _gl.bindFramebuffer(36160, null);
        }
        // Setup storage for internal depth/stencil buffers and bind to correct framebuffer
        function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
            _gl.bindRenderbuffer(36161, renderbuffer);
            if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
                if (isMultisample) {
                    var samples = getRenderTargetSamples(renderTarget);
                    _gl.renderbufferStorageMultisample(36161, samples, 33189, renderTarget.width, renderTarget.height);
                }
                else {
                    _gl.renderbufferStorage(36161, 33189, renderTarget.width, renderTarget.height);
                }
                _gl.framebufferRenderbuffer(36160, 36096, 36161, renderbuffer);
            }
            else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
                if (isMultisample) {
                    var samples = getRenderTargetSamples(renderTarget);
                    _gl.renderbufferStorageMultisample(36161, samples, 35056, renderTarget.width, renderTarget.height);
                }
                else {
                    _gl.renderbufferStorage(36161, 34041, renderTarget.width, renderTarget.height);
                }
                _gl.framebufferRenderbuffer(36160, 33306, 36161, renderbuffer);
            }
            else {
                var glFormat = utils.convert(renderTarget.texture.format);
                var glType = utils.convert(renderTarget.texture.type);
                var glInternalFormat = getInternalFormat(renderTarget.texture.internalFormat, glFormat, glType);
                if (isMultisample) {
                    var samples = getRenderTargetSamples(renderTarget);
                    _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
                }
                else {
                    _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
                }
            }
            _gl.bindRenderbuffer(36161, null);
        }
        // Setup resources for a Depth Texture for a FBO (needs an extension)
        function setupDepthTexture(framebuffer, renderTarget) {
            var isCube = (renderTarget && renderTarget.isWebGLCubeRenderTarget);
            if (isCube)
                throw new Error('Depth Texture with cube render targets is not supported');
            _gl.bindFramebuffer(36160, framebuffer);
            if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
                throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');
            }
            // upload an empty depth texture with framebuffer size
            if (!properties.get(renderTarget.depthTexture).__webglTexture ||
                renderTarget.depthTexture.image.width !== renderTarget.width ||
                renderTarget.depthTexture.image.height !== renderTarget.height) {
                renderTarget.depthTexture.image.width = renderTarget.width;
                renderTarget.depthTexture.image.height = renderTarget.height;
                renderTarget.depthTexture.needsUpdate = true;
            }
            setTexture2D(renderTarget.depthTexture, 0);
            var webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
            if (renderTarget.depthTexture.format === DepthFormat) {
                _gl.framebufferTexture2D(36160, 36096, 3553, webglDepthTexture, 0);
            }
            else if (renderTarget.depthTexture.format === DepthStencilFormat) {
                _gl.framebufferTexture2D(36160, 33306, 3553, webglDepthTexture, 0);
            }
            else {
                throw new Error('Unknown depthTexture format');
            }
        }
        // Setup GL resources for a non-texture depth buffer
        function setupDepthRenderbuffer(renderTarget) {
            var renderTargetProperties = properties.get(renderTarget);
            var isCube = (renderTarget.isWebGLCubeRenderTarget === true);
            if (renderTarget.depthTexture) {
                if (isCube)
                    throw new Error('target.depthTexture not supported in Cube render targets');
                setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
            }
            else {
                if (isCube) {
                    renderTargetProperties.__webglDepthbuffer = [];
                    for (var i = 0; i < 6; i++) {
                        _gl.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer[i]);
                        renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
                        setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget);
                    }
                }
                else {
                    _gl.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);
                    renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
                    setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget);
                }
            }
            _gl.bindFramebuffer(36160, null);
        }
        // Set up GL resources for the render target
        function setupRenderTarget(renderTarget) {
            var renderTargetProperties = properties.get(renderTarget);
            var textureProperties = properties.get(renderTarget.texture);
            renderTarget.addEventListener('dispose', onRenderTargetDispose);
            textureProperties.__webglTexture = _gl.createTexture();
            info.memory.textures++;
            var isCube = (renderTarget.isWebGLCubeRenderTarget === true);
            var isMultisample = (renderTarget.isWebGLMultisampleRenderTarget === true);
            var isMultiview = (renderTarget.isWebGLMultiviewRenderTarget === true);
            var supportsMips = isPowerOfTwo(renderTarget) || isWebGL2;
            // Setup framebuffer
            if (isCube) {
                renderTargetProperties.__webglFramebuffer = [];
                for (var i = 0; i < 6; i++) {
                    renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
                }
            }
            else {
                renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
                if (isMultisample) {
                    if (isWebGL2) {
                        renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
                        renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();
                        _gl.bindRenderbuffer(36161, renderTargetProperties.__webglColorRenderbuffer);
                        var glFormat = utils.convert(renderTarget.texture.format);
                        var glType = utils.convert(renderTarget.texture.type);
                        var glInternalFormat = getInternalFormat(renderTarget.texture.internalFormat, glFormat, glType);
                        var samples = getRenderTargetSamples(renderTarget);
                        _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
                        _gl.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);
                        _gl.framebufferRenderbuffer(36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer);
                        _gl.bindRenderbuffer(36161, null);
                        if (renderTarget.depthBuffer) {
                            renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
                            setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
                        }
                        _gl.bindFramebuffer(36160, null);
                    }
                    else {
                        console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');
                    }
                }
                else if (isMultiview) {
                    var width = renderTarget.width;
                    var height = renderTarget.height;
                    var numViews = renderTarget.numViews;
                    _gl.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);
                    var ext = extensions.get('OVR_multiview2');
                    info.memory.textures += 2;
                    var colorTexture = _gl.createTexture();
                    _gl.bindTexture(35866, colorTexture);
                    _gl.texParameteri(35866, 10240, 9728);
                    _gl.texParameteri(35866, 10241, 9728);
                    _gl.texImage3D(35866, 0, 32856, width, height, numViews, 0, 6408, 5121, null);
                    ext.framebufferTextureMultiviewOVR(36160, 36064, colorTexture, 0, 0, numViews);
                    var depthStencilTexture = _gl.createTexture();
                    _gl.bindTexture(35866, depthStencilTexture);
                    _gl.texParameteri(35866, 10240, 9728);
                    _gl.texParameteri(35866, 10241, 9728);
                    _gl.texImage3D(35866, 0, 35056, width, height, numViews, 0, 34041, 34042, null);
                    ext.framebufferTextureMultiviewOVR(36160, 33306, depthStencilTexture, 0, 0, numViews);
                    var viewFramebuffers = new Array(numViews);
                    for (var i = 0; i < numViews; ++i) {
                        viewFramebuffers[i] = _gl.createFramebuffer();
                        _gl.bindFramebuffer(36160, viewFramebuffers[i]);
                        _gl.framebufferTextureLayer(36160, 36064, colorTexture, 0, i);
                    }
                    renderTargetProperties.__webglColorTexture = colorTexture;
                    renderTargetProperties.__webglDepthStencilTexture = depthStencilTexture;
                    renderTargetProperties.__webglViewFramebuffers = viewFramebuffers;
                    _gl.bindFramebuffer(36160, null);
                    _gl.bindTexture(35866, null);
                }
            }
            // Setup color buffer
            if (isCube) {
                state.bindTexture(34067, textureProperties.__webglTexture);
                setTextureParameters(34067, renderTarget.texture, supportsMips);
                for (var i = 0; i < 6; i++) {
                    setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, 36064, 34069 + i);
                }
                if (textureNeedsGenerateMipmaps(renderTarget.texture, supportsMips)) {
                    generateMipmap(34067, renderTarget.texture, renderTarget.width, renderTarget.height);
                }
                state.bindTexture(34067, null);
            }
            else if (!isMultiview) {
                state.bindTexture(3553, textureProperties.__webglTexture);
                setTextureParameters(3553, renderTarget.texture, supportsMips);
                setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, 36064, 3553);
                if (textureNeedsGenerateMipmaps(renderTarget.texture, supportsMips)) {
                    generateMipmap(3553, renderTarget.texture, renderTarget.width, renderTarget.height);
                }
                state.bindTexture(3553, null);
            }
            // Setup depth and stencil buffers
            if (renderTarget.depthBuffer) {
                setupDepthRenderbuffer(renderTarget);
            }
        }
        function updateRenderTargetMipmap(renderTarget) {
            var texture = renderTarget.texture;
            var supportsMips = isPowerOfTwo(renderTarget) || isWebGL2;
            if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
                var target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;
                var webglTexture = properties.get(texture).__webglTexture;
                state.bindTexture(target, webglTexture);
                generateMipmap(target, texture, renderTarget.width, renderTarget.height);
                state.bindTexture(target, null);
            }
        }
        function updateMultisampleRenderTarget(renderTarget) {
            if (renderTarget.isWebGLMultisampleRenderTarget) {
                if (isWebGL2) {
                    var renderTargetProperties = properties.get(renderTarget);
                    _gl.bindFramebuffer(36008, renderTargetProperties.__webglMultisampledFramebuffer);
                    _gl.bindFramebuffer(36009, renderTargetProperties.__webglFramebuffer);
                    var width = renderTarget.width;
                    var height = renderTarget.height;
                    var mask = 16384;
                    if (renderTarget.depthBuffer)
                        mask |= 256;
                    if (renderTarget.stencilBuffer)
                        mask |= 1024;
                    _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, 9728);
                }
                else {
                    console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');
                }
            }
        }
        function getRenderTargetSamples(renderTarget) {
            return (isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget) ?
                Math.min(maxSamples, renderTarget.samples) : 0;
        }
        function updateVideoTexture(texture) {
            var frame = info.render.frame;
            // Check the last frame we updated the VideoTexture
            if (_videoTextures.get(texture) !== frame) {
                _videoTextures.set(texture, frame);
                texture.update();
            }
        }
        // backwards compatibility
        var warnedTexture2D = false;
        var warnedTextureCube = false;
        function safeSetTexture2D(texture, slot) {
            if (texture && texture.isWebGLRenderTarget) {
                if (warnedTexture2D === false) {
                    console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead.");
                    warnedTexture2D = true;
                }
                texture = texture.texture;
            }
            setTexture2D(texture, slot);
        }
        function safeSetTextureCube(texture, slot) {
            if (texture && texture.isWebGLCubeRenderTarget) {
                if (warnedTextureCube === false) {
                    console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead.");
                    warnedTextureCube = true;
                }
                texture = texture.texture;
            }
            // currently relying on the fact that WebGLCubeRenderTarget.texture is a Texture and NOT a CubeTexture
            // TODO: unify these code paths
            if ((texture && texture.isCubeTexture) ||
                (Array.isArray(texture.image) && texture.image.length === 6)) {
                // CompressedTexture can have Array in image :/
                // this function alone should take care of cube textures
                setTextureCube(texture, slot);
            }
            else {
                // assumed: texture property of THREE.WebGLCubeRenderTarget
                setTextureCubeDynamic(texture, slot);
            }
        }
        //
        this.allocateTextureUnit = allocateTextureUnit;
        this.resetTextureUnits = resetTextureUnits;
        this.setTexture2D = setTexture2D;
        this.setTexture2DArray = setTexture2DArray;
        this.setTexture3D = setTexture3D;
        this.setTextureCube = setTextureCube;
        this.setTextureCubeDynamic = setTextureCubeDynamic;
        this.setupRenderTarget = setupRenderTarget;
        this.updateRenderTargetMipmap = updateRenderTargetMipmap;
        this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
        this.safeSetTexture2D = safeSetTexture2D;
        this.safeSetTextureCube = safeSetTextureCube;
    }
    /**
     * @author thespite / http://www.twitter.com/thespite
     */
    function WebGLUtils(gl, extensions, capabilities) {
        var isWebGL2 = capabilities.isWebGL2;
        function convert(p) {
            var extension;
            if (p === UnsignedByteType)
                return 5121;
            if (p === UnsignedShort4444Type)
                return 32819;
            if (p === UnsignedShort5551Type)
                return 32820;
            if (p === UnsignedShort565Type)
                return 33635;
            if (p === ByteType)
                return 5120;
            if (p === ShortType)
                return 5122;
            if (p === UnsignedShortType)
                return 5123;
            if (p === IntType)
                return 5124;
            if (p === UnsignedIntType)
                return 5125;
            if (p === FloatType)
                return 5126;
            if (p === HalfFloatType) {
                if (isWebGL2)
                    return 5131;
                extension = extensions.get('OES_texture_half_float');
                if (extension !== null) {
                    return extension.HALF_FLOAT_OES;
                }
                else {
                    return null;
                }
            }
            if (p === AlphaFormat)
                return 6406;
            if (p === RGBFormat)
                return 6407;
            if (p === RGBAFormat)
                return 6408;
            if (p === LuminanceFormat)
                return 6409;
            if (p === LuminanceAlphaFormat)
                return 6410;
            if (p === DepthFormat)
                return 6402;
            if (p === DepthStencilFormat)
                return 34041;
            if (p === RedFormat)
                return 6403;
            // WebGL2 formats.
            if (p === RedIntegerFormat)
                return 36244;
            if (p === RGFormat)
                return 33319;
            if (p === RGIntegerFormat)
                return 33320;
            if (p === RGBIntegerFormat)
                return 36248;
            if (p === RGBAIntegerFormat)
                return 36249;
            if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||
                p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
                extension = extensions.get('WEBGL_compressed_texture_s3tc');
                if (extension !== null) {
                    if (p === RGB_S3TC_DXT1_Format)
                        return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    if (p === RGBA_S3TC_DXT1_Format)
                        return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    if (p === RGBA_S3TC_DXT3_Format)
                        return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    if (p === RGBA_S3TC_DXT5_Format)
                        return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                }
                else {
                    return null;
                }
            }
            if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||
                p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
                extension = extensions.get('WEBGL_compressed_texture_pvrtc');
                if (extension !== null) {
                    if (p === RGB_PVRTC_4BPPV1_Format)
                        return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                    if (p === RGB_PVRTC_2BPPV1_Format)
                        return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                    if (p === RGBA_PVRTC_4BPPV1_Format)
                        return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                    if (p === RGBA_PVRTC_2BPPV1_Format)
                        return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
                }
                else {
                    return null;
                }
            }
            if (p === RGB_ETC1_Format) {
                extension = extensions.get('WEBGL_compressed_texture_etc1');
                if (extension !== null) {
                    return extension.COMPRESSED_RGB_ETC1_WEBGL;
                }
                else {
                    return null;
                }
            }
            if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||
                p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||
                p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||
                p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||
                p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format) {
                extension = extensions.get('WEBGL_compressed_texture_astc');
                if (extension !== null) {
                    // TODO Complete?
                    return p;
                }
                else {
                    return null;
                }
            }
            if (p === UnsignedInt248Type) {
                if (isWebGL2)
                    return 34042;
                extension = extensions.get('WEBGL_depth_texture');
                if (extension !== null) {
                    return extension.UNSIGNED_INT_24_8_WEBGL;
                }
                else {
                    return null;
                }
            }
        }
        return { convert: convert };
    }
    exports_14("WebGLUtils", WebGLUtils);
    /**
     * @author fernandojsg / http://fernandojsg.com
     * @author Takahiro https://github.com/takahirox
     */
    function WebGLMultiviewRenderTarget(width, height, numViews, options) {
        WebGLRenderTarget.call(this, width, height, options);
        this.depthBuffer = false;
        this.stencilBuffer = false;
        this.numViews = numViews;
    }
    /**
     * @author fernandojsg / http://fernandojsg.com
     * @author Takahiro https://github.com/takahirox
     */
    function WebGLMultiview(renderer, gl) {
        var DEFAULT_NUMVIEWS = 2;
        var extensions = renderer.extensions;
        var properties = renderer.properties;
        var renderTarget, currentRenderTarget;
        var mat3, mat4, cameraArray, renderSize;
        var available;
        var maxNumViews = 0;
        //
        function isAvailable() {
            if (available === undefined) {
                var extension = extensions.get('OVR_multiview2');
                available = extension !== null && gl.getContextAttributes().antialias === false;
                if (available) {
                    maxNumViews = gl.getParameter(extension.MAX_VIEWS_OVR);
                    renderTarget = new WebGLMultiviewRenderTarget(0, 0, DEFAULT_NUMVIEWS);
                    renderSize = new Vector2();
                    mat4 = [];
                    mat3 = [];
                    cameraArray = [];
                    for (var i = 0; i < maxNumViews; i++) {
                        mat4[i] = new Matrix4();
                        mat3[i] = new Matrix3();
                    }
                }
            }
            return available;
        }
        function getCameraArray(camera) {
            if (camera.isArrayCamera)
                return camera.cameras;
            cameraArray[0] = camera;
            return cameraArray;
        }
        function updateCameraProjectionMatricesUniform(camera, uniforms) {
            var cameras = getCameraArray(camera);
            for (var i = 0; i < cameras.length; i++) {
                mat4[i].copy(cameras[i].projectionMatrix);
            }
            uniforms.setValue(gl, 'projectionMatrices', mat4);
        }
        function updateCameraViewMatricesUniform(camera, uniforms) {
            var cameras = getCameraArray(camera);
            for (var i = 0; i < cameras.length; i++) {
                mat4[i].copy(cameras[i].matrixWorldInverse);
            }
            uniforms.setValue(gl, 'viewMatrices', mat4);
        }
        function updateObjectMatricesUniforms(object, camera, uniforms) {
            var cameras = getCameraArray(camera);
            for (var i = 0; i < cameras.length; i++) {
                mat4[i].multiplyMatrices(cameras[i].matrixWorldInverse, object.matrixWorld);
                mat3[i].getNormalMatrix(mat4[i]);
            }
            uniforms.setValue(gl, 'modelViewMatrices', mat4);
            uniforms.setValue(gl, 'normalMatrices', mat3);
        }
        function isMultiviewCompatible(camera) {
            if (camera.isArrayCamera === undefined)
                return true;
            var cameras = camera.cameras;
            if (cameras.length > maxNumViews)
                return false;
            for (var i = 1, il = cameras.length; i < il; i++) {
                if (cameras[0].viewport.z !== cameras[i].viewport.z ||
                    cameras[0].viewport.w !== cameras[i].viewport.w)
                    return false;
            }
            return true;
        }
        function resizeRenderTarget(camera) {
            if (currentRenderTarget) {
                renderSize.set(currentRenderTarget.width, currentRenderTarget.height);
            }
            else {
                renderer.getDrawingBufferSize(renderSize);
            }
            if (camera.isArrayCamera) {
                var viewport = camera.cameras[0].viewport;
                renderTarget.setSize(viewport.z, viewport.w);
                renderTarget.setNumViews(camera.cameras.length);
            }
            else {
                renderTarget.setSize(renderSize.x, renderSize.y);
                renderTarget.setNumViews(DEFAULT_NUMVIEWS);
            }
        }
        function attachCamera(camera) {
            if (isMultiviewCompatible(camera) === false)
                return;
            currentRenderTarget = renderer.getRenderTarget();
            resizeRenderTarget(camera);
            renderer.setRenderTarget(renderTarget);
        }
        function detachCamera(camera) {
            if (renderTarget !== renderer.getRenderTarget())
                return;
            renderer.setRenderTarget(currentRenderTarget);
            flush(camera);
        }
        function flush(camera) {
            var srcRenderTarget = renderTarget;
            var numViews = srcRenderTarget.numViews;
            var srcFramebuffers = properties.get(srcRenderTarget).__webglViewFramebuffers;
            var viewWidth = srcRenderTarget.width;
            var viewHeight = srcRenderTarget.height;
            if (camera.isArrayCamera) {
                for (var i = 0; i < numViews; i++) {
                    var viewport = camera.cameras[i].viewport;
                    var x1 = viewport.x;
                    var y1 = viewport.y;
                    var x2 = x1 + viewport.z;
                    var y2 = y1 + viewport.w;
                    gl.bindFramebuffer(36008, srcFramebuffers[i]);
                    gl.blitFramebuffer(0, 0, viewWidth, viewHeight, x1, y1, x2, y2, 16384, 9728);
                }
            }
            else {
                gl.bindFramebuffer(36008, srcFramebuffers[0]);
                gl.blitFramebuffer(0, 0, viewWidth, viewHeight, 0, 0, renderSize.x, renderSize.y, 16384, 9728);
            }
        }
        this.isAvailable = isAvailable;
        this.attachCamera = attachCamera;
        this.detachCamera = detachCamera;
        this.updateCameraProjectionMatricesUniform = updateCameraProjectionMatricesUniform;
        this.updateCameraViewMatricesUniform = updateCameraViewMatricesUniform;
        this.updateObjectMatricesUniforms = updateObjectMatricesUniforms;
    }
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    function ArrayCamera(array) {
        PerspectiveCamera.call(this);
        this.cameras = array || [];
    }
    exports_14("ArrayCamera", ArrayCamera);
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    function Group() {
        Object3D.call(this);
        this.type = 'Group';
    }
    exports_14("Group", Group);
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    function WebXRManager(renderer, gl) {
        var scope = this;
        var session = null;
        // var framebufferScaleFactor = 1.0;
        var referenceSpace = null;
        var referenceSpaceType = 'local-floor';
        var pose = null;
        var controllers = [];
        var inputSourcesMap = new Map();
        //
        var cameraL = new PerspectiveCamera();
        cameraL.layers.enable(1);
        cameraL.viewport = new Vector4();
        var cameraR = new PerspectiveCamera();
        cameraR.layers.enable(2);
        cameraR.viewport = new Vector4();
        var cameraVR = new ArrayCamera([cameraL, cameraR]);
        cameraVR.layers.enable(1);
        cameraVR.layers.enable(2);
        var _currentDepthNear = null;
        var _currentDepthFar = null;
        //
        this.enabled = false;
        this.isPresenting = false;
        this.getController = function (id) {
            var controller = controllers[id];
            if (controller === undefined) {
                controller = {};
                controllers[id] = controller;
            }
            if (controller.targetRay === undefined) {
                controller.targetRay = new Group();
                controller.targetRay.matrixAutoUpdate = false;
                controller.targetRay.visible = false;
            }
            return controller.targetRay;
        };
        this.getControllerGrip = function (id) {
            var controller = controllers[id];
            if (controller === undefined) {
                controller = {};
                controllers[id] = controller;
            }
            if (controller.grip === undefined) {
                controller.grip = new Group();
                controller.grip.matrixAutoUpdate = false;
                controller.grip.visible = false;
            }
            return controller.grip;
        };
        //
        function onSessionEvent(event) {
            var controller = inputSourcesMap.get(event.inputSource);
            if (controller) {
                if (controller.targetRay) {
                    controller.targetRay.dispatchEvent({ type: event.type });
                }
                if (controller.grip) {
                    controller.grip.dispatchEvent({ type: event.type });
                }
            }
        }
        function onSessionEnd() {
            inputSourcesMap.forEach(function (controller, inputSource) {
                if (controller.targetRay) {
                    controller.targetRay.dispatchEvent({ type: 'disconnected', data: inputSource });
                    controller.targetRay.visible = false;
                }
                if (controller.grip) {
                    controller.grip.dispatchEvent({ type: 'disconnected', data: inputSource });
                    controller.grip.visible = false;
                }
            });
            inputSourcesMap.clear();
            //
            renderer.setFramebuffer(null);
            renderer.setRenderTarget(renderer.getRenderTarget()); // Hack #15830
            animation.stop();
            scope.isPresenting = false;
            scope.dispatchEvent({ type: 'sessionend' });
        }
        function onRequestReferenceSpace(value) {
            referenceSpace = value;
            animation.setContext(session);
            animation.start();
            scope.isPresenting = true;
            scope.dispatchEvent({ type: 'sessionstart' });
        }
        this.setFramebufferScaleFactor = function ( /* value */) {
            // framebufferScaleFactor = value;
        };
        this.setReferenceSpaceType = function (value) {
            referenceSpaceType = value;
        };
        this.getReferenceSpace = function () {
            return referenceSpace;
        };
        this.getSession = function () {
            return session;
        };
        this.setSession = function (value) {
            session = value;
            if (session !== null) {
                session.addEventListener('select', onSessionEvent);
                session.addEventListener('selectstart', onSessionEvent);
                session.addEventListener('selectend', onSessionEvent);
                session.addEventListener('squeeze', onSessionEvent);
                session.addEventListener('squeezestart', onSessionEvent);
                session.addEventListener('squeezeend', onSessionEvent);
                session.addEventListener('end', onSessionEnd);
                var attributes = gl.getContextAttributes();
                var layerInit = {
                    antialias: attributes.antialias,
                    alpha: attributes.alpha,
                    depth: attributes.depth,
                    stencil: attributes.stencil
                };
                // eslint-disable-next-line no-undef
                var baseLayer = new XRWebGLLayer(session, gl, layerInit);
                session.updateRenderState({ baseLayer: baseLayer });
                session.requestReferenceSpace(referenceSpaceType).then(onRequestReferenceSpace);
                //
                session.addEventListener('inputsourceschange', updateInputSources);
            }
        };
        function updateInputSources(event) {
            var inputSources = session.inputSources;
            // Assign inputSources to available controllers
            for (var i = 0; i < controllers.length; i++) {
                inputSourcesMap.set(inputSources[i], controllers[i]);
            }
            // Notify disconnected
            for (var i = 0; i < event.removed.length; i++) {
                var inputSource = event.removed[i];
                var controller = inputSourcesMap.get(inputSource);
                if (controller) {
                    if (controller.targetRay) {
                        controller.targetRay.dispatchEvent({ type: 'disconnected', data: inputSource });
                    }
                    if (controller.grip) {
                        controller.grip.dispatchEvent({ type: 'disconnected', data: inputSource });
                    }
                    inputSourcesMap.delete(inputSource);
                }
            }
            // Notify connected
            for (var i = 0; i < event.added.length; i++) {
                var inputSource = event.added[i];
                var controller = inputSourcesMap.get(inputSource);
                if (controller) {
                    if (controller.targetRay) {
                        controller.targetRay.dispatchEvent({ type: 'connected', data: inputSource });
                    }
                    if (controller.grip) {
                        controller.grip.dispatchEvent({ type: 'connected', data: inputSource });
                    }
                }
            }
        }
        //
        var cameraLPos = new Vector3();
        var cameraRPos = new Vector3();
        /**
         * @author jsantell / https://www.jsantell.com/
         *
         * Assumes 2 cameras that are parallel and share an X-axis, and that
         * the cameras' projection and world matrices have already been set.
         * And that near and far planes are identical for both cameras.
         * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
         */
        function setProjectionFromUnion(camera, cameraL, cameraR) {
            cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);
            cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);
            var ipd = cameraLPos.distanceTo(cameraRPos);
            var projL = cameraL.projectionMatrix.elements;
            var projR = cameraR.projectionMatrix.elements;
            // VR systems will have identical far and near planes, and
            // most likely identical top and bottom frustum extents.
            // Use the left camera for these values.
            var near = projL[14] / (projL[10] - 1);
            var far = projL[14] / (projL[10] + 1);
            var topFov = (projL[9] + 1) / projL[5];
            var bottomFov = (projL[9] - 1) / projL[5];
            var leftFov = (projL[8] - 1) / projL[0];
            var rightFov = (projR[8] + 1) / projR[0];
            var left = near * leftFov;
            var right = near * rightFov;
            // Calculate the new camera's position offset from the
            // left camera. xOffset should be roughly half `ipd`.
            var zOffset = ipd / (-leftFov + rightFov);
            var xOffset = zOffset * -leftFov;
            // TODO: Better way to apply this offset?
            cameraL.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
            camera.translateX(xOffset);
            camera.translateZ(zOffset);
            camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
            camera.matrixWorldInverse.getInverse(camera.matrixWorld);
            // Find the union of the frustum values of the cameras and scale
            // the values so that the near plane's position does not change in world space,
            // although must now be relative to the new union camera.
            var near2 = near + zOffset;
            var far2 = far + zOffset;
            var left2 = left - xOffset;
            var right2 = right + (ipd - xOffset);
            var top2 = topFov * far / far2 * near2;
            var bottom2 = bottomFov * far / far2 * near2;
            camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
        }
        function updateCamera(camera, parent) {
            if (parent === null) {
                camera.matrixWorld.copy(camera.matrix);
            }
            else {
                camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
            }
            camera.matrixWorldInverse.getInverse(camera.matrixWorld);
        }
        this.getCamera = function (camera) {
            cameraVR.near = cameraR.near = cameraL.near = camera.near;
            cameraVR.far = cameraR.far = cameraL.far = camera.far;
            if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {
                // Note that the new renderState won't apply until the next frame. See #18320
                session.updateRenderState({
                    depthNear: cameraVR.near,
                    depthFar: cameraVR.far
                });
                _currentDepthNear = cameraVR.near;
                _currentDepthFar = cameraVR.far;
            }
            var parent = camera.parent;
            var cameras = cameraVR.cameras;
            updateCamera(cameraVR, parent);
            for (var i = 0; i < cameras.length; i++) {
                updateCamera(cameras[i], parent);
            }
            // update camera and its children
            camera.matrixWorld.copy(cameraVR.matrixWorld);
            var children = camera.children;
            for (var i = 0, l = children.length; i < l; i++) {
                children[i].updateMatrixWorld(true);
            }
            setProjectionFromUnion(cameraVR, cameraL, cameraR);
            return cameraVR;
        };
        // Animation Loop
        var onAnimationFrameCallback = null;
        function onAnimationFrame(time, frame) {
            pose = frame.getViewerPose(referenceSpace);
            if (pose !== null) {
                var views = pose.views;
                var baseLayer = session.renderState.baseLayer;
                renderer.setFramebuffer(baseLayer.framebuffer);
                for (var i = 0; i < views.length; i++) {
                    var view = views[i];
                    var viewport = baseLayer.getViewport(view);
                    var camera = cameraVR.cameras[i];
                    camera.matrix.fromArray(view.transform.matrix);
                    camera.projectionMatrix.fromArray(view.projectionMatrix);
                    camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
                    if (i === 0) {
                        cameraVR.matrix.copy(camera.matrix);
                    }
                }
            }
            //
            var inputSources = session.inputSources;
            for (var i = 0; i < controllers.length; i++) {
                var controller = controllers[i];
                var inputSource = inputSources[i];
                var inputPose = null;
                var gripPose = null;
                if (inputSource) {
                    if (controller.targetRay) {
                        inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
                        if (inputPose !== null) {
                            controller.targetRay.matrix.fromArray(inputPose.transform.matrix);
                            controller.targetRay.matrix.decompose(controller.targetRay.position, controller.targetRay.rotation, controller.targetRay.scale);
                        }
                    }
                    if (controller.grip && inputSource.gripSpace) {
                        gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
                        if (gripPose !== null) {
                            controller.grip.matrix.fromArray(gripPose.transform.matrix);
                            controller.grip.matrix.decompose(controller.grip.position, controller.grip.rotation, controller.grip.scale);
                        }
                    }
                }
                if (controller.targetRay) {
                    controller.targetRay.visible = inputPose !== null;
                }
                if (controller.grip) {
                    controller.grip.visible = gripPose !== null;
                }
            }
            if (onAnimationFrameCallback)
                onAnimationFrameCallback(time, frame);
        }
        var animation = new WebGLAnimation();
        animation.setAnimationLoop(onAnimationFrame);
        this.setAnimationLoop = function (callback) {
            onAnimationFrameCallback = callback;
        };
        this.dispose = function () { };
    }
    /**
     * @author supereggbert / http://www.paulbrunt.co.uk/
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     * @author szimek / https://github.com/szimek/
     * @author tschw
     */
    function WebGLRenderer(parameters) {
        parameters = parameters || {};
        var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas'), _context = parameters.context !== undefined ? parameters.context : null, _alpha = parameters.alpha !== undefined ? parameters.alpha : false, _depth = parameters.depth !== undefined ? parameters.depth : true, _stencil = parameters.stencil !== undefined ? parameters.stencil : true, _antialias = parameters.antialias !== undefined ? parameters.antialias : false, _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true, _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false, _powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default', _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;
        var currentRenderList = null;
        var currentRenderState = null;
        // public properties
        this.domElement = _canvas;
        // Debug configuration container
        this.debug = {
            /**
             * Enables error checking and reporting when shader programs are being compiled
             * @type {boolean}
             */
            checkShaderErrors: true
        };
        // clearing
        this.autoClear = true;
        this.autoClearColor = true;
        this.autoClearDepth = true;
        this.autoClearStencil = true;
        // scene graph
        this.sortObjects = true;
        // user-defined clipping
        this.clippingPlanes = [];
        this.localClippingEnabled = false;
        // physically based shading
        this.gammaFactor = 2.0; // for backwards compatibility
        this.outputEncoding = LinearEncoding;
        // physical lights
        this.physicallyCorrectLights = false;
        // tone mapping
        this.toneMapping = LinearToneMapping;
        this.toneMappingExposure = 1.0;
        this.toneMappingWhitePoint = 1.0;
        // morphs
        this.maxMorphTargets = 8;
        this.maxMorphNormals = 4;
        // internal properties
        var _this = this, _isContextLost = false, 
        // internal state cache
        _framebuffer = null, _currentActiveCubeFace = 0, _currentActiveMipmapLevel = 0, _currentRenderTarget = null, _currentFramebuffer = null, _currentMaterialId = -1, 
        // geometry and program caching
        _currentGeometryProgram = {
            geometry: null,
            program: null,
            wireframe: false
        }, _currentCamera = null, _currentArrayCamera = null, _currentViewport = new Vector4(), _currentScissor = new Vector4(), _currentScissorTest = null, 
        //
        _width = _canvas.width, _height = _canvas.height, _pixelRatio = 1, _opaqueSort = null, _transparentSort = null, _viewport = new Vector4(0, 0, _width, _height), _scissor = new Vector4(0, 0, _width, _height), _scissorTest = false, 
        // frustum
        _frustum = new Frustum(), 
        // clipping
        _clipping = new WebGLClipping(), _clippingEnabled = false, _localClippingEnabled = false, 
        // camera matrices cache
        _projScreenMatrix = new Matrix4(), _vector3 = new Vector3();
        function getTargetPixelRatio() {
            return _currentRenderTarget === null ? _pixelRatio : 1;
        }
        // initialize
        var _gl;
        try {
            var contextAttributes = {
                alpha: _alpha,
                depth: _depth,
                stencil: _stencil,
                antialias: _antialias,
                premultipliedAlpha: _premultipliedAlpha,
                preserveDrawingBuffer: _preserveDrawingBuffer,
                powerPreference: _powerPreference,
                failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat,
                xrCompatible: true
            };
            // event listeners must be registered before WebGL context is created, see #12753
            _canvas.addEventListener('webglcontextlost', onContextLost, false);
            _canvas.addEventListener('webglcontextrestored', onContextRestore, false);
            _gl = _context || _canvas.getContext('webgl', contextAttributes) || _canvas.getContext('experimental-webgl', contextAttributes);
            if (_gl === null) {
                if (_canvas.getContext('webgl') !== null) {
                    throw new Error('Error creating WebGL context with your selected attributes.');
                }
                else {
                    throw new Error('Error creating WebGL context.');
                }
            }
            // Some experimental-webgl implementations do not have getShaderPrecisionFormat
            if (_gl.getShaderPrecisionFormat === undefined) {
                _gl.getShaderPrecisionFormat = function () {
                    return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };
                };
            }
        }
        catch (error) {
            console.error('THREE.WebGLRenderer: ' + error.message);
            throw error;
        }
        var extensions, capabilities, state, info;
        var properties, textures, attributes, geometries, objects;
        var programCache, renderLists, renderStates;
        var background, morphtargets, bufferRenderer, indexedBufferRenderer;
        var utils;
        function initGLContext() {
            extensions = new WebGLExtensions(_gl);
            capabilities = new WebGLCapabilities(_gl, extensions, parameters);
            if (capabilities.isWebGL2 === false) {
                extensions.get('WEBGL_depth_texture');
                extensions.get('OES_texture_float');
                extensions.get('OES_texture_half_float');
                extensions.get('OES_texture_half_float_linear');
                extensions.get('OES_standard_derivatives');
                extensions.get('OES_element_index_uint');
                extensions.get('ANGLE_instanced_arrays');
            }
            extensions.get('OES_texture_float_linear');
            utils = new WebGLUtils(_gl, extensions, capabilities);
            state = new WebGLState(_gl, extensions, capabilities);
            state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
            state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
            info = new WebGLInfo(_gl);
            properties = new WebGLProperties();
            textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
            attributes = new WebGLAttributes(_gl, capabilities);
            geometries = new WebGLGeometries(_gl, attributes, info);
            objects = new WebGLObjects(_gl, geometries, attributes, info);
            morphtargets = new WebGLMorphtargets(_gl);
            programCache = new WebGLPrograms(_this, extensions, capabilities);
            renderLists = new WebGLRenderLists();
            renderStates = new WebGLRenderStates();
            background = new WebGLBackground(_this, state, objects, _premultipliedAlpha);
            bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);
            indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);
            info.programs = programCache.programs;
            _this.capabilities = capabilities;
            _this.extensions = extensions;
            _this.properties = properties;
            _this.renderLists = renderLists;
            _this.state = state;
            _this.info = info;
        }
        initGLContext();
        // xr
        var xr = new WebXRManager(_this, _gl);
        this.xr = xr;
        // Multiview
        var multiview = new WebGLMultiview(_this, _gl);
        // shadow map
        var shadowMap = new WebGLShadowMap(_this, objects, capabilities.maxTextureSize);
        this.shadowMap = shadowMap;
        // API
        this.getContext = function () {
            return _gl;
        };
        this.getContextAttributes = function () {
            return _gl.getContextAttributes();
        };
        this.forceContextLoss = function () {
            var extension = extensions.get('WEBGL_lose_context');
            if (extension)
                extension.loseContext();
        };
        this.forceContextRestore = function () {
            var extension = extensions.get('WEBGL_lose_context');
            if (extension)
                extension.restoreContext();
        };
        this.getPixelRatio = function () {
            return _pixelRatio;
        };
        this.setPixelRatio = function (value) {
            if (value === undefined)
                return;
            _pixelRatio = value;
            this.setSize(_width, _height, false);
        };
        this.getSize = function (target) {
            if (target === undefined) {
                console.warn('WebGLRenderer: .getsize() now requires a Vector2 as an argument');
                target = new Vector2();
            }
            return target.set(_width, _height);
        };
        this.setSize = function (width, height, updateStyle) {
            if (xr.isPresenting) {
                console.warn('THREE.WebGLRenderer: Can\'t change size while VR device is presenting.');
                return;
            }
            _width = width;
            _height = height;
            _canvas.width = Math.floor(width * _pixelRatio);
            _canvas.height = Math.floor(height * _pixelRatio);
            if (updateStyle !== false) {
                _canvas.style.width = width + 'px';
                _canvas.style.height = height + 'px';
            }
            this.setViewport(0, 0, width, height);
        };
        this.getDrawingBufferSize = function (target) {
            if (target === undefined) {
                console.warn('WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument');
                target = new Vector2();
            }
            return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
        };
        this.setDrawingBufferSize = function (width, height, pixelRatio) {
            _width = width;
            _height = height;
            _pixelRatio = pixelRatio;
            _canvas.width = Math.floor(width * pixelRatio);
            _canvas.height = Math.floor(height * pixelRatio);
            this.setViewport(0, 0, width, height);
        };
        this.getCurrentViewport = function (target) {
            if (target === undefined) {
                console.warn('WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument');
                target = new Vector4();
            }
            return target.copy(_currentViewport);
        };
        this.getViewport = function (target) {
            return target.copy(_viewport);
        };
        this.setViewport = function (x, y, width, height) {
            if (x.isVector4) {
                _viewport.set(x.x, x.y, x.z, x.w);
            }
            else {
                _viewport.set(x, y, width, height);
            }
            state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
        };
        this.getScissor = function (target) {
            return target.copy(_scissor);
        };
        this.setScissor = function (x, y, width, height) {
            if (x.isVector4) {
                _scissor.set(x.x, x.y, x.z, x.w);
            }
            else {
                _scissor.set(x, y, width, height);
            }
            state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
        };
        this.getScissorTest = function () {
            return _scissorTest;
        };
        this.setScissorTest = function (boolean) {
            state.setScissorTest(_scissorTest = boolean);
        };
        this.setOpaqueSort = function (method) {
            _opaqueSort = method;
        };
        this.setTransparentSort = function (method) {
            _transparentSort = method;
        };
        // Clearing
        this.getClearColor = function () {
            return background.getClearColor();
        };
        this.setClearColor = function () {
            background.setClearColor.apply(background, arguments);
        };
        this.getClearAlpha = function () {
            return background.getClearAlpha();
        };
        this.setClearAlpha = function () {
            background.setClearAlpha.apply(background, arguments);
        };
        this.clear = function (color, depth, stencil) {
            var bits = 0;
            if (color === undefined || color)
                bits |= 16384;
            if (depth === undefined || depth)
                bits |= 256;
            if (stencil === undefined || stencil)
                bits |= 1024;
            _gl.clear(bits);
        };
        this.clearColor = function () {
            this.clear(true, false, false);
        };
        this.clearDepth = function () {
            this.clear(false, true, false);
        };
        this.clearStencil = function () {
            this.clear(false, false, true);
        };
        //
        this.dispose = function () {
            _canvas.removeEventListener('webglcontextlost', onContextLost, false);
            _canvas.removeEventListener('webglcontextrestored', onContextRestore, false);
            renderLists.dispose();
            renderStates.dispose();
            properties.dispose();
            objects.dispose();
            xr.dispose();
            animation.stop();
        };
        // Events
        function onContextLost(event) {
            event.preventDefault();
            console.log('THREE.WebGLRenderer: Context Lost.');
            _isContextLost = true;
        }
        function onContextRestore( /* event */) {
            console.log('THREE.WebGLRenderer: Context Restored.');
            _isContextLost = false;
            initGLContext();
        }
        function onMaterialDispose(event) {
            var material = event.target;
            material.removeEventListener('dispose', onMaterialDispose);
            deallocateMaterial(material);
        }
        // Buffer deallocation
        function deallocateMaterial(material) {
            releaseMaterialProgramReference(material);
            properties.remove(material);
        }
        function releaseMaterialProgramReference(material) {
            var programInfo = properties.get(material).program;
            material.program = undefined;
            if (programInfo !== undefined) {
                programCache.releaseProgram(programInfo);
            }
        }
        // Buffer rendering
        function renderObjectImmediate(object, program) {
            object.render(function (object) {
                _this.renderBufferImmediate(object, program);
            });
        }
        this.renderBufferImmediate = function (object, program) {
            state.initAttributes();
            var buffers = properties.get(object);
            if (object.hasPositions && !buffers.position)
                buffers.position = _gl.createBuffer();
            if (object.hasNormals && !buffers.normal)
                buffers.normal = _gl.createBuffer();
            if (object.hasUvs && !buffers.uv)
                buffers.uv = _gl.createBuffer();
            if (object.hasColors && !buffers.color)
                buffers.color = _gl.createBuffer();
            var programAttributes = program.getAttributes();
            if (object.hasPositions) {
                _gl.bindBuffer(34962, buffers.position);
                _gl.bufferData(34962, object.positionArray, 35048);
                state.enableAttribute(programAttributes.position);
                _gl.vertexAttribPointer(programAttributes.position, 3, 5126, false, 0, 0);
            }
            if (object.hasNormals) {
                _gl.bindBuffer(34962, buffers.normal);
                _gl.bufferData(34962, object.normalArray, 35048);
                state.enableAttribute(programAttributes.normal);
                _gl.vertexAttribPointer(programAttributes.normal, 3, 5126, false, 0, 0);
            }
            if (object.hasUvs) {
                _gl.bindBuffer(34962, buffers.uv);
                _gl.bufferData(34962, object.uvArray, 35048);
                state.enableAttribute(programAttributes.uv);
                _gl.vertexAttribPointer(programAttributes.uv, 2, 5126, false, 0, 0);
            }
            if (object.hasColors) {
                _gl.bindBuffer(34962, buffers.color);
                _gl.bufferData(34962, object.colorArray, 35048);
                state.enableAttribute(programAttributes.color);
                _gl.vertexAttribPointer(programAttributes.color, 3, 5126, false, 0, 0);
            }
            state.disableUnusedAttributes();
            _gl.drawArrays(4, 0, object.count);
            object.count = 0;
        };
        var tempScene = new Scene();
        this.renderBufferDirect = function (camera, scene, geometry, material, object, group) {
            if (scene === null)
                scene = tempScene; // renderBufferDirect second parameter used to be fog (could be null)
            var frontFaceCW = (object.isMesh && object.matrixWorld.determinant() < 0);
            var program = setProgram(camera, scene, material, object);
            state.setMaterial(material, frontFaceCW);
            var updateBuffers = false;
            if (_currentGeometryProgram.geometry !== geometry.id ||
                _currentGeometryProgram.program !== program.id ||
                _currentGeometryProgram.wireframe !== (material.wireframe === true)) {
                _currentGeometryProgram.geometry = geometry.id;
                _currentGeometryProgram.program = program.id;
                _currentGeometryProgram.wireframe = material.wireframe === true;
                updateBuffers = true;
            }
            if (material.morphTargets || material.morphNormals) {
                morphtargets.update(object, geometry, material, program);
                updateBuffers = true;
            }
            //
            var index = geometry.index;
            var position = geometry.attributes.position;
            //
            if (index === null) {
                if (position === undefined || position.count === 0)
                    return;
            }
            else if (index.count === 0) {
                return;
            }
            //
            var rangeFactor = 1;
            if (material.wireframe === true) {
                index = geometries.getWireframeAttribute(geometry);
                rangeFactor = 2;
            }
            var attribute;
            var renderer = bufferRenderer;
            if (index !== null) {
                attribute = attributes.get(index);
                renderer = indexedBufferRenderer;
                renderer.setIndex(attribute);
            }
            if (updateBuffers) {
                setupVertexAttributes(object, geometry, material, program);
                if (index !== null) {
                    _gl.bindBuffer(34963, attribute.buffer);
                }
            }
            //
            var dataCount = (index !== null) ? index.count : position.count;
            var rangeStart = geometry.drawRange.start * rangeFactor;
            var rangeCount = geometry.drawRange.count * rangeFactor;
            var groupStart = group !== null ? group.start * rangeFactor : 0;
            var groupCount = group !== null ? group.count * rangeFactor : Infinity;
            var drawStart = Math.max(rangeStart, groupStart);
            var drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
            var drawCount = Math.max(0, drawEnd - drawStart + 1);
            if (drawCount === 0)
                return;
            //
            if (object.isMesh) {
                if (material.wireframe === true) {
                    state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
                    renderer.setMode(1);
                }
                else {
                    renderer.setMode(4);
                }
            }
            else if (object.isLine) {
                var lineWidth = material.linewidth;
                if (lineWidth === undefined)
                    lineWidth = 1; // Not using Line*Material
                state.setLineWidth(lineWidth * getTargetPixelRatio());
                if (object.isLineSegments) {
                    renderer.setMode(1);
                }
                else if (object.isLineLoop) {
                    renderer.setMode(2);
                }
                else {
                    renderer.setMode(3);
                }
            }
            else if (object.isPoints) {
                renderer.setMode(0);
            }
            else if (object.isSprite) {
                renderer.setMode(4);
            }
            if (object.isInstancedMesh) {
                renderer.renderInstances(geometry, drawStart, drawCount, object.count);
            }
            else if (geometry.isInstancedBufferGeometry) {
                renderer.renderInstances(geometry, drawStart, drawCount, geometry.maxInstancedCount);
            }
            else {
                renderer.render(drawStart, drawCount);
            }
        };
        function setupVertexAttributes(object, geometry, material, program) {
            if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
                if (extensions.get('ANGLE_instanced_arrays') === null)
                    return;
            }
            state.initAttributes();
            var geometryAttributes = geometry.attributes;
            var programAttributes = program.getAttributes();
            var materialDefaultAttributeValues = material.defaultAttributeValues;
            for (var name in programAttributes) {
                var programAttribute = programAttributes[name];
                if (programAttribute >= 0) {
                    var geometryAttribute = geometryAttributes[name];
                    if (geometryAttribute !== undefined) {
                        var normalized = geometryAttribute.normalized;
                        var size = geometryAttribute.itemSize;
                        var attribute = attributes.get(geometryAttribute);
                        // TODO Attribute may not be available on context restore
                        if (attribute === undefined)
                            continue;
                        var buffer = attribute.buffer;
                        var type = attribute.type;
                        var bytesPerElement = attribute.bytesPerElement;
                        if (geometryAttribute.isInterleavedBufferAttribute) {
                            var data = geometryAttribute.data;
                            var stride = data.stride;
                            var offset = geometryAttribute.offset;
                            if (data && data.isInstancedInterleavedBuffer) {
                                state.enableAttributeAndDivisor(programAttribute, data.meshPerAttribute);
                                if (geometry.maxInstancedCount === undefined) {
                                    geometry.maxInstancedCount = data.meshPerAttribute * data.count;
                                }
                            }
                            else {
                                state.enableAttribute(programAttribute);
                            }
                            _gl.bindBuffer(34962, buffer);
                            _gl.vertexAttribPointer(programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement);
                        }
                        else {
                            if (geometryAttribute.isInstancedBufferAttribute) {
                                state.enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute);
                                if (geometry.maxInstancedCount === undefined) {
                                    geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
                                }
                            }
                            else {
                                state.enableAttribute(programAttribute);
                            }
                            _gl.bindBuffer(34962, buffer);
                            _gl.vertexAttribPointer(programAttribute, size, type, normalized, 0, 0);
                        }
                    }
                    else if (name === 'instanceMatrix') {
                        var attribute = attributes.get(object.instanceMatrix);
                        // TODO Attribute may not be available on context restore
                        if (attribute === undefined)
                            continue;
                        var buffer = attribute.buffer;
                        var type = attribute.type;
                        state.enableAttributeAndDivisor(programAttribute + 0, 1);
                        state.enableAttributeAndDivisor(programAttribute + 1, 1);
                        state.enableAttributeAndDivisor(programAttribute + 2, 1);
                        state.enableAttributeAndDivisor(programAttribute + 3, 1);
                        _gl.bindBuffer(34962, buffer);
                        _gl.vertexAttribPointer(programAttribute + 0, 4, type, false, 64, 0);
                        _gl.vertexAttribPointer(programAttribute + 1, 4, type, false, 64, 16);
                        _gl.vertexAttribPointer(programAttribute + 2, 4, type, false, 64, 32);
                        _gl.vertexAttribPointer(programAttribute + 3, 4, type, false, 64, 48);
                    }
                    else if (materialDefaultAttributeValues !== undefined) {
                        var value = materialDefaultAttributeValues[name];
                        if (value !== undefined) {
                            switch (value.length) {
                                case 2:
                                    _gl.vertexAttrib2fv(programAttribute, value);
                                    break;
                                case 3:
                                    _gl.vertexAttrib3fv(programAttribute, value);
                                    break;
                                case 4:
                                    _gl.vertexAttrib4fv(programAttribute, value);
                                    break;
                                default:
                                    _gl.vertexAttrib1fv(programAttribute, value);
                            }
                        }
                    }
                }
            }
            state.disableUnusedAttributes();
        }
        // Compile
        this.compile = function (scene, camera) {
            currentRenderState = renderStates.get(scene, camera);
            currentRenderState.init();
            scene.traverse(function (object) {
                if (object.isLight) {
                    currentRenderState.pushLight(object);
                    if (object.castShadow) {
                        currentRenderState.pushShadow(object);
                    }
                }
            });
            currentRenderState.setupLights(camera);
            var compiled = {};
            scene.traverse(function (object) {
                if (object.material) {
                    if (Array.isArray(object.material)) {
                        for (var i = 0; i < object.material.length; i++) {
                            if (object.material[i].uuid in compiled === false) {
                                initMaterial(object.material[i], scene, object);
                                compiled[object.material[i].uuid] = true;
                            }
                        }
                    }
                    else if (object.material.uuid in compiled === false) {
                        initMaterial(object.material, scene, object);
                        compiled[object.material.uuid] = true;
                    }
                }
            });
        };
        // Animation Loop
        var onAnimationFrameCallback = null;
        function onAnimationFrame(time) {
            if (xr.isPresenting)
                return;
            if (onAnimationFrameCallback)
                onAnimationFrameCallback(time);
        }
        var animation = new WebGLAnimation();
        animation.setAnimationLoop(onAnimationFrame);
        if (typeof window !== 'undefined')
            animation.setContext(window);
        this.setAnimationLoop = function (callback) {
            onAnimationFrameCallback = callback;
            xr.setAnimationLoop(callback);
            animation.start();
        };
        // Rendering
        this.render = function (scene, camera) {
            var renderTarget, forceClear;
            if (arguments[2] !== undefined) {
                console.warn('THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.');
                renderTarget = arguments[2];
            }
            if (arguments[3] !== undefined) {
                console.warn('THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.');
                forceClear = arguments[3];
            }
            if (!(camera && camera.isCamera)) {
                console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
                return;
            }
            if (_isContextLost)
                return;
            // reset caching for this frame
            _currentGeometryProgram.geometry = null;
            _currentGeometryProgram.program = null;
            _currentGeometryProgram.wireframe = false;
            _currentMaterialId = -1;
            _currentCamera = null;
            // update scene graph
            if (scene.autoUpdate === true)
                scene.updateMatrixWorld();
            // update camera matrices and frustum
            if (camera.parent === null)
                camera.updateMatrixWorld();
            if (xr.enabled && xr.isPresenting) {
                camera = xr.getCamera(camera);
            }
            //
            currentRenderState = renderStates.get(scene, camera);
            currentRenderState.init();
            scene.onBeforeRender(_this, scene, camera, renderTarget || _currentRenderTarget);
            _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
            _frustum.setFromProjectionMatrix(_projScreenMatrix);
            _localClippingEnabled = this.localClippingEnabled;
            _clippingEnabled = _clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
            currentRenderList = renderLists.get(scene, camera);
            currentRenderList.init();
            projectObject(scene, camera, 0, _this.sortObjects);
            if (_this.sortObjects === true) {
                currentRenderList.sort(_opaqueSort, _transparentSort);
            }
            //
            if (_clippingEnabled)
                _clipping.beginShadows();
            var shadowsArray = currentRenderState.state.shadowsArray;
            shadowMap.render(shadowsArray, scene, camera);
            currentRenderState.setupLights(camera);
            if (_clippingEnabled)
                _clipping.endShadows();
            //
            if (this.info.autoReset)
                this.info.reset();
            if (renderTarget !== undefined) {
                this.setRenderTarget(renderTarget);
            }
            if (xr.enabled && multiview.isAvailable()) {
                multiview.attachCamera(camera);
            }
            //
            background.render(currentRenderList, scene, camera, forceClear);
            // render scene
            var opaqueObjects = currentRenderList.opaque;
            var transparentObjects = currentRenderList.transparent;
            if (scene.overrideMaterial) {
                var overrideMaterial = scene.overrideMaterial;
                if (opaqueObjects.length)
                    renderObjects(opaqueObjects, scene, camera, overrideMaterial);
                if (transparentObjects.length)
                    renderObjects(transparentObjects, scene, camera, overrideMaterial);
            }
            else {
                // opaque pass (front-to-back order)
                if (opaqueObjects.length)
                    renderObjects(opaqueObjects, scene, camera);
                // transparent pass (back-to-front order)
                if (transparentObjects.length)
                    renderObjects(transparentObjects, scene, camera);
            }
            //
            scene.onAfterRender(_this, scene, camera);
            //
            if (_currentRenderTarget !== null) {
                // Generate mipmap if we're using any kind of mipmap filtering
                textures.updateRenderTargetMipmap(_currentRenderTarget);
                // resolve multisample renderbuffers to a single-sample texture if necessary
                textures.updateMultisampleRenderTarget(_currentRenderTarget);
            }
            // Ensure depth buffer writing is enabled so it can be cleared on next render
            state.buffers.depth.setTest(true);
            state.buffers.depth.setMask(true);
            state.buffers.color.setMask(true);
            state.setPolygonOffset(false);
            if (xr.enabled) {
                if (multiview.isAvailable()) {
                    multiview.detachCamera(camera);
                }
            }
            // _gl.finish();
            currentRenderList = null;
            currentRenderState = null;
        };
        function projectObject(object, camera, groupOrder, sortObjects) {
            if (object.visible === false)
                return;
            var visible = object.layers.test(camera.layers);
            if (visible) {
                if (object.isGroup) {
                    groupOrder = object.renderOrder;
                }
                else if (object.isLOD) {
                    if (object.autoUpdate === true)
                        object.update(camera);
                }
                else if (object.isLight) {
                    currentRenderState.pushLight(object);
                    if (object.castShadow) {
                        currentRenderState.pushShadow(object);
                    }
                }
                else if (object.isSprite) {
                    if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
                        if (sortObjects) {
                            _vector3.setFromMatrixPosition(object.matrixWorld)
                                .applyMatrix4(_projScreenMatrix);
                        }
                        var geometry = objects.update(object);
                        var material = object.material;
                        if (material.visible) {
                            currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
                        }
                    }
                }
                else if (object.isImmediateRenderObject) {
                    if (sortObjects) {
                        _vector3.setFromMatrixPosition(object.matrixWorld)
                            .applyMatrix4(_projScreenMatrix);
                    }
                    currentRenderList.push(object, null, object.material, groupOrder, _vector3.z, null);
                }
                else if (object.isMesh || object.isLine || object.isPoints) {
                    if (object.isSkinnedMesh) {
                        // update skeleton only once in a frame
                        if (object.skeleton.frame !== info.render.frame) {
                            object.skeleton.update();
                            object.skeleton.frame = info.render.frame;
                        }
                    }
                    if (!object.frustumCulled || _frustum.intersectsObject(object)) {
                        if (sortObjects) {
                            _vector3.setFromMatrixPosition(object.matrixWorld)
                                .applyMatrix4(_projScreenMatrix);
                        }
                        var geometry = objects.update(object);
                        var material = object.material;
                        if (Array.isArray(material)) {
                            var groups = geometry.groups;
                            for (var i = 0, l = groups.length; i < l; i++) {
                                var group = groups[i];
                                var groupMaterial = material[group.materialIndex];
                                if (groupMaterial && groupMaterial.visible) {
                                    currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);
                                }
                            }
                        }
                        else if (material.visible) {
                            currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
                        }
                    }
                }
            }
            var children = object.children;
            for (var i = 0, l = children.length; i < l; i++) {
                projectObject(children[i], camera, groupOrder, sortObjects);
            }
        }
        function renderObjects(renderList, scene, camera, overrideMaterial) {
            for (var i = 0, l = renderList.length; i < l; i++) {
                var renderItem = renderList[i];
                var object = renderItem.object;
                var geometry = renderItem.geometry;
                var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
                var group = renderItem.group;
                if (camera.isArrayCamera) {
                    _currentArrayCamera = camera;
                    if (xr.enabled && multiview.isAvailable()) {
                        renderObject(object, scene, camera, geometry, material, group);
                    }
                    else {
                        var cameras = camera.cameras;
                        for (var j = 0, jl = cameras.length; j < jl; j++) {
                            var camera2 = cameras[j];
                            if (object.layers.test(camera2.layers)) {
                                state.viewport(_currentViewport.copy(camera2.viewport));
                                currentRenderState.setupLights(camera2);
                                renderObject(object, scene, camera2, geometry, material, group);
                            }
                        }
                    }
                }
                else {
                    _currentArrayCamera = null;
                    renderObject(object, scene, camera, geometry, material, group);
                }
            }
        }
        function renderObject(object, scene, camera, geometry, material, group) {
            object.onBeforeRender(_this, scene, camera, geometry, material, group);
            currentRenderState = renderStates.get(scene, _currentArrayCamera || camera);
            object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
            object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
            if (object.isImmediateRenderObject) {
                var program = setProgram(camera, scene, material, object);
                state.setMaterial(material);
                _currentGeometryProgram.geometry = null;
                _currentGeometryProgram.program = null;
                _currentGeometryProgram.wireframe = false;
                renderObjectImmediate(object, program);
            }
            else {
                _this.renderBufferDirect(camera, scene, geometry, material, object, group);
            }
            object.onAfterRender(_this, scene, camera, geometry, material, group);
            currentRenderState = renderStates.get(scene, _currentArrayCamera || camera);
        }
        function initMaterial(material, scene, object) {
            var materialProperties = properties.get(material);
            var lights = currentRenderState.state.lights;
            var shadowsArray = currentRenderState.state.shadowsArray;
            var lightsStateVersion = lights.state.version;
            var parameters = programCache.getParameters(material, lights.state, shadowsArray, scene, _clipping.numPlanes, _clipping.numIntersection, object);
            var programCacheKey = programCache.getProgramCacheKey(parameters);
            var program = materialProperties.program;
            var programChange = true;
            if (program === undefined) {
                // new material
                material.addEventListener('dispose', onMaterialDispose);
            }
            else if (program.cacheKey !== programCacheKey) {
                // changed glsl or parameters
                releaseMaterialProgramReference(material);
            }
            else if (materialProperties.lightsStateVersion !== lightsStateVersion) {
                materialProperties.lightsStateVersion = lightsStateVersion;
                programChange = false;
            }
            else if (parameters.shaderID !== undefined) {
                // same glsl and uniform list
                return;
            }
            else {
                // only rebuild uniform list
                programChange = false;
            }
            if (programChange) {
                program = programCache.acquireProgram(parameters, programCacheKey);
                materialProperties.program = program;
                materialProperties.uniforms = parameters.uniforms;
                materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
                materialProperties.outputEncoding = _this.outputEncoding;
                material.program = program;
            }
            var programAttributes = program.getAttributes();
            if (material.morphTargets) {
                material.numSupportedMorphTargets = 0;
                for (var i = 0; i < _this.maxMorphTargets; i++) {
                    if (programAttributes['morphTarget' + i] >= 0) {
                        material.numSupportedMorphTargets++;
                    }
                }
            }
            if (material.morphNormals) {
                material.numSupportedMorphNormals = 0;
                for (var i = 0; i < _this.maxMorphNormals; i++) {
                    if (programAttributes['morphNormal' + i] >= 0) {
                        material.numSupportedMorphNormals++;
                    }
                }
            }
            var uniforms = materialProperties.uniforms;
            if (!material.isShaderMaterial &&
                !material.isRawShaderMaterial ||
                material.clipping === true) {
                materialProperties.numClippingPlanes = _clipping.numPlanes;
                materialProperties.numIntersection = _clipping.numIntersection;
                uniforms.clippingPlanes = _clipping.uniform;
            }
            materialProperties.fog = scene.fog;
            // store the light setup it was created for
            materialProperties.needsLights = materialNeedsLights(material);
            materialProperties.lightsStateVersion = lightsStateVersion;
            if (materialProperties.needsLights) {
                // wire up the material to this renderer's lighting state
                uniforms.ambientLightColor.value = lights.state.ambient;
                uniforms.lightProbe.value = lights.state.probe;
                uniforms.directionalLights.value = lights.state.directional;
                uniforms.spotLights.value = lights.state.spot;
                uniforms.rectAreaLights.value = lights.state.rectArea;
                uniforms.pointLights.value = lights.state.point;
                uniforms.hemisphereLights.value = lights.state.hemi;
                uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
                uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
                uniforms.spotShadowMap.value = lights.state.spotShadowMap;
                uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
                uniforms.pointShadowMap.value = lights.state.pointShadowMap;
                uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
                // TODO (abelnation): add area lights shadow info to uniforms
            }
            var progUniforms = materialProperties.program.getUniforms(), uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
            materialProperties.uniformsList = uniformsList;
        }
        function setProgram(camera, scene, material, object) {
            textures.resetTextureUnits();
            var fog = scene.fog;
            var environment = material.isMeshStandardMaterial ? scene.environment : null;
            var materialProperties = properties.get(material);
            var lights = currentRenderState.state.lights;
            if (_clippingEnabled) {
                if (_localClippingEnabled || camera !== _currentCamera) {
                    var useCache = camera === _currentCamera &&
                        material.id === _currentMaterialId;
                    // we might want to call this function with some ClippingGroup
                    // object instead of the material, once it becomes feasible
                    // (#8465, #8379)
                    _clipping.setState(material.clippingPlanes, material.clipIntersection, material.clipShadows, camera, materialProperties, useCache);
                }
            }
            if (material.version === materialProperties.__version) {
                if (materialProperties.program === undefined) {
                    initMaterial(material, scene, object);
                }
                else if (material.fog && materialProperties.fog !== fog) {
                    initMaterial(material, scene, object);
                }
                else if (materialProperties.environment !== environment) {
                    initMaterial(material, scene, object);
                }
                else if (materialProperties.needsLights && (materialProperties.lightsStateVersion !== lights.state.version)) {
                    initMaterial(material, scene, object);
                }
                else if (materialProperties.numClippingPlanes !== undefined &&
                    (materialProperties.numClippingPlanes !== _clipping.numPlanes ||
                        materialProperties.numIntersection !== _clipping.numIntersection)) {
                    initMaterial(material, scene, object);
                }
                else if (materialProperties.outputEncoding !== _this.outputEncoding) {
                    initMaterial(material, scene, object);
                }
            }
            else {
                initMaterial(material, scene, object);
                materialProperties.__version = material.version;
            }
            var refreshProgram = false;
            var refreshMaterial = false;
            var refreshLights = false;
            var program = materialProperties.program, p_uniforms = program.getUniforms(), m_uniforms = materialProperties.uniforms;
            if (state.useProgram(program.program)) {
                refreshProgram = true;
                refreshMaterial = true;
                refreshLights = true;
            }
            if (material.id !== _currentMaterialId) {
                _currentMaterialId = material.id;
                refreshMaterial = true;
            }
            if (refreshProgram || _currentCamera !== camera) {
                if (program.numMultiviewViews > 0) {
                    multiview.updateCameraProjectionMatricesUniform(camera, p_uniforms);
                }
                else {
                    p_uniforms.setValue(_gl, 'projectionMatrix', camera.projectionMatrix);
                }
                if (capabilities.logarithmicDepthBuffer) {
                    p_uniforms.setValue(_gl, 'logDepthBufFC', 2.0 / (Math.log(camera.far + 1.0) / Math.LN2));
                }
                if (_currentCamera !== camera) {
                    _currentCamera = camera;
                    // lighting uniforms depend on the camera so enforce an update
                    // now, in case this material supports lights - or later, when
                    // the next material that does gets activated:
                    refreshMaterial = true; // set to true on material change
                    refreshLights = true; // remains set until update done
                }
                // load material specific uniforms
                // (shader material also gets them for the sake of genericity)
                if (material.isShaderMaterial ||
                    material.isMeshPhongMaterial ||
                    material.isMeshToonMaterial ||
                    material.isMeshStandardMaterial ||
                    material.envMap) {
                    var uCamPos = p_uniforms.map.cameraPosition;
                    if (uCamPos !== undefined) {
                        uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
                    }
                }
                if (material.isMeshPhongMaterial ||
                    material.isMeshToonMaterial ||
                    material.isMeshLambertMaterial ||
                    material.isMeshBasicMaterial ||
                    material.isMeshStandardMaterial ||
                    material.isShaderMaterial) {
                    p_uniforms.setValue(_gl, 'isOrthographic', camera.isOrthographicCamera === true);
                }
                if (material.isMeshPhongMaterial ||
                    material.isMeshToonMaterial ||
                    material.isMeshLambertMaterial ||
                    material.isMeshBasicMaterial ||
                    material.isMeshStandardMaterial ||
                    material.isShaderMaterial ||
                    material.skinning) {
                    if (program.numMultiviewViews > 0) {
                        multiview.updateCameraViewMatricesUniform(camera, p_uniforms);
                    }
                    else {
                        p_uniforms.setValue(_gl, 'viewMatrix', camera.matrixWorldInverse);
                    }
                }
            }
            // skinning uniforms must be set even if material didn't change
            // auto-setting of texture unit for bone texture must go before other textures
            // not sure why, but otherwise weird things happen
            if (material.skinning) {
                p_uniforms.setOptional(_gl, object, 'bindMatrix');
                p_uniforms.setOptional(_gl, object, 'bindMatrixInverse');
                var skeleton = object.skeleton;
                if (skeleton) {
                    var bones = skeleton.bones;
                    if (capabilities.floatVertexTextures) {
                        if (skeleton.boneTexture === undefined) {
                            // layout (1 matrix = 4 pixels)
                            //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
                            //  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
                            //       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
                            //       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
                            //       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)
                            var size = Math.sqrt(bones.length * 4); // 4 pixels needed for 1 matrix
                            size = MathUtils.ceilPowerOfTwo(size);
                            size = Math.max(size, 4);
                            var boneMatrices = new Float32Array(size * size * 4); // 4 floats per RGBA pixel
                            boneMatrices.set(skeleton.boneMatrices); // copy current values
                            var boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
                            skeleton.boneMatrices = boneMatrices;
                            skeleton.boneTexture = boneTexture;
                            skeleton.boneTextureSize = size;
                        }
                        p_uniforms.setValue(_gl, 'boneTexture', skeleton.boneTexture, textures);
                        p_uniforms.setValue(_gl, 'boneTextureSize', skeleton.boneTextureSize);
                    }
                    else {
                        p_uniforms.setOptional(_gl, skeleton, 'boneMatrices');
                    }
                }
            }
            if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
                materialProperties.receiveShadow = object.receiveShadow;
                p_uniforms.setValue(_gl, 'receiveShadow', object.receiveShadow);
            }
            if (refreshMaterial) {
                p_uniforms.setValue(_gl, 'toneMappingExposure', _this.toneMappingExposure);
                p_uniforms.setValue(_gl, 'toneMappingWhitePoint', _this.toneMappingWhitePoint);
                if (materialProperties.needsLights) {
                    // the current material requires lighting info
                    // note: all lighting uniforms are always set correctly
                    // they simply reference the renderer's state for their
                    // values
                    //
                    // use the current material's .needsUpdate flags to set
                    // the GL state when required
                    markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
                }
                // refresh uniforms common to several materials
                if (fog && material.fog) {
                    refreshUniformsFog(m_uniforms, fog);
                }
                if (material.isMeshBasicMaterial) {
                    refreshUniformsCommon(m_uniforms, material);
                }
                else if (material.isMeshLambertMaterial) {
                    refreshUniformsCommon(m_uniforms, material);
                    refreshUniformsLambert(m_uniforms, material);
                }
                else if (material.isMeshToonMaterial) {
                    refreshUniformsCommon(m_uniforms, material);
                    refreshUniformsToon(m_uniforms, material);
                }
                else if (material.isMeshPhongMaterial) {
                    refreshUniformsCommon(m_uniforms, material);
                    refreshUniformsPhong(m_uniforms, material);
                }
                else if (material.isMeshStandardMaterial) {
                    refreshUniformsCommon(m_uniforms, material, environment);
                    if (material.isMeshPhysicalMaterial) {
                        refreshUniformsPhysical(m_uniforms, material, environment);
                    }
                    else {
                        refreshUniformsStandard(m_uniforms, material, environment);
                    }
                }
                else if (material.isMeshMatcapMaterial) {
                    refreshUniformsCommon(m_uniforms, material);
                    refreshUniformsMatcap(m_uniforms, material);
                }
                else if (material.isMeshDepthMaterial) {
                    refreshUniformsCommon(m_uniforms, material);
                    refreshUniformsDepth(m_uniforms, material);
                }
                else if (material.isMeshDistanceMaterial) {
                    refreshUniformsCommon(m_uniforms, material);
                    refreshUniformsDistance(m_uniforms, material);
                }
                else if (material.isMeshNormalMaterial) {
                    refreshUniformsCommon(m_uniforms, material);
                    refreshUniformsNormal(m_uniforms, material);
                }
                else if (material.isLineBasicMaterial) {
                    refreshUniformsLine(m_uniforms, material);
                    if (material.isLineDashedMaterial) {
                        refreshUniformsDash(m_uniforms, material);
                    }
                }
                else if (material.isPointsMaterial) {
                    refreshUniformsPoints(m_uniforms, material);
                }
                else if (material.isSpriteMaterial) {
                    refreshUniformsSprites(m_uniforms, material);
                }
                else if (material.isShadowMaterial) {
                    m_uniforms.color.value.copy(material.color);
                    m_uniforms.opacity.value = material.opacity;
                }
                // RectAreaLight Texture
                // TODO (mrdoob): Find a nicer implementation
                if (m_uniforms.ltc_1 !== undefined)
                    m_uniforms.ltc_1.value = UniformsLib.LTC_1;
                if (m_uniforms.ltc_2 !== undefined)
                    m_uniforms.ltc_2.value = UniformsLib.LTC_2;
                WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
                if (material.isShaderMaterial) {
                    material.uniformsNeedUpdate = false; // #15581
                }
            }
            if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
                WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
                material.uniformsNeedUpdate = false;
            }
            if (material.isSpriteMaterial) {
                p_uniforms.setValue(_gl, 'center', object.center);
            }
            // common matrices
            if (program.numMultiviewViews > 0) {
                multiview.updateObjectMatricesUniforms(object, camera, p_uniforms);
            }
            else {
                p_uniforms.setValue(_gl, 'modelViewMatrix', object.modelViewMatrix);
                p_uniforms.setValue(_gl, 'normalMatrix', object.normalMatrix);
            }
            p_uniforms.setValue(_gl, 'modelMatrix', object.matrixWorld);
            return program;
        }
        // Uniforms (refresh uniforms objects)
        function refreshUniformsCommon(uniforms, material, environment) {
            uniforms.opacity.value = material.opacity;
            if (material.color) {
                uniforms.diffuse.value.copy(material.color);
            }
            if (material.emissive) {
                uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
            }
            if (material.map) {
                uniforms.map.value = material.map;
            }
            if (material.alphaMap) {
                uniforms.alphaMap.value = material.alphaMap;
            }
            if (material.specularMap) {
                uniforms.specularMap.value = material.specularMap;
            }
            var envMap = material.envMap || environment;
            if (envMap) {
                uniforms.envMap.value = envMap;
                uniforms.flipEnvMap.value = envMap.isCubeTexture ? -1 : 1;
                uniforms.reflectivity.value = material.reflectivity;
                uniforms.refractionRatio.value = material.refractionRatio;
                uniforms.maxMipLevel.value = properties.get(envMap).__maxMipLevel;
            }
            if (material.lightMap) {
                uniforms.lightMap.value = material.lightMap;
                uniforms.lightMapIntensity.value = material.lightMapIntensity;
            }
            if (material.aoMap) {
                uniforms.aoMap.value = material.aoMap;
                uniforms.aoMapIntensity.value = material.aoMapIntensity;
            }
            // uv repeat and offset setting priorities
            // 1. color map
            // 2. specular map
            // 3. normal map
            // 4. bump map
            // 5. alpha map
            // 6. emissive map
            var uvScaleMap;
            if (material.map) {
                uvScaleMap = material.map;
            }
            else if (material.specularMap) {
                uvScaleMap = material.specularMap;
            }
            else if (material.displacementMap) {
                uvScaleMap = material.displacementMap;
            }
            else if (material.normalMap) {
                uvScaleMap = material.normalMap;
            }
            else if (material.bumpMap) {
                uvScaleMap = material.bumpMap;
            }
            else if (material.roughnessMap) {
                uvScaleMap = material.roughnessMap;
            }
            else if (material.metalnessMap) {
                uvScaleMap = material.metalnessMap;
            }
            else if (material.alphaMap) {
                uvScaleMap = material.alphaMap;
            }
            else if (material.emissiveMap) {
                uvScaleMap = material.emissiveMap;
            }
            if (uvScaleMap !== undefined) {
                // backwards compatibility
                if (uvScaleMap.isWebGLRenderTarget) {
                    uvScaleMap = uvScaleMap.texture;
                }
                if (uvScaleMap.matrixAutoUpdate === true) {
                    uvScaleMap.updateMatrix();
                }
                uniforms.uvTransform.value.copy(uvScaleMap.matrix);
            }
            // uv repeat and offset setting priorities for uv2
            // 1. ao map
            // 2. light map
            var uv2ScaleMap;
            if (material.aoMap) {
                uv2ScaleMap = material.aoMap;
            }
            else if (material.lightMap) {
                uv2ScaleMap = material.lightMap;
            }
            if (uv2ScaleMap !== undefined) {
                // backwards compatibility
                if (uv2ScaleMap.isWebGLRenderTarget) {
                    uv2ScaleMap = uv2ScaleMap.texture;
                }
                if (uv2ScaleMap.matrixAutoUpdate === true) {
                    uv2ScaleMap.updateMatrix();
                }
                uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
            }
        }
        function refreshUniformsLine(uniforms, material) {
            uniforms.diffuse.value.copy(material.color);
            uniforms.opacity.value = material.opacity;
        }
        function refreshUniformsDash(uniforms, material) {
            uniforms.dashSize.value = material.dashSize;
            uniforms.totalSize.value = material.dashSize + material.gapSize;
            uniforms.scale.value = material.scale;
        }
        function refreshUniformsPoints(uniforms, material) {
            uniforms.diffuse.value.copy(material.color);
            uniforms.opacity.value = material.opacity;
            uniforms.size.value = material.size * _pixelRatio;
            uniforms.scale.value = _height * 0.5;
            if (material.map) {
                uniforms.map.value = material.map;
            }
            if (material.alphaMap) {
                uniforms.alphaMap.value = material.alphaMap;
            }
            // uv repeat and offset setting priorities
            // 1. color map
            // 2. alpha map
            var uvScaleMap;
            if (material.map) {
                uvScaleMap = material.map;
            }
            else if (material.alphaMap) {
                uvScaleMap = material.alphaMap;
            }
            if (uvScaleMap !== undefined) {
                if (uvScaleMap.matrixAutoUpdate === true) {
                    uvScaleMap.updateMatrix();
                }
                uniforms.uvTransform.value.copy(uvScaleMap.matrix);
            }
        }
        function refreshUniformsSprites(uniforms, material) {
            uniforms.diffuse.value.copy(material.color);
            uniforms.opacity.value = material.opacity;
            uniforms.rotation.value = material.rotation;
            if (material.map) {
                uniforms.map.value = material.map;
            }
            if (material.alphaMap) {
                uniforms.alphaMap.value = material.alphaMap;
            }
            // uv repeat and offset setting priorities
            // 1. color map
            // 2. alpha map
            var uvScaleMap;
            if (material.map) {
                uvScaleMap = material.map;
            }
            else if (material.alphaMap) {
                uvScaleMap = material.alphaMap;
            }
            if (uvScaleMap !== undefined) {
                if (uvScaleMap.matrixAutoUpdate === true) {
                    uvScaleMap.updateMatrix();
                }
                uniforms.uvTransform.value.copy(uvScaleMap.matrix);
            }
        }
        function refreshUniformsFog(uniforms, fog) {
            uniforms.fogColor.value.copy(fog.color);
            if (fog.isFog) {
                uniforms.fogNear.value = fog.near;
                uniforms.fogFar.value = fog.far;
            }
            else if (fog.isFogExp2) {
                uniforms.fogDensity.value = fog.density;
            }
        }
        function refreshUniformsLambert(uniforms, material) {
            if (material.emissiveMap) {
                uniforms.emissiveMap.value = material.emissiveMap;
            }
        }
        function refreshUniformsPhong(uniforms, material) {
            uniforms.specular.value.copy(material.specular);
            uniforms.shininess.value = Math.max(material.shininess, 1e-4); // to prevent pow( 0.0, 0.0 )
            if (material.emissiveMap) {
                uniforms.emissiveMap.value = material.emissiveMap;
            }
            if (material.bumpMap) {
                uniforms.bumpMap.value = material.bumpMap;
                uniforms.bumpScale.value = material.bumpScale;
                if (material.side === BackSide)
                    uniforms.bumpScale.value *= -1;
            }
            if (material.normalMap) {
                uniforms.normalMap.value = material.normalMap;
                uniforms.normalScale.value.copy(material.normalScale);
                if (material.side === BackSide)
                    uniforms.normalScale.value.negate();
            }
            if (material.displacementMap) {
                uniforms.displacementMap.value = material.displacementMap;
                uniforms.displacementScale.value = material.displacementScale;
                uniforms.displacementBias.value = material.displacementBias;
            }
        }
        function refreshUniformsToon(uniforms, material) {
            uniforms.specular.value.copy(material.specular);
            uniforms.shininess.value = Math.max(material.shininess, 1e-4); // to prevent pow( 0.0, 0.0 )
            if (material.gradientMap) {
                uniforms.gradientMap.value = material.gradientMap;
            }
            if (material.emissiveMap) {
                uniforms.emissiveMap.value = material.emissiveMap;
            }
            if (material.bumpMap) {
                uniforms.bumpMap.value = material.bumpMap;
                uniforms.bumpScale.value = material.bumpScale;
                if (material.side === BackSide)
                    uniforms.bumpScale.value *= -1;
            }
            if (material.normalMap) {
                uniforms.normalMap.value = material.normalMap;
                uniforms.normalScale.value.copy(material.normalScale);
                if (material.side === BackSide)
                    uniforms.normalScale.value.negate();
            }
            if (material.displacementMap) {
                uniforms.displacementMap.value = material.displacementMap;
                uniforms.displacementScale.value = material.displacementScale;
                uniforms.displacementBias.value = material.displacementBias;
            }
        }
        function refreshUniformsStandard(uniforms, material, environment) {
            uniforms.roughness.value = material.roughness;
            uniforms.metalness.value = material.metalness;
            if (material.roughnessMap) {
                uniforms.roughnessMap.value = material.roughnessMap;
            }
            if (material.metalnessMap) {
                uniforms.metalnessMap.value = material.metalnessMap;
            }
            if (material.emissiveMap) {
                uniforms.emissiveMap.value = material.emissiveMap;
            }
            if (material.bumpMap) {
                uniforms.bumpMap.value = material.bumpMap;
                uniforms.bumpScale.value = material.bumpScale;
                if (material.side === BackSide)
                    uniforms.bumpScale.value *= -1;
            }
            if (material.normalMap) {
                uniforms.normalMap.value = material.normalMap;
                uniforms.normalScale.value.copy(material.normalScale);
                if (material.side === BackSide)
                    uniforms.normalScale.value.negate();
            }
            if (material.displacementMap) {
                uniforms.displacementMap.value = material.displacementMap;
                uniforms.displacementScale.value = material.displacementScale;
                uniforms.displacementBias.value = material.displacementBias;
            }
            if (material.envMap || environment) {
                //uniforms.envMap.value = material.envMap; // part of uniforms common
                uniforms.envMapIntensity.value = material.envMapIntensity;
            }
        }
        function refreshUniformsPhysical(uniforms, material, environment) {
            refreshUniformsStandard(uniforms, material, environment);
            uniforms.reflectivity.value = material.reflectivity; // also part of uniforms common
            uniforms.clearcoat.value = material.clearcoat;
            uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
            if (material.sheen)
                uniforms.sheen.value.copy(material.sheen);
            if (material.clearcoatNormalMap) {
                uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
                uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
                if (material.side === BackSide) {
                    uniforms.clearcoatNormalScale.value.negate();
                }
            }
            uniforms.transparency.value = material.transparency;
        }
        function refreshUniformsMatcap(uniforms, material) {
            if (material.matcap) {
                uniforms.matcap.value = material.matcap;
            }
            if (material.bumpMap) {
                uniforms.bumpMap.value = material.bumpMap;
                uniforms.bumpScale.value = material.bumpScale;
                if (material.side === BackSide)
                    uniforms.bumpScale.value *= -1;
            }
            if (material.normalMap) {
                uniforms.normalMap.value = material.normalMap;
                uniforms.normalScale.value.copy(material.normalScale);
                if (material.side === BackSide)
                    uniforms.normalScale.value.negate();
            }
            if (material.displacementMap) {
                uniforms.displacementMap.value = material.displacementMap;
                uniforms.displacementScale.value = material.displacementScale;
                uniforms.displacementBias.value = material.displacementBias;
            }
        }
        function refreshUniformsDepth(uniforms, material) {
            if (material.displacementMap) {
                uniforms.displacementMap.value = material.displacementMap;
                uniforms.displacementScale.value = material.displacementScale;
                uniforms.displacementBias.value = material.displacementBias;
            }
        }
        function refreshUniformsDistance(uniforms, material) {
            if (material.displacementMap) {
                uniforms.displacementMap.value = material.displacementMap;
                uniforms.displacementScale.value = material.displacementScale;
                uniforms.displacementBias.value = material.displacementBias;
            }
            uniforms.referencePosition.value.copy(material.referencePosition);
            uniforms.nearDistance.value = material.nearDistance;
            uniforms.farDistance.value = material.farDistance;
        }
        function refreshUniformsNormal(uniforms, material) {
            if (material.bumpMap) {
                uniforms.bumpMap.value = material.bumpMap;
                uniforms.bumpScale.value = material.bumpScale;
                if (material.side === BackSide)
                    uniforms.bumpScale.value *= -1;
            }
            if (material.normalMap) {
                uniforms.normalMap.value = material.normalMap;
                uniforms.normalScale.value.copy(material.normalScale);
                if (material.side === BackSide)
                    uniforms.normalScale.value.negate();
            }
            if (material.displacementMap) {
                uniforms.displacementMap.value = material.displacementMap;
                uniforms.displacementScale.value = material.displacementScale;
                uniforms.displacementBias.value = material.displacementBias;
            }
        }
        // If uniforms are marked as clean, they don't need to be loaded to the GPU.
        function markUniformsLightsNeedsUpdate(uniforms, value) {
            uniforms.ambientLightColor.needsUpdate = value;
            uniforms.lightProbe.needsUpdate = value;
            uniforms.directionalLights.needsUpdate = value;
            uniforms.pointLights.needsUpdate = value;
            uniforms.spotLights.needsUpdate = value;
            uniforms.rectAreaLights.needsUpdate = value;
            uniforms.hemisphereLights.needsUpdate = value;
        }
        function materialNeedsLights(material) {
            return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial ||
                material.isMeshStandardMaterial || material.isShadowMaterial ||
                (material.isShaderMaterial && material.lights === true);
        }
        //
        this.setFramebuffer = function (value) {
            if (_framebuffer !== value && _currentRenderTarget === null)
                _gl.bindFramebuffer(36160, value);
            _framebuffer = value;
        };
        this.getActiveCubeFace = function () {
            return _currentActiveCubeFace;
        };
        this.getActiveMipmapLevel = function () {
            return _currentActiveMipmapLevel;
        };
        this.getRenderTarget = function () {
            return _currentRenderTarget;
        };
        this.setRenderTarget = function (renderTarget, activeCubeFace, activeMipmapLevel) {
            _currentRenderTarget = renderTarget;
            _currentActiveCubeFace = activeCubeFace;
            _currentActiveMipmapLevel = activeMipmapLevel;
            if (renderTarget && properties.get(renderTarget).__webglFramebuffer === undefined) {
                textures.setupRenderTarget(renderTarget);
            }
            var framebuffer = _framebuffer;
            var isCube = false;
            if (renderTarget) {
                var __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
                if (renderTarget.isWebGLCubeRenderTarget) {
                    framebuffer = __webglFramebuffer[activeCubeFace || 0];
                    isCube = true;
                }
                else if (renderTarget.isWebGLMultisampleRenderTarget) {
                    framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
                }
                else {
                    framebuffer = __webglFramebuffer;
                }
                _currentViewport.copy(renderTarget.viewport);
                _currentScissor.copy(renderTarget.scissor);
                _currentScissorTest = renderTarget.scissorTest;
            }
            else {
                _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
                _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
                _currentScissorTest = _scissorTest;
            }
            if (_currentFramebuffer !== framebuffer) {
                _gl.bindFramebuffer(36160, framebuffer);
                _currentFramebuffer = framebuffer;
            }
            state.viewport(_currentViewport);
            state.scissor(_currentScissor);
            state.setScissorTest(_currentScissorTest);
            if (isCube) {
                var textureProperties = properties.get(renderTarget.texture);
                _gl.framebufferTexture2D(36160, 36064, 34069 + (activeCubeFace || 0), textureProperties.__webglTexture, activeMipmapLevel || 0);
            }
        };
        this.readRenderTargetPixels = function (renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {
            if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
                console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');
                return;
            }
            var framebuffer = properties.get(renderTarget).__webglFramebuffer;
            if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined) {
                framebuffer = framebuffer[activeCubeFaceIndex];
            }
            if (framebuffer) {
                var restore = false;
                if (framebuffer !== _currentFramebuffer) {
                    _gl.bindFramebuffer(36160, framebuffer);
                    restore = true;
                }
                try {
                    var texture = renderTarget.texture;
                    var textureFormat = texture.format;
                    var textureType = texture.type;
                    if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(35739)) {
                        console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');
                        return;
                    }
                    if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(35738) && // IE11, Edge and Chrome Mac < 52 (#9513)
                        !(textureType === FloatType && (capabilities.isWebGL2 || extensions.get('OES_texture_float') || extensions.get('WEBGL_color_buffer_float'))) && // Chrome Mac >= 52 and Firefox
                        !(textureType === HalfFloatType && (capabilities.isWebGL2 ? extensions.get('EXT_color_buffer_float') : extensions.get('EXT_color_buffer_half_float')))) {
                        console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');
                        return;
                    }
                    if (_gl.checkFramebufferStatus(36160) === 36053) {
                        // the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)
                        if ((x >= 0 && x <= (renderTarget.width - width)) && (y >= 0 && y <= (renderTarget.height - height))) {
                            _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
                        }
                    }
                    else {
                        console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');
                    }
                }
                finally {
                    if (restore) {
                        _gl.bindFramebuffer(36160, _currentFramebuffer);
                    }
                }
            }
        };
        this.copyFramebufferToTexture = function (position, texture, level) {
            if (level === undefined)
                level = 0;
            var levelScale = Math.pow(2, -level);
            var width = Math.floor(texture.image.width * levelScale);
            var height = Math.floor(texture.image.height * levelScale);
            var glFormat = utils.convert(texture.format);
            textures.setTexture2D(texture, 0);
            _gl.copyTexImage2D(3553, level, glFormat, position.x, position.y, width, height, 0);
            state.unbindTexture();
        };
        this.copyTextureToTexture = function (position, srcTexture, dstTexture, level) {
            var width = srcTexture.image.width;
            var height = srcTexture.image.height;
            var glFormat = utils.convert(dstTexture.format);
            var glType = utils.convert(dstTexture.type);
            textures.setTexture2D(dstTexture, 0);
            if (srcTexture.isDataTexture) {
                _gl.texSubImage2D(3553, level || 0, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
            }
            else {
                _gl.texSubImage2D(3553, level || 0, position.x, position.y, glFormat, glType, srcTexture.image);
            }
            state.unbindTexture();
        };
        this.initTexture = function (texture) {
            textures.setTexture2D(texture, 0);
            state.unbindTexture();
        };
        if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
            __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', { detail: this })); // eslint-disable-line no-undef
        }
    }
    exports_14("WebGLRenderer", WebGLRenderer);
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */
    function FogExp2(color, density) {
        this.name = '';
        this.color = new Color(color);
        this.density = (density !== undefined) ? density : 0.00025;
    }
    exports_14("FogExp2", FogExp2);
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */
    function Fog(color, near, far) {
        this.name = '';
        this.color = new Color(color);
        this.near = (near !== undefined) ? near : 1;
        this.far = (far !== undefined) ? far : 1000;
    }
    exports_14("Fog", Fog);
    /**
     * @author benaadams / https://twitter.com/ben_a_adams
     */
    function InterleavedBuffer(array, stride) {
        this.array = array;
        this.stride = stride;
        this.count = array !== undefined ? array.length / stride : 0;
        this.usage = StaticDrawUsage;
        this.updateRange = { offset: 0, count: -1 };
        this.version = 0;
    }
    exports_14("InterleavedBuffer", InterleavedBuffer);
    function InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, normalized) {
        this.data = interleavedBuffer;
        this.itemSize = itemSize;
        this.offset = offset;
        this.normalized = normalized === true;
    }
    exports_14("InterleavedBufferAttribute", InterleavedBufferAttribute);
    /**
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  color: <hex>,
     *  map: new THREE.Texture( <Image> ),
     *  alphaMap: new THREE.Texture( <Image> ),
     *  rotation: <float>,
     *  sizeAttenuation: <bool>
     * }
     */
    function SpriteMaterial(parameters) {
        Material.call(this);
        this.type = 'SpriteMaterial';
        this.color = new Color(0xffffff);
        this.map = null;
        this.alphaMap = null;
        this.rotation = 0;
        this.sizeAttenuation = true;
        this.transparent = true;
        this.setValues(parameters);
    }
    exports_14("SpriteMaterial", SpriteMaterial);
    function Sprite(material) {
        Object3D.call(this);
        this.type = 'Sprite';
        if (_geometry === undefined) {
            _geometry = new BufferGeometry();
            var float32Array = new Float32Array([
                -0.5, -0.5, 0, 0, 0,
                0.5, -0.5, 0, 1, 0,
                0.5, 0.5, 0, 1, 1,
                -0.5, 0.5, 0, 0, 1
            ]);
            var interleavedBuffer = new InterleavedBuffer(float32Array, 5);
            _geometry.setIndex([0, 1, 2, 0, 2, 3]);
            _geometry.setAttribute('position', new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));
            _geometry.setAttribute('uv', new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
        }
        this.geometry = _geometry;
        this.material = (material !== undefined) ? material : new SpriteMaterial();
        this.center = new Vector2(0.5, 0.5);
    }
    exports_14("Sprite", Sprite);
    function transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {
        // compute position in camera space
        _alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale);
        // to check if rotation is not zero
        if (sin !== undefined) {
            _rotatedPosition.x = (cos * _alignedPosition.x) - (sin * _alignedPosition.y);
            _rotatedPosition.y = (sin * _alignedPosition.x) + (cos * _alignedPosition.y);
        }
        else {
            _rotatedPosition.copy(_alignedPosition);
        }
        vertexPosition.copy(mvPosition);
        vertexPosition.x += _rotatedPosition.x;
        vertexPosition.y += _rotatedPosition.y;
        // transform to world space
        vertexPosition.applyMatrix4(_viewWorldMatrix);
    }
    function LOD() {
        Object3D.call(this);
        this.type = 'LOD';
        Object.defineProperties(this, {
            levels: {
                enumerable: true,
                value: []
            }
        });
        this.autoUpdate = true;
    }
    exports_14("LOD", LOD);
    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     * @author ikerr / http://verold.com
     */
    function SkinnedMesh(geometry, material) {
        if (geometry && geometry.isGeometry) {
            console.error('THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
        }
        Mesh.call(this, geometry, material);
        this.type = 'SkinnedMesh';
        this.bindMode = 'attached';
        this.bindMatrix = new Matrix4();
        this.bindMatrixInverse = new Matrix4();
    }
    exports_14("SkinnedMesh", SkinnedMesh);
    function Skeleton(bones, boneInverses) {
        // copy the bone array
        bones = bones || [];
        this.bones = bones.slice(0);
        this.boneMatrices = new Float32Array(this.bones.length * 16);
        this.frame = -1;
        // use the supplied bone inverses or calculate the inverses
        if (boneInverses === undefined) {
            this.calculateInverses();
        }
        else {
            if (this.bones.length === boneInverses.length) {
                this.boneInverses = boneInverses.slice(0);
            }
            else {
                console.warn('THREE.Skeleton boneInverses is the wrong length.');
                this.boneInverses = [];
                for (var i = 0, il = this.bones.length; i < il; i++) {
                    this.boneInverses.push(new Matrix4());
                }
            }
        }
    }
    exports_14("Skeleton", Skeleton);
    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     * @author ikerr / http://verold.com
     */
    function Bone() {
        Object3D.call(this);
        this.type = 'Bone';
    }
    exports_14("Bone", Bone);
    function InstancedMesh(geometry, material, count) {
        Mesh.call(this, geometry, material);
        this.instanceMatrix = new BufferAttribute(new Float32Array(count * 16), 16);
        this.count = count;
        this.frustumCulled = false;
    }
    exports_14("InstancedMesh", InstancedMesh);
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  color: <hex>,
     *  opacity: <float>,
     *
     *  linewidth: <float>,
     *  linecap: "round",
     *  linejoin: "round"
     * }
     */
    function LineBasicMaterial(parameters) {
        Material.call(this);
        this.type = 'LineBasicMaterial';
        this.color = new Color(0xffffff);
        this.linewidth = 1;
        this.linecap = 'round';
        this.linejoin = 'round';
        this.setValues(parameters);
    }
    exports_14("LineBasicMaterial", LineBasicMaterial);
    function Line(geometry, material, mode) {
        if (mode === 1) {
            console.error('THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.');
        }
        Object3D.call(this);
        this.type = 'Line';
        this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
        this.material = material !== undefined ? material : new LineBasicMaterial();
    }
    exports_14("Line", Line);
    function LineSegments(geometry, material) {
        Line.call(this, geometry, material);
        this.type = 'LineSegments';
    }
    exports_14("LineSegments", LineSegments);
    /**
     * @author mgreter / http://github.com/mgreter
     */
    function LineLoop(geometry, material) {
        Line.call(this, geometry, material);
        this.type = 'LineLoop';
    }
    exports_14("LineLoop", LineLoop);
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  color: <hex>,
     *  opacity: <float>,
     *  map: new THREE.Texture( <Image> ),
     *  alphaMap: new THREE.Texture( <Image> ),
     *
     *  size: <float>,
     *  sizeAttenuation: <bool>
     *
     *  morphTargets: <bool>
     * }
     */
    function PointsMaterial(parameters) {
        Material.call(this);
        this.type = 'PointsMaterial';
        this.color = new Color(0xffffff);
        this.map = null;
        this.alphaMap = null;
        this.size = 1;
        this.sizeAttenuation = true;
        this.morphTargets = false;
        this.setValues(parameters);
    }
    exports_14("PointsMaterial", PointsMaterial);
    function Points(geometry, material) {
        Object3D.call(this);
        this.type = 'Points';
        this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
        this.material = material !== undefined ? material : new PointsMaterial();
        this.updateMorphTargets();
    }
    exports_14("Points", Points);
    function testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects, object) {
        var rayPointDistanceSq = _ray$2.distanceSqToPoint(point);
        if (rayPointDistanceSq < localThresholdSq) {
            var intersectPoint = new Vector3();
            _ray$2.closestPointToPoint(point, intersectPoint);
            intersectPoint.applyMatrix4(matrixWorld);
            var distance = raycaster.ray.origin.distanceTo(intersectPoint);
            if (distance < raycaster.near || distance > raycaster.far)
                return;
            intersects.push({
                distance: distance,
                distanceToRay: Math.sqrt(rayPointDistanceSq),
                point: intersectPoint,
                index: index,
                face: null,
                object: object
            });
        }
    }
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    function VideoTexture(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
        Texture.call(this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
        this.format = format !== undefined ? format : RGBFormat;
        this.minFilter = minFilter !== undefined ? minFilter : LinearFilter;
        this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
        this.generateMipmaps = false;
    }
    exports_14("VideoTexture", VideoTexture);
    /**
     * @author alteredq / http://alteredqualia.com/
     */
    function CompressedTexture(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
        Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
        this.image = { width: width, height: height };
        this.mipmaps = mipmaps;
        // no flipping for cube textures
        // (also flipping doesn't work for compressed textures )
        this.flipY = false;
        // can't generate mipmaps for compressed textures
        // mips must be embedded in DDS files
        this.generateMipmaps = false;
    }
    exports_14("CompressedTexture", CompressedTexture);
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    function CanvasTexture(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
        Texture.call(this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
        this.needsUpdate = true;
    }
    exports_14("CanvasTexture", CanvasTexture);
    /**
     * @author Matt DesLauriers / @mattdesl
     * @author atix / arthursilber.de
     */
    function DepthTexture(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
        format = format !== undefined ? format : DepthFormat;
        if (format !== DepthFormat && format !== DepthStencilFormat) {
            throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');
        }
        if (type === undefined && format === DepthFormat)
            type = UnsignedShortType;
        if (type === undefined && format === DepthStencilFormat)
            type = UnsignedInt248Type;
        Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
        this.image = { width: width, height: height };
        this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
        this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
        this.flipY = false;
        this.generateMipmaps = false;
    }
    exports_14("DepthTexture", DepthTexture);
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author Mugen87 / https://github.com/Mugen87
     */
    function WireframeGeometry(geometry) {
        BufferGeometry.call(this);
        this.type = 'WireframeGeometry';
        // buffer
        var vertices = [];
        // helper variables
        var i, j, l, o, ol;
        var edge = [0, 0], edges = {}, e, edge1, edge2;
        var key, keys = ['a', 'b', 'c'];
        var vertex;
        // different logic for Geometry and BufferGeometry
        if (geometry && geometry.isGeometry) {
            // create a data structure that contains all edges without duplicates
            var faces = geometry.faces;
            for (i = 0, l = faces.length; i < l; i++) {
                var face = faces[i];
                for (j = 0; j < 3; j++) {
                    edge1 = face[keys[j]];
                    edge2 = face[keys[(j + 1) % 3]];
                    edge[0] = Math.min(edge1, edge2); // sorting prevents duplicates
                    edge[1] = Math.max(edge1, edge2);
                    key = edge[0] + ',' + edge[1];
                    if (edges[key] === undefined) {
                        edges[key] = { index1: edge[0], index2: edge[1] };
                    }
                }
            }
            // generate vertices
            for (key in edges) {
                e = edges[key];
                vertex = geometry.vertices[e.index1];
                vertices.push(vertex.x, vertex.y, vertex.z);
                vertex = geometry.vertices[e.index2];
                vertices.push(vertex.x, vertex.y, vertex.z);
            }
        }
        else if (geometry && geometry.isBufferGeometry) {
            var position, indices, groups;
            var group, start, count;
            var index1, index2;
            vertex = new Vector3();
            if (geometry.index !== null) {
                // indexed BufferGeometry
                position = geometry.attributes.position;
                indices = geometry.index;
                groups = geometry.groups;
                if (groups.length === 0) {
                    groups = [{ start: 0, count: indices.count, materialIndex: 0 }];
                }
                // create a data structure that contains all eges without duplicates
                for (o = 0, ol = groups.length; o < ol; ++o) {
                    group = groups[o];
                    start = group.start;
                    count = group.count;
                    for (i = start, l = (start + count); i < l; i += 3) {
                        for (j = 0; j < 3; j++) {
                            edge1 = indices.getX(i + j);
                            edge2 = indices.getX(i + (j + 1) % 3);
                            edge[0] = Math.min(edge1, edge2); // sorting prevents duplicates
                            edge[1] = Math.max(edge1, edge2);
                            key = edge[0] + ',' + edge[1];
                            if (edges[key] === undefined) {
                                edges[key] = { index1: edge[0], index2: edge[1] };
                            }
                        }
                    }
                }
                // generate vertices
                for (key in edges) {
                    e = edges[key];
                    vertex.fromBufferAttribute(position, e.index1);
                    vertices.push(vertex.x, vertex.y, vertex.z);
                    vertex.fromBufferAttribute(position, e.index2);
                    vertices.push(vertex.x, vertex.y, vertex.z);
                }
            }
            else {
                // non-indexed BufferGeometry
                position = geometry.attributes.position;
                for (i = 0, l = (position.count / 3); i < l; i++) {
                    for (j = 0; j < 3; j++) {
                        // three edges per triangle, an edge is represented as (index1, index2)
                        // e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)
                        index1 = 3 * i + j;
                        vertex.fromBufferAttribute(position, index1);
                        vertices.push(vertex.x, vertex.y, vertex.z);
                        index2 = 3 * i + ((j + 1) % 3);
                        vertex.fromBufferAttribute(position, index2);
                        vertices.push(vertex.x, vertex.y, vertex.z);
                    }
                }
            }
        }
        // build geometry
        this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    }
    exports_14("WireframeGeometry", WireframeGeometry);
    /**
     * @author zz85 / https://github.com/zz85
     * @author Mugen87 / https://github.com/Mugen87
     *
     * Parametric Surfaces Geometry
     * based on the brilliant article by @prideout https://prideout.net/blog/old/blog/index.html@p=44.html
     */
    // ParametricGeometry
    function ParametricGeometry(func, slices, stacks) {
        Geometry.call(this);
        this.type = 'ParametricGeometry';
        this.parameters = {
            func: func,
            slices: slices,
            stacks: stacks
        };
        this.fromBufferGeometry(new ParametricBufferGeometry(func, slices, stacks));
        this.mergeVertices();
    }
    exports_14("ParametricGeometry", ParametricGeometry);
    // ParametricBufferGeometry
    function ParametricBufferGeometry(func, slices, stacks) {
        BufferGeometry.call(this);
        this.type = 'ParametricBufferGeometry';
        this.parameters = {
            func: func,
            slices: slices,
            stacks: stacks
        };
        // buffers
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
        var EPS = 0.00001;
        var normal = new Vector3();
        var p0 = new Vector3(), p1 = new Vector3();
        var pu = new Vector3(), pv = new Vector3();
        var i, j;
        if (func.length < 3) {
            console.error('THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.');
        }
        // generate vertices, normals and uvs
        var sliceCount = slices + 1;
        for (i = 0; i <= stacks; i++) {
            var v = i / stacks;
            for (j = 0; j <= slices; j++) {
                var u = j / slices;
                // vertex
                func(u, v, p0);
                vertices.push(p0.x, p0.y, p0.z);
                // normal
                // approximate tangent vectors via finite differences
                if (u - EPS >= 0) {
                    func(u - EPS, v, p1);
                    pu.subVectors(p0, p1);
                }
                else {
                    func(u + EPS, v, p1);
                    pu.subVectors(p1, p0);
                }
                if (v - EPS >= 0) {
                    func(u, v - EPS, p1);
                    pv.subVectors(p0, p1);
                }
                else {
                    func(u, v + EPS, p1);
                    pv.subVectors(p1, p0);
                }
                // cross product of tangent vectors returns surface normal
                normal.crossVectors(pu, pv).normalize();
                normals.push(normal.x, normal.y, normal.z);
                // uv
                uvs.push(u, v);
            }
        }
        // generate indices
        for (i = 0; i < stacks; i++) {
            for (j = 0; j < slices; j++) {
                var a = i * sliceCount + j;
                var b = i * sliceCount + j + 1;
                var c = (i + 1) * sliceCount + j + 1;
                var d = (i + 1) * sliceCount + j;
                // faces one and two
                indices.push(a, b, d);
                indices.push(b, c, d);
            }
        }
        // build geometry
        this.setIndex(indices);
        this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
        this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
    }
    exports_14("ParametricBufferGeometry", ParametricBufferGeometry);
    /**
     * @author clockworkgeek / https://github.com/clockworkgeek
     * @author timothypratley / https://github.com/timothypratley
     * @author WestLangley / http://github.com/WestLangley
     * @author Mugen87 / https://github.com/Mugen87
     */
    // PolyhedronGeometry
    function PolyhedronGeometry(vertices, indices, radius, detail) {
        Geometry.call(this);
        this.type = 'PolyhedronGeometry';
        this.parameters = {
            vertices: vertices,
            indices: indices,
            radius: radius,
            detail: detail
        };
        this.fromBufferGeometry(new PolyhedronBufferGeometry(vertices, indices, radius, detail));
        this.mergeVertices();
    }
    exports_14("PolyhedronGeometry", PolyhedronGeometry);
    // PolyhedronBufferGeometry
    function PolyhedronBufferGeometry(vertices, indices, radius, detail) {
        BufferGeometry.call(this);
        this.type = 'PolyhedronBufferGeometry';
        this.parameters = {
            vertices: vertices,
            indices: indices,
            radius: radius,
            detail: detail
        };
        radius = radius || 1;
        detail = detail || 0;
        // default buffer data
        var vertexBuffer = [];
        var uvBuffer = [];
        // the subdivision creates the vertex buffer data
        subdivide(detail);
        // all vertices should lie on a conceptual sphere with a given radius
        applyRadius(radius);
        // finally, create the uv data
        generateUVs();
        // build non-indexed geometry
        this.setAttribute('position', new Float32BufferAttribute(vertexBuffer, 3));
        this.setAttribute('normal', new Float32BufferAttribute(vertexBuffer.slice(), 3));
        this.setAttribute('uv', new Float32BufferAttribute(uvBuffer, 2));
        if (detail === 0) {
            this.computeVertexNormals(); // flat normals
        }
        else {
            this.normalizeNormals(); // smooth normals
        }
        // helper functions
        function subdivide(detail) {
            var a = new Vector3();
            var b = new Vector3();
            var c = new Vector3();
            // iterate over all faces and apply a subdivison with the given detail value
            for (var i = 0; i < indices.length; i += 3) {
                // get the vertices of the face
                getVertexByIndex(indices[i + 0], a);
                getVertexByIndex(indices[i + 1], b);
                getVertexByIndex(indices[i + 2], c);
                // perform subdivision
                subdivideFace(a, b, c, detail);
            }
        }
        function subdivideFace(a, b, c, detail) {
            var cols = Math.pow(2, detail);
            // we use this multidimensional array as a data structure for creating the subdivision
            var v = [];
            var i, j;
            // construct all of the vertices for this subdivision
            for (i = 0; i <= cols; i++) {
                v[i] = [];
                var aj = a.clone().lerp(c, i / cols);
                var bj = b.clone().lerp(c, i / cols);
                var rows = cols - i;
                for (j = 0; j <= rows; j++) {
                    if (j === 0 && i === cols) {
                        v[i][j] = aj;
                    }
                    else {
                        v[i][j] = aj.clone().lerp(bj, j / rows);
                    }
                }
            }
            // construct all of the faces
            for (i = 0; i < cols; i++) {
                for (j = 0; j < 2 * (cols - i) - 1; j++) {
                    var k = Math.floor(j / 2);
                    if (j % 2 === 0) {
                        pushVertex(v[i][k + 1]);
                        pushVertex(v[i + 1][k]);
                        pushVertex(v[i][k]);
                    }
                    else {
                        pushVertex(v[i][k + 1]);
                        pushVertex(v[i + 1][k + 1]);
                        pushVertex(v[i + 1][k]);
                    }
                }
            }
        }
        function applyRadius(radius) {
            var vertex = new Vector3();
            // iterate over the entire buffer and apply the radius to each vertex
            for (var i = 0; i < vertexBuffer.length; i += 3) {
                vertex.x = vertexBuffer[i + 0];
                vertex.y = vertexBuffer[i + 1];
                vertex.z = vertexBuffer[i + 2];
                vertex.normalize().multiplyScalar(radius);
                vertexBuffer[i + 0] = vertex.x;
                vertexBuffer[i + 1] = vertex.y;
                vertexBuffer[i + 2] = vertex.z;
            }
        }
        function generateUVs() {
            var vertex = new Vector3();
            for (var i = 0; i < vertexBuffer.length; i += 3) {
                vertex.x = vertexBuffer[i + 0];
                vertex.y = vertexBuffer[i + 1];
                vertex.z = vertexBuffer[i + 2];
                var u = azimuth(vertex) / 2 / Math.PI + 0.5;
                var v = inclination(vertex) / Math.PI + 0.5;
                uvBuffer.push(u, 1 - v);
            }
            correctUVs();
            correctSeam();
        }
        function correctSeam() {
            // handle case when face straddles the seam, see #3269
            for (var i = 0; i < uvBuffer.length; i += 6) {
                // uv data of a single face
                var x0 = uvBuffer[i + 0];
                var x1 = uvBuffer[i + 2];
                var x2 = uvBuffer[i + 4];
                var max = Math.max(x0, x1, x2);
                var min = Math.min(x0, x1, x2);
                // 0.9 is somewhat arbitrary
                if (max > 0.9 && min < 0.1) {
                    if (x0 < 0.2)
                        uvBuffer[i + 0] += 1;
                    if (x1 < 0.2)
                        uvBuffer[i + 2] += 1;
                    if (x2 < 0.2)
                        uvBuffer[i + 4] += 1;
                }
            }
        }
        function pushVertex(vertex) {
            vertexBuffer.push(vertex.x, vertex.y, vertex.z);
        }
        function getVertexByIndex(index, vertex) {
            var stride = index * 3;
            vertex.x = vertices[stride + 0];
            vertex.y = vertices[stride + 1];
            vertex.z = vertices[stride + 2];
        }
        function correctUVs() {
            var a = new Vector3();
            var b = new Vector3();
            var c = new Vector3();
            var centroid = new Vector3();
            var uvA = new Vector2();
            var uvB = new Vector2();
            var uvC = new Vector2();
            for (var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {
                a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);
                b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);
                c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);
                uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
                uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
                uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
                centroid.copy(a).add(b).add(c).divideScalar(3);
                var azi = azimuth(centroid);
                correctUV(uvA, j + 0, a, azi);
                correctUV(uvB, j + 2, b, azi);
                correctUV(uvC, j + 4, c, azi);
            }
        }
        function correctUV(uv, stride, vector, azimuth) {
            if ((azimuth < 0) && (uv.x === 1)) {
                uvBuffer[stride] = uv.x - 1;
            }
            if ((vector.x === 0) && (vector.z === 0)) {
                uvBuffer[stride] = azimuth / 2 / Math.PI + 0.5;
            }
        }
        // Angle around the Y axis, counter-clockwise when looking from above.
        function azimuth(vector) {
            return Math.atan2(vector.z, -vector.x);
        }
        // Angle above the XZ plane.
        function inclination(vector) {
            return Math.atan2(-vector.y, Math.sqrt((vector.x * vector.x) + (vector.z * vector.z)));
        }
    }
    exports_14("PolyhedronBufferGeometry", PolyhedronBufferGeometry);
    /**
     * @author timothypratley / https://github.com/timothypratley
     * @author Mugen87 / https://github.com/Mugen87
     */
    // TetrahedronGeometry
    function TetrahedronGeometry(radius, detail) {
        Geometry.call(this);
        this.type = 'TetrahedronGeometry';
        this.parameters = {
            radius: radius,
            detail: detail
        };
        this.fromBufferGeometry(new TetrahedronBufferGeometry(radius, detail));
        this.mergeVertices();
    }
    exports_14("TetrahedronGeometry", TetrahedronGeometry);
    // TetrahedronBufferGeometry
    function TetrahedronBufferGeometry(radius, detail) {
        var vertices = [
            1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1
        ];
        var indices = [
            2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1
        ];
        PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
        this.type = 'TetrahedronBufferGeometry';
        this.parameters = {
            radius: radius,
            detail: detail
        };
    }
    exports_14("TetrahedronBufferGeometry", TetrahedronBufferGeometry);
    /**
     * @author timothypratley / https://github.com/timothypratley
     * @author Mugen87 / https://github.com/Mugen87
     */
    // OctahedronGeometry
    function OctahedronGeometry(radius, detail) {
        Geometry.call(this);
        this.type = 'OctahedronGeometry';
        this.parameters = {
            radius: radius,
            detail: detail
        };
        this.fromBufferGeometry(new OctahedronBufferGeometry(radius, detail));
        this.mergeVertices();
    }
    exports_14("OctahedronGeometry", OctahedronGeometry);
    // OctahedronBufferGeometry
    function OctahedronBufferGeometry(radius, detail) {
        var vertices = [
            1, 0, 0, -1, 0, 0, 0, 1, 0,
            0, -1, 0, 0, 0, 1, 0, 0, -1
        ];
        var indices = [
            0, 2, 4, 0, 4, 3, 0, 3, 5,
            0, 5, 2, 1, 2, 5, 1, 5, 3,
            1, 3, 4, 1, 4, 2
        ];
        PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
        this.type = 'OctahedronBufferGeometry';
        this.parameters = {
            radius: radius,
            detail: detail
        };
    }
    exports_14("OctahedronBufferGeometry", OctahedronBufferGeometry);
    /**
     * @author timothypratley / https://github.com/timothypratley
     * @author Mugen87 / https://github.com/Mugen87
     */
    // IcosahedronGeometry
    function IcosahedronGeometry(radius, detail) {
        Geometry.call(this);
        this.type = 'IcosahedronGeometry';
        this.parameters = {
            radius: radius,
            detail: detail
        };
        this.fromBufferGeometry(new IcosahedronBufferGeometry(radius, detail));
        this.mergeVertices();
    }
    exports_14("IcosahedronGeometry", IcosahedronGeometry);
    // IcosahedronBufferGeometry
    function IcosahedronBufferGeometry(radius, detail) {
        var t = (1 + Math.sqrt(5)) / 2;
        var vertices = [
            -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0,
            0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t,
            t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1
        ];
        var indices = [
            0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11,
            1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8,
            3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9,
            4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1
        ];
        PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
        this.type = 'IcosahedronBufferGeometry';
        this.parameters = {
            radius: radius,
            detail: detail
        };
    }
    exports_14("IcosahedronBufferGeometry", IcosahedronBufferGeometry);
    /**
     * @author Abe Pazos / https://hamoid.com
     * @author Mugen87 / https://github.com/Mugen87
     */
    // DodecahedronGeometry
    function DodecahedronGeometry(radius, detail) {
        Geometry.call(this);
        this.type = 'DodecahedronGeometry';
        this.parameters = {
            radius: radius,
            detail: detail
        };
        this.fromBufferGeometry(new DodecahedronBufferGeometry(radius, detail));
        this.mergeVertices();
    }
    exports_14("DodecahedronGeometry", DodecahedronGeometry);
    // DodecahedronBufferGeometry
    function DodecahedronBufferGeometry(radius, detail) {
        var t = (1 + Math.sqrt(5)) / 2;
        var r = 1 / t;
        var vertices = [
            // (1, 1, 1)
            -1, -1, -1, -1, -1, 1,
            -1, 1, -1, -1, 1, 1,
            1, -1, -1, 1, -1, 1,
            1, 1, -1, 1, 1, 1,
            // (0, 1/, )
            0, -r, -t, 0, -r, t,
            0, r, -t, 0, r, t,
            // (1/, , 0)
            -r, -t, 0, -r, t, 0,
            r, -t, 0, r, t, 0,
            // (, 0, 1/)
            -t, 0, -r, t, 0, -r,
            -t, 0, r, t, 0, r
        ];
        var indices = [
            3, 11, 7, 3, 7, 15, 3, 15, 13,
            7, 19, 17, 7, 17, 6, 7, 6, 15,
            17, 4, 8, 17, 8, 10, 17, 10, 6,
            8, 0, 16, 8, 16, 2, 8, 2, 10,
            0, 12, 1, 0, 1, 18, 0, 18, 16,
            6, 10, 2, 6, 2, 13, 6, 13, 15,
            2, 16, 18, 2, 18, 3, 2, 3, 13,
            18, 1, 9, 18, 9, 11, 18, 11, 3,
            4, 14, 12, 4, 12, 0, 4, 0, 8,
            11, 9, 5, 11, 5, 19, 11, 19, 7,
            19, 5, 14, 19, 14, 4, 19, 4, 17,
            1, 12, 14, 1, 14, 5, 1, 5, 9
        ];
        PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
        this.type = 'DodecahedronBufferGeometry';
        this.parameters = {
            radius: radius,
            detail: detail
        };
    }
    exports_14("DodecahedronBufferGeometry", DodecahedronBufferGeometry);
    /**
     * @author oosmoxiecode / https://github.com/oosmoxiecode
     * @author WestLangley / https://github.com/WestLangley
     * @author zz85 / https://github.com/zz85
     * @author miningold / https://github.com/miningold
     * @author jonobr1 / https://github.com/jonobr1
     * @author Mugen87 / https://github.com/Mugen87
     *
     */
    // TubeGeometry
    function TubeGeometry(path, tubularSegments, radius, radialSegments, closed, taper) {
        Geometry.call(this);
        this.type = 'TubeGeometry';
        this.parameters = {
            path: path,
            tubularSegments: tubularSegments,
            radius: radius,
            radialSegments: radialSegments,
            closed: closed
        };
        if (taper !== undefined)
            console.warn('THREE.TubeGeometry: taper has been removed.');
        var bufferGeometry = new TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed);
        // expose internals
        this.tangents = bufferGeometry.tangents;
        this.normals = bufferGeometry.normals;
        this.binormals = bufferGeometry.binormals;
        // create geometry
        this.fromBufferGeometry(bufferGeometry);
        this.mergeVertices();
    }
    exports_14("TubeGeometry", TubeGeometry);
    // TubeBufferGeometry
    function TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed) {
        BufferGeometry.call(this);
        this.type = 'TubeBufferGeometry';
        this.parameters = {
            path: path,
            tubularSegments: tubularSegments,
            radius: radius,
            radialSegments: radialSegments,
            closed: closed
        };
        tubularSegments = tubularSegments || 64;
        radius = radius || 1;
        radialSegments = radialSegments || 8;
        closed = closed || false;
        var frames = path.computeFrenetFrames(tubularSegments, closed);
        // expose internals
        this.tangents = frames.tangents;
        this.normals = frames.normals;
        this.binormals = frames.binormals;
        // helper variables
        var vertex = new Vector3();
        var normal = new Vector3();
        var uv = new Vector2();
        var P = new Vector3();
        var i, j;
        // buffer
        var vertices = [];
        var normals = [];
        var uvs = [];
        var indices = [];
        // create buffer data
        generateBufferData();
        // build geometry
        this.setIndex(indices);
        this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
        this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
        // functions
        function generateBufferData() {
            for (i = 0; i < tubularSegments; i++) {
                generateSegment(i);
            }
            // if the geometry is not closed, generate the last row of vertices and normals
            // at the regular position on the given path
            //
            // if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)
            generateSegment((closed === false) ? tubularSegments : 0);
            // uvs are generated in a separate function.
            // this makes it easy compute correct values for closed geometries
            generateUVs();
            // finally create faces
            generateIndices();
        }
        function generateSegment(i) {
            // we use getPointAt to sample evenly distributed points from the given path
            P = path.getPointAt(i / tubularSegments, P);
            // retrieve corresponding normal and binormal
            var N = frames.normals[i];
            var B = frames.binormals[i];
            // generate normals and vertices for the current segment
            for (j = 0; j <= radialSegments; j++) {
                var v = j / radialSegments * Math.PI * 2;
                var sin = Math.sin(v);
                var cos = -Math.cos(v);
                // normal
                normal.x = (cos * N.x + sin * B.x);
                normal.y = (cos * N.y + sin * B.y);
                normal.z = (cos * N.z + sin * B.z);
                normal.normalize();
                normals.push(normal.x, normal.y, normal.z);
                // vertex
                vertex.x = P.x + radius * normal.x;
                vertex.y = P.y + radius * normal.y;
                vertex.z = P.z + radius * normal.z;
                vertices.push(vertex.x, vertex.y, vertex.z);
            }
        }
        function generateIndices() {
            for (j = 1; j <= tubularSegments; j++) {
                for (i = 1; i <= radialSegments; i++) {
                    var a = (radialSegments + 1) * (j - 1) + (i - 1);
                    var b = (radialSegments + 1) * j + (i - 1);
                    var c = (radialSegments + 1) * j + i;
                    var d = (radialSegments + 1) * (j - 1) + i;
                    // faces
                    indices.push(a, b, d);
                    indices.push(b, c, d);
                }
            }
        }
        function generateUVs() {
            for (i = 0; i <= tubularSegments; i++) {
                for (j = 0; j <= radialSegments; j++) {
                    uv.x = i / tubularSegments;
                    uv.y = j / radialSegments;
                    uvs.push(uv.x, uv.y);
                }
            }
        }
    }
    exports_14("TubeBufferGeometry", TubeBufferGeometry);
    /**
     * @author oosmoxiecode
     * @author Mugen87 / https://github.com/Mugen87
     *
     * based on http://www.blackpawn.com/texts/pqtorus/
     */
    // TorusKnotGeometry
    function TorusKnotGeometry(radius, tube, tubularSegments, radialSegments, p, q, heightScale) {
        Geometry.call(this);
        this.type = 'TorusKnotGeometry';
        this.parameters = {
            radius: radius,
            tube: tube,
            tubularSegments: tubularSegments,
            radialSegments: radialSegments,
            p: p,
            q: q
        };
        if (heightScale !== undefined)
            console.warn('THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.');
        this.fromBufferGeometry(new TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q));
        this.mergeVertices();
    }
    exports_14("TorusKnotGeometry", TorusKnotGeometry);
    // TorusKnotBufferGeometry
    function TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q) {
        BufferGeometry.call(this);
        this.type = 'TorusKnotBufferGeometry';
        this.parameters = {
            radius: radius,
            tube: tube,
            tubularSegments: tubularSegments,
            radialSegments: radialSegments,
            p: p,
            q: q
        };
        radius = radius || 1;
        tube = tube || 0.4;
        tubularSegments = Math.floor(tubularSegments) || 64;
        radialSegments = Math.floor(radialSegments) || 8;
        p = p || 2;
        q = q || 3;
        // buffers
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
        // helper variables
        var i, j;
        var vertex = new Vector3();
        var normal = new Vector3();
        var P1 = new Vector3();
        var P2 = new Vector3();
        var B = new Vector3();
        var T = new Vector3();
        var N = new Vector3();
        // generate vertices, normals and uvs
        for (i = 0; i <= tubularSegments; ++i) {
            // the radian "u" is used to calculate the position on the torus curve of the current tubular segement
            var u = i / tubularSegments * p * Math.PI * 2;
            // now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
            // these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions
            calculatePositionOnCurve(u, p, q, radius, P1);
            calculatePositionOnCurve(u + 0.01, p, q, radius, P2);
            // calculate orthonormal basis
            T.subVectors(P2, P1);
            N.addVectors(P2, P1);
            B.crossVectors(T, N);
            N.crossVectors(B, T);
            // normalize B, N. T can be ignored, we don't use it
            B.normalize();
            N.normalize();
            for (j = 0; j <= radialSegments; ++j) {
                // now calculate the vertices. they are nothing more than an extrusion of the torus curve.
                // because we extrude a shape in the xy-plane, there is no need to calculate a z-value.
                var v = j / radialSegments * Math.PI * 2;
                var cx = -tube * Math.cos(v);
                var cy = tube * Math.sin(v);
                // now calculate the final vertex position.
                // first we orient the extrusion with our basis vectos, then we add it to the current position on the curve
                vertex.x = P1.x + (cx * N.x + cy * B.x);
                vertex.y = P1.y + (cx * N.y + cy * B.y);
                vertex.z = P1.z + (cx * N.z + cy * B.z);
                vertices.push(vertex.x, vertex.y, vertex.z);
                // normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)
                normal.subVectors(vertex, P1).normalize();
                normals.push(normal.x, normal.y, normal.z);
                // uv
                uvs.push(i / tubularSegments);
                uvs.push(j / radialSegments);
            }
        }
        // generate indices
        for (j = 1; j <= tubularSegments; j++) {
            for (i = 1; i <= radialSegments; i++) {
                // indices
                var a = (radialSegments + 1) * (j - 1) + (i - 1);
                var b = (radialSegments + 1) * j + (i - 1);
                var c = (radialSegments + 1) * j + i;
                var d = (radialSegments + 1) * (j - 1) + i;
                // faces
                indices.push(a, b, d);
                indices.push(b, c, d);
            }
        }
        // build geometry
        this.setIndex(indices);
        this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
        this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
        // this function calculates the current position on the torus curve
        function calculatePositionOnCurve(u, p, q, radius, position) {
            var cu = Math.cos(u);
            var su = Math.sin(u);
            var quOverP = q / p * u;
            var cs = Math.cos(quOverP);
            position.x = radius * (2 + cs) * 0.5 * cu;
            position.y = radius * (2 + cs) * su * 0.5;
            position.z = radius * Math.sin(quOverP) * 0.5;
        }
    }
    exports_14("TorusKnotBufferGeometry", TorusKnotBufferGeometry);
    /**
     * @author oosmoxiecode
     * @author mrdoob / http://mrdoob.com/
     * @author Mugen87 / https://github.com/Mugen87
     */
    // TorusGeometry
    function TorusGeometry(radius, tube, radialSegments, tubularSegments, arc) {
        Geometry.call(this);
        this.type = 'TorusGeometry';
        this.parameters = {
            radius: radius,
            tube: tube,
            radialSegments: radialSegments,
            tubularSegments: tubularSegments,
            arc: arc
        };
        this.fromBufferGeometry(new TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc));
        this.mergeVertices();
    }
    exports_14("TorusGeometry", TorusGeometry);
    // TorusBufferGeometry
    function TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc) {
        BufferGeometry.call(this);
        this.type = 'TorusBufferGeometry';
        this.parameters = {
            radius: radius,
            tube: tube,
            radialSegments: radialSegments,
            tubularSegments: tubularSegments,
            arc: arc
        };
        radius = radius || 1;
        tube = tube || 0.4;
        radialSegments = Math.floor(radialSegments) || 8;
        tubularSegments = Math.floor(tubularSegments) || 6;
        arc = arc || Math.PI * 2;
        // buffers
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
        // helper variables
        var center = new Vector3();
        var vertex = new Vector3();
        var normal = new Vector3();
        var j, i;
        // generate vertices, normals and uvs
        for (j = 0; j <= radialSegments; j++) {
            for (i = 0; i <= tubularSegments; i++) {
                var u = i / tubularSegments * arc;
                var v = j / radialSegments * Math.PI * 2;
                // vertex
                vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
                vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
                vertex.z = tube * Math.sin(v);
                vertices.push(vertex.x, vertex.y, vertex.z);
                // normal
                center.x = radius * Math.cos(u);
                center.y = radius * Math.sin(u);
                normal.subVectors(vertex, center).normalize();
                normals.push(normal.x, normal.y, normal.z);
                // uv
                uvs.push(i / tubularSegments);
                uvs.push(j / radialSegments);
            }
        }
        // generate indices
        for (j = 1; j <= radialSegments; j++) {
            for (i = 1; i <= tubularSegments; i++) {
                // indices
                var a = (tubularSegments + 1) * j + i - 1;
                var b = (tubularSegments + 1) * (j - 1) + i - 1;
                var c = (tubularSegments + 1) * (j - 1) + i;
                var d = (tubularSegments + 1) * j + i;
                // faces
                indices.push(a, b, d);
                indices.push(b, c, d);
            }
        }
        // build geometry
        this.setIndex(indices);
        this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
        this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
    }
    exports_14("TorusBufferGeometry", TorusBufferGeometry);
    // create a circular doubly linked list from polygon points in the specified winding order
    function linkedList(data, start, end, dim, clockwise) {
        var i, last;
        if (clockwise === (signedArea(data, start, end, dim) > 0)) {
            for (i = start; i < end; i += dim)
                last = insertNode(i, data[i], data[i + 1], last);
        }
        else {
            for (i = end - dim; i >= start; i -= dim)
                last = insertNode(i, data[i], data[i + 1], last);
        }
        if (last && equals(last, last.next)) {
            removeNode(last);
            last = last.next;
        }
        return last;
    }
    // eliminate colinear or duplicate points
    function filterPoints(start, end) {
        if (!start)
            return start;
        if (!end)
            end = start;
        var p = start, again;
        do {
            again = false;
            if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
                removeNode(p);
                p = end = p.prev;
                if (p === p.next)
                    break;
                again = true;
            }
            else {
                p = p.next;
            }
        } while (again || p !== end);
        return end;
    }
    // main ear slicing loop which triangulates a polygon (given as a linked list)
    function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
        if (!ear)
            return;
        // interlink polygon nodes in z-order
        if (!pass && invSize)
            indexCurve(ear, minX, minY, invSize);
        var stop = ear, prev, next;
        // iterate through ears, slicing them one by one
        while (ear.prev !== ear.next) {
            prev = ear.prev;
            next = ear.next;
            if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
                // cut off the triangle
                triangles.push(prev.i / dim);
                triangles.push(ear.i / dim);
                triangles.push(next.i / dim);
                removeNode(ear);
                // skipping the next vertex leads to less sliver triangles
                ear = next.next;
                stop = next.next;
                continue;
            }
            ear = next;
            // if we looped through the whole remaining polygon and can't find any more ears
            if (ear === stop) {
                // try filtering points and slicing again
                if (!pass) {
                    earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
                    // if this didn't work, try curing all small self-intersections locally
                }
                else if (pass === 1) {
                    ear = cureLocalIntersections(ear, triangles, dim);
                    earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
                    // as a last resort, try splitting the remaining polygon into two
                }
                else if (pass === 2) {
                    splitEarcut(ear, triangles, dim, minX, minY, invSize);
                }
                break;
            }
        }
    }
    // check whether a polygon node forms a valid ear with adjacent nodes
    function isEar(ear) {
        var a = ear.prev, b = ear, c = ear.next;
        if (area(a, b, c) >= 0)
            return false; // reflex, can't be an ear
        // now make sure we don't have other points inside the potential ear
        var p = ear.next.next;
        while (p !== ear.prev) {
            if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                area(p.prev, p, p.next) >= 0)
                return false;
            p = p.next;
        }
        return true;
    }
    function isEarHashed(ear, minX, minY, invSize) {
        var a = ear.prev, b = ear, c = ear.next;
        if (area(a, b, c) >= 0)
            return false; // reflex, can't be an ear
        // triangle bbox; min & max are calculated like this for speed
        var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x), minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y), maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x), maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);
        // z-order range for the current triangle bbox;
        var minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
        var p = ear.prevZ, n = ear.nextZ;
        // look for points inside the triangle in both directions
        while (p && p.z >= minZ && n && n.z <= maxZ) {
            if (p !== ear.prev && p !== ear.next &&
                pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                area(p.prev, p, p.next) >= 0)
                return false;
            p = p.prevZ;
            if (n !== ear.prev && n !== ear.next &&
                pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
                area(n.prev, n, n.next) >= 0)
                return false;
            n = n.nextZ;
        }
        // look for remaining points in decreasing z-order
        while (p && p.z >= minZ) {
            if (p !== ear.prev && p !== ear.next &&
                pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                area(p.prev, p, p.next) >= 0)
                return false;
            p = p.prevZ;
        }
        // look for remaining points in increasing z-order
        while (n && n.z <= maxZ) {
            if (n !== ear.prev && n !== ear.next &&
                pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
                area(n.prev, n, n.next) >= 0)
                return false;
            n = n.nextZ;
        }
        return true;
    }
    // go through all polygon nodes and cure small local self-intersections
    function cureLocalIntersections(start, triangles, dim) {
        var p = start;
        do {
            var a = p.prev, b = p.next.next;
            if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
                triangles.push(a.i / dim);
                triangles.push(p.i / dim);
                triangles.push(b.i / dim);
                // remove two nodes involved
                removeNode(p);
                removeNode(p.next);
                p = start = b;
            }
            p = p.next;
        } while (p !== start);
        return p;
    }
    // try splitting polygon into two and triangulate them independently
    function splitEarcut(start, triangles, dim, minX, minY, invSize) {
        // look for a valid diagonal that divides the polygon into two
        var a = start;
        do {
            var b = a.next.next;
            while (b !== a.prev) {
                if (a.i !== b.i && isValidDiagonal(a, b)) {
                    // split the polygon in two by the diagonal
                    var c = splitPolygon(a, b);
                    // filter colinear points around the cuts
                    a = filterPoints(a, a.next);
                    c = filterPoints(c, c.next);
                    // run earcut on each half
                    earcutLinked(a, triangles, dim, minX, minY, invSize);
                    earcutLinked(c, triangles, dim, minX, minY, invSize);
                    return;
                }
                b = b.next;
            }
            a = a.next;
        } while (a !== start);
    }
    // link every hole into the outer loop, producing a single-ring polygon without holes
    function eliminateHoles(data, holeIndices, outerNode, dim) {
        var queue = [], i, len, start, end, list;
        for (i = 0, len = holeIndices.length; i < len; i++) {
            start = holeIndices[i] * dim;
            end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            list = linkedList(data, start, end, dim, false);
            if (list === list.next)
                list.steiner = true;
            queue.push(getLeftmost(list));
        }
        queue.sort(compareX);
        // process holes from left to right
        for (i = 0; i < queue.length; i++) {
            eliminateHole(queue[i], outerNode);
            outerNode = filterPoints(outerNode, outerNode.next);
        }
        return outerNode;
    }
    function compareX(a, b) {
        return a.x - b.x;
    }
    // find a bridge between vertices that connects hole with an outer ring and and link it
    function eliminateHole(hole, outerNode) {
        outerNode = findHoleBridge(hole, outerNode);
        if (outerNode) {
            var b = splitPolygon(outerNode, hole);
            filterPoints(b, b.next);
        }
    }
    // David Eberly's algorithm for finding a bridge between hole and outer polygon
    function findHoleBridge(hole, outerNode) {
        var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
        // find a segment intersected by a ray from the hole's leftmost point to the left;
        // segment's endpoint with lesser x will be potential connection point
        do {
            if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
                var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
                if (x <= hx && x > qx) {
                    qx = x;
                    if (x === hx) {
                        if (hy === p.y)
                            return p;
                        if (hy === p.next.y)
                            return p.next;
                    }
                    m = p.x < p.next.x ? p : p.next;
                }
            }
            p = p.next;
        } while (p !== outerNode);
        if (!m)
            return null;
        if (hx === qx)
            return m.prev; // hole touches outer segment; pick lower endpoint
        // look for points inside the triangle of hole point, segment intersection and endpoint;
        // if there are no points found, we have a valid connection;
        // otherwise choose the point of the minimum angle with the ray as connection point
        var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;
        p = m.next;
        while (p !== stop) {
            if (hx >= p.x && p.x >= mx && hx !== p.x &&
                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
                tan = Math.abs(hy - p.y) / (hx - p.x); // tangential
                if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && locallyInside(p, hole)) {
                    m = p;
                    tanMin = tan;
                }
            }
            p = p.next;
        }
        return m;
    }
    // interlink polygon nodes in z-order
    function indexCurve(start, minX, minY, invSize) {
        var p = start;
        do {
            if (p.z === null)
                p.z = zOrder(p.x, p.y, minX, minY, invSize);
            p.prevZ = p.prev;
            p.nextZ = p.next;
            p = p.next;
        } while (p !== start);
        p.prevZ.nextZ = null;
        p.prevZ = null;
        sortLinked(p);
    }
    // Simon Tatham's linked list merge sort algorithm
    // http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
    function sortLinked(list) {
        var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
        do {
            p = list;
            list = null;
            tail = null;
            numMerges = 0;
            while (p) {
                numMerges++;
                q = p;
                pSize = 0;
                for (i = 0; i < inSize; i++) {
                    pSize++;
                    q = q.nextZ;
                    if (!q)
                        break;
                }
                qSize = inSize;
                while (pSize > 0 || (qSize > 0 && q)) {
                    if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                        e = p;
                        p = p.nextZ;
                        pSize--;
                    }
                    else {
                        e = q;
                        q = q.nextZ;
                        qSize--;
                    }
                    if (tail)
                        tail.nextZ = e;
                    else
                        list = e;
                    e.prevZ = tail;
                    tail = e;
                }
                p = q;
            }
            tail.nextZ = null;
            inSize *= 2;
        } while (numMerges > 1);
        return list;
    }
    // z-order of a point given coords and inverse of the longer side of data bbox
    function zOrder(x, y, minX, minY, invSize) {
        // coords are transformed into non-negative 15-bit integer range
        x = 32767 * (x - minX) * invSize;
        y = 32767 * (y - minY) * invSize;
        x = (x | (x << 8)) & 0x00FF00FF;
        x = (x | (x << 4)) & 0x0F0F0F0F;
        x = (x | (x << 2)) & 0x33333333;
        x = (x | (x << 1)) & 0x55555555;
        y = (y | (y << 8)) & 0x00FF00FF;
        y = (y | (y << 4)) & 0x0F0F0F0F;
        y = (y | (y << 2)) & 0x33333333;
        y = (y | (y << 1)) & 0x55555555;
        return x | (y << 1);
    }
    // find the leftmost node of a polygon ring
    function getLeftmost(start) {
        var p = start, leftmost = start;
        do {
            if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y))
                leftmost = p;
            p = p.next;
        } while (p !== start);
        return leftmost;
    }
    // check if a point lies within a convex triangle
    function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
        return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
            (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
            (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
    }
    // check if a diagonal between two polygon nodes is valid (lies in polygon interior)
    function isValidDiagonal(a, b) {
        return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) &&
            locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
    }
    // signed area of a triangle
    function area(p, q, r) {
        return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
    }
    // check if two points are equal
    function equals(p1, p2) {
        return p1.x === p2.x && p1.y === p2.y;
    }
    // check if two segments intersect
    function intersects(p1, q1, p2, q2) {
        if ((equals(p1, p2) && equals(q1, q2)) ||
            (equals(p1, q2) && equals(p2, q1)))
            return true;
        return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 &&
            area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
    }
    // check if a polygon diagonal intersects any polygon segments
    function intersectsPolygon(a, b) {
        var p = a;
        do {
            if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                intersects(p, p.next, a, b))
                return true;
            p = p.next;
        } while (p !== a);
        return false;
    }
    // check if a polygon diagonal is locally inside the polygon
    function locallyInside(a, b) {
        return area(a.prev, a, a.next) < 0 ?
            area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
            area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
    }
    // check if the middle point of a polygon diagonal is inside the polygon
    function middleInside(a, b) {
        var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
        do {
            if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
                inside = !inside;
            p = p.next;
        } while (p !== a);
        return inside;
    }
    // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
    // if one belongs to the outer ring and another to a hole, it merges it into a single ring
    function splitPolygon(a, b) {
        var a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
        a.next = b;
        b.prev = a;
        a2.next = an;
        an.prev = a2;
        b2.next = a2;
        a2.prev = b2;
        bp.next = b2;
        b2.prev = bp;
        return b2;
    }
    // create a node and optionally link it with previous one (in a circular doubly linked list)
    function insertNode(i, x, y, last) {
        var p = new Node(i, x, y);
        if (!last) {
            p.prev = p;
            p.next = p;
        }
        else {
            p.next = last.next;
            p.prev = last;
            last.next.prev = p;
            last.next = p;
        }
        return p;
    }
    function removeNode(p) {
        p.next.prev = p.prev;
        p.prev.next = p.next;
        if (p.prevZ)
            p.prevZ.nextZ = p.nextZ;
        if (p.nextZ)
            p.nextZ.prevZ = p.prevZ;
    }
    function Node(i, x, y) {
        // vertex index in coordinates array
        this.i = i;
        // vertex coordinates
        this.x = x;
        this.y = y;
        // previous and next vertex nodes in a polygon ring
        this.prev = null;
        this.next = null;
        // z-order curve value
        this.z = null;
        // previous and next nodes in z-order
        this.prevZ = null;
        this.nextZ = null;
        // indicates whether this is a steiner point
        this.steiner = false;
    }
    function signedArea(data, start, end, dim) {
        var sum = 0;
        for (var i = start, j = end - dim; i < end; i += dim) {
            sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
            j = i;
        }
        return sum;
    }
    function removeDupEndPts(points) {
        var l = points.length;
        if (l > 2 && points[l - 1].equals(points[0])) {
            points.pop();
        }
    }
    function addContour(vertices, contour) {
        for (var i = 0; i < contour.length; i++) {
            vertices.push(contour[i].x);
            vertices.push(contour[i].y);
        }
    }
    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     *
     * Creates extruded geometry from a path shape.
     *
     * parameters = {
     *
     *  curveSegments: <int>, // number of points on the curves
     *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
     *  depth: <float>, // Depth to extrude the shape
     *
     *  bevelEnabled: <bool>, // turn on bevel
     *  bevelThickness: <float>, // how deep into the original shape bevel goes
     *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
     *  bevelOffset: <float>, // how far from shape outline does bevel start
     *  bevelSegments: <int>, // number of bevel layers
     *
     *  extrudePath: <THREE.Curve> // curve to extrude shape along
     *
     *  UVGenerator: <Object> // object that provides UV generator functions
     *
     * }
     */
    // ExtrudeGeometry
    function ExtrudeGeometry(shapes, options) {
        Geometry.call(this);
        this.type = 'ExtrudeGeometry';
        this.parameters = {
            shapes: shapes,
            options: options
        };
        this.fromBufferGeometry(new ExtrudeBufferGeometry(shapes, options));
        this.mergeVertices();
    }
    exports_14("ExtrudeGeometry", ExtrudeGeometry);
    // ExtrudeBufferGeometry
    function ExtrudeBufferGeometry(shapes, options) {
        BufferGeometry.call(this);
        this.type = 'ExtrudeBufferGeometry';
        this.parameters = {
            shapes: shapes,
            options: options
        };
        shapes = Array.isArray(shapes) ? shapes : [shapes];
        var scope = this;
        var verticesArray = [];
        var uvArray = [];
        for (var i = 0, l = shapes.length; i < l; i++) {
            var shape = shapes[i];
            addShape(shape);
        }
        // build geometry
        this.setAttribute('position', new Float32BufferAttribute(verticesArray, 3));
        this.setAttribute('uv', new Float32BufferAttribute(uvArray, 2));
        this.computeVertexNormals();
        // functions
        function addShape(shape) {
            var placeholder = [];
            // options
            var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
            var steps = options.steps !== undefined ? options.steps : 1;
            var depth = options.depth !== undefined ? options.depth : 100;
            var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
            var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
            var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
            var bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;
            var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
            var extrudePath = options.extrudePath;
            var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;
            // deprecated options
            if (options.amount !== undefined) {
                console.warn('THREE.ExtrudeBufferGeometry: amount has been renamed to depth.');
                depth = options.amount;
            }
            //
            var extrudePts, extrudeByPath = false;
            var splineTube, binormal, normal, position2;
            if (extrudePath) {
                extrudePts = extrudePath.getSpacedPoints(steps);
                extrudeByPath = true;
                bevelEnabled = false; // bevels not supported for path extrusion
                // SETUP TNB variables
                // TODO1 - have a .isClosed in spline?
                splineTube = extrudePath.computeFrenetFrames(steps, false);
                // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);
                binormal = new Vector3();
                normal = new Vector3();
                position2 = new Vector3();
            }
            // Safeguards if bevels are not enabled
            if (!bevelEnabled) {
                bevelSegments = 0;
                bevelThickness = 0;
                bevelSize = 0;
                bevelOffset = 0;
            }
            // Variables initialization
            var ahole, h, hl; // looping of holes
            var shapePoints = shape.extractPoints(curveSegments);
            var vertices = shapePoints.shape;
            var holes = shapePoints.holes;
            var reverse = !ShapeUtils.isClockWise(vertices);
            if (reverse) {
                vertices = vertices.reverse();
                // Maybe we should also check if holes are in the opposite direction, just to be safe ...
                for (h = 0, hl = holes.length; h < hl; h++) {
                    ahole = holes[h];
                    if (ShapeUtils.isClockWise(ahole)) {
                        holes[h] = ahole.reverse();
                    }
                }
            }
            var faces = ShapeUtils.triangulateShape(vertices, holes);
            /* Vertices */
            var contour = vertices; // vertices has all points but contour has only points of circumference
            for (h = 0, hl = holes.length; h < hl; h++) {
                ahole = holes[h];
                vertices = vertices.concat(ahole);
            }
            function scalePt2(pt, vec, size) {
                if (!vec)
                    console.error("THREE.ExtrudeGeometry: vec does not exist");
                return vec.clone().multiplyScalar(size).add(pt);
            }
            var b, bs, t, z, vert, vlen = vertices.length, face, flen = faces.length;
            // Find directions for point movement
            function getBevelVec(inPt, inPrev, inNext) {
                // computes for inPt the corresponding point inPt' on a new contour
                //   shifted by 1 unit (length of normalized vector) to the left
                // if we walk along contour clockwise, this new contour is outside the old one
                //
                // inPt' is the intersection of the two lines parallel to the two
                //  adjacent edges of inPt at a distance of 1 unit on the left side.
                var v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt
                // good reading for geometry algorithms (here: line-line intersection)
                // http://geomalgorithms.com/a05-_intersect-1.html
                var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
                var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
                var v_prev_lensq = (v_prev_x * v_prev_x + v_prev_y * v_prev_y);
                // check for collinear edges
                var collinear0 = (v_prev_x * v_next_y - v_prev_y * v_next_x);
                if (Math.abs(collinear0) > Number.EPSILON) {
                    // not collinear
                    // length of vectors for normalizing
                    var v_prev_len = Math.sqrt(v_prev_lensq);
                    var v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
                    // shift adjacent points by unit vectors to the left
                    var ptPrevShift_x = (inPrev.x - v_prev_y / v_prev_len);
                    var ptPrevShift_y = (inPrev.y + v_prev_x / v_prev_len);
                    var ptNextShift_x = (inNext.x - v_next_y / v_next_len);
                    var ptNextShift_y = (inNext.y + v_next_x / v_next_len);
                    // scaling factor for v_prev to intersection point
                    var sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y -
                        (ptNextShift_y - ptPrevShift_y) * v_next_x) /
                        (v_prev_x * v_next_y - v_prev_y * v_next_x);
                    // vector from inPt to intersection point
                    v_trans_x = (ptPrevShift_x + v_prev_x * sf - inPt.x);
                    v_trans_y = (ptPrevShift_y + v_prev_y * sf - inPt.y);
                    // Don't normalize!, otherwise sharp corners become ugly
                    //  but prevent crazy spikes
                    var v_trans_lensq = (v_trans_x * v_trans_x + v_trans_y * v_trans_y);
                    if (v_trans_lensq <= 2) {
                        return new Vector2(v_trans_x, v_trans_y);
                    }
                    else {
                        shrink_by = Math.sqrt(v_trans_lensq / 2);
                    }
                }
                else {
                    // handle special case of collinear edges
                    var direction_eq = false; // assumes: opposite
                    if (v_prev_x > Number.EPSILON) {
                        if (v_next_x > Number.EPSILON) {
                            direction_eq = true;
                        }
                    }
                    else {
                        if (v_prev_x < -Number.EPSILON) {
                            if (v_next_x < -Number.EPSILON) {
                                direction_eq = true;
                            }
                        }
                        else {
                            if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                                direction_eq = true;
                            }
                        }
                    }
                    if (direction_eq) {
                        // console.log("Warning: lines are a straight sequence");
                        v_trans_x = -v_prev_y;
                        v_trans_y = v_prev_x;
                        shrink_by = Math.sqrt(v_prev_lensq);
                    }
                    else {
                        // console.log("Warning: lines are a straight spike");
                        v_trans_x = v_prev_x;
                        v_trans_y = v_prev_y;
                        shrink_by = Math.sqrt(v_prev_lensq / 2);
                    }
                }
                return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
            }
            var contourMovements = [];
            for (var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
                if (j === il)
                    j = 0;
                if (k === il)
                    k = 0;
                //  (j)---(i)---(k)
                // console.log('i,j,k', i, j , k)
                contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
            }
            var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();
            for (h = 0, hl = holes.length; h < hl; h++) {
                ahole = holes[h];
                oneHoleMovements = [];
                for (i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
                    if (j === il)
                        j = 0;
                    if (k === il)
                        k = 0;
                    //  (j)---(i)---(k)
                    oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
                }
                holesMovements.push(oneHoleMovements);
                verticesMovements = verticesMovements.concat(oneHoleMovements);
            }
            // Loop bevelSegments, 1 for the front, 1 for the back
            for (b = 0; b < bevelSegments; b++) {
                //for ( b = bevelSegments; b > 0; b -- ) {
                t = b / bevelSegments;
                z = bevelThickness * Math.cos(t * Math.PI / 2);
                bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
                // contract shape
                for (i = 0, il = contour.length; i < il; i++) {
                    vert = scalePt2(contour[i], contourMovements[i], bs);
                    v(vert.x, vert.y, -z);
                }
                // expand holes
                for (h = 0, hl = holes.length; h < hl; h++) {
                    ahole = holes[h];
                    oneHoleMovements = holesMovements[h];
                    for (i = 0, il = ahole.length; i < il; i++) {
                        vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
                        v(vert.x, vert.y, -z);
                    }
                }
            }
            bs = bevelSize + bevelOffset;
            // Back facing vertices
            for (i = 0; i < vlen; i++) {
                vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
                if (!extrudeByPath) {
                    v(vert.x, vert.y, 0);
                }
                else {
                    // v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );
                    normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
                    binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
                    position2.copy(extrudePts[0]).add(normal).add(binormal);
                    v(position2.x, position2.y, position2.z);
                }
            }
            // Add stepped vertices...
            // Including front facing vertices
            var s;
            for (s = 1; s <= steps; s++) {
                for (i = 0; i < vlen; i++) {
                    vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
                    if (!extrudeByPath) {
                        v(vert.x, vert.y, depth / steps * s);
                    }
                    else {
                        // v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );
                        normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
                        binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);
                        position2.copy(extrudePts[s]).add(normal).add(binormal);
                        v(position2.x, position2.y, position2.z);
                    }
                }
            }
            // Add bevel segments planes
            //for ( b = 1; b <= bevelSegments; b ++ ) {
            for (b = bevelSegments - 1; b >= 0; b--) {
                t = b / bevelSegments;
                z = bevelThickness * Math.cos(t * Math.PI / 2);
                bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
                // contract shape
                for (i = 0, il = contour.length; i < il; i++) {
                    vert = scalePt2(contour[i], contourMovements[i], bs);
                    v(vert.x, vert.y, depth + z);
                }
                // expand holes
                for (h = 0, hl = holes.length; h < hl; h++) {
                    ahole = holes[h];
                    oneHoleMovements = holesMovements[h];
                    for (i = 0, il = ahole.length; i < il; i++) {
                        vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
                        if (!extrudeByPath) {
                            v(vert.x, vert.y, depth + z);
                        }
                        else {
                            v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
                        }
                    }
                }
            }
            /* Faces */
            // Top and bottom faces
            buildLidFaces();
            // Sides faces
            buildSideFaces();
            /////  Internal functions
            function buildLidFaces() {
                var start = verticesArray.length / 3;
                if (bevelEnabled) {
                    var layer = 0; // steps + 1
                    var offset = vlen * layer;
                    // Bottom faces
                    for (i = 0; i < flen; i++) {
                        face = faces[i];
                        f3(face[2] + offset, face[1] + offset, face[0] + offset);
                    }
                    layer = steps + bevelSegments * 2;
                    offset = vlen * layer;
                    // Top faces
                    for (i = 0; i < flen; i++) {
                        face = faces[i];
                        f3(face[0] + offset, face[1] + offset, face[2] + offset);
                    }
                }
                else {
                    // Bottom faces
                    for (i = 0; i < flen; i++) {
                        face = faces[i];
                        f3(face[2], face[1], face[0]);
                    }
                    // Top faces
                    for (i = 0; i < flen; i++) {
                        face = faces[i];
                        f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
                    }
                }
                scope.addGroup(start, verticesArray.length / 3 - start, 0);
            }
            // Create faces for the z-sides of the shape
            function buildSideFaces() {
                var start = verticesArray.length / 3;
                var layeroffset = 0;
                sidewalls(contour, layeroffset);
                layeroffset += contour.length;
                for (h = 0, hl = holes.length; h < hl; h++) {
                    ahole = holes[h];
                    sidewalls(ahole, layeroffset);
                    //, true
                    layeroffset += ahole.length;
                }
                scope.addGroup(start, verticesArray.length / 3 - start, 1);
            }
            function sidewalls(contour, layeroffset) {
                var j, k;
                i = contour.length;
                while (--i >= 0) {
                    j = i;
                    k = i - 1;
                    if (k < 0)
                        k = contour.length - 1;
                    //console.log('b', i,j, i-1, k,vertices.length);
                    var s = 0, sl = steps + bevelSegments * 2;
                    for (s = 0; s < sl; s++) {
                        var slen1 = vlen * s;
                        var slen2 = vlen * (s + 1);
                        var a = layeroffset + j + slen1, b = layeroffset + k + slen1, c = layeroffset + k + slen2, d = layeroffset + j + slen2;
                        f4(a, b, c, d);
                    }
                }
            }
            function v(x, y, z) {
                placeholder.push(x);
                placeholder.push(y);
                placeholder.push(z);
            }
            function f3(a, b, c) {
                addVertex(a);
                addVertex(b);
                addVertex(c);
                var nextIndex = verticesArray.length / 3;
                var uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
                addUV(uvs[0]);
                addUV(uvs[1]);
                addUV(uvs[2]);
            }
            function f4(a, b, c, d) {
                addVertex(a);
                addVertex(b);
                addVertex(d);
                addVertex(b);
                addVertex(c);
                addVertex(d);
                var nextIndex = verticesArray.length / 3;
                var uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
                addUV(uvs[0]);
                addUV(uvs[1]);
                addUV(uvs[3]);
                addUV(uvs[1]);
                addUV(uvs[2]);
                addUV(uvs[3]);
            }
            function addVertex(index) {
                verticesArray.push(placeholder[index * 3 + 0]);
                verticesArray.push(placeholder[index * 3 + 1]);
                verticesArray.push(placeholder[index * 3 + 2]);
            }
            function addUV(vector2) {
                uvArray.push(vector2.x);
                uvArray.push(vector2.y);
            }
        }
    }
    exports_14("ExtrudeBufferGeometry", ExtrudeBufferGeometry);
    function toJSON(shapes, options, data) {
        //
        data.shapes = [];
        if (Array.isArray(shapes)) {
            for (var i = 0, l = shapes.length; i < l; i++) {
                var shape = shapes[i];
                data.shapes.push(shape.uuid);
            }
        }
        else {
            data.shapes.push(shapes.uuid);
        }
        //
        if (options.extrudePath !== undefined)
            data.options.extrudePath = options.extrudePath.toJSON();
        return data;
    }
    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     * @author alteredq / http://alteredqualia.com/
     *
     * Text = 3D Text
     *
     * parameters = {
     *  font: <THREE.Font>, // font
     *
     *  size: <float>, // size of the text
     *  height: <float>, // thickness to extrude text
     *  curveSegments: <int>, // number of points on the curves
     *
     *  bevelEnabled: <bool>, // turn on bevel
     *  bevelThickness: <float>, // how deep into text bevel goes
     *  bevelSize: <float>, // how far from text outline (including bevelOffset) is bevel
     *  bevelOffset: <float> // how far from text outline does bevel start
     * }
     */
    // TextGeometry
    function TextGeometry(text, parameters) {
        Geometry.call(this);
        this.type = 'TextGeometry';
        this.parameters = {
            text: text,
            parameters: parameters
        };
        this.fromBufferGeometry(new TextBufferGeometry(text, parameters));
        this.mergeVertices();
    }
    exports_14("TextGeometry", TextGeometry);
    // TextBufferGeometry
    function TextBufferGeometry(text, parameters) {
        parameters = parameters || {};
        var font = parameters.font;
        if (!(font && font.isFont)) {
            console.error('THREE.TextGeometry: font parameter is not an instance of THREE.Font.');
            return new Geometry();
        }
        var shapes = font.generateShapes(text, parameters.size);
        // translate parameters to ExtrudeGeometry API
        parameters.depth = parameters.height !== undefined ? parameters.height : 50;
        // defaults
        if (parameters.bevelThickness === undefined)
            parameters.bevelThickness = 10;
        if (parameters.bevelSize === undefined)
            parameters.bevelSize = 8;
        if (parameters.bevelEnabled === undefined)
            parameters.bevelEnabled = false;
        ExtrudeBufferGeometry.call(this, shapes, parameters);
        this.type = 'TextBufferGeometry';
    }
    exports_14("TextBufferGeometry", TextBufferGeometry);
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author benaadams / https://twitter.com/ben_a_adams
     * @author Mugen87 / https://github.com/Mugen87
     */
    // SphereGeometry
    function SphereGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
        Geometry.call(this);
        this.type = 'SphereGeometry';
        this.parameters = {
            radius: radius,
            widthSegments: widthSegments,
            heightSegments: heightSegments,
            phiStart: phiStart,
            phiLength: phiLength,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
        this.fromBufferGeometry(new SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength));
        this.mergeVertices();
    }
    exports_14("SphereGeometry", SphereGeometry);
    // SphereBufferGeometry
    function SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
        BufferGeometry.call(this);
        this.type = 'SphereBufferGeometry';
        this.parameters = {
            radius: radius,
            widthSegments: widthSegments,
            heightSegments: heightSegments,
            phiStart: phiStart,
            phiLength: phiLength,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
        radius = radius || 1;
        widthSegments = Math.max(3, Math.floor(widthSegments) || 8);
        heightSegments = Math.max(2, Math.floor(heightSegments) || 6);
        phiStart = phiStart !== undefined ? phiStart : 0;
        phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;
        thetaStart = thetaStart !== undefined ? thetaStart : 0;
        thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;
        var thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
        var ix, iy;
        var index = 0;
        var grid = [];
        var vertex = new Vector3();
        var normal = new Vector3();
        // buffers
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
        // generate vertices, normals and uvs
        for (iy = 0; iy <= heightSegments; iy++) {
            var verticesRow = [];
            var v = iy / heightSegments;
            // special case for the poles
            var uOffset = 0;
            if (iy == 0 && thetaStart == 0) {
                uOffset = 0.5 / widthSegments;
            }
            else if (iy == heightSegments && thetaEnd == Math.PI) {
                uOffset = -0.5 / widthSegments;
            }
            for (ix = 0; ix <= widthSegments; ix++) {
                var u = ix / widthSegments;
                // vertex
                vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
                vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
                vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
                vertices.push(vertex.x, vertex.y, vertex.z);
                // normal
                normal.copy(vertex).normalize();
                normals.push(normal.x, normal.y, normal.z);
                // uv
                uvs.push(u + uOffset, 1 - v);
                verticesRow.push(index++);
            }
            grid.push(verticesRow);
        }
        // indices
        for (iy = 0; iy < heightSegments; iy++) {
            for (ix = 0; ix < widthSegments; ix++) {
                var a = grid[iy][ix + 1];
                var b = grid[iy][ix];
                var c = grid[iy + 1][ix];
                var d = grid[iy + 1][ix + 1];
                if (iy !== 0 || thetaStart > 0)
                    indices.push(a, b, d);
                if (iy !== heightSegments - 1 || thetaEnd < Math.PI)
                    indices.push(b, c, d);
            }
        }
        // build geometry
        this.setIndex(indices);
        this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
        this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
    }
    exports_14("SphereBufferGeometry", SphereBufferGeometry);
    /**
     * @author Kaleb Murphy
     * @author Mugen87 / https://github.com/Mugen87
     */
    // RingGeometry
    function RingGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
        Geometry.call(this);
        this.type = 'RingGeometry';
        this.parameters = {
            innerRadius: innerRadius,
            outerRadius: outerRadius,
            thetaSegments: thetaSegments,
            phiSegments: phiSegments,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
        this.fromBufferGeometry(new RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength));
        this.mergeVertices();
    }
    exports_14("RingGeometry", RingGeometry);
    // RingBufferGeometry
    function RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
        BufferGeometry.call(this);
        this.type = 'RingBufferGeometry';
        this.parameters = {
            innerRadius: innerRadius,
            outerRadius: outerRadius,
            thetaSegments: thetaSegments,
            phiSegments: phiSegments,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
        innerRadius = innerRadius || 0.5;
        outerRadius = outerRadius || 1;
        thetaStart = thetaStart !== undefined ? thetaStart : 0;
        thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
        thetaSegments = thetaSegments !== undefined ? Math.max(3, thetaSegments) : 8;
        phiSegments = phiSegments !== undefined ? Math.max(1, phiSegments) : 1;
        // buffers
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
        // some helper variables
        var segment;
        var radius = innerRadius;
        var radiusStep = ((outerRadius - innerRadius) / phiSegments);
        var vertex = new Vector3();
        var uv = new Vector2();
        var j, i;
        // generate vertices, normals and uvs
        for (j = 0; j <= phiSegments; j++) {
            for (i = 0; i <= thetaSegments; i++) {
                // values are generate from the inside of the ring to the outside
                segment = thetaStart + i / thetaSegments * thetaLength;
                // vertex
                vertex.x = radius * Math.cos(segment);
                vertex.y = radius * Math.sin(segment);
                vertices.push(vertex.x, vertex.y, vertex.z);
                // normal
                normals.push(0, 0, 1);
                // uv
                uv.x = (vertex.x / outerRadius + 1) / 2;
                uv.y = (vertex.y / outerRadius + 1) / 2;
                uvs.push(uv.x, uv.y);
            }
            // increase the radius for next row of vertices
            radius += radiusStep;
        }
        // indices
        for (j = 0; j < phiSegments; j++) {
            var thetaSegmentLevel = j * (thetaSegments + 1);
            for (i = 0; i < thetaSegments; i++) {
                segment = i + thetaSegmentLevel;
                var a = segment;
                var b = segment + thetaSegments + 1;
                var c = segment + thetaSegments + 2;
                var d = segment + 1;
                // faces
                indices.push(a, b, d);
                indices.push(b, c, d);
            }
        }
        // build geometry
        this.setIndex(indices);
        this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
        this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
    }
    exports_14("RingBufferGeometry", RingBufferGeometry);
    /**
     * @author zz85 / https://github.com/zz85
     * @author bhouston / http://clara.io
     * @author Mugen87 / https://github.com/Mugen87
     */
    // LatheGeometry
    function LatheGeometry(points, segments, phiStart, phiLength) {
        Geometry.call(this);
        this.type = 'LatheGeometry';
        this.parameters = {
            points: points,
            segments: segments,
            phiStart: phiStart,
            phiLength: phiLength
        };
        this.fromBufferGeometry(new LatheBufferGeometry(points, segments, phiStart, phiLength));
        this.mergeVertices();
    }
    exports_14("LatheGeometry", LatheGeometry);
    // LatheBufferGeometry
    function LatheBufferGeometry(points, segments, phiStart, phiLength) {
        BufferGeometry.call(this);
        this.type = 'LatheBufferGeometry';
        this.parameters = {
            points: points,
            segments: segments,
            phiStart: phiStart,
            phiLength: phiLength
        };
        segments = Math.floor(segments) || 12;
        phiStart = phiStart || 0;
        phiLength = phiLength || Math.PI * 2;
        // clamp phiLength so it's in range of [ 0, 2PI ]
        phiLength = MathUtils.clamp(phiLength, 0, Math.PI * 2);
        // buffers
        var indices = [];
        var vertices = [];
        var uvs = [];
        // helper variables
        var base;
        var inverseSegments = 1.0 / segments;
        var vertex = new Vector3();
        var uv = new Vector2();
        var i, j;
        // generate vertices and uvs
        for (i = 0; i <= segments; i++) {
            var phi = phiStart + i * inverseSegments * phiLength;
            var sin = Math.sin(phi);
            var cos = Math.cos(phi);
            for (j = 0; j <= (points.length - 1); j++) {
                // vertex
                vertex.x = points[j].x * sin;
                vertex.y = points[j].y;
                vertex.z = points[j].x * cos;
                vertices.push(vertex.x, vertex.y, vertex.z);
                // uv
                uv.x = i / segments;
                uv.y = j / (points.length - 1);
                uvs.push(uv.x, uv.y);
            }
        }
        // indices
        for (i = 0; i < segments; i++) {
            for (j = 0; j < (points.length - 1); j++) {
                base = j + i * points.length;
                var a = base;
                var b = base + points.length;
                var c = base + points.length + 1;
                var d = base + 1;
                // faces
                indices.push(a, b, d);
                indices.push(b, c, d);
            }
        }
        // build geometry
        this.setIndex(indices);
        this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
        // generate normals
        this.computeVertexNormals();
        // if the geometry is closed, we need to average the normals along the seam.
        // because the corresponding vertices are identical (but still have different UVs).
        if (phiLength === Math.PI * 2) {
            var normals = this.attributes.normal.array;
            var n1 = new Vector3();
            var n2 = new Vector3();
            var n = new Vector3();
            // this is the buffer offset for the last line of vertices
            base = segments * points.length * 3;
            for (i = 0, j = 0; i < points.length; i++, j += 3) {
                // select the normal of the vertex in the first line
                n1.x = normals[j + 0];
                n1.y = normals[j + 1];
                n1.z = normals[j + 2];
                // select the normal of the vertex in the last line
                n2.x = normals[base + j + 0];
                n2.y = normals[base + j + 1];
                n2.z = normals[base + j + 2];
                // average normals
                n.addVectors(n1, n2).normalize();
                // assign the new values to both normals
                normals[j + 0] = normals[base + j + 0] = n.x;
                normals[j + 1] = normals[base + j + 1] = n.y;
                normals[j + 2] = normals[base + j + 2] = n.z;
            }
        }
    }
    exports_14("LatheBufferGeometry", LatheBufferGeometry);
    /**
     * @author jonobr1 / http://jonobr1.com
     * @author Mugen87 / https://github.com/Mugen87
     */
    // ShapeGeometry
    function ShapeGeometry(shapes, curveSegments) {
        Geometry.call(this);
        this.type = 'ShapeGeometry';
        if (typeof curveSegments === 'object') {
            console.warn('THREE.ShapeGeometry: Options parameter has been removed.');
            curveSegments = curveSegments.curveSegments;
        }
        this.parameters = {
            shapes: shapes,
            curveSegments: curveSegments
        };
        this.fromBufferGeometry(new ShapeBufferGeometry(shapes, curveSegments));
        this.mergeVertices();
    }
    exports_14("ShapeGeometry", ShapeGeometry);
    // ShapeBufferGeometry
    function ShapeBufferGeometry(shapes, curveSegments) {
        BufferGeometry.call(this);
        this.type = 'ShapeBufferGeometry';
        this.parameters = {
            shapes: shapes,
            curveSegments: curveSegments
        };
        curveSegments = curveSegments || 12;
        // buffers
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
        // helper variables
        var groupStart = 0;
        var groupCount = 0;
        // allow single and array values for "shapes" parameter
        if (Array.isArray(shapes) === false) {
            addShape(shapes);
        }
        else {
            for (var i = 0; i < shapes.length; i++) {
                addShape(shapes[i]);
                this.addGroup(groupStart, groupCount, i); // enables MultiMaterial support
                groupStart += groupCount;
                groupCount = 0;
            }
        }
        // build geometry
        this.setIndex(indices);
        this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
        this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
        // helper functions
        function addShape(shape) {
            var i, l, shapeHole;
            var indexOffset = vertices.length / 3;
            var points = shape.extractPoints(curveSegments);
            var shapeVertices = points.shape;
            var shapeHoles = points.holes;
            // check direction of vertices
            if (ShapeUtils.isClockWise(shapeVertices) === false) {
                shapeVertices = shapeVertices.reverse();
            }
            for (i = 0, l = shapeHoles.length; i < l; i++) {
                shapeHole = shapeHoles[i];
                if (ShapeUtils.isClockWise(shapeHole) === true) {
                    shapeHoles[i] = shapeHole.reverse();
                }
            }
            var faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);
            // join vertices of inner and outer paths to a single array
            for (i = 0, l = shapeHoles.length; i < l; i++) {
                shapeHole = shapeHoles[i];
                shapeVertices = shapeVertices.concat(shapeHole);
            }
            // vertices, normals, uvs
            for (i = 0, l = shapeVertices.length; i < l; i++) {
                var vertex = shapeVertices[i];
                vertices.push(vertex.x, vertex.y, 0);
                normals.push(0, 0, 1);
                uvs.push(vertex.x, vertex.y); // world uvs
            }
            // incides
            for (i = 0, l = faces.length; i < l; i++) {
                var face = faces[i];
                var a = face[0] + indexOffset;
                var b = face[1] + indexOffset;
                var c = face[2] + indexOffset;
                indices.push(a, b, c);
                groupCount += 3;
            }
        }
    }
    exports_14("ShapeBufferGeometry", ShapeBufferGeometry);
    //
    function toJSON$1(shapes, data) {
        data.shapes = [];
        if (Array.isArray(shapes)) {
            for (var i = 0, l = shapes.length; i < l; i++) {
                var shape = shapes[i];
                data.shapes.push(shape.uuid);
            }
        }
        else {
            data.shapes.push(shapes.uuid);
        }
        return data;
    }
    /**
     * @author WestLangley / http://github.com/WestLangley
     * @author Mugen87 / https://github.com/Mugen87
     */
    function EdgesGeometry(geometry, thresholdAngle) {
        BufferGeometry.call(this);
        this.type = 'EdgesGeometry';
        this.parameters = {
            thresholdAngle: thresholdAngle
        };
        thresholdAngle = (thresholdAngle !== undefined) ? thresholdAngle : 1;
        // buffer
        var vertices = [];
        // helper variables
        var thresholdDot = Math.cos(MathUtils.DEG2RAD * thresholdAngle);
        var edge = [0, 0], edges = {}, edge1, edge2;
        var key, keys = ['a', 'b', 'c'];
        // prepare source geometry
        var geometry2;
        if (geometry.isBufferGeometry) {
            geometry2 = new Geometry();
            geometry2.fromBufferGeometry(geometry);
        }
        else {
            geometry2 = geometry.clone();
        }
        geometry2.mergeVertices();
        geometry2.computeFaceNormals();
        var sourceVertices = geometry2.vertices;
        var faces = geometry2.faces;
        // now create a data structure where each entry represents an edge with its adjoining faces
        for (var i = 0, l = faces.length; i < l; i++) {
            var face = faces[i];
            for (var j = 0; j < 3; j++) {
                edge1 = face[keys[j]];
                edge2 = face[keys[(j + 1) % 3]];
                edge[0] = Math.min(edge1, edge2);
                edge[1] = Math.max(edge1, edge2);
                key = edge[0] + ',' + edge[1];
                if (edges[key] === undefined) {
                    edges[key] = { index1: edge[0], index2: edge[1], face1: i, face2: undefined };
                }
                else {
                    edges[key].face2 = i;
                }
            }
        }
        // generate vertices
        for (key in edges) {
            var e = edges[key];
            // an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.
            if (e.face2 === undefined || faces[e.face1].normal.dot(faces[e.face2].normal) <= thresholdDot) {
                var vertex = sourceVertices[e.index1];
                vertices.push(vertex.x, vertex.y, vertex.z);
                vertex = sourceVertices[e.index2];
                vertices.push(vertex.x, vertex.y, vertex.z);
            }
        }
        // build geometry
        this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    }
    exports_14("EdgesGeometry", EdgesGeometry);
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author Mugen87 / https://github.com/Mugen87
     */
    // CylinderGeometry
    function CylinderGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
        Geometry.call(this);
        this.type = 'CylinderGeometry';
        this.parameters = {
            radiusTop: radiusTop,
            radiusBottom: radiusBottom,
            height: height,
            radialSegments: radialSegments,
            heightSegments: heightSegments,
            openEnded: openEnded,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
        this.fromBufferGeometry(new CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength));
        this.mergeVertices();
    }
    exports_14("CylinderGeometry", CylinderGeometry);
    // CylinderBufferGeometry
    function CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
        BufferGeometry.call(this);
        this.type = 'CylinderBufferGeometry';
        this.parameters = {
            radiusTop: radiusTop,
            radiusBottom: radiusBottom,
            height: height,
            radialSegments: radialSegments,
            heightSegments: heightSegments,
            openEnded: openEnded,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
        var scope = this;
        radiusTop = radiusTop !== undefined ? radiusTop : 1;
        radiusBottom = radiusBottom !== undefined ? radiusBottom : 1;
        height = height || 1;
        radialSegments = Math.floor(radialSegments) || 8;
        heightSegments = Math.floor(heightSegments) || 1;
        openEnded = openEnded !== undefined ? openEnded : false;
        thetaStart = thetaStart !== undefined ? thetaStart : 0.0;
        thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
        // buffers
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
        // helper variables
        var index = 0;
        var indexArray = [];
        var halfHeight = height / 2;
        var groupStart = 0;
        // generate geometry
        generateTorso();
        if (openEnded === false) {
            if (radiusTop > 0)
                generateCap(true);
            if (radiusBottom > 0)
                generateCap(false);
        }
        // build geometry
        this.setIndex(indices);
        this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
        this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
        function generateTorso() {
            var x, y;
            var normal = new Vector3();
            var vertex = new Vector3();
            var groupCount = 0;
            // this will be used to calculate the normal
            var slope = (radiusBottom - radiusTop) / height;
            // generate vertices, normals and uvs
            for (y = 0; y <= heightSegments; y++) {
                var indexRow = [];
                var v = y / heightSegments;
                // calculate the radius of the current row
                var radius = v * (radiusBottom - radiusTop) + radiusTop;
                for (x = 0; x <= radialSegments; x++) {
                    var u = x / radialSegments;
                    var theta = u * thetaLength + thetaStart;
                    var sinTheta = Math.sin(theta);
                    var cosTheta = Math.cos(theta);
                    // vertex
                    vertex.x = radius * sinTheta;
                    vertex.y = -v * height + halfHeight;
                    vertex.z = radius * cosTheta;
                    vertices.push(vertex.x, vertex.y, vertex.z);
                    // normal
                    normal.set(sinTheta, slope, cosTheta).normalize();
                    normals.push(normal.x, normal.y, normal.z);
                    // uv
                    uvs.push(u, 1 - v);
                    // save index of vertex in respective row
                    indexRow.push(index++);
                }
                // now save vertices of the row in our index array
                indexArray.push(indexRow);
            }
            // generate indices
            for (x = 0; x < radialSegments; x++) {
                for (y = 0; y < heightSegments; y++) {
                    // we use the index array to access the correct indices
                    var a = indexArray[y][x];
                    var b = indexArray[y + 1][x];
                    var c = indexArray[y + 1][x + 1];
                    var d = indexArray[y][x + 1];
                    // faces
                    indices.push(a, b, d);
                    indices.push(b, c, d);
                    // update group counter
                    groupCount += 6;
                }
            }
            // add a group to the geometry. this will ensure multi material support
            scope.addGroup(groupStart, groupCount, 0);
            // calculate new start value for groups
            groupStart += groupCount;
        }
        function generateCap(top) {
            var x, centerIndexStart, centerIndexEnd;
            var uv = new Vector2();
            var vertex = new Vector3();
            var groupCount = 0;
            var radius = (top === true) ? radiusTop : radiusBottom;
            var sign = (top === true) ? 1 : -1;
            // save the index of the first center vertex
            centerIndexStart = index;
            // first we generate the center vertex data of the cap.
            // because the geometry needs one set of uvs per face,
            // we must generate a center vertex per face/segment
            for (x = 1; x <= radialSegments; x++) {
                // vertex
                vertices.push(0, halfHeight * sign, 0);
                // normal
                normals.push(0, sign, 0);
                // uv
                uvs.push(0.5, 0.5);
                // increase index
                index++;
            }
            // save the index of the last center vertex
            centerIndexEnd = index;
            // now we generate the surrounding vertices, normals and uvs
            for (x = 0; x <= radialSegments; x++) {
                var u = x / radialSegments;
                var theta = u * thetaLength + thetaStart;
                var cosTheta = Math.cos(theta);
                var sinTheta = Math.sin(theta);
                // vertex
                vertex.x = radius * sinTheta;
                vertex.y = halfHeight * sign;
                vertex.z = radius * cosTheta;
                vertices.push(vertex.x, vertex.y, vertex.z);
                // normal
                normals.push(0, sign, 0);
                // uv
                uv.x = (cosTheta * 0.5) + 0.5;
                uv.y = (sinTheta * 0.5 * sign) + 0.5;
                uvs.push(uv.x, uv.y);
                // increase index
                index++;
            }
            // generate indices
            for (x = 0; x < radialSegments; x++) {
                var c = centerIndexStart + x;
                var i = centerIndexEnd + x;
                if (top === true) {
                    // face top
                    indices.push(i, i + 1, c);
                }
                else {
                    // face bottom
                    indices.push(i + 1, i, c);
                }
                groupCount += 3;
            }
            // add a group to the geometry. this will ensure multi material support
            scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);
            // calculate new start value for groups
            groupStart += groupCount;
        }
    }
    exports_14("CylinderBufferGeometry", CylinderBufferGeometry);
    /**
     * @author abelnation / http://github.com/abelnation
     */
    // ConeGeometry
    function ConeGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
        CylinderGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
        this.type = 'ConeGeometry';
        this.parameters = {
            radius: radius,
            height: height,
            radialSegments: radialSegments,
            heightSegments: heightSegments,
            openEnded: openEnded,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
    }
    exports_14("ConeGeometry", ConeGeometry);
    // ConeBufferGeometry
    function ConeBufferGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
        CylinderBufferGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
        this.type = 'ConeBufferGeometry';
        this.parameters = {
            radius: radius,
            height: height,
            radialSegments: radialSegments,
            heightSegments: heightSegments,
            openEnded: openEnded,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
    }
    exports_14("ConeBufferGeometry", ConeBufferGeometry);
    /**
     * @author benaadams / https://twitter.com/ben_a_adams
     * @author Mugen87 / https://github.com/Mugen87
     * @author hughes
     */
    // CircleGeometry
    function CircleGeometry(radius, segments, thetaStart, thetaLength) {
        Geometry.call(this);
        this.type = 'CircleGeometry';
        this.parameters = {
            radius: radius,
            segments: segments,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
        this.fromBufferGeometry(new CircleBufferGeometry(radius, segments, thetaStart, thetaLength));
        this.mergeVertices();
    }
    exports_14("CircleGeometry", CircleGeometry);
    // CircleBufferGeometry
    function CircleBufferGeometry(radius, segments, thetaStart, thetaLength) {
        BufferGeometry.call(this);
        this.type = 'CircleBufferGeometry';
        this.parameters = {
            radius: radius,
            segments: segments,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
        radius = radius || 1;
        segments = segments !== undefined ? Math.max(3, segments) : 8;
        thetaStart = thetaStart !== undefined ? thetaStart : 0;
        thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
        // buffers
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
        // helper variables
        var i, s;
        var vertex = new Vector3();
        var uv = new Vector2();
        // center point
        vertices.push(0, 0, 0);
        normals.push(0, 0, 1);
        uvs.push(0.5, 0.5);
        for (s = 0, i = 3; s <= segments; s++, i += 3) {
            var segment = thetaStart + s / segments * thetaLength;
            // vertex
            vertex.x = radius * Math.cos(segment);
            vertex.y = radius * Math.sin(segment);
            vertices.push(vertex.x, vertex.y, vertex.z);
            // normal
            normals.push(0, 0, 1);
            // uvs
            uv.x = (vertices[i] / radius + 1) / 2;
            uv.y = (vertices[i + 1] / radius + 1) / 2;
            uvs.push(uv.x, uv.y);
        }
        // indices
        for (i = 1; i <= segments; i++) {
            indices.push(i, i + 1, 0);
        }
        // build geometry
        this.setIndex(indices);
        this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
        this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
    }
    exports_14("CircleBufferGeometry", CircleBufferGeometry);
    /**
     * @author mrdoob / http://mrdoob.com/
     *
     * parameters = {
     *  color: <THREE.Color>
     * }
     */
    function ShadowMaterial(parameters) {
        Material.call(this);
        this.type = 'ShadowMaterial';
        this.color = new Color(0x000000);
        this.transparent = true;
        this.setValues(parameters);
    }
    exports_14("ShadowMaterial", ShadowMaterial);
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    function RawShaderMaterial(parameters) {
        ShaderMaterial.call(this, parameters);
        this.type = 'RawShaderMaterial';
    }
    exports_14("RawShaderMaterial", RawShaderMaterial);
    /**
     * @author WestLangley / http://github.com/WestLangley
     *
     * parameters = {
     *  color: <hex>,
     *  roughness: <float>,
     *  metalness: <float>,
     *  opacity: <float>,
     *
     *  map: new THREE.Texture( <Image> ),
     *
     *  lightMap: new THREE.Texture( <Image> ),
     *  lightMapIntensity: <float>
     *
     *  aoMap: new THREE.Texture( <Image> ),
     *  aoMapIntensity: <float>
     *
     *  emissive: <hex>,
     *  emissiveIntensity: <float>
     *  emissiveMap: new THREE.Texture( <Image> ),
     *
     *  bumpMap: new THREE.Texture( <Image> ),
     *  bumpScale: <float>,
     *
     *  normalMap: new THREE.Texture( <Image> ),
     *  normalMapType: THREE.TangentSpaceNormalMap,
     *  normalScale: <Vector2>,
     *
     *  displacementMap: new THREE.Texture( <Image> ),
     *  displacementScale: <float>,
     *  displacementBias: <float>,
     *
     *  roughnessMap: new THREE.Texture( <Image> ),
     *
     *  metalnessMap: new THREE.Texture( <Image> ),
     *
     *  alphaMap: new THREE.Texture( <Image> ),
     *
     *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
     *  envMapIntensity: <float>
     *
     *  refractionRatio: <float>,
     *
     *  wireframe: <boolean>,
     *  wireframeLinewidth: <float>,
     *
     *  skinning: <bool>,
     *  morphTargets: <bool>,
     *  morphNormals: <bool>
     * }
     */
    function MeshStandardMaterial(parameters) {
        Material.call(this);
        this.defines = { 'STANDARD': '' };
        this.type = 'MeshStandardMaterial';
        this.color = new Color(0xffffff); // diffuse
        this.roughness = 1.0;
        this.metalness = 0.0;
        this.map = null;
        this.lightMap = null;
        this.lightMapIntensity = 1.0;
        this.aoMap = null;
        this.aoMapIntensity = 1.0;
        this.emissive = new Color(0x000000);
        this.emissiveIntensity = 1.0;
        this.emissiveMap = null;
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalMapType = TangentSpaceNormalMap;
        this.normalScale = new Vector2(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.roughnessMap = null;
        this.metalnessMap = null;
        this.alphaMap = null;
        this.envMap = null;
        this.envMapIntensity = 1.0;
        this.refractionRatio = 0.98;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = 'round';
        this.wireframeLinejoin = 'round';
        this.skinning = false;
        this.morphTargets = false;
        this.morphNormals = false;
        this.setValues(parameters);
    }
    exports_14("MeshStandardMaterial", MeshStandardMaterial);
    /**
     * @author WestLangley / http://github.com/WestLangley
     *
     * parameters = {
     *  reflectivity: <float>
     *  clearcoat: <float>
     *  clearcoatRoughness: <float>
     *
     *  sheen: <Color>
     *
     *  clearcoatNormalScale: <Vector2>,
     *  clearcoatNormalMap: new THREE.Texture( <Image> ),
     * }
     */
    function MeshPhysicalMaterial(parameters) {
        MeshStandardMaterial.call(this);
        this.defines = {
            'STANDARD': '',
            'PHYSICAL': ''
        };
        this.type = 'MeshPhysicalMaterial';
        this.reflectivity = 0.5; // maps to F0 = 0.04
        this.clearcoat = 0.0;
        this.clearcoatRoughness = 0.0;
        this.sheen = null; // null will disable sheen bsdf
        this.clearcoatNormalScale = new Vector2(1, 1);
        this.clearcoatNormalMap = null;
        this.transparency = 0.0;
        this.setValues(parameters);
    }
    exports_14("MeshPhysicalMaterial", MeshPhysicalMaterial);
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  color: <hex>,
     *  specular: <hex>,
     *  shininess: <float>,
     *  opacity: <float>,
     *
     *  map: new THREE.Texture( <Image> ),
     *
     *  lightMap: new THREE.Texture( <Image> ),
     *  lightMapIntensity: <float>
     *
     *  aoMap: new THREE.Texture( <Image> ),
     *  aoMapIntensity: <float>
     *
     *  emissive: <hex>,
     *  emissiveIntensity: <float>
     *  emissiveMap: new THREE.Texture( <Image> ),
     *
     *  bumpMap: new THREE.Texture( <Image> ),
     *  bumpScale: <float>,
     *
     *  normalMap: new THREE.Texture( <Image> ),
     *  normalMapType: THREE.TangentSpaceNormalMap,
     *  normalScale: <Vector2>,
     *
     *  displacementMap: new THREE.Texture( <Image> ),
     *  displacementScale: <float>,
     *  displacementBias: <float>,
     *
     *  specularMap: new THREE.Texture( <Image> ),
     *
     *  alphaMap: new THREE.Texture( <Image> ),
     *
     *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
     *  combine: THREE.MultiplyOperation,
     *  reflectivity: <float>,
     *  refractionRatio: <float>,
     *
     *  wireframe: <boolean>,
     *  wireframeLinewidth: <float>,
     *
     *  skinning: <bool>,
     *  morphTargets: <bool>,
     *  morphNormals: <bool>
     * }
     */
    function MeshPhongMaterial(parameters) {
        Material.call(this);
        this.type = 'MeshPhongMaterial';
        this.color = new Color(0xffffff); // diffuse
        this.specular = new Color(0x111111);
        this.shininess = 30;
        this.map = null;
        this.lightMap = null;
        this.lightMapIntensity = 1.0;
        this.aoMap = null;
        this.aoMapIntensity = 1.0;
        this.emissive = new Color(0x000000);
        this.emissiveIntensity = 1.0;
        this.emissiveMap = null;
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalMapType = TangentSpaceNormalMap;
        this.normalScale = new Vector2(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.specularMap = null;
        this.alphaMap = null;
        this.envMap = null;
        this.combine = MultiplyOperation;
        this.reflectivity = 1;
        this.refractionRatio = 0.98;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = 'round';
        this.wireframeLinejoin = 'round';
        this.skinning = false;
        this.morphTargets = false;
        this.morphNormals = false;
        this.setValues(parameters);
    }
    exports_14("MeshPhongMaterial", MeshPhongMaterial);
    /**
     * @author takahirox / http://github.com/takahirox
     *
     * parameters = {
     *  color: <hex>,
     *  specular: <hex>,
     *  shininess: <float>,
     *
     *  map: new THREE.Texture( <Image> ),
     *  gradientMap: new THREE.Texture( <Image> ),
     *
     *  lightMap: new THREE.Texture( <Image> ),
     *  lightMapIntensity: <float>
     *
     *  aoMap: new THREE.Texture( <Image> ),
     *  aoMapIntensity: <float>
     *
     *  emissive: <hex>,
     *  emissiveIntensity: <float>
     *  emissiveMap: new THREE.Texture( <Image> ),
     *
     *  bumpMap: new THREE.Texture( <Image> ),
     *  bumpScale: <float>,
     *
     *  normalMap: new THREE.Texture( <Image> ),
     *  normalMapType: THREE.TangentSpaceNormalMap,
     *  normalScale: <Vector2>,
     *
     *  displacementMap: new THREE.Texture( <Image> ),
     *  displacementScale: <float>,
     *  displacementBias: <float>,
     *
     *  specularMap: new THREE.Texture( <Image> ),
     *
     *  alphaMap: new THREE.Texture( <Image> ),
     *
     *  wireframe: <boolean>,
     *  wireframeLinewidth: <float>,
     *
     *  skinning: <bool>,
     *  morphTargets: <bool>,
     *  morphNormals: <bool>
     * }
     */
    function MeshToonMaterial(parameters) {
        Material.call(this);
        this.defines = { 'TOON': '' };
        this.type = 'MeshToonMaterial';
        this.color = new Color(0xffffff);
        this.specular = new Color(0x111111);
        this.shininess = 30;
        this.map = null;
        this.gradientMap = null;
        this.lightMap = null;
        this.lightMapIntensity = 1.0;
        this.aoMap = null;
        this.aoMapIntensity = 1.0;
        this.emissive = new Color(0x000000);
        this.emissiveIntensity = 1.0;
        this.emissiveMap = null;
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalMapType = TangentSpaceNormalMap;
        this.normalScale = new Vector2(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.specularMap = null;
        this.alphaMap = null;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = 'round';
        this.wireframeLinejoin = 'round';
        this.skinning = false;
        this.morphTargets = false;
        this.morphNormals = false;
        this.setValues(parameters);
    }
    exports_14("MeshToonMaterial", MeshToonMaterial);
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author WestLangley / http://github.com/WestLangley
     *
     * parameters = {
     *  opacity: <float>,
     *
     *  bumpMap: new THREE.Texture( <Image> ),
     *  bumpScale: <float>,
     *
     *  normalMap: new THREE.Texture( <Image> ),
     *  normalMapType: THREE.TangentSpaceNormalMap,
     *  normalScale: <Vector2>,
     *
     *  displacementMap: new THREE.Texture( <Image> ),
     *  displacementScale: <float>,
     *  displacementBias: <float>,
     *
     *  wireframe: <boolean>,
     *  wireframeLinewidth: <float>
     *
     *  skinning: <bool>,
     *  morphTargets: <bool>,
     *  morphNormals: <bool>
     * }
     */
    function MeshNormalMaterial(parameters) {
        Material.call(this);
        this.type = 'MeshNormalMaterial';
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalMapType = TangentSpaceNormalMap;
        this.normalScale = new Vector2(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.fog = false;
        this.skinning = false;
        this.morphTargets = false;
        this.morphNormals = false;
        this.setValues(parameters);
    }
    exports_14("MeshNormalMaterial", MeshNormalMaterial);
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  color: <hex>,
     *  opacity: <float>,
     *
     *  map: new THREE.Texture( <Image> ),
     *
     *  lightMap: new THREE.Texture( <Image> ),
     *  lightMapIntensity: <float>
     *
     *  aoMap: new THREE.Texture( <Image> ),
     *  aoMapIntensity: <float>
     *
     *  emissive: <hex>,
     *  emissiveIntensity: <float>
     *  emissiveMap: new THREE.Texture( <Image> ),
     *
     *  specularMap: new THREE.Texture( <Image> ),
     *
     *  alphaMap: new THREE.Texture( <Image> ),
     *
     *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
     *  combine: THREE.Multiply,
     *  reflectivity: <float>,
     *  refractionRatio: <float>,
     *
     *  wireframe: <boolean>,
     *  wireframeLinewidth: <float>,
     *
     *  skinning: <bool>,
     *  morphTargets: <bool>,
     *  morphNormals: <bool>
     * }
     */
    function MeshLambertMaterial(parameters) {
        Material.call(this);
        this.type = 'MeshLambertMaterial';
        this.color = new Color(0xffffff); // diffuse
        this.map = null;
        this.lightMap = null;
        this.lightMapIntensity = 1.0;
        this.aoMap = null;
        this.aoMapIntensity = 1.0;
        this.emissive = new Color(0x000000);
        this.emissiveIntensity = 1.0;
        this.emissiveMap = null;
        this.specularMap = null;
        this.alphaMap = null;
        this.envMap = null;
        this.combine = MultiplyOperation;
        this.reflectivity = 1;
        this.refractionRatio = 0.98;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = 'round';
        this.wireframeLinejoin = 'round';
        this.skinning = false;
        this.morphTargets = false;
        this.morphNormals = false;
        this.setValues(parameters);
    }
    exports_14("MeshLambertMaterial", MeshLambertMaterial);
    /**
     * @author WestLangley / http://github.com/WestLangley
     *
     * parameters = {
     *  color: <hex>,
     *  opacity: <float>,
     *
     *  matcap: new THREE.Texture( <Image> ),
     *
     *  map: new THREE.Texture( <Image> ),
     *
     *  bumpMap: new THREE.Texture( <Image> ),
     *  bumpScale: <float>,
     *
     *  normalMap: new THREE.Texture( <Image> ),
     *  normalMapType: THREE.TangentSpaceNormalMap,
     *  normalScale: <Vector2>,
     *
     *  displacementMap: new THREE.Texture( <Image> ),
     *  displacementScale: <float>,
     *  displacementBias: <float>,
     *
     *  alphaMap: new THREE.Texture( <Image> ),
     *
     *  skinning: <bool>,
     *  morphTargets: <bool>,
     *  morphNormals: <bool>
     * }
     */
    function MeshMatcapMaterial(parameters) {
        Material.call(this);
        this.defines = { 'MATCAP': '' };
        this.type = 'MeshMatcapMaterial';
        this.color = new Color(0xffffff); // diffuse
        this.matcap = null;
        this.map = null;
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalMapType = TangentSpaceNormalMap;
        this.normalScale = new Vector2(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.alphaMap = null;
        this.skinning = false;
        this.morphTargets = false;
        this.morphNormals = false;
        this.setValues(parameters);
    }
    exports_14("MeshMatcapMaterial", MeshMatcapMaterial);
    /**
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  color: <hex>,
     *  opacity: <float>,
     *
     *  linewidth: <float>,
     *
     *  scale: <float>,
     *  dashSize: <float>,
     *  gapSize: <float>
     * }
     */
    function LineDashedMaterial(parameters) {
        LineBasicMaterial.call(this);
        this.type = 'LineDashedMaterial';
        this.scale = 1;
        this.dashSize = 3;
        this.gapSize = 1;
        this.setValues(parameters);
    }
    exports_14("LineDashedMaterial", LineDashedMaterial);
    /**
     * Abstract base class of interpolants over parametric samples.
     *
     * The parameter domain is one dimensional, typically the time or a path
     * along a curve defined by the data.
     *
     * The sample values can have any dimensionality and derived classes may
     * apply special interpretations to the data.
     *
     * This class provides the interval seek in a Template Method, deferring
     * the actual interpolation to derived classes.
     *
     * Time complexity is O(1) for linear access crossing at most two points
     * and O(log N) for random access, where N is the number of positions.
     *
     * References:
     *
     * 		http://www.oodesign.com/template-method-pattern.html
     *
     * @author tschw
     */
    function Interpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        this.parameterPositions = parameterPositions;
        this._cachedIndex = 0;
        this.resultBuffer = resultBuffer !== undefined ?
            resultBuffer : new sampleValues.constructor(sampleSize);
        this.sampleValues = sampleValues;
        this.valueSize = sampleSize;
    }
    exports_14("Interpolant", Interpolant);
    /**
     * Fast and simple cubic spline interpolant.
     *
     * It was derived from a Hermitian construction setting the first derivative
     * at each sample position to the linear slope between neighboring positions
     * over their parameter interval.
     *
     * @author tschw
     */
    function CubicInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
        this._weightPrev = -0;
        this._offsetPrev = -0;
        this._weightNext = -0;
        this._offsetNext = -0;
    }
    exports_14("CubicInterpolant", CubicInterpolant);
    /**
     * @author tschw
     */
    function LinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    exports_14("LinearInterpolant", LinearInterpolant);
    /**
     *
     * Interpolant that evaluates to the sample value at the position preceeding
     * the parameter.
     *
     * @author tschw
     */
    function DiscreteInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    exports_14("DiscreteInterpolant", DiscreteInterpolant);
    /**
     *
     * A timed sequence of keyframes for a specific property.
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */
    function KeyframeTrack(name, times, values, interpolation) {
        if (name === undefined)
            throw new Error('THREE.KeyframeTrack: track name is undefined');
        if (times === undefined || times.length === 0)
            throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + name);
        this.name = name;
        this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
        this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
        this.setInterpolation(interpolation || this.DefaultInterpolation);
    }
    exports_14("KeyframeTrack", KeyframeTrack);
    /**
     *
     * A Track of Boolean keyframe values.
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */
    function BooleanKeyframeTrack(name, times, values) {
        KeyframeTrack.call(this, name, times, values);
    }
    exports_14("BooleanKeyframeTrack", BooleanKeyframeTrack);
    /**
     *
     * A Track of keyframe values that represent color.
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */
    function ColorKeyframeTrack(name, times, values, interpolation) {
        KeyframeTrack.call(this, name, times, values, interpolation);
    }
    exports_14("ColorKeyframeTrack", ColorKeyframeTrack);
    /**
     *
     * A Track of numeric keyframe values.
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */
    function NumberKeyframeTrack(name, times, values, interpolation) {
        KeyframeTrack.call(this, name, times, values, interpolation);
    }
    exports_14("NumberKeyframeTrack", NumberKeyframeTrack);
    /**
     * Spherical linear unit quaternion interpolant.
     *
     * @author tschw
     */
    function QuaternionLinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    exports_14("QuaternionLinearInterpolant", QuaternionLinearInterpolant);
    /**
     *
     * A Track of quaternion keyframe values.
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */
    function QuaternionKeyframeTrack(name, times, values, interpolation) {
        KeyframeTrack.call(this, name, times, values, interpolation);
    }
    exports_14("QuaternionKeyframeTrack", QuaternionKeyframeTrack);
    /**
     *
     * A Track that interpolates Strings
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */
    function StringKeyframeTrack(name, times, values, interpolation) {
        KeyframeTrack.call(this, name, times, values, interpolation);
    }
    exports_14("StringKeyframeTrack", StringKeyframeTrack);
    /**
     *
     * A Track of vectored keyframe values.
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */
    function VectorKeyframeTrack(name, times, values, interpolation) {
        KeyframeTrack.call(this, name, times, values, interpolation);
    }
    exports_14("VectorKeyframeTrack", VectorKeyframeTrack);
    /**
     *
     * Reusable set of Tracks that represent an animation.
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     */
    function AnimationClip(name, duration, tracks) {
        this.name = name;
        this.tracks = tracks;
        this.duration = (duration !== undefined) ? duration : -1;
        this.uuid = MathUtils.generateUUID();
        // this means it should figure out its duration by scanning the tracks
        if (this.duration < 0) {
            this.resetDuration();
        }
    }
    exports_14("AnimationClip", AnimationClip);
    function getTrackTypeForValueTypeName(typeName) {
        switch (typeName.toLowerCase()) {
            case 'scalar':
            case 'double':
            case 'float':
            case 'number':
            case 'integer':
                return NumberKeyframeTrack;
            case 'vector':
            case 'vector2':
            case 'vector3':
            case 'vector4':
                return VectorKeyframeTrack;
            case 'color':
                return ColorKeyframeTrack;
            case 'quaternion':
                return QuaternionKeyframeTrack;
            case 'bool':
            case 'boolean':
                return BooleanKeyframeTrack;
            case 'string':
                return StringKeyframeTrack;
        }
        throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + typeName);
    }
    function parseKeyframeTrack(json) {
        if (json.type === undefined) {
            throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');
        }
        var trackType = getTrackTypeForValueTypeName(json.type);
        if (json.times === undefined) {
            var times = [], values = [];
            AnimationUtils.flattenJSON(json.keys, times, values, 'value');
            json.times = times;
            json.values = values;
        }
        // derived classes can define a static parse method
        if (trackType.parse !== undefined) {
            return trackType.parse(json);
        }
        else {
            // by default, we assume a constructor compatible with the base
            return new trackType(json.name, json.times, json.values, json.interpolation);
        }
    }
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    function LoadingManager(onLoad, onProgress, onError) {
        var scope = this;
        var isLoading = false;
        var itemsLoaded = 0;
        var itemsTotal = 0;
        var urlModifier = undefined;
        var handlers = [];
        // Refer to #5689 for the reason why we don't set .onStart
        // in the constructor
        this.onStart = undefined;
        this.onLoad = onLoad;
        this.onProgress = onProgress;
        this.onError = onError;
        this.itemStart = function (url) {
            itemsTotal++;
            if (isLoading === false) {
                if (scope.onStart !== undefined) {
                    scope.onStart(url, itemsLoaded, itemsTotal);
                }
            }
            isLoading = true;
        };
        this.itemEnd = function (url) {
            itemsLoaded++;
            if (scope.onProgress !== undefined) {
                scope.onProgress(url, itemsLoaded, itemsTotal);
            }
            if (itemsLoaded === itemsTotal) {
                isLoading = false;
                if (scope.onLoad !== undefined) {
                    scope.onLoad();
                }
            }
        };
        this.itemError = function (url) {
            if (scope.onError !== undefined) {
                scope.onError(url);
            }
        };
        this.resolveURL = function (url) {
            if (urlModifier) {
                return urlModifier(url);
            }
            return url;
        };
        this.setURLModifier = function (transform) {
            urlModifier = transform;
            return this;
        };
        this.addHandler = function (regex, loader) {
            handlers.push(regex, loader);
            return this;
        };
        this.removeHandler = function (regex) {
            var index = handlers.indexOf(regex);
            if (index !== -1) {
                handlers.splice(index, 2);
            }
            return this;
        };
        this.getHandler = function (file) {
            for (var i = 0, l = handlers.length; i < l; i += 2) {
                var regex = handlers[i];
                var loader = handlers[i + 1];
                if (regex.global)
                    regex.lastIndex = 0; // see #17920
                if (regex.test(file)) {
                    return loader;
                }
            }
            return null;
        };
    }
    exports_14("LoadingManager", LoadingManager);
    /**
     * @author alteredq / http://alteredqualia.com/
     */
    function Loader(manager) {
        this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;
        this.crossOrigin = 'anonymous';
        this.path = '';
        this.resourcePath = '';
    }
    exports_14("Loader", Loader);
    function FileLoader(manager) {
        Loader.call(this, manager);
    }
    exports_14("FileLoader", FileLoader);
    /**
     * @author bhouston / http://clara.io/
     */
    function AnimationLoader(manager) {
        Loader.call(this, manager);
    }
    exports_14("AnimationLoader", AnimationLoader);
    /**
     * @author mrdoob / http://mrdoob.com/
     *
     * Abstract Base class to block based textures loader (dds, pvr, ...)
     *
     * Sub classes have to implement the parse() method which will be used in load().
     */
    function CompressedTextureLoader(manager) {
        Loader.call(this, manager);
    }
    exports_14("CompressedTextureLoader", CompressedTextureLoader);
    /**
     * @author Nikos M. / https://github.com/foo123/
     *
     * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
     *
     * Sub classes have to implement the parse() method which will be used in load().
     */
    function DataTextureLoader(manager) {
        Loader.call(this, manager);
    }
    exports_14("DataTextureLoader", DataTextureLoader);
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    function ImageLoader(manager) {
        Loader.call(this, manager);
    }
    exports_14("ImageLoader", ImageLoader);
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    function CubeTextureLoader(manager) {
        Loader.call(this, manager);
    }
    exports_14("CubeTextureLoader", CubeTextureLoader);
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    function TextureLoader(manager) {
        Loader.call(this, manager);
    }
    exports_14("TextureLoader", TextureLoader);
    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     * Extensible curve object
     *
     * Some common of curve methods:
     * .getPoint( t, optionalTarget ), .getTangent( t )
     * .getPointAt( u, optionalTarget ), .getTangentAt( u )
     * .getPoints(), .getSpacedPoints()
     * .getLength()
     * .updateArcLengths()
     *
     * This following curves inherit from THREE.Curve:
     *
     * -- 2D curves --
     * THREE.ArcCurve
     * THREE.CubicBezierCurve
     * THREE.EllipseCurve
     * THREE.LineCurve
     * THREE.QuadraticBezierCurve
     * THREE.SplineCurve
     *
     * -- 3D curves --
     * THREE.CatmullRomCurve3
     * THREE.CubicBezierCurve3
     * THREE.LineCurve3
     * THREE.QuadraticBezierCurve3
     *
     * A series of curves can be represented as a THREE.CurvePath.
     *
     **/
    /**************************************************************
     *	Abstract Curve base class
     **************************************************************/
    function Curve() {
        this.type = 'Curve';
        this.arcLengthDivisions = 200;
    }
    exports_14("Curve", Curve);
    function EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
        Curve.call(this);
        this.type = 'EllipseCurve';
        this.aX = aX || 0;
        this.aY = aY || 0;
        this.xRadius = xRadius || 1;
        this.yRadius = yRadius || 1;
        this.aStartAngle = aStartAngle || 0;
        this.aEndAngle = aEndAngle || 2 * Math.PI;
        this.aClockwise = aClockwise || false;
        this.aRotation = aRotation || 0;
    }
    exports_14("EllipseCurve", EllipseCurve);
    function ArcCurve(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
        EllipseCurve.call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
        this.type = 'ArcCurve';
    }
    exports_14("ArcCurve", ArcCurve);
    /**
     * @author zz85 https://github.com/zz85
     *
     * Centripetal CatmullRom Curve - which is useful for avoiding
     * cusps and self-intersections in non-uniform catmull rom curves.
     * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
     *
     * curve.type accepts centripetal(default), chordal and catmullrom
     * curve.tension is used for catmullrom which defaults to 0.5
     */
    /*
    Based on an optimized c++ solution in
     - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
     - http://ideone.com/NoEbVM
    
    This CubicPoly class could be used for reusing some variables and calculations,
    but for three.js curve use, it could be possible inlined and flatten into a single function call
    which can be placed in CurveUtils.
    */
    function CubicPoly() {
        var c0 = 0, c1 = 0, c2 = 0, c3 = 0;
        /*
         * Compute coefficients for a cubic polynomial
         *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
         * such that
         *   p(0) = x0, p(1) = x1
         *  and
         *   p'(0) = t0, p'(1) = t1.
         */
        function init(x0, x1, t0, t1) {
            c0 = x0;
            c1 = t0;
            c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
            c3 = 2 * x0 - 2 * x1 + t0 + t1;
        }
        return {
            initCatmullRom: function (x0, x1, x2, x3, tension) {
                init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
            },
            initNonuniformCatmullRom: function (x0, x1, x2, x3, dt0, dt1, dt2) {
                // compute tangents when parameterized in [t1,t2]
                var t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
                var t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
                // rescale tangents for parametrization in [0,1]
                t1 *= dt1;
                t2 *= dt1;
                init(x1, x2, t1, t2);
            },
            calc: function (t) {
                var t2 = t * t;
                var t3 = t2 * t;
                return c0 + c1 * t + c2 * t2 + c3 * t3;
            }
        };
    }
    function CatmullRomCurve3(points, closed, curveType, tension) {
        Curve.call(this);
        this.type = 'CatmullRomCurve3';
        this.points = points || [];
        this.closed = closed || false;
        this.curveType = curveType || 'centripetal';
        this.tension = tension || 0.5;
    }
    exports_14("CatmullRomCurve3", CatmullRomCurve3);
    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     *
     * Bezier Curves formulas obtained from
     * http://en.wikipedia.org/wiki/Bzier_curve
     */
    function CatmullRom(t, p0, p1, p2, p3) {
        var v0 = (p2 - p0) * 0.5;
        var v1 = (p3 - p1) * 0.5;
        var t2 = t * t;
        var t3 = t * t2;
        return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
    }
    //
    function QuadraticBezierP0(t, p) {
        var k = 1 - t;
        return k * k * p;
    }
    function QuadraticBezierP1(t, p) {
        return 2 * (1 - t) * t * p;
    }
    function QuadraticBezierP2(t, p) {
        return t * t * p;
    }
    function QuadraticBezier(t, p0, p1, p2) {
        return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) +
            QuadraticBezierP2(t, p2);
    }
    //
    function CubicBezierP0(t, p) {
        var k = 1 - t;
        return k * k * k * p;
    }
    function CubicBezierP1(t, p) {
        var k = 1 - t;
        return 3 * k * k * t * p;
    }
    function CubicBezierP2(t, p) {
        return 3 * (1 - t) * t * t * p;
    }
    function CubicBezierP3(t, p) {
        return t * t * t * p;
    }
    function CubicBezier(t, p0, p1, p2, p3) {
        return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) +
            CubicBezierP3(t, p3);
    }
    function CubicBezierCurve(v0, v1, v2, v3) {
        Curve.call(this);
        this.type = 'CubicBezierCurve';
        this.v0 = v0 || new Vector2();
        this.v1 = v1 || new Vector2();
        this.v2 = v2 || new Vector2();
        this.v3 = v3 || new Vector2();
    }
    exports_14("CubicBezierCurve", CubicBezierCurve);
    function CubicBezierCurve3(v0, v1, v2, v3) {
        Curve.call(this);
        this.type = 'CubicBezierCurve3';
        this.v0 = v0 || new Vector3();
        this.v1 = v1 || new Vector3();
        this.v2 = v2 || new Vector3();
        this.v3 = v3 || new Vector3();
    }
    exports_14("CubicBezierCurve3", CubicBezierCurve3);
    function LineCurve(v1, v2) {
        Curve.call(this);
        this.type = 'LineCurve';
        this.v1 = v1 || new Vector2();
        this.v2 = v2 || new Vector2();
    }
    exports_14("LineCurve", LineCurve);
    function LineCurve3(v1, v2) {
        Curve.call(this);
        this.type = 'LineCurve3';
        this.v1 = v1 || new Vector3();
        this.v2 = v2 || new Vector3();
    }
    exports_14("LineCurve3", LineCurve3);
    function QuadraticBezierCurve(v0, v1, v2) {
        Curve.call(this);
        this.type = 'QuadraticBezierCurve';
        this.v0 = v0 || new Vector2();
        this.v1 = v1 || new Vector2();
        this.v2 = v2 || new Vector2();
    }
    exports_14("QuadraticBezierCurve", QuadraticBezierCurve);
    function QuadraticBezierCurve3(v0, v1, v2) {
        Curve.call(this);
        this.type = 'QuadraticBezierCurve3';
        this.v0 = v0 || new Vector3();
        this.v1 = v1 || new Vector3();
        this.v2 = v2 || new Vector3();
    }
    exports_14("QuadraticBezierCurve3", QuadraticBezierCurve3);
    function SplineCurve(points /* array of Vector2 */) {
        Curve.call(this);
        this.type = 'SplineCurve';
        this.points = points || [];
    }
    exports_14("SplineCurve", SplineCurve);
    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     *
     **/
    /**************************************************************
     *	Curved Path - a curve path is simply a array of connected
     *  curves, but retains the api of a curve
     **************************************************************/
    function CurvePath() {
        Curve.call(this);
        this.type = 'CurvePath';
        this.curves = [];
        this.autoClose = false; // Automatically closes the path
    }
    exports_14("CurvePath", CurvePath);
    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     * Creates free form 2d path using series of points, lines or curves.
     **/
    function Path(points) {
        CurvePath.call(this);
        this.type = 'Path';
        this.currentPoint = new Vector2();
        if (points) {
            this.setFromPoints(points);
        }
    }
    exports_14("Path", Path);
    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     * Defines a 2d shape plane using paths.
     **/
    // STEP 1 Create a path.
    // STEP 2 Turn path into shape.
    // STEP 3 ExtrudeGeometry takes in Shape/Shapes
    // STEP 3a - Extract points from each shape, turn to vertices
    // STEP 3b - Triangulate each shape, add faces.
    function Shape(points) {
        Path.call(this, points);
        this.uuid = MathUtils.generateUUID();
        this.type = 'Shape';
        this.holes = [];
    }
    exports_14("Shape", Shape);
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */
    function Light(color, intensity) {
        Object3D.call(this);
        this.type = 'Light';
        this.color = new Color(color);
        this.intensity = intensity !== undefined ? intensity : 1;
        this.receiveShadow = undefined;
    }
    exports_14("Light", Light);
    /**
     * @author alteredq / http://alteredqualia.com/
     */
    function HemisphereLight(skyColor, groundColor, intensity) {
        Light.call(this, skyColor, intensity);
        this.type = 'HemisphereLight';
        this.castShadow = undefined;
        this.position.copy(Object3D.DefaultUp);
        this.updateMatrix();
        this.groundColor = new Color(groundColor);
    }
    exports_14("HemisphereLight", HemisphereLight);
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    function LightShadow(camera) {
        this.camera = camera;
        this.bias = 0;
        this.radius = 1;
        this.mapSize = new Vector2(512, 512);
        this.map = null;
        this.mapPass = null;
        this.matrix = new Matrix4();
        this._frustum = new Frustum();
        this._frameExtents = new Vector2(1, 1);
        this._viewportCount = 1;
        this._viewports = [
            new Vector4(0, 0, 1, 1)
        ];
    }
    exports_14("LightShadow", LightShadow);
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    function SpotLightShadow() {
        LightShadow.call(this, new PerspectiveCamera(50, 1, 0.5, 500));
    }
    exports_14("SpotLightShadow", SpotLightShadow);
    /**
     * @author alteredq / http://alteredqualia.com/
     */
    function SpotLight(color, intensity, distance, angle, penumbra, decay) {
        Light.call(this, color, intensity);
        this.type = 'SpotLight';
        this.position.copy(Object3D.DefaultUp);
        this.updateMatrix();
        this.target = new Object3D();
        Object.defineProperty(this, 'power', {
            get: function () {
                // intensity = power per solid angle.
                // ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
                return this.intensity * Math.PI;
            },
            set: function (power) {
                // intensity = power per solid angle.
                // ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
                this.intensity = power / Math.PI;
            }
        });
        this.distance = (distance !== undefined) ? distance : 0;
        this.angle = (angle !== undefined) ? angle : Math.PI / 3;
        this.penumbra = (penumbra !== undefined) ? penumbra : 0;
        this.decay = (decay !== undefined) ? decay : 1; // for physically correct lights, should be 2.
        this.shadow = new SpotLightShadow();
    }
    exports_14("SpotLight", SpotLight);
    function PointLightShadow() {
        LightShadow.call(this, new PerspectiveCamera(90, 1, 0.5, 500));
        this._frameExtents = new Vector2(4, 2);
        this._viewportCount = 6;
        this._viewports = [
            // These viewports map a cube-map onto a 2D texture with the
            // following orientation:
            //
            //  xzXZ
            //   y Y
            //
            // X - Positive x direction
            // x - Negative x direction
            // Y - Positive y direction
            // y - Negative y direction
            // Z - Positive z direction
            // z - Negative z direction
            // positive X
            new Vector4(2, 1, 1, 1),
            // negative X
            new Vector4(0, 1, 1, 1),
            // positive Z
            new Vector4(3, 1, 1, 1),
            // negative Z
            new Vector4(1, 1, 1, 1),
            // positive Y
            new Vector4(3, 0, 1, 1),
            // negative Y
            new Vector4(1, 0, 1, 1)
        ];
        this._cubeDirections = [
            new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 0, 1),
            new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, -1, 0)
        ];
        this._cubeUps = [
            new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0),
            new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1)
        ];
    }
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    function PointLight(color, intensity, distance, decay) {
        Light.call(this, color, intensity);
        this.type = 'PointLight';
        Object.defineProperty(this, 'power', {
            get: function () {
                // intensity = power per solid angle.
                // ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
                return this.intensity * 4 * Math.PI;
            },
            set: function (power) {
                // intensity = power per solid angle.
                // ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
                this.intensity = power / (4 * Math.PI);
            }
        });
        this.distance = (distance !== undefined) ? distance : 0;
        this.decay = (decay !== undefined) ? decay : 1; // for physically correct lights, should be 2.
        this.shadow = new PointLightShadow();
    }
    exports_14("PointLight", PointLight);
    /**
     * @author alteredq / http://alteredqualia.com/
     * @author arose / http://github.com/arose
     */
    function OrthographicCamera(left, right, top, bottom, near, far) {
        Camera.call(this);
        this.type = 'OrthographicCamera';
        this.zoom = 1;
        this.view = null;
        this.left = (left !== undefined) ? left : -1;
        this.right = (right !== undefined) ? right : 1;
        this.top = (top !== undefined) ? top : 1;
        this.bottom = (bottom !== undefined) ? bottom : -1;
        this.near = (near !== undefined) ? near : 0.1;
        this.far = (far !== undefined) ? far : 2000;
        this.updateProjectionMatrix();
    }
    exports_14("OrthographicCamera", OrthographicCamera);
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    function DirectionalLightShadow() {
        LightShadow.call(this, new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
    }
    exports_14("DirectionalLightShadow", DirectionalLightShadow);
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */
    function DirectionalLight(color, intensity) {
        Light.call(this, color, intensity);
        this.type = 'DirectionalLight';
        this.position.copy(Object3D.DefaultUp);
        this.updateMatrix();
        this.target = new Object3D();
        this.shadow = new DirectionalLightShadow();
    }
    exports_14("DirectionalLight", DirectionalLight);
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    function AmbientLight(color, intensity) {
        Light.call(this, color, intensity);
        this.type = 'AmbientLight';
        this.castShadow = undefined;
    }
    exports_14("AmbientLight", AmbientLight);
    /**
     * @author abelnation / http://github.com/abelnation
     */
    function RectAreaLight(color, intensity, width, height) {
        Light.call(this, color, intensity);
        this.type = 'RectAreaLight';
        this.width = (width !== undefined) ? width : 10;
        this.height = (height !== undefined) ? height : 10;
    }
    exports_14("RectAreaLight", RectAreaLight);
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    function MaterialLoader(manager) {
        Loader.call(this, manager);
        this.textures = {};
    }
    exports_14("MaterialLoader", MaterialLoader);
    /**
     * @author benaadams / https://twitter.com/ben_a_adams
     */
    function InstancedBufferGeometry() {
        BufferGeometry.call(this);
        this.type = 'InstancedBufferGeometry';
        this.maxInstancedCount = undefined;
    }
    exports_14("InstancedBufferGeometry", InstancedBufferGeometry);
    /**
     * @author benaadams / https://twitter.com/ben_a_adams
     */
    function InstancedBufferAttribute(array, itemSize, normalized, meshPerAttribute) {
        if (typeof (normalized) === 'number') {
            meshPerAttribute = normalized;
            normalized = false;
            console.error('THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.');
        }
        BufferAttribute.call(this, array, itemSize, normalized);
        this.meshPerAttribute = meshPerAttribute || 1;
    }
    exports_14("InstancedBufferAttribute", InstancedBufferAttribute);
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    function BufferGeometryLoader(manager) {
        Loader.call(this, manager);
    }
    exports_14("BufferGeometryLoader", BufferGeometryLoader);
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    function ObjectLoader(manager) {
        Loader.call(this, manager);
    }
    exports_14("ObjectLoader", ObjectLoader);
    /**
     * @author thespite / http://clicktorelease.com/
     */
    function ImageBitmapLoader(manager) {
        if (typeof createImageBitmap === 'undefined') {
            console.warn('THREE.ImageBitmapLoader: createImageBitmap() not supported.');
        }
        if (typeof fetch === 'undefined') {
            console.warn('THREE.ImageBitmapLoader: fetch() not supported.');
        }
        Loader.call(this, manager);
        this.options = undefined;
    }
    exports_14("ImageBitmapLoader", ImageBitmapLoader);
    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     * minimal class for proxing functions to Path. Replaces old "extractSubpaths()"
     **/
    function ShapePath() {
        this.type = 'ShapePath';
        this.color = new Color();
        this.subPaths = [];
        this.currentPath = null;
    }
    exports_14("ShapePath", ShapePath);
    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     * @author mrdoob / http://mrdoob.com/
     */
    function Font(data) {
        this.type = 'Font';
        this.data = data;
    }
    exports_14("Font", Font);
    function createPaths(text, size, data) {
        var chars = Array.from ? Array.from(text) : String(text).split(''); // workaround for IE11, see #13988
        var scale = size / data.resolution;
        var line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;
        var paths = [];
        var offsetX = 0, offsetY = 0;
        for (var i = 0; i < chars.length; i++) {
            var char = chars[i];
            if (char === '\n') {
                offsetX = 0;
                offsetY -= line_height;
            }
            else {
                var ret = createPath(char, scale, offsetX, offsetY, data);
                offsetX += ret.offsetX;
                paths.push(ret.path);
            }
        }
        return paths;
    }
    function createPath(char, scale, offsetX, offsetY, data) {
        var glyph = data.glyphs[char] || data.glyphs['?'];
        if (!glyph) {
            console.error('THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + '.');
            return;
        }
        var path = new ShapePath();
        var x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;
        if (glyph.o) {
            var outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));
            for (var i = 0, l = outline.length; i < l;) {
                var action = outline[i++];
                switch (action) {
                    case 'm': // moveTo
                        x = outline[i++] * scale + offsetX;
                        y = outline[i++] * scale + offsetY;
                        path.moveTo(x, y);
                        break;
                    case 'l': // lineTo
                        x = outline[i++] * scale + offsetX;
                        y = outline[i++] * scale + offsetY;
                        path.lineTo(x, y);
                        break;
                    case 'q': // quadraticCurveTo
                        cpx = outline[i++] * scale + offsetX;
                        cpy = outline[i++] * scale + offsetY;
                        cpx1 = outline[i++] * scale + offsetX;
                        cpy1 = outline[i++] * scale + offsetY;
                        path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
                        break;
                    case 'b': // bezierCurveTo
                        cpx = outline[i++] * scale + offsetX;
                        cpy = outline[i++] * scale + offsetY;
                        cpx1 = outline[i++] * scale + offsetX;
                        cpy1 = outline[i++] * scale + offsetY;
                        cpx2 = outline[i++] * scale + offsetX;
                        cpy2 = outline[i++] * scale + offsetY;
                        path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
                        break;
                }
            }
        }
        return { offsetX: glyph.ha * scale, path: path };
    }
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    function FontLoader(manager) {
        Loader.call(this, manager);
    }
    exports_14("FontLoader", FontLoader);
    /**
     * @author Reece Aaron Lecrivain / http://reecenotes.com/
     */
    function AudioLoader(manager) {
        Loader.call(this, manager);
    }
    exports_14("AudioLoader", AudioLoader);
    /**
     * @author bhouston / http://clara.io
     * @author WestLangley / http://github.com/WestLangley
     *
     * Primary reference:
     *   https://graphics.stanford.edu/papers/envmap/envmap.pdf
     *
     * Secondary reference:
     *   https://www.ppsloan.org/publications/StupidSH36.pdf
     */
    // 3-band SH defined by 9 coefficients
    function SphericalHarmonics3() {
        this.coefficients = [];
        for (var i = 0; i < 9; i++) {
            this.coefficients.push(new Vector3());
        }
    }
    exports_14("SphericalHarmonics3", SphericalHarmonics3);
    /**
     * @author WestLangley / http://github.com/WestLangley
     *
     * A LightProbe is a source of indirect-diffuse light
     */
    function LightProbe(sh, intensity) {
        Light.call(this, undefined, intensity);
        this.sh = (sh !== undefined) ? sh : new SphericalHarmonics3();
    }
    exports_14("LightProbe", LightProbe);
    /**
     * @author WestLangley / http://github.com/WestLangley
     */
    function HemisphereLightProbe(skyColor, groundColor, intensity) {
        LightProbe.call(this, undefined, intensity);
        var color1 = new Color().set(skyColor);
        var color2 = new Color().set(groundColor);
        var sky = new Vector3(color1.r, color1.g, color1.b);
        var ground = new Vector3(color2.r, color2.g, color2.b);
        // without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );
        var c0 = Math.sqrt(Math.PI);
        var c1 = c0 * Math.sqrt(0.75);
        this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);
        this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);
    }
    exports_14("HemisphereLightProbe", HemisphereLightProbe);
    /**
     * @author WestLangley / http://github.com/WestLangley
     */
    function AmbientLightProbe(color, intensity) {
        LightProbe.call(this, undefined, intensity);
        var color1 = new Color().set(color);
        // without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );
        this.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));
    }
    exports_14("AmbientLightProbe", AmbientLightProbe);
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    function StereoCamera() {
        this.type = 'StereoCamera';
        this.aspect = 1;
        this.eyeSep = 0.064;
        this.cameraL = new PerspectiveCamera();
        this.cameraL.layers.enable(1);
        this.cameraL.matrixAutoUpdate = false;
        this.cameraR = new PerspectiveCamera();
        this.cameraR.layers.enable(2);
        this.cameraR.matrixAutoUpdate = false;
        this._cache = {
            focus: null,
            fov: null,
            aspect: null,
            near: null,
            far: null,
            zoom: null,
            eyeSep: null
        };
    }
    exports_14("StereoCamera", StereoCamera);
    /**
     * @author alteredq / http://alteredqualia.com/
     */
    function Clock(autoStart) {
        this.autoStart = (autoStart !== undefined) ? autoStart : true;
        this.startTime = 0;
        this.oldTime = 0;
        this.elapsedTime = 0;
        this.running = false;
    }
    exports_14("Clock", Clock);
    function AudioListener() {
        Object3D.call(this);
        this.type = 'AudioListener';
        this.context = AudioContext.getContext();
        this.gain = this.context.createGain();
        this.gain.connect(this.context.destination);
        this.filter = null;
        this.timeDelta = 0;
        // private
        this._clock = new Clock();
    }
    exports_14("AudioListener", AudioListener);
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author Reece Aaron Lecrivain / http://reecenotes.com/
     */
    function Audio(listener) {
        Object3D.call(this);
        this.type = 'Audio';
        this.listener = listener;
        this.context = listener.context;
        this.gain = this.context.createGain();
        this.gain.connect(listener.getInput());
        this.autoplay = false;
        this.buffer = null;
        this.detune = 0;
        this.loop = false;
        this.loopStart = 0;
        this.loopEnd = 0;
        this.offset = 0;
        this.duration = undefined;
        this.playbackRate = 1;
        this.isPlaying = false;
        this.hasPlaybackControl = true;
        this.sourceType = 'empty';
        this._startedAt = 0;
        this._pausedAt = 0;
        this.filters = [];
    }
    exports_14("Audio", Audio);
    function PositionalAudio(listener) {
        Audio.call(this, listener);
        this.panner = this.context.createPanner();
        this.panner.panningModel = 'HRTF';
        this.panner.connect(this.gain);
    }
    exports_14("PositionalAudio", PositionalAudio);
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    function AudioAnalyser(audio, fftSize) {
        this.analyser = audio.context.createAnalyser();
        this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;
        this.data = new Uint8Array(this.analyser.frequencyBinCount);
        audio.getOutput().connect(this.analyser);
    }
    exports_14("AudioAnalyser", AudioAnalyser);
    /**
     *
     * Buffered scene graph property that allows weighted accumulation.
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */
    function PropertyMixer(binding, typeName, valueSize) {
        this.binding = binding;
        this.valueSize = valueSize;
        var bufferType = Float64Array, mixFunction;
        switch (typeName) {
            case 'quaternion':
                mixFunction = this._slerp;
                break;
            case 'string':
            case 'bool':
                bufferType = Array;
                mixFunction = this._select;
                break;
            default:
                mixFunction = this._lerp;
        }
        this.buffer = new bufferType(valueSize * 4);
        // layout: [ incoming | accu0 | accu1 | orig ]
        //
        // interpolators can use .buffer as their .result
        // the data then goes to 'incoming'
        //
        // 'accu0' and 'accu1' are used frame-interleaved for
        // the cumulative result and are compared to detect
        // changes
        //
        // 'orig' stores the original state of the property
        this._mixBufferRegion = mixFunction;
        this.cumulativeWeight = 0;
        this.useCount = 0;
        this.referenceCount = 0;
    }
    exports_14("PropertyMixer", PropertyMixer);
    function Composite(targetGroup, path, optionalParsedPath) {
        var parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
        this._targetGroup = targetGroup;
        this._bindings = targetGroup.subscribe_(path, parsedPath);
    }
    function PropertyBinding(rootNode, path, parsedPath) {
        this.path = path;
        this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
        this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
        this.rootNode = rootNode;
    }
    exports_14("PropertyBinding", PropertyBinding);
    /**
     *
     * A group of objects that receives a shared animation state.
     *
     * Usage:
     *
     *  - Add objects you would otherwise pass as 'root' to the
     *    constructor or the .clipAction method of AnimationMixer.
     *
     *  - Instead pass this object as 'root'.
     *
     *  - You can also add and remove objects later when the mixer
     *    is running.
     *
     * Note:
     *
     *    Objects of this class appear as one object to the mixer,
     *    so cache control of the individual objects must be done
     *    on the group.
     *
     * Limitation:
     *
     *  - The animated properties must be compatible among the
     *    all objects in the group.
     *
     *  - A single property can either be controlled through a
     *    target group or directly, but not both.
     *
     * @author tschw
     */
    function AnimationObjectGroup() {
        this.uuid = MathUtils.generateUUID();
        // cached objects followed by the active ones
        this._objects = Array.prototype.slice.call(arguments);
        this.nCachedObjects_ = 0; // threshold
        // note: read by PropertyBinding.Composite
        var indices = {};
        this._indicesByUUID = indices; // for bookkeeping
        for (var i = 0, n = arguments.length; i !== n; ++i) {
            indices[arguments[i].uuid] = i;
        }
        this._paths = []; // inside: string
        this._parsedPaths = []; // inside: { we don't care, here }
        this._bindings = []; // inside: Array< PropertyBinding >
        this._bindingsIndicesByPath = {}; // inside: indices in these arrays
        var scope = this;
        this.stats = {
            objects: {
                get total() {
                    return scope._objects.length;
                },
                get inUse() {
                    return this.total - scope.nCachedObjects_;
                }
            },
            get bindingsPerObject() {
                return scope._bindings.length;
            }
        };
    }
    exports_14("AnimationObjectGroup", AnimationObjectGroup);
    /**
     *
     * Action provided by AnimationMixer for scheduling clip playback on specific
     * objects.
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     *
     */
    function AnimationAction(mixer, clip, localRoot) {
        this._mixer = mixer;
        this._clip = clip;
        this._localRoot = localRoot || null;
        var tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks);
        var interpolantSettings = {
            endingStart: ZeroCurvatureEnding,
            endingEnd: ZeroCurvatureEnding
        };
        for (var i = 0; i !== nTracks; ++i) {
            var interpolant = tracks[i].createInterpolant(null);
            interpolants[i] = interpolant;
            interpolant.settings = interpolantSettings;
        }
        this._interpolantSettings = interpolantSettings;
        this._interpolants = interpolants; // bound by the mixer
        // inside: PropertyMixer (managed by the mixer)
        this._propertyBindings = new Array(nTracks);
        this._cacheIndex = null; // for the memory manager
        this._byClipCacheIndex = null; // for the memory manager
        this._timeScaleInterpolant = null;
        this._weightInterpolant = null;
        this.loop = LoopRepeat;
        this._loopCount = -1;
        // global mixer time when the action is to be started
        // it's set back to 'null' upon start of the action
        this._startTime = null;
        // scaled local time of the action
        // gets clamped or wrapped to 0..clip.duration according to loop
        this.time = 0;
        this.timeScale = 1;
        this._effectiveTimeScale = 1;
        this.weight = 1;
        this._effectiveWeight = 1;
        this.repetitions = Infinity; // no. of repetitions when looping
        this.paused = false; // true -> zero effective time scale
        this.enabled = true; // false -> zero effective weight
        this.clampWhenFinished = false; // keep feeding the last frame?
        this.zeroSlopeAtStart = true; // for smooth interpolation w/o separate
        this.zeroSlopeAtEnd = true; // clips for start, loop and end
    }
    /**
     *
     * Player for AnimationClips.
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */
    function AnimationMixer(root) {
        this._root = root;
        this._initMemoryManager();
        this._accuIndex = 0;
        this.time = 0;
        this.timeScale = 1.0;
    }
    exports_14("AnimationMixer", AnimationMixer);
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    function Uniform(value) {
        if (typeof value === 'string') {
            console.warn('THREE.Uniform: Type parameter is no longer needed.');
            value = arguments[1];
        }
        this.value = value;
    }
    exports_14("Uniform", Uniform);
    /**
     * @author benaadams / https://twitter.com/ben_a_adams
     */
    function InstancedInterleavedBuffer(array, stride, meshPerAttribute) {
        InterleavedBuffer.call(this, array, stride);
        this.meshPerAttribute = meshPerAttribute || 1;
    }
    exports_14("InstancedInterleavedBuffer", InstancedInterleavedBuffer);
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author bhouston / http://clara.io/
     * @author stephomi / http://stephaneginier.com/
     */
    function Raycaster(origin, direction, near, far) {
        this.ray = new Ray(origin, direction);
        // direction is assumed to be normalized (for accurate distance calculations)
        this.near = near || 0;
        this.far = far || Infinity;
        this.camera = null;
        this.params = {
            Mesh: {},
            Line: {},
            LOD: {},
            Points: { threshold: 1 },
            Sprite: {}
        };
        Object.defineProperties(this.params, {
            PointCloud: {
                get: function () {
                    console.warn('THREE.Raycaster: params.PointCloud has been renamed to params.Points.');
                    return this.Points;
                }
            }
        });
    }
    exports_14("Raycaster", Raycaster);
    function ascSort(a, b) {
        return a.distance - b.distance;
    }
    function intersectObject(object, raycaster, intersects, recursive) {
        if (object.visible === false)
            return;
        object.raycast(raycaster, intersects);
        if (recursive === true) {
            var children = object.children;
            for (var i = 0, l = children.length; i < l; i++) {
                intersectObject(children[i], raycaster, intersects, true);
            }
        }
    }
    /**
     * @author bhouston / http://clara.io
     * @author WestLangley / http://github.com/WestLangley
     *
     * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
     *
     * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
     * The azimuthal angle (theta) is measured from the positive z-axis.
     */
    function Spherical(radius, phi, theta) {
        this.radius = (radius !== undefined) ? radius : 1.0;
        this.phi = (phi !== undefined) ? phi : 0; // polar angle
        this.theta = (theta !== undefined) ? theta : 0; // azimuthal angle
        return this;
    }
    exports_14("Spherical", Spherical);
    /**
     * @author Mugen87 / https://github.com/Mugen87
     *
     * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
     *
     */
    function Cylindrical(radius, theta, y) {
        this.radius = (radius !== undefined) ? radius : 1.0; // distance from the origin to a point in the x-z plane
        this.theta = (theta !== undefined) ? theta : 0; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis
        this.y = (y !== undefined) ? y : 0; // height above the x-z plane
        return this;
    }
    exports_14("Cylindrical", Cylindrical);
    function Box2(min, max) {
        this.min = (min !== undefined) ? min : new Vector2(+Infinity, +Infinity);
        this.max = (max !== undefined) ? max : new Vector2(-Infinity, -Infinity);
    }
    exports_14("Box2", Box2);
    function Line3(start, end) {
        this.start = (start !== undefined) ? start : new Vector3();
        this.end = (end !== undefined) ? end : new Vector3();
    }
    exports_14("Line3", Line3);
    /**
     * @author alteredq / http://alteredqualia.com/
     */
    function ImmediateRenderObject(material) {
        Object3D.call(this);
        this.material = material;
        this.render = function ( /* renderCallback */) { };
    }
    exports_14("ImmediateRenderObject", ImmediateRenderObject);
    function SpotLightHelper(light, color) {
        Object3D.call(this);
        this.light = light;
        this.light.updateMatrixWorld();
        this.matrix = light.matrixWorld;
        this.matrixAutoUpdate = false;
        this.color = color;
        var geometry = new BufferGeometry();
        var positions = [
            0, 0, 0, 0, 0, 1,
            0, 0, 0, 1, 0, 1,
            0, 0, 0, -1, 0, 1,
            0, 0, 0, 0, 1, 1,
            0, 0, 0, 0, -1, 1
        ];
        for (var i = 0, j = 1, l = 32; i < l; i++, j++) {
            var p1 = (i / l) * Math.PI * 2;
            var p2 = (j / l) * Math.PI * 2;
            positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);
        }
        geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
        var material = new LineBasicMaterial({ fog: false });
        this.cone = new LineSegments(geometry, material);
        this.add(this.cone);
        this.update();
    }
    exports_14("SpotLightHelper", SpotLightHelper);
    function getBoneList(object) {
        var boneList = [];
        if (object && object.isBone) {
            boneList.push(object);
        }
        for (var i = 0; i < object.children.length; i++) {
            boneList.push.apply(boneList, getBoneList(object.children[i]));
        }
        return boneList;
    }
    function SkeletonHelper(object) {
        var bones = getBoneList(object);
        var geometry = new BufferGeometry();
        var vertices = [];
        var colors = [];
        var color1 = new Color(0, 0, 1);
        var color2 = new Color(0, 1, 0);
        for (var i = 0; i < bones.length; i++) {
            var bone = bones[i];
            if (bone.parent && bone.parent.isBone) {
                vertices.push(0, 0, 0);
                vertices.push(0, 0, 0);
                colors.push(color1.r, color1.g, color1.b);
                colors.push(color2.r, color2.g, color2.b);
            }
        }
        geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
        geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
        var material = new LineBasicMaterial({ vertexColors: VertexColors, depthTest: false, depthWrite: false, transparent: true });
        LineSegments.call(this, geometry, material);
        this.root = object;
        this.bones = bones;
        this.matrix = object.matrixWorld;
        this.matrixAutoUpdate = false;
    }
    exports_14("SkeletonHelper", SkeletonHelper);
    /**
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     */
    function PointLightHelper(light, sphereSize, color) {
        this.light = light;
        this.light.updateMatrixWorld();
        this.color = color;
        var geometry = new SphereBufferGeometry(sphereSize, 4, 2);
        var material = new MeshBasicMaterial({ wireframe: true, fog: false });
        Mesh.call(this, geometry, material);
        this.matrix = this.light.matrixWorld;
        this.matrixAutoUpdate = false;
        this.update();
        /*
        var distanceGeometry = new THREE.IcosahedronBufferGeometry( 1, 2 );
        var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );
    
        this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
        this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );
    
        var d = light.distance;
    
        if ( d === 0.0 ) {
    
            this.lightDistance.visible = false;
    
        } else {
    
            this.lightDistance.scale.set( d, d, d );
    
        }
    
        this.add( this.lightDistance );
        */
    }
    exports_14("PointLightHelper", PointLightHelper);
    function HemisphereLightHelper(light, size, color) {
        Object3D.call(this);
        this.light = light;
        this.light.updateMatrixWorld();
        this.matrix = light.matrixWorld;
        this.matrixAutoUpdate = false;
        this.color = color;
        var geometry = new OctahedronBufferGeometry(size);
        geometry.rotateY(Math.PI * 0.5);
        this.material = new MeshBasicMaterial({ wireframe: true, fog: false });
        if (this.color === undefined)
            this.material.vertexColors = VertexColors;
        var position = geometry.getAttribute('position');
        var colors = new Float32Array(position.count * 3);
        geometry.setAttribute('color', new BufferAttribute(colors, 3));
        this.add(new Mesh(geometry, this.material));
        this.update();
    }
    exports_14("HemisphereLightHelper", HemisphereLightHelper);
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    function GridHelper(size, divisions, color1, color2) {
        size = size || 10;
        divisions = divisions || 10;
        color1 = new Color(color1 !== undefined ? color1 : 0x444444);
        color2 = new Color(color2 !== undefined ? color2 : 0x888888);
        var center = divisions / 2;
        var step = size / divisions;
        var halfSize = size / 2;
        var vertices = [], colors = [];
        for (var i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step) {
            vertices.push(-halfSize, 0, k, halfSize, 0, k);
            vertices.push(k, 0, -halfSize, k, 0, halfSize);
            var color = i === center ? color1 : color2;
            color.toArray(colors, j);
            j += 3;
            color.toArray(colors, j);
            j += 3;
            color.toArray(colors, j);
            j += 3;
            color.toArray(colors, j);
            j += 3;
        }
        var geometry = new BufferGeometry();
        geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
        geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
        var material = new LineBasicMaterial({ vertexColors: VertexColors });
        LineSegments.call(this, geometry, material);
    }
    exports_14("GridHelper", GridHelper);
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author Mugen87 / http://github.com/Mugen87
     * @author Hectate / http://www.github.com/Hectate
     */
    function PolarGridHelper(radius, radials, circles, divisions, color1, color2) {
        radius = radius || 10;
        radials = radials || 16;
        circles = circles || 8;
        divisions = divisions || 64;
        color1 = new Color(color1 !== undefined ? color1 : 0x444444);
        color2 = new Color(color2 !== undefined ? color2 : 0x888888);
        var vertices = [];
        var colors = [];
        var x, z;
        var v, i, j, r, color;
        // create the radials
        for (i = 0; i <= radials; i++) {
            v = (i / radials) * (Math.PI * 2);
            x = Math.sin(v) * radius;
            z = Math.cos(v) * radius;
            vertices.push(0, 0, 0);
            vertices.push(x, 0, z);
            color = (i & 1) ? color1 : color2;
            colors.push(color.r, color.g, color.b);
            colors.push(color.r, color.g, color.b);
        }
        // create the circles
        for (i = 0; i <= circles; i++) {
            color = (i & 1) ? color1 : color2;
            r = radius - (radius / circles * i);
            for (j = 0; j < divisions; j++) {
                // first vertex
                v = (j / divisions) * (Math.PI * 2);
                x = Math.sin(v) * r;
                z = Math.cos(v) * r;
                vertices.push(x, 0, z);
                colors.push(color.r, color.g, color.b);
                // second vertex
                v = ((j + 1) / divisions) * (Math.PI * 2);
                x = Math.sin(v) * r;
                z = Math.cos(v) * r;
                vertices.push(x, 0, z);
                colors.push(color.r, color.g, color.b);
            }
        }
        var geometry = new BufferGeometry();
        geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
        geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
        var material = new LineBasicMaterial({ vertexColors: VertexColors });
        LineSegments.call(this, geometry, material);
    }
    exports_14("PolarGridHelper", PolarGridHelper);
    function DirectionalLightHelper(light, size, color) {
        Object3D.call(this);
        this.light = light;
        this.light.updateMatrixWorld();
        this.matrix = light.matrixWorld;
        this.matrixAutoUpdate = false;
        this.color = color;
        if (size === undefined)
            size = 1;
        var geometry = new BufferGeometry();
        geometry.setAttribute('position', new Float32BufferAttribute([
            -size, size, 0,
            size, size, 0,
            size, -size, 0,
            -size, -size, 0,
            -size, size, 0
        ], 3));
        var material = new LineBasicMaterial({ fog: false });
        this.lightPlane = new Line(geometry, material);
        this.add(this.lightPlane);
        geometry = new BufferGeometry();
        geometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));
        this.targetLine = new Line(geometry, material);
        this.add(this.targetLine);
        this.update();
    }
    exports_14("DirectionalLightHelper", DirectionalLightHelper);
    function CameraHelper(camera) {
        var geometry = new BufferGeometry();
        var material = new LineBasicMaterial({ color: 0xffffff, vertexColors: FaceColors });
        var vertices = [];
        var colors = [];
        var pointMap = {};
        // colors
        var colorFrustum = new Color(0xffaa00);
        var colorCone = new Color(0xff0000);
        var colorUp = new Color(0x00aaff);
        var colorTarget = new Color(0xffffff);
        var colorCross = new Color(0x333333);
        // near
        addLine('n1', 'n2', colorFrustum);
        addLine('n2', 'n4', colorFrustum);
        addLine('n4', 'n3', colorFrustum);
        addLine('n3', 'n1', colorFrustum);
        // far
        addLine('f1', 'f2', colorFrustum);
        addLine('f2', 'f4', colorFrustum);
        addLine('f4', 'f3', colorFrustum);
        addLine('f3', 'f1', colorFrustum);
        // sides
        addLine('n1', 'f1', colorFrustum);
        addLine('n2', 'f2', colorFrustum);
        addLine('n3', 'f3', colorFrustum);
        addLine('n4', 'f4', colorFrustum);
        // cone
        addLine('p', 'n1', colorCone);
        addLine('p', 'n2', colorCone);
        addLine('p', 'n3', colorCone);
        addLine('p', 'n4', colorCone);
        // up
        addLine('u1', 'u2', colorUp);
        addLine('u2', 'u3', colorUp);
        addLine('u3', 'u1', colorUp);
        // target
        addLine('c', 't', colorTarget);
        addLine('p', 'c', colorCross);
        // cross
        addLine('cn1', 'cn2', colorCross);
        addLine('cn3', 'cn4', colorCross);
        addLine('cf1', 'cf2', colorCross);
        addLine('cf3', 'cf4', colorCross);
        function addLine(a, b, color) {
            addPoint(a, color);
            addPoint(b, color);
        }
        function addPoint(id, color) {
            vertices.push(0, 0, 0);
            colors.push(color.r, color.g, color.b);
            if (pointMap[id] === undefined) {
                pointMap[id] = [];
            }
            pointMap[id].push((vertices.length / 3) - 1);
        }
        geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
        geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
        LineSegments.call(this, geometry, material);
        this.camera = camera;
        if (this.camera.updateProjectionMatrix)
            this.camera.updateProjectionMatrix();
        this.matrix = camera.matrixWorld;
        this.matrixAutoUpdate = false;
        this.pointMap = pointMap;
        this.update();
    }
    exports_14("CameraHelper", CameraHelper);
    function setPoint(point, pointMap, geometry, camera, x, y, z) {
        _vector$b.set(x, y, z).unproject(camera);
        var points = pointMap[point];
        if (points !== undefined) {
            var position = geometry.getAttribute('position');
            for (var i = 0, l = points.length; i < l; i++) {
                position.setXYZ(points[i], _vector$b.x, _vector$b.y, _vector$b.z);
            }
        }
    }
    function BoxHelper(object, color) {
        this.object = object;
        if (color === undefined)
            color = 0xffff00;
        var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
        var positions = new Float32Array(8 * 3);
        var geometry = new BufferGeometry();
        geometry.setIndex(new BufferAttribute(indices, 1));
        geometry.setAttribute('position', new BufferAttribute(positions, 3));
        LineSegments.call(this, geometry, new LineBasicMaterial({ color: color }));
        this.matrixAutoUpdate = false;
        this.update();
    }
    exports_14("BoxHelper", BoxHelper);
    /**
     * @author WestLangley / http://github.com/WestLangley
     */
    function Box3Helper(box, color) {
        this.type = 'Box3Helper';
        this.box = box;
        color = color || 0xffff00;
        var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
        var positions = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1];
        var geometry = new BufferGeometry();
        geometry.setIndex(new BufferAttribute(indices, 1));
        geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
        LineSegments.call(this, geometry, new LineBasicMaterial({ color: color }));
        this.geometry.computeBoundingSphere();
    }
    exports_14("Box3Helper", Box3Helper);
    /**
     * @author WestLangley / http://github.com/WestLangley
     */
    function PlaneHelper(plane, size, hex) {
        this.type = 'PlaneHelper';
        this.plane = plane;
        this.size = (size === undefined) ? 1 : size;
        var color = (hex !== undefined) ? hex : 0xffff00;
        var positions = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0];
        var geometry = new BufferGeometry();
        geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
        geometry.computeBoundingSphere();
        Line.call(this, geometry, new LineBasicMaterial({ color: color }));
        //
        var positions2 = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1];
        var geometry2 = new BufferGeometry();
        geometry2.setAttribute('position', new Float32BufferAttribute(positions2, 3));
        geometry2.computeBoundingSphere();
        this.add(new Mesh(geometry2, new MeshBasicMaterial({ color: color, opacity: 0.2, transparent: true, depthWrite: false })));
    }
    exports_14("PlaneHelper", PlaneHelper);
    function ArrowHelper(dir, origin, length, color, headLength, headWidth) {
        // dir is assumed to be normalized
        Object3D.call(this);
        if (dir === undefined)
            dir = new Vector3(0, 0, 1);
        if (origin === undefined)
            origin = new Vector3(0, 0, 0);
        if (length === undefined)
            length = 1;
        if (color === undefined)
            color = 0xffff00;
        if (headLength === undefined)
            headLength = 0.2 * length;
        if (headWidth === undefined)
            headWidth = 0.2 * headLength;
        if (_lineGeometry === undefined) {
            _lineGeometry = new BufferGeometry();
            _lineGeometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));
            _coneGeometry = new CylinderBufferGeometry(0, 0.5, 1, 5, 1);
            _coneGeometry.translate(0, -0.5, 0);
        }
        this.position.copy(origin);
        this.line = new Line(_lineGeometry, new LineBasicMaterial({ color: color }));
        this.line.matrixAutoUpdate = false;
        this.add(this.line);
        this.cone = new Mesh(_coneGeometry, new MeshBasicMaterial({ color: color }));
        this.cone.matrixAutoUpdate = false;
        this.add(this.cone);
        this.setDirection(dir);
        this.setLength(length, headLength, headWidth);
    }
    exports_14("ArrowHelper", ArrowHelper);
    /**
     * @author sroucheray / http://sroucheray.org/
     * @author mrdoob / http://mrdoob.com/
     */
    function AxesHelper(size) {
        size = size || 1;
        var vertices = [
            0, 0, 0, size, 0, 0,
            0, 0, 0, 0, size, 0,
            0, 0, 0, 0, 0, size
        ];
        var colors = [
            1, 0, 0, 1, 0.6, 0,
            0, 1, 0, 0.6, 1, 0,
            0, 0, 1, 0, 0.6, 1
        ];
        var geometry = new BufferGeometry();
        geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
        geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
        var material = new LineBasicMaterial({ vertexColors: VertexColors });
        LineSegments.call(this, geometry, material);
    }
    exports_14("AxesHelper", AxesHelper);
    function PMREMGenerator(renderer) {
        _renderer = renderer;
        _compileMaterial(_blurMaterial);
    }
    exports_14("PMREMGenerator", PMREMGenerator);
    function _createPlanes() {
        var _lodPlanes = [];
        var _sizeLods = [];
        var _sigmas = [];
        var lod = LOD_MAX;
        for (var i = 0; i < TOTAL_LODS; i++) {
            var sizeLod = Math.pow(2, lod);
            _sizeLods.push(sizeLod);
            var sigma = 1.0 / sizeLod;
            if (i > LOD_MAX - LOD_MIN) {
                sigma = EXTRA_LOD_SIGMA[i - LOD_MAX + LOD_MIN - 1];
            }
            else if (i == 0) {
                sigma = 0;
            }
            _sigmas.push(sigma);
            var texelSize = 1.0 / (sizeLod - 1);
            var min = -texelSize / 2;
            var max = 1 + texelSize / 2;
            var uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];
            var cubeFaces = 6;
            var vertices = 6;
            var positionSize = 3;
            var uvSize = 2;
            var faceIndexSize = 1;
            var position = new Float32Array(positionSize * vertices * cubeFaces);
            var uv = new Float32Array(uvSize * vertices * cubeFaces);
            var faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
            for (var face = 0; face < cubeFaces; face++) {
                var x = (face % 3) * 2 / 3 - 1;
                var y = face > 2 ? 0 : -1;
                var coordinates = [
                    x, y, 0,
                    x + 2 / 3, y, 0,
                    x + 2 / 3, y + 1, 0,
                    x, y, 0,
                    x + 2 / 3, y + 1, 0,
                    x, y + 1, 0
                ];
                position.set(coordinates, positionSize * vertices * face);
                uv.set(uv1, uvSize * vertices * face);
                var fill = [face, face, face, face, face, face];
                faceIndex.set(fill, faceIndexSize * vertices * face);
            }
            var planes = new BufferGeometry();
            planes.setAttribute('position', new BufferAttribute(position, positionSize));
            planes.setAttribute('uv', new BufferAttribute(uv, uvSize));
            planes.setAttribute('faceIndex', new BufferAttribute(faceIndex, faceIndexSize));
            _lodPlanes.push(planes);
            if (lod > LOD_MIN) {
                lod--;
            }
        }
        return { _lodPlanes, _sizeLods, _sigmas };
    }
    function _allocateTargets(equirectangular) {
        var params = {
            magFilter: NearestFilter,
            minFilter: NearestFilter,
            generateMipmaps: false,
            type: equirectangular ? equirectangular.type : UnsignedByteType,
            format: equirectangular ? equirectangular.format : RGBEFormat,
            encoding: equirectangular ? equirectangular.encoding : RGBEEncoding,
            depthBuffer: false,
            stencilBuffer: false
        };
        var cubeUVRenderTarget = _createRenderTarget(params);
        cubeUVRenderTarget.depthBuffer = equirectangular ? false : true;
        _pingPongRenderTarget = _createRenderTarget(params);
        return cubeUVRenderTarget;
    }
    function _cleanup(outputTarget) {
        _pingPongRenderTarget.dispose();
        _renderer.setRenderTarget(_oldTarget);
        outputTarget.scissorTest = false;
        // reset viewport and scissor
        outputTarget.setSize(outputTarget.width, outputTarget.height);
    }
    function _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
        var fov = 90;
        var aspect = 1;
        var cubeCamera = new PerspectiveCamera(fov, aspect, near, far);
        var upSign = [1, 1, 1, 1, -1, 1];
        var forwardSign = [1, 1, -1, -1, -1, 1];
        var outputEncoding = _renderer.outputEncoding;
        var toneMapping = _renderer.toneMapping;
        var toneMappingExposure = _renderer.toneMappingExposure;
        var clearColor = _renderer.getClearColor();
        var clearAlpha = _renderer.getClearAlpha();
        _renderer.toneMapping = LinearToneMapping;
        _renderer.toneMappingExposure = 1.0;
        _renderer.outputEncoding = LinearEncoding;
        scene.scale.z *= -1;
        var background = scene.background;
        if (background && background.isColor) {
            background.convertSRGBToLinear();
            // Convert linear to RGBE
            var maxComponent = Math.max(background.r, background.g, background.b);
            var fExp = Math.min(Math.max(Math.ceil(Math.log2(maxComponent)), -128.0), 127.0);
            background = background.multiplyScalar(Math.pow(2.0, -fExp));
            var alpha = (fExp + 128.0) / 255.0;
            _renderer.setClearColor(background, alpha);
            scene.background = null;
        }
        for (var i = 0; i < 6; i++) {
            var col = i % 3;
            if (col == 0) {
                cubeCamera.up.set(0, upSign[i], 0);
                cubeCamera.lookAt(forwardSign[i], 0, 0);
            }
            else if (col == 1) {
                cubeCamera.up.set(0, 0, upSign[i]);
                cubeCamera.lookAt(0, forwardSign[i], 0);
            }
            else {
                cubeCamera.up.set(0, upSign[i], 0);
                cubeCamera.lookAt(0, 0, forwardSign[i]);
            }
            _setViewport(cubeUVRenderTarget, col * SIZE_MAX, i > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX);
            _renderer.setRenderTarget(cubeUVRenderTarget);
            _renderer.render(scene, cubeCamera);
        }
        _renderer.toneMapping = toneMapping;
        _renderer.toneMappingExposure = toneMappingExposure;
        _renderer.outputEncoding = outputEncoding;
        _renderer.setClearColor(clearColor, clearAlpha);
        scene.scale.z *= -1;
    }
    function _textureToCubeUV(texture, cubeUVRenderTarget) {
        var scene = new Scene();
        if (texture.isCubeTexture) {
            if (_cubemapShader == null) {
                _cubemapShader = _getCubemapShader();
            }
        }
        else {
            if (_equirectShader == null) {
                _equirectShader = _getEquirectShader();
            }
        }
        var material = texture.isCubeTexture ? _cubemapShader : _equirectShader;
        scene.add(new Mesh(_lodPlanes[0], material));
        var uniforms = material.uniforms;
        uniforms['envMap'].value = texture;
        if (!texture.isCubeTexture) {
            uniforms['texelSize'].value.set(1.0 / texture.image.width, 1.0 / texture.image.height);
        }
        uniforms['inputEncoding'].value = ENCODINGS[texture.encoding];
        uniforms['outputEncoding'].value = ENCODINGS[texture.encoding];
        _setViewport(cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX);
        _renderer.setRenderTarget(cubeUVRenderTarget);
        _renderer.render(scene, _flatCamera);
    }
    function _compileMaterial(material) {
        var tmpScene = new Scene();
        tmpScene.add(new Mesh(_lodPlanes[0], material));
        _renderer.compile(tmpScene, _flatCamera);
    }
    function _createRenderTarget(params) {
        var cubeUVRenderTarget = new WebGLRenderTarget(3 * SIZE_MAX, 3 * SIZE_MAX, params);
        cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
        cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';
        cubeUVRenderTarget.scissorTest = true;
        return cubeUVRenderTarget;
    }
    function _setViewport(target, x, y, width, height) {
        target.viewport.set(x, y, width, height);
        target.scissor.set(x, y, width, height);
    }
    function _applyPMREM(cubeUVRenderTarget) {
        var autoClear = _renderer.autoClear;
        _renderer.autoClear = false;
        for (var i = 1; i < TOTAL_LODS; i++) {
            var sigma = Math.sqrt(_sigmas[i] * _sigmas[i] -
                _sigmas[i - 1] * _sigmas[i - 1]);
            var poleAxis = _axisDirections[(i - 1) % _axisDirections.length];
            _blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);
        }
        _renderer.autoClear = autoClear;
    }
    /**
     * This is a two-pass Gaussian blur for a cubemap. Normally this is done
     * vertically and horizontally, but this breaks down on a cube. Here we apply
     * the blur latitudinally (around the poles), and then longitudinally (towards
     * the poles) to approximate the orthogonally-separable blur. It is least
     * accurate at the poles, but still does a decent job.
     */
    function _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
        _halfBlur(cubeUVRenderTarget, _pingPongRenderTarget, lodIn, lodOut, sigma, 'latitudinal', poleAxis);
        _halfBlur(_pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, 'longitudinal', poleAxis);
    }
    function _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
        if (direction !== 'latitudinal' && direction !== 'longitudinal') {
            console.error('blur direction must be either latitudinal or longitudinal!');
        }
        // Number of standard deviations at which to cut off the discrete approximation.
        var STANDARD_DEVIATIONS = 3;
        var blurScene = new Scene();
        blurScene.add(new Mesh(_lodPlanes[lodOut], _blurMaterial));
        var blurUniforms = _blurMaterial.uniforms;
        var pixels = _sizeLods[lodIn] - 1;
        var radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
        var sigmaPixels = sigmaRadians / radiansPerPixel;
        var samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
        if (samples > MAX_SAMPLES) {
            console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
        }
        var weights = [];
        var sum = 0;
        for (var i = 0; i < MAX_SAMPLES; ++i) {
            var x = i / sigmaPixels;
            var weight = Math.exp(-x * x / 2);
            weights.push(weight);
            if (i == 0) {
                sum += weight;
            }
            else if (i < samples) {
                sum += 2 * weight;
            }
        }
        for (var i = 0; i < weights.length; i++) {
            weights[i] = weights[i] / sum;
        }
        blurUniforms['envMap'].value = targetIn.texture;
        blurUniforms['samples'].value = samples;
        blurUniforms['weights'].value = weights;
        blurUniforms['latitudinal'].value = direction === 'latitudinal';
        if (poleAxis) {
            blurUniforms['poleAxis'].value = poleAxis;
        }
        blurUniforms['dTheta'].value = radiansPerPixel;
        blurUniforms['mipInt'].value = LOD_MAX - lodIn;
        blurUniforms['inputEncoding'].value = ENCODINGS[targetIn.texture.encoding];
        blurUniforms['outputEncoding'].value = ENCODINGS[targetIn.texture.encoding];
        var outputSize = _sizeLods[lodOut];
        var x = 3 * Math.max(0, SIZE_MAX - 2 * outputSize);
        var y = (lodOut === 0 ? 0 : 2 * SIZE_MAX) +
            2 * outputSize *
                (lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0);
        _setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);
        _renderer.setRenderTarget(targetOut);
        _renderer.render(blurScene, _flatCamera);
    }
    function _getBlurShader(maxSamples) {
        var weights = new Float32Array(maxSamples);
        var poleAxis = new Vector3(0, 1, 0);
        var shaderMaterial = new RawShaderMaterial({
            defines: { 'n': maxSamples },
            uniforms: {
                'envMap': { value: null },
                'samples': { value: 1 },
                'weights': { value: weights },
                'latitudinal': { value: false },
                'dTheta': { value: 0 },
                'mipInt': { value: 0 },
                'poleAxis': { value: poleAxis },
                'inputEncoding': { value: ENCODINGS[LinearEncoding] },
                'outputEncoding': { value: ENCODINGS[LinearEncoding] }
            },
            vertexShader: _getCommonVertexShader(),
            fragmentShader: `
precision mediump float;
precision mediump int;
varying vec3 vOutputDirection;
uniform sampler2D envMap;
uniform int samples;
uniform float weights[n];
uniform bool latitudinal;
uniform float dTheta;
uniform float mipInt;
uniform vec3 poleAxis;

${_getEncodings()}

#define ENVMAP_TYPE_CUBE_UV
#include <cube_uv_reflection_fragment>

void main() {
	gl_FragColor = vec4(0.0);
	for (int i = 0; i < n; i++) {
		if (i >= samples)
			break;
		for (int dir = -1; dir < 2; dir += 2) {
			if (i == 0 && dir == 1)
				continue;
			vec3 axis = latitudinal ? poleAxis : cross(poleAxis, vOutputDirection);
			if (all(equal(axis, vec3(0.0))))
				axis = cross(vec3(0.0, 1.0, 0.0), vOutputDirection);
			axis = normalize(axis);
			float theta = dTheta * float(dir * i);
			float cosTheta = cos(theta);
			// Rodrigues' axis-angle rotation
			vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross(axis, vOutputDirection) * sin(theta)
					+ axis * dot(axis, vOutputDirection) * (1.0 - cosTheta);
			gl_FragColor.rgb +=
					weights[i] * bilinearCubeUV(envMap, sampleDirection, mipInt);
		}
	}
	gl_FragColor = linearToOutputTexel(gl_FragColor);
}
		`,
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });
        shaderMaterial.type = 'SphericalGaussianBlur';
        return shaderMaterial;
    }
    function _getEquirectShader() {
        var texelSize = new Vector2(1, 1);
        var shaderMaterial = new RawShaderMaterial({
            uniforms: {
                'envMap': { value: null },
                'texelSize': { value: texelSize },
                'inputEncoding': { value: ENCODINGS[LinearEncoding] },
                'outputEncoding': { value: ENCODINGS[LinearEncoding] }
            },
            vertexShader: _getCommonVertexShader(),
            fragmentShader: `
precision mediump float;
precision mediump int;
varying vec3 vOutputDirection;
uniform sampler2D envMap;
uniform vec2 texelSize;

${_getEncodings()}

#define RECIPROCAL_PI 0.31830988618
#define RECIPROCAL_PI2 0.15915494

void main() {
	gl_FragColor = vec4(0.0);
	vec3 outputDirection = normalize(vOutputDirection);
	vec2 uv;
	uv.y = asin(clamp(outputDirection.y, -1.0, 1.0)) * RECIPROCAL_PI + 0.5;
	uv.x = atan(outputDirection.z, outputDirection.x) * RECIPROCAL_PI2 + 0.5;
	vec2 f = fract(uv / texelSize - 0.5);
	uv -= f * texelSize;
	vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
	uv.x += texelSize.x;
	vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
	uv.y += texelSize.y;
	vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
	uv.x -= texelSize.x;
	vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
	vec3 tm = mix(tl, tr, f.x);
	vec3 bm = mix(bl, br, f.x);
	gl_FragColor.rgb = mix(tm, bm, f.y);
	gl_FragColor = linearToOutputTexel(gl_FragColor);
}
		`,
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });
        shaderMaterial.type = 'EquirectangularToCubeUV';
        return shaderMaterial;
    }
    function _getCubemapShader() {
        var shaderMaterial = new RawShaderMaterial({
            uniforms: {
                'envMap': { value: null },
                'inputEncoding': { value: ENCODINGS[LinearEncoding] },
                'outputEncoding': { value: ENCODINGS[LinearEncoding] }
            },
            vertexShader: _getCommonVertexShader(),
            fragmentShader: `
precision mediump float;
precision mediump int;
varying vec3 vOutputDirection;
uniform samplerCube envMap;

${_getEncodings()}

void main() {
	gl_FragColor = vec4(0.0);
	gl_FragColor.rgb = envMapTexelToLinear(textureCube(envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ))).rgb;
	gl_FragColor = linearToOutputTexel(gl_FragColor);
}
		`,
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });
        shaderMaterial.type = 'CubemapToCubeUV';
        return shaderMaterial;
    }
    function _getCommonVertexShader() {
        return `
precision mediump float;
precision mediump int;
attribute vec3 position;
attribute vec2 uv;
attribute float faceIndex;
varying vec3 vOutputDirection;
vec3 getDirection(vec2 uv, float face) {
	uv = 2.0 * uv - 1.0;
	vec3 direction = vec3(uv, 1.0);
	if (face == 0.0) {
		direction = direction.zyx;
		direction.z *= -1.0;
	} else if (face == 1.0) {
		direction = direction.xzy;
		direction.z *= -1.0;
	} else if (face == 3.0) {
		direction = direction.zyx;
		direction.x *= -1.0;
	} else if (face == 4.0) {
		direction = direction.xzy;
		direction.y *= -1.0;
	} else if (face == 5.0) {
		direction.xz *= -1.0;
	}
	return direction;
}
void main() {
	vOutputDirection = getDirection(uv, faceIndex);
	gl_Position = vec4( position, 1.0 );
}
	`;
    }
    function _getEncodings() {
        return `
uniform int inputEncoding;
uniform int outputEncoding;

#include <encodings_pars_fragment>

vec4 inputTexelToLinear(vec4 value){
	if(inputEncoding == 0){
		return value;
	}else if(inputEncoding == 1){
		return sRGBToLinear(value);
	}else if(inputEncoding == 2){
		return RGBEToLinear(value);
	}else if(inputEncoding == 3){
		return RGBMToLinear(value, 7.0);
	}else if(inputEncoding == 4){
		return RGBMToLinear(value, 16.0);
	}else if(inputEncoding == 5){
		return RGBDToLinear(value, 256.0);
	}else{
		return GammaToLinear(value, 2.2);
	}
}

vec4 linearToOutputTexel(vec4 value){
	if(outputEncoding == 0){
		return value;
	}else if(outputEncoding == 1){
		return LinearTosRGB(value);
	}else if(outputEncoding == 2){
		return LinearToRGBE(value);
	}else if(outputEncoding == 3){
		return LinearToRGBM(value, 7.0);
	}else if(outputEncoding == 4){
		return LinearToRGBM(value, 16.0);
	}else if(outputEncoding == 5){
		return LinearToRGBD(value, 256.0);
	}else{
		return LinearToGamma(value, 2.2);
	}
}

vec4 envMapTexelToLinear(vec4 color) {
	return inputTexelToLinear(color);
}
	`;
    }
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    function Face4(a, b, c, d, normal, color, materialIndex) {
        console.warn('THREE.Face4 has been removed. A THREE.Face3 will be created instead.');
        return new Face3(a, b, c, normal, color, materialIndex);
    }
    exports_14("Face4", Face4);
    function MeshFaceMaterial(materials) {
        console.warn('THREE.MeshFaceMaterial has been removed. Use an Array instead.');
        return materials;
    }
    exports_14("MeshFaceMaterial", MeshFaceMaterial);
    function MultiMaterial(materials) {
        if (materials === undefined)
            materials = [];
        console.warn('THREE.MultiMaterial has been removed. Use an Array instead.');
        materials.isMultiMaterial = true;
        materials.materials = materials;
        materials.clone = function () {
            return materials.slice();
        };
        return materials;
    }
    exports_14("MultiMaterial", MultiMaterial);
    function PointCloud(geometry, material) {
        console.warn('THREE.PointCloud has been renamed to THREE.Points.');
        return new Points(geometry, material);
    }
    exports_14("PointCloud", PointCloud);
    function Particle(material) {
        console.warn('THREE.Particle has been renamed to THREE.Sprite.');
        return new Sprite(material);
    }
    exports_14("Particle", Particle);
    function ParticleSystem(geometry, material) {
        console.warn('THREE.ParticleSystem has been renamed to THREE.Points.');
        return new Points(geometry, material);
    }
    exports_14("ParticleSystem", ParticleSystem);
    function PointCloudMaterial(parameters) {
        console.warn('THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.');
        return new PointsMaterial(parameters);
    }
    exports_14("PointCloudMaterial", PointCloudMaterial);
    function ParticleBasicMaterial(parameters) {
        console.warn('THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.');
        return new PointsMaterial(parameters);
    }
    exports_14("ParticleBasicMaterial", ParticleBasicMaterial);
    function ParticleSystemMaterial(parameters) {
        console.warn('THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.');
        return new PointsMaterial(parameters);
    }
    exports_14("ParticleSystemMaterial", ParticleSystemMaterial);
    function Vertex(x, y, z) {
        console.warn('THREE.Vertex has been removed. Use THREE.Vector3 instead.');
        return new Vector3(x, y, z);
    }
    exports_14("Vertex", Vertex);
    //
    function DynamicBufferAttribute(array, itemSize) {
        console.warn('THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.');
        return new BufferAttribute(array, itemSize).setUsage(DynamicDrawUsage);
    }
    exports_14("DynamicBufferAttribute", DynamicBufferAttribute);
    function Int8Attribute(array, itemSize) {
        console.warn('THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.');
        return new Int8BufferAttribute(array, itemSize);
    }
    exports_14("Int8Attribute", Int8Attribute);
    function Uint8Attribute(array, itemSize) {
        console.warn('THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.');
        return new Uint8BufferAttribute(array, itemSize);
    }
    exports_14("Uint8Attribute", Uint8Attribute);
    function Uint8ClampedAttribute(array, itemSize) {
        console.warn('THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.');
        return new Uint8ClampedBufferAttribute(array, itemSize);
    }
    exports_14("Uint8ClampedAttribute", Uint8ClampedAttribute);
    function Int16Attribute(array, itemSize) {
        console.warn('THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.');
        return new Int16BufferAttribute(array, itemSize);
    }
    exports_14("Int16Attribute", Int16Attribute);
    function Uint16Attribute(array, itemSize) {
        console.warn('THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.');
        return new Uint16BufferAttribute(array, itemSize);
    }
    exports_14("Uint16Attribute", Uint16Attribute);
    function Int32Attribute(array, itemSize) {
        console.warn('THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.');
        return new Int32BufferAttribute(array, itemSize);
    }
    exports_14("Int32Attribute", Int32Attribute);
    function Uint32Attribute(array, itemSize) {
        console.warn('THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.');
        return new Uint32BufferAttribute(array, itemSize);
    }
    exports_14("Uint32Attribute", Uint32Attribute);
    function Float32Attribute(array, itemSize) {
        console.warn('THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.');
        return new Float32BufferAttribute(array, itemSize);
    }
    exports_14("Float32Attribute", Float32Attribute);
    function Float64Attribute(array, itemSize) {
        console.warn('THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.');
        return new Float64BufferAttribute(array, itemSize);
    }
    exports_14("Float64Attribute", Float64Attribute);
    //
    function ClosedSplineCurve3(points) {
        console.warn('THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.');
        CatmullRomCurve3.call(this, points);
        this.type = 'catmullrom';
        this.closed = true;
    }
    exports_14("ClosedSplineCurve3", ClosedSplineCurve3);
    //
    function SplineCurve3(points) {
        console.warn('THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.');
        CatmullRomCurve3.call(this, points);
        this.type = 'catmullrom';
    }
    exports_14("SplineCurve3", SplineCurve3);
    //
    function Spline(points) {
        console.warn('THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.');
        CatmullRomCurve3.call(this, points);
        this.type = 'catmullrom';
    }
    exports_14("Spline", Spline);
    //
    function AxisHelper(size) {
        console.warn('THREE.AxisHelper has been renamed to THREE.AxesHelper.');
        return new AxesHelper(size);
    }
    exports_14("AxisHelper", AxisHelper);
    function BoundingBoxHelper(object, color) {
        console.warn('THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.');
        return new BoxHelper(object, color);
    }
    exports_14("BoundingBoxHelper", BoundingBoxHelper);
    function EdgesHelper(object, hex) {
        console.warn('THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.');
        return new LineSegments(new EdgesGeometry(object.geometry), new LineBasicMaterial({ color: hex !== undefined ? hex : 0xffffff }));
    }
    exports_14("EdgesHelper", EdgesHelper);
    function WireframeHelper(object, hex) {
        console.warn('THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.');
        return new LineSegments(new WireframeGeometry(object.geometry), new LineBasicMaterial({ color: hex !== undefined ? hex : 0xffffff }));
    }
    exports_14("WireframeHelper", WireframeHelper);
    function XHRLoader(manager) {
        console.warn('THREE.XHRLoader has been renamed to THREE.FileLoader.');
        return new FileLoader(manager);
    }
    exports_14("XHRLoader", XHRLoader);
    function BinaryTextureLoader(manager) {
        console.warn('THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.');
        return new DataTextureLoader(manager);
    }
    exports_14("BinaryTextureLoader", BinaryTextureLoader);
    function WebGLRenderTargetCube(width, height, options) {
        console.warn('THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).');
        return new WebGLCubeRenderTarget(width, options);
    }
    exports_14("WebGLRenderTargetCube", WebGLRenderTargetCube);
    //
    function CanvasRenderer() {
        console.error('THREE.CanvasRenderer has been removed');
    }
    exports_14("CanvasRenderer", CanvasRenderer);
    //
    function JSONLoader() {
        console.error('THREE.JSONLoader has been removed.');
    }
    exports_14("JSONLoader", JSONLoader);
    //
    function LensFlare() {
        console.error('THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js');
    }
    exports_14("LensFlare", LensFlare);
    return {
        setters: [],
        execute: function () {
            if (Number.EPSILON === undefined) {
                Number.EPSILON = Math.pow(2, -52);
            }
            if (Number.isInteger === undefined) {
                // Missing in IE
                // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger
                Number.isInteger = function (value) {
                    return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;
                };
            }
            //
            if (Math.sign === undefined) {
                // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign
                Math.sign = function (x) {
                    return (x < 0) ? -1 : (x > 0) ? 1 : +x;
                };
            }
            if ('name' in Function.prototype === false) {
                // Missing in IE
                // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name
                Object.defineProperty(Function.prototype, 'name', {
                    get: function () {
                        return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
                    }
                });
            }
            if (Object.assign === undefined) {
                // Missing in IE
                // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
                Object.assign = function (target) {
                    if (target === undefined || target === null) {
                        throw new TypeError('Cannot convert undefined or null to object');
                    }
                    var output = Object(target);
                    for (var index = 1; index < arguments.length; index++) {
                        var source = arguments[index];
                        if (source !== undefined && source !== null) {
                            for (var nextKey in source) {
                                if (Object.prototype.hasOwnProperty.call(source, nextKey)) {
                                    output[nextKey] = source[nextKey];
                                }
                            }
                        }
                    }
                    return output;
                };
            }
            REVISION = '113';
            exports_14("REVISION", REVISION);
            MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
            exports_14("MOUSE", MOUSE);
            TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };
            exports_14("TOUCH", TOUCH);
            CullFaceNone = 0;
            exports_14("CullFaceNone", CullFaceNone);
            CullFaceBack = 1;
            exports_14("CullFaceBack", CullFaceBack);
            CullFaceFront = 2;
            exports_14("CullFaceFront", CullFaceFront);
            CullFaceFrontBack = 3;
            exports_14("CullFaceFrontBack", CullFaceFrontBack);
            FrontFaceDirectionCW = 0;
            exports_14("FrontFaceDirectionCW", FrontFaceDirectionCW);
            FrontFaceDirectionCCW = 1;
            exports_14("FrontFaceDirectionCCW", FrontFaceDirectionCCW);
            BasicShadowMap = 0;
            exports_14("BasicShadowMap", BasicShadowMap);
            PCFShadowMap = 1;
            exports_14("PCFShadowMap", PCFShadowMap);
            PCFSoftShadowMap = 2;
            exports_14("PCFSoftShadowMap", PCFSoftShadowMap);
            VSMShadowMap = 3;
            exports_14("VSMShadowMap", VSMShadowMap);
            FrontSide = 0;
            exports_14("FrontSide", FrontSide);
            BackSide = 1;
            exports_14("BackSide", BackSide);
            DoubleSide = 2;
            exports_14("DoubleSide", DoubleSide);
            FlatShading = 1;
            exports_14("FlatShading", FlatShading);
            SmoothShading = 2;
            exports_14("SmoothShading", SmoothShading);
            NoColors = 0;
            exports_14("NoColors", NoColors);
            FaceColors = 1;
            exports_14("FaceColors", FaceColors);
            VertexColors = 2;
            exports_14("VertexColors", VertexColors);
            NoBlending = 0;
            exports_14("NoBlending", NoBlending);
            NormalBlending = 1;
            exports_14("NormalBlending", NormalBlending);
            AdditiveBlending = 2;
            exports_14("AdditiveBlending", AdditiveBlending);
            SubtractiveBlending = 3;
            exports_14("SubtractiveBlending", SubtractiveBlending);
            MultiplyBlending = 4;
            exports_14("MultiplyBlending", MultiplyBlending);
            CustomBlending = 5;
            exports_14("CustomBlending", CustomBlending);
            AddEquation = 100;
            exports_14("AddEquation", AddEquation);
            SubtractEquation = 101;
            exports_14("SubtractEquation", SubtractEquation);
            ReverseSubtractEquation = 102;
            exports_14("ReverseSubtractEquation", ReverseSubtractEquation);
            MinEquation = 103;
            exports_14("MinEquation", MinEquation);
            MaxEquation = 104;
            exports_14("MaxEquation", MaxEquation);
            ZeroFactor = 200;
            exports_14("ZeroFactor", ZeroFactor);
            OneFactor = 201;
            exports_14("OneFactor", OneFactor);
            SrcColorFactor = 202;
            exports_14("SrcColorFactor", SrcColorFactor);
            OneMinusSrcColorFactor = 203;
            exports_14("OneMinusSrcColorFactor", OneMinusSrcColorFactor);
            SrcAlphaFactor = 204;
            exports_14("SrcAlphaFactor", SrcAlphaFactor);
            OneMinusSrcAlphaFactor = 205;
            exports_14("OneMinusSrcAlphaFactor", OneMinusSrcAlphaFactor);
            DstAlphaFactor = 206;
            exports_14("DstAlphaFactor", DstAlphaFactor);
            OneMinusDstAlphaFactor = 207;
            exports_14("OneMinusDstAlphaFactor", OneMinusDstAlphaFactor);
            DstColorFactor = 208;
            exports_14("DstColorFactor", DstColorFactor);
            OneMinusDstColorFactor = 209;
            exports_14("OneMinusDstColorFactor", OneMinusDstColorFactor);
            SrcAlphaSaturateFactor = 210;
            exports_14("SrcAlphaSaturateFactor", SrcAlphaSaturateFactor);
            NeverDepth = 0;
            exports_14("NeverDepth", NeverDepth);
            AlwaysDepth = 1;
            exports_14("AlwaysDepth", AlwaysDepth);
            LessDepth = 2;
            exports_14("LessDepth", LessDepth);
            LessEqualDepth = 3;
            exports_14("LessEqualDepth", LessEqualDepth);
            EqualDepth = 4;
            exports_14("EqualDepth", EqualDepth);
            GreaterEqualDepth = 5;
            exports_14("GreaterEqualDepth", GreaterEqualDepth);
            GreaterDepth = 6;
            exports_14("GreaterDepth", GreaterDepth);
            NotEqualDepth = 7;
            exports_14("NotEqualDepth", NotEqualDepth);
            MultiplyOperation = 0;
            exports_14("MultiplyOperation", MultiplyOperation);
            MixOperation = 1;
            exports_14("MixOperation", MixOperation);
            AddOperation = 2;
            exports_14("AddOperation", AddOperation);
            NoToneMapping = 0;
            exports_14("NoToneMapping", NoToneMapping);
            LinearToneMapping = 1;
            exports_14("LinearToneMapping", LinearToneMapping);
            ReinhardToneMapping = 2;
            exports_14("ReinhardToneMapping", ReinhardToneMapping);
            Uncharted2ToneMapping = 3;
            exports_14("Uncharted2ToneMapping", Uncharted2ToneMapping);
            CineonToneMapping = 4;
            exports_14("CineonToneMapping", CineonToneMapping);
            ACESFilmicToneMapping = 5;
            exports_14("ACESFilmicToneMapping", ACESFilmicToneMapping);
            UVMapping = 300;
            exports_14("UVMapping", UVMapping);
            CubeReflectionMapping = 301;
            exports_14("CubeReflectionMapping", CubeReflectionMapping);
            CubeRefractionMapping = 302;
            exports_14("CubeRefractionMapping", CubeRefractionMapping);
            EquirectangularReflectionMapping = 303;
            exports_14("EquirectangularReflectionMapping", EquirectangularReflectionMapping);
            EquirectangularRefractionMapping = 304;
            exports_14("EquirectangularRefractionMapping", EquirectangularRefractionMapping);
            SphericalReflectionMapping = 305;
            exports_14("SphericalReflectionMapping", SphericalReflectionMapping);
            CubeUVReflectionMapping = 306;
            exports_14("CubeUVReflectionMapping", CubeUVReflectionMapping);
            CubeUVRefractionMapping = 307;
            exports_14("CubeUVRefractionMapping", CubeUVRefractionMapping);
            RepeatWrapping = 1000;
            exports_14("RepeatWrapping", RepeatWrapping);
            ClampToEdgeWrapping = 1001;
            exports_14("ClampToEdgeWrapping", ClampToEdgeWrapping);
            MirroredRepeatWrapping = 1002;
            exports_14("MirroredRepeatWrapping", MirroredRepeatWrapping);
            NearestFilter = 1003;
            exports_14("NearestFilter", NearestFilter);
            NearestMipmapNearestFilter = 1004;
            exports_14("NearestMipmapNearestFilter", NearestMipmapNearestFilter);
            NearestMipMapNearestFilter = 1004;
            exports_14("NearestMipMapNearestFilter", NearestMipMapNearestFilter);
            NearestMipmapLinearFilter = 1005;
            exports_14("NearestMipmapLinearFilter", NearestMipmapLinearFilter);
            NearestMipMapLinearFilter = 1005;
            exports_14("NearestMipMapLinearFilter", NearestMipMapLinearFilter);
            LinearFilter = 1006;
            exports_14("LinearFilter", LinearFilter);
            LinearMipmapNearestFilter = 1007;
            exports_14("LinearMipmapNearestFilter", LinearMipmapNearestFilter);
            LinearMipMapNearestFilter = 1007;
            exports_14("LinearMipMapNearestFilter", LinearMipMapNearestFilter);
            LinearMipmapLinearFilter = 1008;
            exports_14("LinearMipmapLinearFilter", LinearMipmapLinearFilter);
            LinearMipMapLinearFilter = 1008;
            exports_14("LinearMipMapLinearFilter", LinearMipMapLinearFilter);
            UnsignedByteType = 1009;
            exports_14("UnsignedByteType", UnsignedByteType);
            ByteType = 1010;
            exports_14("ByteType", ByteType);
            ShortType = 1011;
            exports_14("ShortType", ShortType);
            UnsignedShortType = 1012;
            exports_14("UnsignedShortType", UnsignedShortType);
            IntType = 1013;
            exports_14("IntType", IntType);
            UnsignedIntType = 1014;
            exports_14("UnsignedIntType", UnsignedIntType);
            FloatType = 1015;
            exports_14("FloatType", FloatType);
            HalfFloatType = 1016;
            exports_14("HalfFloatType", HalfFloatType);
            UnsignedShort4444Type = 1017;
            exports_14("UnsignedShort4444Type", UnsignedShort4444Type);
            UnsignedShort5551Type = 1018;
            exports_14("UnsignedShort5551Type", UnsignedShort5551Type);
            UnsignedShort565Type = 1019;
            exports_14("UnsignedShort565Type", UnsignedShort565Type);
            UnsignedInt248Type = 1020;
            exports_14("UnsignedInt248Type", UnsignedInt248Type);
            AlphaFormat = 1021;
            exports_14("AlphaFormat", AlphaFormat);
            RGBFormat = 1022;
            exports_14("RGBFormat", RGBFormat);
            RGBAFormat = 1023;
            exports_14("RGBAFormat", RGBAFormat);
            LuminanceFormat = 1024;
            exports_14("LuminanceFormat", LuminanceFormat);
            LuminanceAlphaFormat = 1025;
            exports_14("LuminanceAlphaFormat", LuminanceAlphaFormat);
            RGBEFormat = RGBAFormat;
            exports_14("RGBEFormat", RGBEFormat);
            DepthFormat = 1026;
            exports_14("DepthFormat", DepthFormat);
            DepthStencilFormat = 1027;
            exports_14("DepthStencilFormat", DepthStencilFormat);
            RedFormat = 1028;
            exports_14("RedFormat", RedFormat);
            RedIntegerFormat = 1029;
            exports_14("RedIntegerFormat", RedIntegerFormat);
            RGFormat = 1030;
            exports_14("RGFormat", RGFormat);
            RGIntegerFormat = 1031;
            exports_14("RGIntegerFormat", RGIntegerFormat);
            RGBIntegerFormat = 1032;
            exports_14("RGBIntegerFormat", RGBIntegerFormat);
            RGBAIntegerFormat = 1033;
            exports_14("RGBAIntegerFormat", RGBAIntegerFormat);
            RGB_S3TC_DXT1_Format = 33776;
            exports_14("RGB_S3TC_DXT1_Format", RGB_S3TC_DXT1_Format);
            RGBA_S3TC_DXT1_Format = 33777;
            exports_14("RGBA_S3TC_DXT1_Format", RGBA_S3TC_DXT1_Format);
            RGBA_S3TC_DXT3_Format = 33778;
            exports_14("RGBA_S3TC_DXT3_Format", RGBA_S3TC_DXT3_Format);
            RGBA_S3TC_DXT5_Format = 33779;
            exports_14("RGBA_S3TC_DXT5_Format", RGBA_S3TC_DXT5_Format);
            RGB_PVRTC_4BPPV1_Format = 35840;
            exports_14("RGB_PVRTC_4BPPV1_Format", RGB_PVRTC_4BPPV1_Format);
            RGB_PVRTC_2BPPV1_Format = 35841;
            exports_14("RGB_PVRTC_2BPPV1_Format", RGB_PVRTC_2BPPV1_Format);
            RGBA_PVRTC_4BPPV1_Format = 35842;
            exports_14("RGBA_PVRTC_4BPPV1_Format", RGBA_PVRTC_4BPPV1_Format);
            RGBA_PVRTC_2BPPV1_Format = 35843;
            exports_14("RGBA_PVRTC_2BPPV1_Format", RGBA_PVRTC_2BPPV1_Format);
            RGB_ETC1_Format = 36196;
            exports_14("RGB_ETC1_Format", RGB_ETC1_Format);
            RGBA_ASTC_4x4_Format = 37808;
            exports_14("RGBA_ASTC_4x4_Format", RGBA_ASTC_4x4_Format);
            RGBA_ASTC_5x4_Format = 37809;
            exports_14("RGBA_ASTC_5x4_Format", RGBA_ASTC_5x4_Format);
            RGBA_ASTC_5x5_Format = 37810;
            exports_14("RGBA_ASTC_5x5_Format", RGBA_ASTC_5x5_Format);
            RGBA_ASTC_6x5_Format = 37811;
            exports_14("RGBA_ASTC_6x5_Format", RGBA_ASTC_6x5_Format);
            RGBA_ASTC_6x6_Format = 37812;
            exports_14("RGBA_ASTC_6x6_Format", RGBA_ASTC_6x6_Format);
            RGBA_ASTC_8x5_Format = 37813;
            exports_14("RGBA_ASTC_8x5_Format", RGBA_ASTC_8x5_Format);
            RGBA_ASTC_8x6_Format = 37814;
            exports_14("RGBA_ASTC_8x6_Format", RGBA_ASTC_8x6_Format);
            RGBA_ASTC_8x8_Format = 37815;
            exports_14("RGBA_ASTC_8x8_Format", RGBA_ASTC_8x8_Format);
            RGBA_ASTC_10x5_Format = 37816;
            exports_14("RGBA_ASTC_10x5_Format", RGBA_ASTC_10x5_Format);
            RGBA_ASTC_10x6_Format = 37817;
            exports_14("RGBA_ASTC_10x6_Format", RGBA_ASTC_10x6_Format);
            RGBA_ASTC_10x8_Format = 37818;
            exports_14("RGBA_ASTC_10x8_Format", RGBA_ASTC_10x8_Format);
            RGBA_ASTC_10x10_Format = 37819;
            exports_14("RGBA_ASTC_10x10_Format", RGBA_ASTC_10x10_Format);
            RGBA_ASTC_12x10_Format = 37820;
            exports_14("RGBA_ASTC_12x10_Format", RGBA_ASTC_12x10_Format);
            RGBA_ASTC_12x12_Format = 37821;
            exports_14("RGBA_ASTC_12x12_Format", RGBA_ASTC_12x12_Format);
            LoopOnce = 2200;
            exports_14("LoopOnce", LoopOnce);
            LoopRepeat = 2201;
            exports_14("LoopRepeat", LoopRepeat);
            LoopPingPong = 2202;
            exports_14("LoopPingPong", LoopPingPong);
            InterpolateDiscrete = 2300;
            exports_14("InterpolateDiscrete", InterpolateDiscrete);
            InterpolateLinear = 2301;
            exports_14("InterpolateLinear", InterpolateLinear);
            InterpolateSmooth = 2302;
            exports_14("InterpolateSmooth", InterpolateSmooth);
            ZeroCurvatureEnding = 2400;
            exports_14("ZeroCurvatureEnding", ZeroCurvatureEnding);
            ZeroSlopeEnding = 2401;
            exports_14("ZeroSlopeEnding", ZeroSlopeEnding);
            WrapAroundEnding = 2402;
            exports_14("WrapAroundEnding", WrapAroundEnding);
            TrianglesDrawMode = 0;
            exports_14("TrianglesDrawMode", TrianglesDrawMode);
            TriangleStripDrawMode = 1;
            exports_14("TriangleStripDrawMode", TriangleStripDrawMode);
            TriangleFanDrawMode = 2;
            exports_14("TriangleFanDrawMode", TriangleFanDrawMode);
            LinearEncoding = 3000;
            exports_14("LinearEncoding", LinearEncoding);
            sRGBEncoding = 3001;
            exports_14("sRGBEncoding", sRGBEncoding);
            GammaEncoding = 3007;
            exports_14("GammaEncoding", GammaEncoding);
            RGBEEncoding = 3002;
            exports_14("RGBEEncoding", RGBEEncoding);
            LogLuvEncoding = 3003;
            exports_14("LogLuvEncoding", LogLuvEncoding);
            RGBM7Encoding = 3004;
            exports_14("RGBM7Encoding", RGBM7Encoding);
            RGBM16Encoding = 3005;
            exports_14("RGBM16Encoding", RGBM16Encoding);
            RGBDEncoding = 3006;
            exports_14("RGBDEncoding", RGBDEncoding);
            BasicDepthPacking = 3200;
            exports_14("BasicDepthPacking", BasicDepthPacking);
            RGBADepthPacking = 3201;
            exports_14("RGBADepthPacking", RGBADepthPacking);
            TangentSpaceNormalMap = 0;
            exports_14("TangentSpaceNormalMap", TangentSpaceNormalMap);
            ObjectSpaceNormalMap = 1;
            exports_14("ObjectSpaceNormalMap", ObjectSpaceNormalMap);
            ZeroStencilOp = 0;
            exports_14("ZeroStencilOp", ZeroStencilOp);
            KeepStencilOp = 7680;
            exports_14("KeepStencilOp", KeepStencilOp);
            ReplaceStencilOp = 7681;
            exports_14("ReplaceStencilOp", ReplaceStencilOp);
            IncrementStencilOp = 7682;
            exports_14("IncrementStencilOp", IncrementStencilOp);
            DecrementStencilOp = 7683;
            exports_14("DecrementStencilOp", DecrementStencilOp);
            IncrementWrapStencilOp = 34055;
            exports_14("IncrementWrapStencilOp", IncrementWrapStencilOp);
            DecrementWrapStencilOp = 34056;
            exports_14("DecrementWrapStencilOp", DecrementWrapStencilOp);
            InvertStencilOp = 5386;
            exports_14("InvertStencilOp", InvertStencilOp);
            NeverStencilFunc = 512;
            exports_14("NeverStencilFunc", NeverStencilFunc);
            LessStencilFunc = 513;
            exports_14("LessStencilFunc", LessStencilFunc);
            EqualStencilFunc = 514;
            exports_14("EqualStencilFunc", EqualStencilFunc);
            LessEqualStencilFunc = 515;
            exports_14("LessEqualStencilFunc", LessEqualStencilFunc);
            GreaterStencilFunc = 516;
            exports_14("GreaterStencilFunc", GreaterStencilFunc);
            NotEqualStencilFunc = 517;
            exports_14("NotEqualStencilFunc", NotEqualStencilFunc);
            GreaterEqualStencilFunc = 518;
            exports_14("GreaterEqualStencilFunc", GreaterEqualStencilFunc);
            AlwaysStencilFunc = 519;
            exports_14("AlwaysStencilFunc", AlwaysStencilFunc);
            StaticDrawUsage = 35044;
            exports_14("StaticDrawUsage", StaticDrawUsage);
            DynamicDrawUsage = 35048;
            exports_14("DynamicDrawUsage", DynamicDrawUsage);
            StreamDrawUsage = 35040;
            exports_14("StreamDrawUsage", StreamDrawUsage);
            StaticReadUsage = 35045;
            exports_14("StaticReadUsage", StaticReadUsage);
            DynamicReadUsage = 35049;
            exports_14("DynamicReadUsage", DynamicReadUsage);
            StreamReadUsage = 35041;
            exports_14("StreamReadUsage", StreamReadUsage);
            StaticCopyUsage = 35046;
            exports_14("StaticCopyUsage", StaticCopyUsage);
            DynamicCopyUsage = 35050;
            exports_14("DynamicCopyUsage", DynamicCopyUsage);
            StreamCopyUsage = 35042;
            exports_14("StreamCopyUsage", StreamCopyUsage);
            Object.assign(EventDispatcher.prototype, {
                addEventListener: function (type, listener) {
                    if (this._listeners === undefined)
                        this._listeners = {};
                    var listeners = this._listeners;
                    if (listeners[type] === undefined) {
                        listeners[type] = [];
                    }
                    if (listeners[type].indexOf(listener) === -1) {
                        listeners[type].push(listener);
                    }
                },
                hasEventListener: function (type, listener) {
                    if (this._listeners === undefined)
                        return false;
                    var listeners = this._listeners;
                    return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;
                },
                removeEventListener: function (type, listener) {
                    if (this._listeners === undefined)
                        return;
                    var listeners = this._listeners;
                    var listenerArray = listeners[type];
                    if (listenerArray !== undefined) {
                        var index = listenerArray.indexOf(listener);
                        if (index !== -1) {
                            listenerArray.splice(index, 1);
                        }
                    }
                },
                dispatchEvent: function (event) {
                    if (this._listeners === undefined)
                        return;
                    var listeners = this._listeners;
                    var listenerArray = listeners[event.type];
                    if (listenerArray !== undefined) {
                        event.target = this;
                        var array = listenerArray.slice(0);
                        for (var i = 0, l = array.length; i < l; i++) {
                            array[i].call(this, event);
                        }
                    }
                }
            });
            /**
             * @author alteredq / http://alteredqualia.com/
             * @author mrdoob / http://mrdoob.com/
             * @author WestLangley / http://github.com/WestLangley
             * @author thezwap
             */
            _lut = [];
            for (i = 0; i < 256; i++) {
                _lut[i] = (i < 16 ? '0' : '') + (i).toString(16);
            }
            MathUtils = {
                DEG2RAD: Math.PI / 180,
                RAD2DEG: 180 / Math.PI,
                generateUUID: function () {
                    // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
                    var d0 = Math.random() * 0xffffffff | 0;
                    var d1 = Math.random() * 0xffffffff | 0;
                    var d2 = Math.random() * 0xffffffff | 0;
                    var d3 = Math.random() * 0xffffffff | 0;
                    var uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + '-' +
                        _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + '-' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + '-' +
                        _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + '-' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] +
                        _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff];
                    // .toUpperCase() here flattens concatenated strings to save heap memory space.
                    return uuid.toUpperCase();
                },
                clamp: function (value, min, max) {
                    return Math.max(min, Math.min(max, value));
                },
                // compute euclidian modulo of m % n
                // https://en.wikipedia.org/wiki/Modulo_operation
                euclideanModulo: function (n, m) {
                    return ((n % m) + m) % m;
                },
                // Linear mapping from range <a1, a2> to range <b1, b2>
                mapLinear: function (x, a1, a2, b1, b2) {
                    return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
                },
                // https://en.wikipedia.org/wiki/Linear_interpolation
                lerp: function (x, y, t) {
                    return (1 - t) * x + t * y;
                },
                // http://en.wikipedia.org/wiki/Smoothstep
                smoothstep: function (x, min, max) {
                    if (x <= min)
                        return 0;
                    if (x >= max)
                        return 1;
                    x = (x - min) / (max - min);
                    return x * x * (3 - 2 * x);
                },
                smootherstep: function (x, min, max) {
                    if (x <= min)
                        return 0;
                    if (x >= max)
                        return 1;
                    x = (x - min) / (max - min);
                    return x * x * x * (x * (x * 6 - 15) + 10);
                },
                // Random integer from <low, high> interval
                randInt: function (low, high) {
                    return low + Math.floor(Math.random() * (high - low + 1));
                },
                // Random float from <low, high> interval
                randFloat: function (low, high) {
                    return low + Math.random() * (high - low);
                },
                // Random float from <-range/2, range/2> interval
                randFloatSpread: function (range) {
                    return range * (0.5 - Math.random());
                },
                degToRad: function (degrees) {
                    return degrees * MathUtils.DEG2RAD;
                },
                radToDeg: function (radians) {
                    return radians * MathUtils.RAD2DEG;
                },
                isPowerOfTwo: function (value) {
                    return (value & (value - 1)) === 0 && value !== 0;
                },
                ceilPowerOfTwo: function (value) {
                    return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
                },
                floorPowerOfTwo: function (value) {
                    return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
                },
                setQuaternionFromProperEuler: function (q, a, b, c, order) {
                    // Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles
                    // rotations are applied to the axes in the order specified by 'order'
                    // rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
                    // angles are in radians
                    var cos = Math.cos;
                    var sin = Math.sin;
                    var c2 = cos(b / 2);
                    var s2 = sin(b / 2);
                    var c13 = cos((a + c) / 2);
                    var s13 = sin((a + c) / 2);
                    var c1_3 = cos((a - c) / 2);
                    var s1_3 = sin((a - c) / 2);
                    var c3_1 = cos((c - a) / 2);
                    var s3_1 = sin((c - a) / 2);
                    if (order === 'XYX') {
                        q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
                    }
                    else if (order === 'YZY') {
                        q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
                    }
                    else if (order === 'ZXZ') {
                        q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
                    }
                    else if (order === 'XZX') {
                        q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
                    }
                    else if (order === 'YXY') {
                        q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
                    }
                    else if (order === 'ZYZ') {
                        q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
                    }
                    else {
                        console.warn('THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order.');
                    }
                }
            };
            exports_14("Math", MathUtils);
            exports_14("MathUtils", MathUtils);
            Object.defineProperties(Vector2.prototype, {
                "width": {
                    get: function () {
                        return this.x;
                    },
                    set: function (value) {
                        this.x = value;
                    }
                },
                "height": {
                    get: function () {
                        return this.y;
                    },
                    set: function (value) {
                        this.y = value;
                    }
                }
            });
            Object.assign(Vector2.prototype, {
                isVector2: true,
                set: function (x, y) {
                    this.x = x;
                    this.y = y;
                    return this;
                },
                setScalar: function (scalar) {
                    this.x = scalar;
                    this.y = scalar;
                    return this;
                },
                setX: function (x) {
                    this.x = x;
                    return this;
                },
                setY: function (y) {
                    this.y = y;
                    return this;
                },
                setComponent: function (index, value) {
                    switch (index) {
                        case 0:
                            this.x = value;
                            break;
                        case 1:
                            this.y = value;
                            break;
                        default: throw new Error('index is out of range: ' + index);
                    }
                    return this;
                },
                getComponent: function (index) {
                    switch (index) {
                        case 0: return this.x;
                        case 1: return this.y;
                        default: throw new Error('index is out of range: ' + index);
                    }
                },
                clone: function () {
                    return new this.constructor(this.x, this.y);
                },
                copy: function (v) {
                    this.x = v.x;
                    this.y = v.y;
                    return this;
                },
                add: function (v, w) {
                    if (w !== undefined) {
                        console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
                        return this.addVectors(v, w);
                    }
                    this.x += v.x;
                    this.y += v.y;
                    return this;
                },
                addScalar: function (s) {
                    this.x += s;
                    this.y += s;
                    return this;
                },
                addVectors: function (a, b) {
                    this.x = a.x + b.x;
                    this.y = a.y + b.y;
                    return this;
                },
                addScaledVector: function (v, s) {
                    this.x += v.x * s;
                    this.y += v.y * s;
                    return this;
                },
                sub: function (v, w) {
                    if (w !== undefined) {
                        console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
                        return this.subVectors(v, w);
                    }
                    this.x -= v.x;
                    this.y -= v.y;
                    return this;
                },
                subScalar: function (s) {
                    this.x -= s;
                    this.y -= s;
                    return this;
                },
                subVectors: function (a, b) {
                    this.x = a.x - b.x;
                    this.y = a.y - b.y;
                    return this;
                },
                multiply: function (v) {
                    this.x *= v.x;
                    this.y *= v.y;
                    return this;
                },
                multiplyScalar: function (scalar) {
                    this.x *= scalar;
                    this.y *= scalar;
                    return this;
                },
                divide: function (v) {
                    this.x /= v.x;
                    this.y /= v.y;
                    return this;
                },
                divideScalar: function (scalar) {
                    return this.multiplyScalar(1 / scalar);
                },
                applyMatrix3: function (m) {
                    var x = this.x, y = this.y;
                    var e = m.elements;
                    this.x = e[0] * x + e[3] * y + e[6];
                    this.y = e[1] * x + e[4] * y + e[7];
                    return this;
                },
                min: function (v) {
                    this.x = Math.min(this.x, v.x);
                    this.y = Math.min(this.y, v.y);
                    return this;
                },
                max: function (v) {
                    this.x = Math.max(this.x, v.x);
                    this.y = Math.max(this.y, v.y);
                    return this;
                },
                clamp: function (min, max) {
                    // assumes min < max, componentwise
                    this.x = Math.max(min.x, Math.min(max.x, this.x));
                    this.y = Math.max(min.y, Math.min(max.y, this.y));
                    return this;
                },
                clampScalar: function (minVal, maxVal) {
                    this.x = Math.max(minVal, Math.min(maxVal, this.x));
                    this.y = Math.max(minVal, Math.min(maxVal, this.y));
                    return this;
                },
                clampLength: function (min, max) {
                    var length = this.length();
                    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
                },
                floor: function () {
                    this.x = Math.floor(this.x);
                    this.y = Math.floor(this.y);
                    return this;
                },
                ceil: function () {
                    this.x = Math.ceil(this.x);
                    this.y = Math.ceil(this.y);
                    return this;
                },
                round: function () {
                    this.x = Math.round(this.x);
                    this.y = Math.round(this.y);
                    return this;
                },
                roundToZero: function () {
                    this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x);
                    this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y);
                    return this;
                },
                negate: function () {
                    this.x = -this.x;
                    this.y = -this.y;
                    return this;
                },
                dot: function (v) {
                    return this.x * v.x + this.y * v.y;
                },
                cross: function (v) {
                    return this.x * v.y - this.y * v.x;
                },
                lengthSq: function () {
                    return this.x * this.x + this.y * this.y;
                },
                length: function () {
                    return Math.sqrt(this.x * this.x + this.y * this.y);
                },
                manhattanLength: function () {
                    return Math.abs(this.x) + Math.abs(this.y);
                },
                normalize: function () {
                    return this.divideScalar(this.length() || 1);
                },
                angle: function () {
                    // computes the angle in radians with respect to the positive x-axis
                    var angle = Math.atan2(this.y, this.x);
                    if (angle < 0)
                        angle += 2 * Math.PI;
                    return angle;
                },
                distanceTo: function (v) {
                    return Math.sqrt(this.distanceToSquared(v));
                },
                distanceToSquared: function (v) {
                    var dx = this.x - v.x, dy = this.y - v.y;
                    return dx * dx + dy * dy;
                },
                manhattanDistanceTo: function (v) {
                    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
                },
                setLength: function (length) {
                    return this.normalize().multiplyScalar(length);
                },
                lerp: function (v, alpha) {
                    this.x += (v.x - this.x) * alpha;
                    this.y += (v.y - this.y) * alpha;
                    return this;
                },
                lerpVectors: function (v1, v2, alpha) {
                    return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
                },
                equals: function (v) {
                    return ((v.x === this.x) && (v.y === this.y));
                },
                fromArray: function (array, offset) {
                    if (offset === undefined)
                        offset = 0;
                    this.x = array[offset];
                    this.y = array[offset + 1];
                    return this;
                },
                toArray: function (array, offset) {
                    if (array === undefined)
                        array = [];
                    if (offset === undefined)
                        offset = 0;
                    array[offset] = this.x;
                    array[offset + 1] = this.y;
                    return array;
                },
                fromBufferAttribute: function (attribute, index, offset) {
                    if (offset !== undefined) {
                        console.warn('THREE.Vector2: offset has been removed from .fromBufferAttribute().');
                    }
                    this.x = attribute.getX(index);
                    this.y = attribute.getY(index);
                    return this;
                },
                rotateAround: function (center, angle) {
                    var c = Math.cos(angle), s = Math.sin(angle);
                    var x = this.x - center.x;
                    var y = this.y - center.y;
                    this.x = x * c - y * s + center.x;
                    this.y = x * s + y * c + center.y;
                    return this;
                }
            });
            Object.assign(Matrix3.prototype, {
                isMatrix3: true,
                set: function (n11, n12, n13, n21, n22, n23, n31, n32, n33) {
                    var te = this.elements;
                    te[0] = n11;
                    te[1] = n21;
                    te[2] = n31;
                    te[3] = n12;
                    te[4] = n22;
                    te[5] = n32;
                    te[6] = n13;
                    te[7] = n23;
                    te[8] = n33;
                    return this;
                },
                identity: function () {
                    this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
                    return this;
                },
                clone: function () {
                    return new this.constructor().fromArray(this.elements);
                },
                copy: function (m) {
                    var te = this.elements;
                    var me = m.elements;
                    te[0] = me[0];
                    te[1] = me[1];
                    te[2] = me[2];
                    te[3] = me[3];
                    te[4] = me[4];
                    te[5] = me[5];
                    te[6] = me[6];
                    te[7] = me[7];
                    te[8] = me[8];
                    return this;
                },
                setFromMatrix4: function (m) {
                    var me = m.elements;
                    this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
                    return this;
                },
                multiply: function (m) {
                    return this.multiplyMatrices(this, m);
                },
                premultiply: function (m) {
                    return this.multiplyMatrices(m, this);
                },
                multiplyMatrices: function (a, b) {
                    var ae = a.elements;
                    var be = b.elements;
                    var te = this.elements;
                    var a11 = ae[0], a12 = ae[3], a13 = ae[6];
                    var a21 = ae[1], a22 = ae[4], a23 = ae[7];
                    var a31 = ae[2], a32 = ae[5], a33 = ae[8];
                    var b11 = be[0], b12 = be[3], b13 = be[6];
                    var b21 = be[1], b22 = be[4], b23 = be[7];
                    var b31 = be[2], b32 = be[5], b33 = be[8];
                    te[0] = a11 * b11 + a12 * b21 + a13 * b31;
                    te[3] = a11 * b12 + a12 * b22 + a13 * b32;
                    te[6] = a11 * b13 + a12 * b23 + a13 * b33;
                    te[1] = a21 * b11 + a22 * b21 + a23 * b31;
                    te[4] = a21 * b12 + a22 * b22 + a23 * b32;
                    te[7] = a21 * b13 + a22 * b23 + a23 * b33;
                    te[2] = a31 * b11 + a32 * b21 + a33 * b31;
                    te[5] = a31 * b12 + a32 * b22 + a33 * b32;
                    te[8] = a31 * b13 + a32 * b23 + a33 * b33;
                    return this;
                },
                multiplyScalar: function (s) {
                    var te = this.elements;
                    te[0] *= s;
                    te[3] *= s;
                    te[6] *= s;
                    te[1] *= s;
                    te[4] *= s;
                    te[7] *= s;
                    te[2] *= s;
                    te[5] *= s;
                    te[8] *= s;
                    return this;
                },
                determinant: function () {
                    var te = this.elements;
                    var a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i = te[8];
                    return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
                },
                getInverse: function (matrix, throwOnDegenerate) {
                    if (matrix && matrix.isMatrix4) {
                        console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
                    }
                    var me = matrix.elements, te = this.elements, n11 = me[0], n21 = me[1], n31 = me[2], n12 = me[3], n22 = me[4], n32 = me[5], n13 = me[6], n23 = me[7], n33 = me[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
                    if (det === 0) {
                        var msg = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";
                        if (throwOnDegenerate === true) {
                            throw new Error(msg);
                        }
                        else {
                            console.warn(msg);
                        }
                        return this.identity();
                    }
                    var detInv = 1 / det;
                    te[0] = t11 * detInv;
                    te[1] = (n31 * n23 - n33 * n21) * detInv;
                    te[2] = (n32 * n21 - n31 * n22) * detInv;
                    te[3] = t12 * detInv;
                    te[4] = (n33 * n11 - n31 * n13) * detInv;
                    te[5] = (n31 * n12 - n32 * n11) * detInv;
                    te[6] = t13 * detInv;
                    te[7] = (n21 * n13 - n23 * n11) * detInv;
                    te[8] = (n22 * n11 - n21 * n12) * detInv;
                    return this;
                },
                transpose: function () {
                    var tmp, m = this.elements;
                    tmp = m[1];
                    m[1] = m[3];
                    m[3] = tmp;
                    tmp = m[2];
                    m[2] = m[6];
                    m[6] = tmp;
                    tmp = m[5];
                    m[5] = m[7];
                    m[7] = tmp;
                    return this;
                },
                getNormalMatrix: function (matrix4) {
                    return this.setFromMatrix4(matrix4).getInverse(this).transpose();
                },
                transposeIntoArray: function (r) {
                    var m = this.elements;
                    r[0] = m[0];
                    r[1] = m[3];
                    r[2] = m[6];
                    r[3] = m[1];
                    r[4] = m[4];
                    r[5] = m[7];
                    r[6] = m[2];
                    r[7] = m[5];
                    r[8] = m[8];
                    return this;
                },
                setUvTransform: function (tx, ty, sx, sy, rotation, cx, cy) {
                    var c = Math.cos(rotation);
                    var s = Math.sin(rotation);
                    this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);
                },
                scale: function (sx, sy) {
                    var te = this.elements;
                    te[0] *= sx;
                    te[3] *= sx;
                    te[6] *= sx;
                    te[1] *= sy;
                    te[4] *= sy;
                    te[7] *= sy;
                    return this;
                },
                rotate: function (theta) {
                    var c = Math.cos(theta);
                    var s = Math.sin(theta);
                    var te = this.elements;
                    var a11 = te[0], a12 = te[3], a13 = te[6];
                    var a21 = te[1], a22 = te[4], a23 = te[7];
                    te[0] = c * a11 + s * a21;
                    te[3] = c * a12 + s * a22;
                    te[6] = c * a13 + s * a23;
                    te[1] = -s * a11 + c * a21;
                    te[4] = -s * a12 + c * a22;
                    te[7] = -s * a13 + c * a23;
                    return this;
                },
                translate: function (tx, ty) {
                    var te = this.elements;
                    te[0] += tx * te[2];
                    te[3] += tx * te[5];
                    te[6] += tx * te[8];
                    te[1] += ty * te[2];
                    te[4] += ty * te[5];
                    te[7] += ty * te[8];
                    return this;
                },
                equals: function (matrix) {
                    var te = this.elements;
                    var me = matrix.elements;
                    for (var i = 0; i < 9; i++) {
                        if (te[i] !== me[i])
                            return false;
                    }
                    return true;
                },
                fromArray: function (array, offset) {
                    if (offset === undefined)
                        offset = 0;
                    for (var i = 0; i < 9; i++) {
                        this.elements[i] = array[i + offset];
                    }
                    return this;
                },
                toArray: function (array, offset) {
                    if (array === undefined)
                        array = [];
                    if (offset === undefined)
                        offset = 0;
                    var te = this.elements;
                    array[offset] = te[0];
                    array[offset + 1] = te[1];
                    array[offset + 2] = te[2];
                    array[offset + 3] = te[3];
                    array[offset + 4] = te[4];
                    array[offset + 5] = te[5];
                    array[offset + 6] = te[6];
                    array[offset + 7] = te[7];
                    array[offset + 8] = te[8];
                    return array;
                }
            });
            ImageUtils = {
                getDataURL: function (image) {
                    var canvas;
                    if (typeof HTMLCanvasElement == 'undefined') {
                        return image.src;
                    }
                    else if (image instanceof HTMLCanvasElement) {
                        canvas = image;
                    }
                    else {
                        if (_canvas === undefined)
                            _canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
                        _canvas.width = image.width;
                        _canvas.height = image.height;
                        var context = _canvas.getContext('2d');
                        if (image instanceof ImageData) {
                            context.putImageData(image, 0, 0);
                        }
                        else {
                            context.drawImage(image, 0, 0, image.width, image.height);
                        }
                        canvas = _canvas;
                    }
                    if (canvas.width > 2048 || canvas.height > 2048) {
                        return canvas.toDataURL('image/jpeg', 0.6);
                    }
                    else {
                        return canvas.toDataURL('image/png');
                    }
                }
            };
            exports_14("ImageUtils", ImageUtils);
            /**
             * @author mrdoob / http://mrdoob.com/
             * @author alteredq / http://alteredqualia.com/
             * @author szimek / https://github.com/szimek/
             */
            textureId = 0;
            Texture.DEFAULT_IMAGE = undefined;
            Texture.DEFAULT_MAPPING = UVMapping;
            Texture.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
                constructor: Texture,
                isTexture: true,
                updateMatrix: function () {
                    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
                },
                clone: function () {
                    return new this.constructor().copy(this);
                },
                copy: function (source) {
                    this.name = source.name;
                    this.image = source.image;
                    this.mipmaps = source.mipmaps.slice(0);
                    this.mapping = source.mapping;
                    this.wrapS = source.wrapS;
                    this.wrapT = source.wrapT;
                    this.magFilter = source.magFilter;
                    this.minFilter = source.minFilter;
                    this.anisotropy = source.anisotropy;
                    this.format = source.format;
                    this.internalFormat = source.internalFormat;
                    this.type = source.type;
                    this.offset.copy(source.offset);
                    this.repeat.copy(source.repeat);
                    this.center.copy(source.center);
                    this.rotation = source.rotation;
                    this.matrixAutoUpdate = source.matrixAutoUpdate;
                    this.matrix.copy(source.matrix);
                    this.generateMipmaps = source.generateMipmaps;
                    this.premultiplyAlpha = source.premultiplyAlpha;
                    this.flipY = source.flipY;
                    this.unpackAlignment = source.unpackAlignment;
                    this.encoding = source.encoding;
                    return this;
                },
                toJSON: function (meta) {
                    var isRootObject = (meta === undefined || typeof meta === 'string');
                    if (!isRootObject && meta.textures[this.uuid] !== undefined) {
                        return meta.textures[this.uuid];
                    }
                    var output = {
                        metadata: {
                            version: 4.5,
                            type: 'Texture',
                            generator: 'Texture.toJSON'
                        },
                        uuid: this.uuid,
                        name: this.name,
                        mapping: this.mapping,
                        repeat: [this.repeat.x, this.repeat.y],
                        offset: [this.offset.x, this.offset.y],
                        center: [this.center.x, this.center.y],
                        rotation: this.rotation,
                        wrap: [this.wrapS, this.wrapT],
                        format: this.format,
                        type: this.type,
                        encoding: this.encoding,
                        minFilter: this.minFilter,
                        magFilter: this.magFilter,
                        anisotropy: this.anisotropy,
                        flipY: this.flipY,
                        premultiplyAlpha: this.premultiplyAlpha,
                        unpackAlignment: this.unpackAlignment
                    };
                    if (this.image !== undefined) {
                        // TODO: Move to THREE.Image
                        var image = this.image;
                        if (image.uuid === undefined) {
                            image.uuid = MathUtils.generateUUID(); // UGH
                        }
                        if (!isRootObject && meta.images[image.uuid] === undefined) {
                            var url;
                            if (Array.isArray(image)) {
                                // process array of images e.g. CubeTexture
                                url = [];
                                for (var i = 0, l = image.length; i < l; i++) {
                                    url.push(ImageUtils.getDataURL(image[i]));
                                }
                            }
                            else {
                                // process single image
                                url = ImageUtils.getDataURL(image);
                            }
                            meta.images[image.uuid] = {
                                uuid: image.uuid,
                                url: url
                            };
                        }
                        output.image = image.uuid;
                    }
                    if (!isRootObject) {
                        meta.textures[this.uuid] = output;
                    }
                    return output;
                },
                dispose: function () {
                    this.dispatchEvent({ type: 'dispose' });
                },
                transformUv: function (uv) {
                    if (this.mapping !== UVMapping)
                        return uv;
                    uv.applyMatrix3(this.matrix);
                    if (uv.x < 0 || uv.x > 1) {
                        switch (this.wrapS) {
                            case RepeatWrapping:
                                uv.x = uv.x - Math.floor(uv.x);
                                break;
                            case ClampToEdgeWrapping:
                                uv.x = uv.x < 0 ? 0 : 1;
                                break;
                            case MirroredRepeatWrapping:
                                if (Math.abs(Math.floor(uv.x) % 2) === 1) {
                                    uv.x = Math.ceil(uv.x) - uv.x;
                                }
                                else {
                                    uv.x = uv.x - Math.floor(uv.x);
                                }
                                break;
                        }
                    }
                    if (uv.y < 0 || uv.y > 1) {
                        switch (this.wrapT) {
                            case RepeatWrapping:
                                uv.y = uv.y - Math.floor(uv.y);
                                break;
                            case ClampToEdgeWrapping:
                                uv.y = uv.y < 0 ? 0 : 1;
                                break;
                            case MirroredRepeatWrapping:
                                if (Math.abs(Math.floor(uv.y) % 2) === 1) {
                                    uv.y = Math.ceil(uv.y) - uv.y;
                                }
                                else {
                                    uv.y = uv.y - Math.floor(uv.y);
                                }
                                break;
                        }
                    }
                    if (this.flipY) {
                        uv.y = 1 - uv.y;
                    }
                    return uv;
                }
            });
            Object.defineProperty(Texture.prototype, "needsUpdate", {
                set: function (value) {
                    if (value === true)
                        this.version++;
                }
            });
            Object.defineProperties(Vector4.prototype, {
                "width": {
                    get: function () {
                        return this.z;
                    },
                    set: function (value) {
                        this.z = value;
                    }
                },
                "height": {
                    get: function () {
                        return this.w;
                    },
                    set: function (value) {
                        this.w = value;
                    }
                }
            });
            Object.assign(Vector4.prototype, {
                isVector4: true,
                set: function (x, y, z, w) {
                    this.x = x;
                    this.y = y;
                    this.z = z;
                    this.w = w;
                    return this;
                },
                setScalar: function (scalar) {
                    this.x = scalar;
                    this.y = scalar;
                    this.z = scalar;
                    this.w = scalar;
                    return this;
                },
                setX: function (x) {
                    this.x = x;
                    return this;
                },
                setY: function (y) {
                    this.y = y;
                    return this;
                },
                setZ: function (z) {
                    this.z = z;
                    return this;
                },
                setW: function (w) {
                    this.w = w;
                    return this;
                },
                setComponent: function (index, value) {
                    switch (index) {
                        case 0:
                            this.x = value;
                            break;
                        case 1:
                            this.y = value;
                            break;
                        case 2:
                            this.z = value;
                            break;
                        case 3:
                            this.w = value;
                            break;
                        default: throw new Error('index is out of range: ' + index);
                    }
                    return this;
                },
                getComponent: function (index) {
                    switch (index) {
                        case 0: return this.x;
                        case 1: return this.y;
                        case 2: return this.z;
                        case 3: return this.w;
                        default: throw new Error('index is out of range: ' + index);
                    }
                },
                clone: function () {
                    return new this.constructor(this.x, this.y, this.z, this.w);
                },
                copy: function (v) {
                    this.x = v.x;
                    this.y = v.y;
                    this.z = v.z;
                    this.w = (v.w !== undefined) ? v.w : 1;
                    return this;
                },
                add: function (v, w) {
                    if (w !== undefined) {
                        console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
                        return this.addVectors(v, w);
                    }
                    this.x += v.x;
                    this.y += v.y;
                    this.z += v.z;
                    this.w += v.w;
                    return this;
                },
                addScalar: function (s) {
                    this.x += s;
                    this.y += s;
                    this.z += s;
                    this.w += s;
                    return this;
                },
                addVectors: function (a, b) {
                    this.x = a.x + b.x;
                    this.y = a.y + b.y;
                    this.z = a.z + b.z;
                    this.w = a.w + b.w;
                    return this;
                },
                addScaledVector: function (v, s) {
                    this.x += v.x * s;
                    this.y += v.y * s;
                    this.z += v.z * s;
                    this.w += v.w * s;
                    return this;
                },
                sub: function (v, w) {
                    if (w !== undefined) {
                        console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
                        return this.subVectors(v, w);
                    }
                    this.x -= v.x;
                    this.y -= v.y;
                    this.z -= v.z;
                    this.w -= v.w;
                    return this;
                },
                subScalar: function (s) {
                    this.x -= s;
                    this.y -= s;
                    this.z -= s;
                    this.w -= s;
                    return this;
                },
                subVectors: function (a, b) {
                    this.x = a.x - b.x;
                    this.y = a.y - b.y;
                    this.z = a.z - b.z;
                    this.w = a.w - b.w;
                    return this;
                },
                multiplyScalar: function (scalar) {
                    this.x *= scalar;
                    this.y *= scalar;
                    this.z *= scalar;
                    this.w *= scalar;
                    return this;
                },
                applyMatrix4: function (m) {
                    var x = this.x, y = this.y, z = this.z, w = this.w;
                    var e = m.elements;
                    this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
                    this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
                    this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
                    this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
                    return this;
                },
                divideScalar: function (scalar) {
                    return this.multiplyScalar(1 / scalar);
                },
                setAxisAngleFromQuaternion: function (q) {
                    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
                    // q is assumed to be normalized
                    this.w = 2 * Math.acos(q.w);
                    var s = Math.sqrt(1 - q.w * q.w);
                    if (s < 0.0001) {
                        this.x = 1;
                        this.y = 0;
                        this.z = 0;
                    }
                    else {
                        this.x = q.x / s;
                        this.y = q.y / s;
                        this.z = q.z / s;
                    }
                    return this;
                },
                setAxisAngleFromRotationMatrix: function (m) {
                    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
                    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
                    var angle, x, y, z, // variables for result
                    epsilon = 0.01, // margin to allow for rounding errors
                    epsilon2 = 0.1, // margin to distinguish between 0 and 180 degrees
                    te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
                    if ((Math.abs(m12 - m21) < epsilon) &&
                        (Math.abs(m13 - m31) < epsilon) &&
                        (Math.abs(m23 - m32) < epsilon)) {
                        // singularity found
                        // first check for identity matrix which must have +1 for all terms
                        // in leading diagonal and zero in other terms
                        if ((Math.abs(m12 + m21) < epsilon2) &&
                            (Math.abs(m13 + m31) < epsilon2) &&
                            (Math.abs(m23 + m32) < epsilon2) &&
                            (Math.abs(m11 + m22 + m33 - 3) < epsilon2)) {
                            // this singularity is identity matrix so angle = 0
                            this.set(1, 0, 0, 0);
                            return this; // zero angle, arbitrary axis
                        }
                        // otherwise this singularity is angle = 180
                        angle = Math.PI;
                        var xx = (m11 + 1) / 2;
                        var yy = (m22 + 1) / 2;
                        var zz = (m33 + 1) / 2;
                        var xy = (m12 + m21) / 4;
                        var xz = (m13 + m31) / 4;
                        var yz = (m23 + m32) / 4;
                        if ((xx > yy) && (xx > zz)) {
                            // m11 is the largest diagonal term
                            if (xx < epsilon) {
                                x = 0;
                                y = 0.707106781;
                                z = 0.707106781;
                            }
                            else {
                                x = Math.sqrt(xx);
                                y = xy / x;
                                z = xz / x;
                            }
                        }
                        else if (yy > zz) {
                            // m22 is the largest diagonal term
                            if (yy < epsilon) {
                                x = 0.707106781;
                                y = 0;
                                z = 0.707106781;
                            }
                            else {
                                y = Math.sqrt(yy);
                                x = xy / y;
                                z = yz / y;
                            }
                        }
                        else {
                            // m33 is the largest diagonal term so base result on this
                            if (zz < epsilon) {
                                x = 0.707106781;
                                y = 0.707106781;
                                z = 0;
                            }
                            else {
                                z = Math.sqrt(zz);
                                x = xz / z;
                                y = yz / z;
                            }
                        }
                        this.set(x, y, z, angle);
                        return this; // return 180 deg rotation
                    }
                    // as we have reached here there are no singularities so we can handle normally
                    var s = Math.sqrt((m32 - m23) * (m32 - m23) +
                        (m13 - m31) * (m13 - m31) +
                        (m21 - m12) * (m21 - m12)); // used to normalize
                    if (Math.abs(s) < 0.001)
                        s = 1;
                    // prevent divide by zero, should not happen if matrix is orthogonal and should be
                    // caught by singularity test above, but I've left it in just in case
                    this.x = (m32 - m23) / s;
                    this.y = (m13 - m31) / s;
                    this.z = (m21 - m12) / s;
                    this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
                    return this;
                },
                min: function (v) {
                    this.x = Math.min(this.x, v.x);
                    this.y = Math.min(this.y, v.y);
                    this.z = Math.min(this.z, v.z);
                    this.w = Math.min(this.w, v.w);
                    return this;
                },
                max: function (v) {
                    this.x = Math.max(this.x, v.x);
                    this.y = Math.max(this.y, v.y);
                    this.z = Math.max(this.z, v.z);
                    this.w = Math.max(this.w, v.w);
                    return this;
                },
                clamp: function (min, max) {
                    // assumes min < max, componentwise
                    this.x = Math.max(min.x, Math.min(max.x, this.x));
                    this.y = Math.max(min.y, Math.min(max.y, this.y));
                    this.z = Math.max(min.z, Math.min(max.z, this.z));
                    this.w = Math.max(min.w, Math.min(max.w, this.w));
                    return this;
                },
                clampScalar: function (minVal, maxVal) {
                    this.x = Math.max(minVal, Math.min(maxVal, this.x));
                    this.y = Math.max(minVal, Math.min(maxVal, this.y));
                    this.z = Math.max(minVal, Math.min(maxVal, this.z));
                    this.w = Math.max(minVal, Math.min(maxVal, this.w));
                    return this;
                },
                clampLength: function (min, max) {
                    var length = this.length();
                    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
                },
                floor: function () {
                    this.x = Math.floor(this.x);
                    this.y = Math.floor(this.y);
                    this.z = Math.floor(this.z);
                    this.w = Math.floor(this.w);
                    return this;
                },
                ceil: function () {
                    this.x = Math.ceil(this.x);
                    this.y = Math.ceil(this.y);
                    this.z = Math.ceil(this.z);
                    this.w = Math.ceil(this.w);
                    return this;
                },
                round: function () {
                    this.x = Math.round(this.x);
                    this.y = Math.round(this.y);
                    this.z = Math.round(this.z);
                    this.w = Math.round(this.w);
                    return this;
                },
                roundToZero: function () {
                    this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x);
                    this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y);
                    this.z = (this.z < 0) ? Math.ceil(this.z) : Math.floor(this.z);
                    this.w = (this.w < 0) ? Math.ceil(this.w) : Math.floor(this.w);
                    return this;
                },
                negate: function () {
                    this.x = -this.x;
                    this.y = -this.y;
                    this.z = -this.z;
                    this.w = -this.w;
                    return this;
                },
                dot: function (v) {
                    return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
                },
                lengthSq: function () {
                    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
                },
                length: function () {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
                },
                manhattanLength: function () {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
                },
                normalize: function () {
                    return this.divideScalar(this.length() || 1);
                },
                setLength: function (length) {
                    return this.normalize().multiplyScalar(length);
                },
                lerp: function (v, alpha) {
                    this.x += (v.x - this.x) * alpha;
                    this.y += (v.y - this.y) * alpha;
                    this.z += (v.z - this.z) * alpha;
                    this.w += (v.w - this.w) * alpha;
                    return this;
                },
                lerpVectors: function (v1, v2, alpha) {
                    return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
                },
                equals: function (v) {
                    return ((v.x === this.x) && (v.y === this.y) && (v.z === this.z) && (v.w === this.w));
                },
                fromArray: function (array, offset) {
                    if (offset === undefined)
                        offset = 0;
                    this.x = array[offset];
                    this.y = array[offset + 1];
                    this.z = array[offset + 2];
                    this.w = array[offset + 3];
                    return this;
                },
                toArray: function (array, offset) {
                    if (array === undefined)
                        array = [];
                    if (offset === undefined)
                        offset = 0;
                    array[offset] = this.x;
                    array[offset + 1] = this.y;
                    array[offset + 2] = this.z;
                    array[offset + 3] = this.w;
                    return array;
                },
                fromBufferAttribute: function (attribute, index, offset) {
                    if (offset !== undefined) {
                        console.warn('THREE.Vector4: offset has been removed from .fromBufferAttribute().');
                    }
                    this.x = attribute.getX(index);
                    this.y = attribute.getY(index);
                    this.z = attribute.getZ(index);
                    this.w = attribute.getW(index);
                    return this;
                }
            });
            WebGLRenderTarget.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
                constructor: WebGLRenderTarget,
                isWebGLRenderTarget: true,
                setSize: function (width, height) {
                    if (this.width !== width || this.height !== height) {
                        this.width = width;
                        this.height = height;
                        this.texture.image.width = width;
                        this.texture.image.height = height;
                        this.dispose();
                    }
                    this.viewport.set(0, 0, width, height);
                    this.scissor.set(0, 0, width, height);
                },
                clone: function () {
                    return new this.constructor().copy(this);
                },
                copy: function (source) {
                    this.width = source.width;
                    this.height = source.height;
                    this.viewport.copy(source.viewport);
                    this.texture = source.texture.clone();
                    this.depthBuffer = source.depthBuffer;
                    this.stencilBuffer = source.stencilBuffer;
                    this.depthTexture = source.depthTexture;
                    return this;
                },
                dispose: function () {
                    this.dispatchEvent({ type: 'dispose' });
                }
            });
            WebGLMultisampleRenderTarget.prototype = Object.assign(Object.create(WebGLRenderTarget.prototype), {
                constructor: WebGLMultisampleRenderTarget,
                isWebGLMultisampleRenderTarget: true,
                copy: function (source) {
                    WebGLRenderTarget.prototype.copy.call(this, source);
                    this.samples = source.samples;
                    return this;
                }
            });
            Object.assign(Quaternion, {
                slerp: function (qa, qb, qm, t) {
                    return qm.copy(qa).slerp(qb, t);
                },
                slerpFlat: function (dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
                    // fuzz-free, array-based Quaternion SLERP operation
                    var x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3], x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
                    if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
                        var s = 1 - t, cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = (cos >= 0 ? 1 : -1), sqrSin = 1 - cos * cos;
                        // Skip the Slerp for tiny steps to avoid numeric problems:
                        if (sqrSin > Number.EPSILON) {
                            var sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
                            s = Math.sin(s * len) / sin;
                            t = Math.sin(t * len) / sin;
                        }
                        var tDir = t * dir;
                        x0 = x0 * s + x1 * tDir;
                        y0 = y0 * s + y1 * tDir;
                        z0 = z0 * s + z1 * tDir;
                        w0 = w0 * s + w1 * tDir;
                        // Normalize in case we just did a lerp:
                        if (s === 1 - t) {
                            var f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
                            x0 *= f;
                            y0 *= f;
                            z0 *= f;
                            w0 *= f;
                        }
                    }
                    dst[dstOffset] = x0;
                    dst[dstOffset + 1] = y0;
                    dst[dstOffset + 2] = z0;
                    dst[dstOffset + 3] = w0;
                }
            });
            Object.defineProperties(Quaternion.prototype, {
                x: {
                    get: function () {
                        return this._x;
                    },
                    set: function (value) {
                        this._x = value;
                        this._onChangeCallback();
                    }
                },
                y: {
                    get: function () {
                        return this._y;
                    },
                    set: function (value) {
                        this._y = value;
                        this._onChangeCallback();
                    }
                },
                z: {
                    get: function () {
                        return this._z;
                    },
                    set: function (value) {
                        this._z = value;
                        this._onChangeCallback();
                    }
                },
                w: {
                    get: function () {
                        return this._w;
                    },
                    set: function (value) {
                        this._w = value;
                        this._onChangeCallback();
                    }
                }
            });
            Object.assign(Quaternion.prototype, {
                isQuaternion: true,
                set: function (x, y, z, w) {
                    this._x = x;
                    this._y = y;
                    this._z = z;
                    this._w = w;
                    this._onChangeCallback();
                    return this;
                },
                clone: function () {
                    return new this.constructor(this._x, this._y, this._z, this._w);
                },
                copy: function (quaternion) {
                    this._x = quaternion.x;
                    this._y = quaternion.y;
                    this._z = quaternion.z;
                    this._w = quaternion.w;
                    this._onChangeCallback();
                    return this;
                },
                setFromEuler: function (euler, update) {
                    if (!(euler && euler.isEuler)) {
                        throw new Error('THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.');
                    }
                    var x = euler._x, y = euler._y, z = euler._z, order = euler.order;
                    // http://www.mathworks.com/matlabcentral/fileexchange/
                    // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
                    //	content/SpinCalc.m
                    var cos = Math.cos;
                    var sin = Math.sin;
                    var c1 = cos(x / 2);
                    var c2 = cos(y / 2);
                    var c3 = cos(z / 2);
                    var s1 = sin(x / 2);
                    var s2 = sin(y / 2);
                    var s3 = sin(z / 2);
                    if (order === 'XYZ') {
                        this._x = s1 * c2 * c3 + c1 * s2 * s3;
                        this._y = c1 * s2 * c3 - s1 * c2 * s3;
                        this._z = c1 * c2 * s3 + s1 * s2 * c3;
                        this._w = c1 * c2 * c3 - s1 * s2 * s3;
                    }
                    else if (order === 'YXZ') {
                        this._x = s1 * c2 * c3 + c1 * s2 * s3;
                        this._y = c1 * s2 * c3 - s1 * c2 * s3;
                        this._z = c1 * c2 * s3 - s1 * s2 * c3;
                        this._w = c1 * c2 * c3 + s1 * s2 * s3;
                    }
                    else if (order === 'ZXY') {
                        this._x = s1 * c2 * c3 - c1 * s2 * s3;
                        this._y = c1 * s2 * c3 + s1 * c2 * s3;
                        this._z = c1 * c2 * s3 + s1 * s2 * c3;
                        this._w = c1 * c2 * c3 - s1 * s2 * s3;
                    }
                    else if (order === 'ZYX') {
                        this._x = s1 * c2 * c3 - c1 * s2 * s3;
                        this._y = c1 * s2 * c3 + s1 * c2 * s3;
                        this._z = c1 * c2 * s3 - s1 * s2 * c3;
                        this._w = c1 * c2 * c3 + s1 * s2 * s3;
                    }
                    else if (order === 'YZX') {
                        this._x = s1 * c2 * c3 + c1 * s2 * s3;
                        this._y = c1 * s2 * c3 + s1 * c2 * s3;
                        this._z = c1 * c2 * s3 - s1 * s2 * c3;
                        this._w = c1 * c2 * c3 - s1 * s2 * s3;
                    }
                    else if (order === 'XZY') {
                        this._x = s1 * c2 * c3 - c1 * s2 * s3;
                        this._y = c1 * s2 * c3 - s1 * c2 * s3;
                        this._z = c1 * c2 * s3 + s1 * s2 * c3;
                        this._w = c1 * c2 * c3 + s1 * s2 * s3;
                    }
                    if (update !== false)
                        this._onChangeCallback();
                    return this;
                },
                setFromAxisAngle: function (axis, angle) {
                    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
                    // assumes axis is normalized
                    var halfAngle = angle / 2, s = Math.sin(halfAngle);
                    this._x = axis.x * s;
                    this._y = axis.y * s;
                    this._z = axis.z * s;
                    this._w = Math.cos(halfAngle);
                    this._onChangeCallback();
                    return this;
                },
                setFromRotationMatrix: function (m) {
                    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
                    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
                    var te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33, s;
                    if (trace > 0) {
                        s = 0.5 / Math.sqrt(trace + 1.0);
                        this._w = 0.25 / s;
                        this._x = (m32 - m23) * s;
                        this._y = (m13 - m31) * s;
                        this._z = (m21 - m12) * s;
                    }
                    else if (m11 > m22 && m11 > m33) {
                        s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
                        this._w = (m32 - m23) / s;
                        this._x = 0.25 * s;
                        this._y = (m12 + m21) / s;
                        this._z = (m13 + m31) / s;
                    }
                    else if (m22 > m33) {
                        s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
                        this._w = (m13 - m31) / s;
                        this._x = (m12 + m21) / s;
                        this._y = 0.25 * s;
                        this._z = (m23 + m32) / s;
                    }
                    else {
                        s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
                        this._w = (m21 - m12) / s;
                        this._x = (m13 + m31) / s;
                        this._y = (m23 + m32) / s;
                        this._z = 0.25 * s;
                    }
                    this._onChangeCallback();
                    return this;
                },
                setFromUnitVectors: function (vFrom, vTo) {
                    // assumes direction vectors vFrom and vTo are normalized
                    var EPS = 0.000001;
                    var r = vFrom.dot(vTo) + 1;
                    if (r < EPS) {
                        r = 0;
                        if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
                            this._x = -vFrom.y;
                            this._y = vFrom.x;
                            this._z = 0;
                            this._w = r;
                        }
                        else {
                            this._x = 0;
                            this._y = -vFrom.z;
                            this._z = vFrom.y;
                            this._w = r;
                        }
                    }
                    else {
                        // crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3
                        this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
                        this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
                        this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
                        this._w = r;
                    }
                    return this.normalize();
                },
                angleTo: function (q) {
                    return 2 * Math.acos(Math.abs(MathUtils.clamp(this.dot(q), -1, 1)));
                },
                rotateTowards: function (q, step) {
                    var angle = this.angleTo(q);
                    if (angle === 0)
                        return this;
                    var t = Math.min(1, step / angle);
                    this.slerp(q, t);
                    return this;
                },
                inverse: function () {
                    // quaternion is assumed to have unit length
                    return this.conjugate();
                },
                conjugate: function () {
                    this._x *= -1;
                    this._y *= -1;
                    this._z *= -1;
                    this._onChangeCallback();
                    return this;
                },
                dot: function (v) {
                    return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
                },
                lengthSq: function () {
                    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
                },
                length: function () {
                    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
                },
                normalize: function () {
                    var l = this.length();
                    if (l === 0) {
                        this._x = 0;
                        this._y = 0;
                        this._z = 0;
                        this._w = 1;
                    }
                    else {
                        l = 1 / l;
                        this._x = this._x * l;
                        this._y = this._y * l;
                        this._z = this._z * l;
                        this._w = this._w * l;
                    }
                    this._onChangeCallback();
                    return this;
                },
                multiply: function (q, p) {
                    if (p !== undefined) {
                        console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');
                        return this.multiplyQuaternions(q, p);
                    }
                    return this.multiplyQuaternions(this, q);
                },
                premultiply: function (q) {
                    return this.multiplyQuaternions(q, this);
                },
                multiplyQuaternions: function (a, b) {
                    // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
                    var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
                    var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
                    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
                    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
                    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
                    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
                    this._onChangeCallback();
                    return this;
                },
                slerp: function (qb, t) {
                    if (t === 0)
                        return this;
                    if (t === 1)
                        return this.copy(qb);
                    var x = this._x, y = this._y, z = this._z, w = this._w;
                    // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
                    var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
                    if (cosHalfTheta < 0) {
                        this._w = -qb._w;
                        this._x = -qb._x;
                        this._y = -qb._y;
                        this._z = -qb._z;
                        cosHalfTheta = -cosHalfTheta;
                    }
                    else {
                        this.copy(qb);
                    }
                    if (cosHalfTheta >= 1.0) {
                        this._w = w;
                        this._x = x;
                        this._y = y;
                        this._z = z;
                        return this;
                    }
                    var sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;
                    if (sqrSinHalfTheta <= Number.EPSILON) {
                        var s = 1 - t;
                        this._w = s * w + t * this._w;
                        this._x = s * x + t * this._x;
                        this._y = s * y + t * this._y;
                        this._z = s * z + t * this._z;
                        this.normalize();
                        this._onChangeCallback();
                        return this;
                    }
                    var sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
                    var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
                    var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
                    this._w = (w * ratioA + this._w * ratioB);
                    this._x = (x * ratioA + this._x * ratioB);
                    this._y = (y * ratioA + this._y * ratioB);
                    this._z = (z * ratioA + this._z * ratioB);
                    this._onChangeCallback();
                    return this;
                },
                equals: function (quaternion) {
                    return (quaternion._x === this._x) && (quaternion._y === this._y) && (quaternion._z === this._z) && (quaternion._w === this._w);
                },
                fromArray: function (array, offset) {
                    if (offset === undefined)
                        offset = 0;
                    this._x = array[offset];
                    this._y = array[offset + 1];
                    this._z = array[offset + 2];
                    this._w = array[offset + 3];
                    this._onChangeCallback();
                    return this;
                },
                toArray: function (array, offset) {
                    if (array === undefined)
                        array = [];
                    if (offset === undefined)
                        offset = 0;
                    array[offset] = this._x;
                    array[offset + 1] = this._y;
                    array[offset + 2] = this._z;
                    array[offset + 3] = this._w;
                    return array;
                },
                _onChange: function (callback) {
                    this._onChangeCallback = callback;
                    return this;
                },
                _onChangeCallback: function () { }
            });
            /**
             * @author mrdoob / http://mrdoob.com/
             * @author kile / http://kile.stravaganza.org/
             * @author philogb / http://blog.thejit.org/
             * @author mikael emtinger / http://gomo.se/
             * @author egraether / http://egraether.com/
             * @author WestLangley / http://github.com/WestLangley
             */
            _vector = new Vector3();
            _quaternion = new Quaternion();
            Object.assign(Vector3.prototype, {
                isVector3: true,
                set: function (x, y, z) {
                    this.x = x;
                    this.y = y;
                    this.z = z;
                    return this;
                },
                setScalar: function (scalar) {
                    this.x = scalar;
                    this.y = scalar;
                    this.z = scalar;
                    return this;
                },
                setX: function (x) {
                    this.x = x;
                    return this;
                },
                setY: function (y) {
                    this.y = y;
                    return this;
                },
                setZ: function (z) {
                    this.z = z;
                    return this;
                },
                setComponent: function (index, value) {
                    switch (index) {
                        case 0:
                            this.x = value;
                            break;
                        case 1:
                            this.y = value;
                            break;
                        case 2:
                            this.z = value;
                            break;
                        default: throw new Error('index is out of range: ' + index);
                    }
                    return this;
                },
                getComponent: function (index) {
                    switch (index) {
                        case 0: return this.x;
                        case 1: return this.y;
                        case 2: return this.z;
                        default: throw new Error('index is out of range: ' + index);
                    }
                },
                clone: function () {
                    return new this.constructor(this.x, this.y, this.z);
                },
                copy: function (v) {
                    this.x = v.x;
                    this.y = v.y;
                    this.z = v.z;
                    return this;
                },
                add: function (v, w) {
                    if (w !== undefined) {
                        console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
                        return this.addVectors(v, w);
                    }
                    this.x += v.x;
                    this.y += v.y;
                    this.z += v.z;
                    return this;
                },
                addScalar: function (s) {
                    this.x += s;
                    this.y += s;
                    this.z += s;
                    return this;
                },
                addVectors: function (a, b) {
                    this.x = a.x + b.x;
                    this.y = a.y + b.y;
                    this.z = a.z + b.z;
                    return this;
                },
                addScaledVector: function (v, s) {
                    this.x += v.x * s;
                    this.y += v.y * s;
                    this.z += v.z * s;
                    return this;
                },
                sub: function (v, w) {
                    if (w !== undefined) {
                        console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
                        return this.subVectors(v, w);
                    }
                    this.x -= v.x;
                    this.y -= v.y;
                    this.z -= v.z;
                    return this;
                },
                subScalar: function (s) {
                    this.x -= s;
                    this.y -= s;
                    this.z -= s;
                    return this;
                },
                subVectors: function (a, b) {
                    this.x = a.x - b.x;
                    this.y = a.y - b.y;
                    this.z = a.z - b.z;
                    return this;
                },
                multiply: function (v, w) {
                    if (w !== undefined) {
                        console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');
                        return this.multiplyVectors(v, w);
                    }
                    this.x *= v.x;
                    this.y *= v.y;
                    this.z *= v.z;
                    return this;
                },
                multiplyScalar: function (scalar) {
                    this.x *= scalar;
                    this.y *= scalar;
                    this.z *= scalar;
                    return this;
                },
                multiplyVectors: function (a, b) {
                    this.x = a.x * b.x;
                    this.y = a.y * b.y;
                    this.z = a.z * b.z;
                    return this;
                },
                applyEuler: function (euler) {
                    if (!(euler && euler.isEuler)) {
                        console.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.');
                    }
                    return this.applyQuaternion(_quaternion.setFromEuler(euler));
                },
                applyAxisAngle: function (axis, angle) {
                    return this.applyQuaternion(_quaternion.setFromAxisAngle(axis, angle));
                },
                applyMatrix3: function (m) {
                    var x = this.x, y = this.y, z = this.z;
                    var e = m.elements;
                    this.x = e[0] * x + e[3] * y + e[6] * z;
                    this.y = e[1] * x + e[4] * y + e[7] * z;
                    this.z = e[2] * x + e[5] * y + e[8] * z;
                    return this;
                },
                applyNormalMatrix: function (m) {
                    return this.applyMatrix3(m).normalize();
                },
                applyMatrix4: function (m) {
                    var x = this.x, y = this.y, z = this.z;
                    var e = m.elements;
                    var w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
                    this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
                    this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
                    this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
                    return this;
                },
                applyQuaternion: function (q) {
                    var x = this.x, y = this.y, z = this.z;
                    var qx = q.x, qy = q.y, qz = q.z, qw = q.w;
                    // calculate quat * vector
                    var ix = qw * x + qy * z - qz * y;
                    var iy = qw * y + qz * x - qx * z;
                    var iz = qw * z + qx * y - qy * x;
                    var iw = -qx * x - qy * y - qz * z;
                    // calculate result * inverse quat
                    this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
                    this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
                    this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
                    return this;
                },
                project: function (camera) {
                    return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
                },
                unproject: function (camera) {
                    return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
                },
                transformDirection: function (m) {
                    // input: THREE.Matrix4 affine matrix
                    // vector interpreted as a direction
                    var x = this.x, y = this.y, z = this.z;
                    var e = m.elements;
                    this.x = e[0] * x + e[4] * y + e[8] * z;
                    this.y = e[1] * x + e[5] * y + e[9] * z;
                    this.z = e[2] * x + e[6] * y + e[10] * z;
                    return this.normalize();
                },
                divide: function (v) {
                    this.x /= v.x;
                    this.y /= v.y;
                    this.z /= v.z;
                    return this;
                },
                divideScalar: function (scalar) {
                    return this.multiplyScalar(1 / scalar);
                },
                min: function (v) {
                    this.x = Math.min(this.x, v.x);
                    this.y = Math.min(this.y, v.y);
                    this.z = Math.min(this.z, v.z);
                    return this;
                },
                max: function (v) {
                    this.x = Math.max(this.x, v.x);
                    this.y = Math.max(this.y, v.y);
                    this.z = Math.max(this.z, v.z);
                    return this;
                },
                clamp: function (min, max) {
                    // assumes min < max, componentwise
                    this.x = Math.max(min.x, Math.min(max.x, this.x));
                    this.y = Math.max(min.y, Math.min(max.y, this.y));
                    this.z = Math.max(min.z, Math.min(max.z, this.z));
                    return this;
                },
                clampScalar: function (minVal, maxVal) {
                    this.x = Math.max(minVal, Math.min(maxVal, this.x));
                    this.y = Math.max(minVal, Math.min(maxVal, this.y));
                    this.z = Math.max(minVal, Math.min(maxVal, this.z));
                    return this;
                },
                clampLength: function (min, max) {
                    var length = this.length();
                    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
                },
                floor: function () {
                    this.x = Math.floor(this.x);
                    this.y = Math.floor(this.y);
                    this.z = Math.floor(this.z);
                    return this;
                },
                ceil: function () {
                    this.x = Math.ceil(this.x);
                    this.y = Math.ceil(this.y);
                    this.z = Math.ceil(this.z);
                    return this;
                },
                round: function () {
                    this.x = Math.round(this.x);
                    this.y = Math.round(this.y);
                    this.z = Math.round(this.z);
                    return this;
                },
                roundToZero: function () {
                    this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x);
                    this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y);
                    this.z = (this.z < 0) ? Math.ceil(this.z) : Math.floor(this.z);
                    return this;
                },
                negate: function () {
                    this.x = -this.x;
                    this.y = -this.y;
                    this.z = -this.z;
                    return this;
                },
                dot: function (v) {
                    return this.x * v.x + this.y * v.y + this.z * v.z;
                },
                // TODO lengthSquared?
                lengthSq: function () {
                    return this.x * this.x + this.y * this.y + this.z * this.z;
                },
                length: function () {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
                },
                manhattanLength: function () {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
                },
                normalize: function () {
                    return this.divideScalar(this.length() || 1);
                },
                setLength: function (length) {
                    return this.normalize().multiplyScalar(length);
                },
                lerp: function (v, alpha) {
                    this.x += (v.x - this.x) * alpha;
                    this.y += (v.y - this.y) * alpha;
                    this.z += (v.z - this.z) * alpha;
                    return this;
                },
                lerpVectors: function (v1, v2, alpha) {
                    return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
                },
                cross: function (v, w) {
                    if (w !== undefined) {
                        console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');
                        return this.crossVectors(v, w);
                    }
                    return this.crossVectors(this, v);
                },
                crossVectors: function (a, b) {
                    var ax = a.x, ay = a.y, az = a.z;
                    var bx = b.x, by = b.y, bz = b.z;
                    this.x = ay * bz - az * by;
                    this.y = az * bx - ax * bz;
                    this.z = ax * by - ay * bx;
                    return this;
                },
                projectOnVector: function (v) {
                    var denominator = v.lengthSq();
                    if (denominator === 0)
                        return this.set(0, 0, 0);
                    var scalar = v.dot(this) / denominator;
                    return this.copy(v).multiplyScalar(scalar);
                },
                projectOnPlane: function (planeNormal) {
                    _vector.copy(this).projectOnVector(planeNormal);
                    return this.sub(_vector);
                },
                reflect: function (normal) {
                    // reflect incident vector off plane orthogonal to normal
                    // normal is assumed to have unit length
                    return this.sub(_vector.copy(normal).multiplyScalar(2 * this.dot(normal)));
                },
                angleTo: function (v) {
                    var denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
                    if (denominator === 0)
                        return Math.PI / 2;
                    var theta = this.dot(v) / denominator;
                    // clamp, to handle numerical problems
                    return Math.acos(MathUtils.clamp(theta, -1, 1));
                },
                distanceTo: function (v) {
                    return Math.sqrt(this.distanceToSquared(v));
                },
                distanceToSquared: function (v) {
                    var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
                    return dx * dx + dy * dy + dz * dz;
                },
                manhattanDistanceTo: function (v) {
                    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
                },
                setFromSpherical: function (s) {
                    return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
                },
                setFromSphericalCoords: function (radius, phi, theta) {
                    var sinPhiRadius = Math.sin(phi) * radius;
                    this.x = sinPhiRadius * Math.sin(theta);
                    this.y = Math.cos(phi) * radius;
                    this.z = sinPhiRadius * Math.cos(theta);
                    return this;
                },
                setFromCylindrical: function (c) {
                    return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
                },
                setFromCylindricalCoords: function (radius, theta, y) {
                    this.x = radius * Math.sin(theta);
                    this.y = y;
                    this.z = radius * Math.cos(theta);
                    return this;
                },
                setFromMatrixPosition: function (m) {
                    var e = m.elements;
                    this.x = e[12];
                    this.y = e[13];
                    this.z = e[14];
                    return this;
                },
                setFromMatrixScale: function (m) {
                    var sx = this.setFromMatrixColumn(m, 0).length();
                    var sy = this.setFromMatrixColumn(m, 1).length();
                    var sz = this.setFromMatrixColumn(m, 2).length();
                    this.x = sx;
                    this.y = sy;
                    this.z = sz;
                    return this;
                },
                setFromMatrixColumn: function (m, index) {
                    return this.fromArray(m.elements, index * 4);
                },
                setFromMatrix3Column: function (m, index) {
                    return this.fromArray(m.elements, index * 3);
                },
                equals: function (v) {
                    return ((v.x === this.x) && (v.y === this.y) && (v.z === this.z));
                },
                fromArray: function (array, offset) {
                    if (offset === undefined)
                        offset = 0;
                    this.x = array[offset];
                    this.y = array[offset + 1];
                    this.z = array[offset + 2];
                    return this;
                },
                toArray: function (array, offset) {
                    if (array === undefined)
                        array = [];
                    if (offset === undefined)
                        offset = 0;
                    array[offset] = this.x;
                    array[offset + 1] = this.y;
                    array[offset + 2] = this.z;
                    return array;
                },
                fromBufferAttribute: function (attribute, index, offset) {
                    if (offset !== undefined) {
                        console.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().');
                    }
                    this.x = attribute.getX(index);
                    this.y = attribute.getY(index);
                    this.z = attribute.getZ(index);
                    return this;
                }
            });
            _v1 = new Vector3();
            _m1 = new Matrix4();
            _zero = new Vector3(0, 0, 0);
            _one = new Vector3(1, 1, 1);
            _x = new Vector3();
            _y = new Vector3();
            _z = new Vector3();
            Object.assign(Matrix4.prototype, {
                isMatrix4: true,
                set: function (n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
                    var te = this.elements;
                    te[0] = n11;
                    te[4] = n12;
                    te[8] = n13;
                    te[12] = n14;
                    te[1] = n21;
                    te[5] = n22;
                    te[9] = n23;
                    te[13] = n24;
                    te[2] = n31;
                    te[6] = n32;
                    te[10] = n33;
                    te[14] = n34;
                    te[3] = n41;
                    te[7] = n42;
                    te[11] = n43;
                    te[15] = n44;
                    return this;
                },
                identity: function () {
                    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
                    return this;
                },
                clone: function () {
                    return new Matrix4().fromArray(this.elements);
                },
                copy: function (m) {
                    var te = this.elements;
                    var me = m.elements;
                    te[0] = me[0];
                    te[1] = me[1];
                    te[2] = me[2];
                    te[3] = me[3];
                    te[4] = me[4];
                    te[5] = me[5];
                    te[6] = me[6];
                    te[7] = me[7];
                    te[8] = me[8];
                    te[9] = me[9];
                    te[10] = me[10];
                    te[11] = me[11];
                    te[12] = me[12];
                    te[13] = me[13];
                    te[14] = me[14];
                    te[15] = me[15];
                    return this;
                },
                copyPosition: function (m) {
                    var te = this.elements, me = m.elements;
                    te[12] = me[12];
                    te[13] = me[13];
                    te[14] = me[14];
                    return this;
                },
                extractBasis: function (xAxis, yAxis, zAxis) {
                    xAxis.setFromMatrixColumn(this, 0);
                    yAxis.setFromMatrixColumn(this, 1);
                    zAxis.setFromMatrixColumn(this, 2);
                    return this;
                },
                makeBasis: function (xAxis, yAxis, zAxis) {
                    this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
                    return this;
                },
                extractRotation: function (m) {
                    // this method does not support reflection matrices
                    var te = this.elements;
                    var me = m.elements;
                    var scaleX = 1 / _v1.setFromMatrixColumn(m, 0).length();
                    var scaleY = 1 / _v1.setFromMatrixColumn(m, 1).length();
                    var scaleZ = 1 / _v1.setFromMatrixColumn(m, 2).length();
                    te[0] = me[0] * scaleX;
                    te[1] = me[1] * scaleX;
                    te[2] = me[2] * scaleX;
                    te[3] = 0;
                    te[4] = me[4] * scaleY;
                    te[5] = me[5] * scaleY;
                    te[6] = me[6] * scaleY;
                    te[7] = 0;
                    te[8] = me[8] * scaleZ;
                    te[9] = me[9] * scaleZ;
                    te[10] = me[10] * scaleZ;
                    te[11] = 0;
                    te[12] = 0;
                    te[13] = 0;
                    te[14] = 0;
                    te[15] = 1;
                    return this;
                },
                makeRotationFromEuler: function (euler) {
                    if (!(euler && euler.isEuler)) {
                        console.error('THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');
                    }
                    var te = this.elements;
                    var x = euler.x, y = euler.y, z = euler.z;
                    var a = Math.cos(x), b = Math.sin(x);
                    var c = Math.cos(y), d = Math.sin(y);
                    var e = Math.cos(z), f = Math.sin(z);
                    if (euler.order === 'XYZ') {
                        var ae = a * e, af = a * f, be = b * e, bf = b * f;
                        te[0] = c * e;
                        te[4] = -c * f;
                        te[8] = d;
                        te[1] = af + be * d;
                        te[5] = ae - bf * d;
                        te[9] = -b * c;
                        te[2] = bf - ae * d;
                        te[6] = be + af * d;
                        te[10] = a * c;
                    }
                    else if (euler.order === 'YXZ') {
                        var ce = c * e, cf = c * f, de = d * e, df = d * f;
                        te[0] = ce + df * b;
                        te[4] = de * b - cf;
                        te[8] = a * d;
                        te[1] = a * f;
                        te[5] = a * e;
                        te[9] = -b;
                        te[2] = cf * b - de;
                        te[6] = df + ce * b;
                        te[10] = a * c;
                    }
                    else if (euler.order === 'ZXY') {
                        var ce = c * e, cf = c * f, de = d * e, df = d * f;
                        te[0] = ce - df * b;
                        te[4] = -a * f;
                        te[8] = de + cf * b;
                        te[1] = cf + de * b;
                        te[5] = a * e;
                        te[9] = df - ce * b;
                        te[2] = -a * d;
                        te[6] = b;
                        te[10] = a * c;
                    }
                    else if (euler.order === 'ZYX') {
                        var ae = a * e, af = a * f, be = b * e, bf = b * f;
                        te[0] = c * e;
                        te[4] = be * d - af;
                        te[8] = ae * d + bf;
                        te[1] = c * f;
                        te[5] = bf * d + ae;
                        te[9] = af * d - be;
                        te[2] = -d;
                        te[6] = b * c;
                        te[10] = a * c;
                    }
                    else if (euler.order === 'YZX') {
                        var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
                        te[0] = c * e;
                        te[4] = bd - ac * f;
                        te[8] = bc * f + ad;
                        te[1] = f;
                        te[5] = a * e;
                        te[9] = -b * e;
                        te[2] = -d * e;
                        te[6] = ad * f + bc;
                        te[10] = ac - bd * f;
                    }
                    else if (euler.order === 'XZY') {
                        var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
                        te[0] = c * e;
                        te[4] = -f;
                        te[8] = d * e;
                        te[1] = ac * f + bd;
                        te[5] = a * e;
                        te[9] = ad * f - bc;
                        te[2] = bc * f - ad;
                        te[6] = b * e;
                        te[10] = bd * f + ac;
                    }
                    // bottom row
                    te[3] = 0;
                    te[7] = 0;
                    te[11] = 0;
                    // last column
                    te[12] = 0;
                    te[13] = 0;
                    te[14] = 0;
                    te[15] = 1;
                    return this;
                },
                makeRotationFromQuaternion: function (q) {
                    return this.compose(_zero, q, _one);
                },
                lookAt: function (eye, target, up) {
                    var te = this.elements;
                    _z.subVectors(eye, target);
                    if (_z.lengthSq() === 0) {
                        // eye and target are in the same position
                        _z.z = 1;
                    }
                    _z.normalize();
                    _x.crossVectors(up, _z);
                    if (_x.lengthSq() === 0) {
                        // up and z are parallel
                        if (Math.abs(up.z) === 1) {
                            _z.x += 0.0001;
                        }
                        else {
                            _z.z += 0.0001;
                        }
                        _z.normalize();
                        _x.crossVectors(up, _z);
                    }
                    _x.normalize();
                    _y.crossVectors(_z, _x);
                    te[0] = _x.x;
                    te[4] = _y.x;
                    te[8] = _z.x;
                    te[1] = _x.y;
                    te[5] = _y.y;
                    te[9] = _z.y;
                    te[2] = _x.z;
                    te[6] = _y.z;
                    te[10] = _z.z;
                    return this;
                },
                multiply: function (m, n) {
                    if (n !== undefined) {
                        console.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');
                        return this.multiplyMatrices(m, n);
                    }
                    return this.multiplyMatrices(this, m);
                },
                premultiply: function (m) {
                    return this.multiplyMatrices(m, this);
                },
                multiplyMatrices: function (a, b) {
                    var ae = a.elements;
                    var be = b.elements;
                    var te = this.elements;
                    var a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
                    var a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
                    var a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
                    var a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
                    var b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
                    var b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
                    var b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
                    var b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
                    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
                    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
                    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
                    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
                    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
                    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
                    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
                    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
                    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
                    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
                    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
                    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
                    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
                    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
                    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
                    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
                    return this;
                },
                multiplyScalar: function (s) {
                    var te = this.elements;
                    te[0] *= s;
                    te[4] *= s;
                    te[8] *= s;
                    te[12] *= s;
                    te[1] *= s;
                    te[5] *= s;
                    te[9] *= s;
                    te[13] *= s;
                    te[2] *= s;
                    te[6] *= s;
                    te[10] *= s;
                    te[14] *= s;
                    te[3] *= s;
                    te[7] *= s;
                    te[11] *= s;
                    te[15] *= s;
                    return this;
                },
                determinant: function () {
                    var te = this.elements;
                    var n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
                    var n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
                    var n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
                    var n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
                    //TODO: make this more efficient
                    //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )
                    return (n41 * (+n14 * n23 * n32
                        - n13 * n24 * n32
                        - n14 * n22 * n33
                        + n12 * n24 * n33
                        + n13 * n22 * n34
                        - n12 * n23 * n34) +
                        n42 * (+n11 * n23 * n34
                            - n11 * n24 * n33
                            + n14 * n21 * n33
                            - n13 * n21 * n34
                            + n13 * n24 * n31
                            - n14 * n23 * n31) +
                        n43 * (+n11 * n24 * n32
                            - n11 * n22 * n34
                            - n14 * n21 * n32
                            + n12 * n21 * n34
                            + n14 * n22 * n31
                            - n12 * n24 * n31) +
                        n44 * (-n13 * n22 * n31
                            - n11 * n23 * n32
                            + n11 * n22 * n33
                            + n13 * n21 * n32
                            - n12 * n21 * n33
                            + n12 * n23 * n31));
                },
                transpose: function () {
                    var te = this.elements;
                    var tmp;
                    tmp = te[1];
                    te[1] = te[4];
                    te[4] = tmp;
                    tmp = te[2];
                    te[2] = te[8];
                    te[8] = tmp;
                    tmp = te[6];
                    te[6] = te[9];
                    te[9] = tmp;
                    tmp = te[3];
                    te[3] = te[12];
                    te[12] = tmp;
                    tmp = te[7];
                    te[7] = te[13];
                    te[13] = tmp;
                    tmp = te[11];
                    te[11] = te[14];
                    te[14] = tmp;
                    return this;
                },
                setPosition: function (x, y, z) {
                    var te = this.elements;
                    if (x.isVector3) {
                        te[12] = x.x;
                        te[13] = x.y;
                        te[14] = x.z;
                    }
                    else {
                        te[12] = x;
                        te[13] = y;
                        te[14] = z;
                    }
                    return this;
                },
                getInverse: function (m, throwOnDegenerate) {
                    // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
                    var te = this.elements, me = m.elements, n11 = me[0], n21 = me[1], n31 = me[2], n41 = me[3], n12 = me[4], n22 = me[5], n32 = me[6], n42 = me[7], n13 = me[8], n23 = me[9], n33 = me[10], n43 = me[11], n14 = me[12], n24 = me[13], n34 = me[14], n44 = me[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
                    var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
                    if (det === 0) {
                        var msg = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";
                        if (throwOnDegenerate === true) {
                            throw new Error(msg);
                        }
                        else {
                            console.warn(msg);
                        }
                        return this.identity();
                    }
                    var detInv = 1 / det;
                    te[0] = t11 * detInv;
                    te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
                    te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
                    te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
                    te[4] = t12 * detInv;
                    te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
                    te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
                    te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
                    te[8] = t13 * detInv;
                    te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
                    te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
                    te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
                    te[12] = t14 * detInv;
                    te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
                    te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
                    te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
                    return this;
                },
                scale: function (v) {
                    var te = this.elements;
                    var x = v.x, y = v.y, z = v.z;
                    te[0] *= x;
                    te[4] *= y;
                    te[8] *= z;
                    te[1] *= x;
                    te[5] *= y;
                    te[9] *= z;
                    te[2] *= x;
                    te[6] *= y;
                    te[10] *= z;
                    te[3] *= x;
                    te[7] *= y;
                    te[11] *= z;
                    return this;
                },
                getMaxScaleOnAxis: function () {
                    var te = this.elements;
                    var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
                    var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
                    var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
                    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
                },
                makeTranslation: function (x, y, z) {
                    this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
                    return this;
                },
                makeRotationX: function (theta) {
                    var c = Math.cos(theta), s = Math.sin(theta);
                    this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
                    return this;
                },
                makeRotationY: function (theta) {
                    var c = Math.cos(theta), s = Math.sin(theta);
                    this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
                    return this;
                },
                makeRotationZ: function (theta) {
                    var c = Math.cos(theta), s = Math.sin(theta);
                    this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
                    return this;
                },
                makeRotationAxis: function (axis, angle) {
                    // Based on http://www.gamedev.net/reference/articles/article1199.asp
                    var c = Math.cos(angle);
                    var s = Math.sin(angle);
                    var t = 1 - c;
                    var x = axis.x, y = axis.y, z = axis.z;
                    var tx = t * x, ty = t * y;
                    this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
                    return this;
                },
                makeScale: function (x, y, z) {
                    this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
                    return this;
                },
                makeShear: function (x, y, z) {
                    this.set(1, y, z, 0, x, 1, z, 0, x, y, 1, 0, 0, 0, 0, 1);
                    return this;
                },
                compose: function (position, quaternion, scale) {
                    var te = this.elements;
                    var x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
                    var x2 = x + x, y2 = y + y, z2 = z + z;
                    var xx = x * x2, xy = x * y2, xz = x * z2;
                    var yy = y * y2, yz = y * z2, zz = z * z2;
                    var wx = w * x2, wy = w * y2, wz = w * z2;
                    var sx = scale.x, sy = scale.y, sz = scale.z;
                    te[0] = (1 - (yy + zz)) * sx;
                    te[1] = (xy + wz) * sx;
                    te[2] = (xz - wy) * sx;
                    te[3] = 0;
                    te[4] = (xy - wz) * sy;
                    te[5] = (1 - (xx + zz)) * sy;
                    te[6] = (yz + wx) * sy;
                    te[7] = 0;
                    te[8] = (xz + wy) * sz;
                    te[9] = (yz - wx) * sz;
                    te[10] = (1 - (xx + yy)) * sz;
                    te[11] = 0;
                    te[12] = position.x;
                    te[13] = position.y;
                    te[14] = position.z;
                    te[15] = 1;
                    return this;
                },
                decompose: function (position, quaternion, scale) {
                    var te = this.elements;
                    var sx = _v1.set(te[0], te[1], te[2]).length();
                    var sy = _v1.set(te[4], te[5], te[6]).length();
                    var sz = _v1.set(te[8], te[9], te[10]).length();
                    // if determine is negative, we need to invert one scale
                    var det = this.determinant();
                    if (det < 0)
                        sx = -sx;
                    position.x = te[12];
                    position.y = te[13];
                    position.z = te[14];
                    // scale the rotation part
                    _m1.copy(this);
                    var invSX = 1 / sx;
                    var invSY = 1 / sy;
                    var invSZ = 1 / sz;
                    _m1.elements[0] *= invSX;
                    _m1.elements[1] *= invSX;
                    _m1.elements[2] *= invSX;
                    _m1.elements[4] *= invSY;
                    _m1.elements[5] *= invSY;
                    _m1.elements[6] *= invSY;
                    _m1.elements[8] *= invSZ;
                    _m1.elements[9] *= invSZ;
                    _m1.elements[10] *= invSZ;
                    quaternion.setFromRotationMatrix(_m1);
                    scale.x = sx;
                    scale.y = sy;
                    scale.z = sz;
                    return this;
                },
                makePerspective: function (left, right, top, bottom, near, far) {
                    if (far === undefined) {
                        console.warn('THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.');
                    }
                    var te = this.elements;
                    var x = 2 * near / (right - left);
                    var y = 2 * near / (top - bottom);
                    var a = (right + left) / (right - left);
                    var b = (top + bottom) / (top - bottom);
                    var c = -(far + near) / (far - near);
                    var d = -2 * far * near / (far - near);
                    te[0] = x;
                    te[4] = 0;
                    te[8] = a;
                    te[12] = 0;
                    te[1] = 0;
                    te[5] = y;
                    te[9] = b;
                    te[13] = 0;
                    te[2] = 0;
                    te[6] = 0;
                    te[10] = c;
                    te[14] = d;
                    te[3] = 0;
                    te[7] = 0;
                    te[11] = -1;
                    te[15] = 0;
                    return this;
                },
                makeOrthographic: function (left, right, top, bottom, near, far) {
                    var te = this.elements;
                    var w = 1.0 / (right - left);
                    var h = 1.0 / (top - bottom);
                    var p = 1.0 / (far - near);
                    var x = (right + left) * w;
                    var y = (top + bottom) * h;
                    var z = (far + near) * p;
                    te[0] = 2 * w;
                    te[4] = 0;
                    te[8] = 0;
                    te[12] = -x;
                    te[1] = 0;
                    te[5] = 2 * h;
                    te[9] = 0;
                    te[13] = -y;
                    te[2] = 0;
                    te[6] = 0;
                    te[10] = -2 * p;
                    te[14] = -z;
                    te[3] = 0;
                    te[7] = 0;
                    te[11] = 0;
                    te[15] = 1;
                    return this;
                },
                equals: function (matrix) {
                    var te = this.elements;
                    var me = matrix.elements;
                    for (var i = 0; i < 16; i++) {
                        if (te[i] !== me[i])
                            return false;
                    }
                    return true;
                },
                fromArray: function (array, offset) {
                    if (offset === undefined)
                        offset = 0;
                    for (var i = 0; i < 16; i++) {
                        this.elements[i] = array[i + offset];
                    }
                    return this;
                },
                toArray: function (array, offset) {
                    if (array === undefined)
                        array = [];
                    if (offset === undefined)
                        offset = 0;
                    var te = this.elements;
                    array[offset] = te[0];
                    array[offset + 1] = te[1];
                    array[offset + 2] = te[2];
                    array[offset + 3] = te[3];
                    array[offset + 4] = te[4];
                    array[offset + 5] = te[5];
                    array[offset + 6] = te[6];
                    array[offset + 7] = te[7];
                    array[offset + 8] = te[8];
                    array[offset + 9] = te[9];
                    array[offset + 10] = te[10];
                    array[offset + 11] = te[11];
                    array[offset + 12] = te[12];
                    array[offset + 13] = te[13];
                    array[offset + 14] = te[14];
                    array[offset + 15] = te[15];
                    return array;
                }
            });
            /**
             * @author mrdoob / http://mrdoob.com/
             * @author WestLangley / http://github.com/WestLangley
             * @author bhouston / http://clara.io
             */
            _matrix = new Matrix4();
            _quaternion$1 = new Quaternion();
            Euler.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'];
            Euler.DefaultOrder = 'XYZ';
            Object.defineProperties(Euler.prototype, {
                x: {
                    get: function () {
                        return this._x;
                    },
                    set: function (value) {
                        this._x = value;
                        this._onChangeCallback();
                    }
                },
                y: {
                    get: function () {
                        return this._y;
                    },
                    set: function (value) {
                        this._y = value;
                        this._onChangeCallback();
                    }
                },
                z: {
                    get: function () {
                        return this._z;
                    },
                    set: function (value) {
                        this._z = value;
                        this._onChangeCallback();
                    }
                },
                order: {
                    get: function () {
                        return this._order;
                    },
                    set: function (value) {
                        this._order = value;
                        this._onChangeCallback();
                    }
                }
            });
            Object.assign(Euler.prototype, {
                isEuler: true,
                set: function (x, y, z, order) {
                    this._x = x;
                    this._y = y;
                    this._z = z;
                    this._order = order || this._order;
                    this._onChangeCallback();
                    return this;
                },
                clone: function () {
                    return new this.constructor(this._x, this._y, this._z, this._order);
                },
                copy: function (euler) {
                    this._x = euler._x;
                    this._y = euler._y;
                    this._z = euler._z;
                    this._order = euler._order;
                    this._onChangeCallback();
                    return this;
                },
                setFromRotationMatrix: function (m, order, update) {
                    var clamp = MathUtils.clamp;
                    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
                    var te = m.elements;
                    var m11 = te[0], m12 = te[4], m13 = te[8];
                    var m21 = te[1], m22 = te[5], m23 = te[9];
                    var m31 = te[2], m32 = te[6], m33 = te[10];
                    order = order || this._order;
                    if (order === 'XYZ') {
                        this._y = Math.asin(clamp(m13, -1, 1));
                        if (Math.abs(m13) < 0.9999999) {
                            this._x = Math.atan2(-m23, m33);
                            this._z = Math.atan2(-m12, m11);
                        }
                        else {
                            this._x = Math.atan2(m32, m22);
                            this._z = 0;
                        }
                    }
                    else if (order === 'YXZ') {
                        this._x = Math.asin(-clamp(m23, -1, 1));
                        if (Math.abs(m23) < 0.9999999) {
                            this._y = Math.atan2(m13, m33);
                            this._z = Math.atan2(m21, m22);
                        }
                        else {
                            this._y = Math.atan2(-m31, m11);
                            this._z = 0;
                        }
                    }
                    else if (order === 'ZXY') {
                        this._x = Math.asin(clamp(m32, -1, 1));
                        if (Math.abs(m32) < 0.9999999) {
                            this._y = Math.atan2(-m31, m33);
                            this._z = Math.atan2(-m12, m22);
                        }
                        else {
                            this._y = 0;
                            this._z = Math.atan2(m21, m11);
                        }
                    }
                    else if (order === 'ZYX') {
                        this._y = Math.asin(-clamp(m31, -1, 1));
                        if (Math.abs(m31) < 0.9999999) {
                            this._x = Math.atan2(m32, m33);
                            this._z = Math.atan2(m21, m11);
                        }
                        else {
                            this._x = 0;
                            this._z = Math.atan2(-m12, m22);
                        }
                    }
                    else if (order === 'YZX') {
                        this._z = Math.asin(clamp(m21, -1, 1));
                        if (Math.abs(m21) < 0.9999999) {
                            this._x = Math.atan2(-m23, m22);
                            this._y = Math.atan2(-m31, m11);
                        }
                        else {
                            this._x = 0;
                            this._y = Math.atan2(m13, m33);
                        }
                    }
                    else if (order === 'XZY') {
                        this._z = Math.asin(-clamp(m12, -1, 1));
                        if (Math.abs(m12) < 0.9999999) {
                            this._x = Math.atan2(m32, m22);
                            this._y = Math.atan2(m13, m11);
                        }
                        else {
                            this._x = Math.atan2(-m23, m33);
                            this._y = 0;
                        }
                    }
                    else {
                        console.warn('THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order);
                    }
                    this._order = order;
                    if (update !== false)
                        this._onChangeCallback();
                    return this;
                },
                setFromQuaternion: function (q, order, update) {
                    _matrix.makeRotationFromQuaternion(q);
                    return this.setFromRotationMatrix(_matrix, order, update);
                },
                setFromVector3: function (v, order) {
                    return this.set(v.x, v.y, v.z, order || this._order);
                },
                reorder: function (newOrder) {
                    // WARNING: this discards revolution information -bhouston
                    _quaternion$1.setFromEuler(this);
                    return this.setFromQuaternion(_quaternion$1, newOrder);
                },
                equals: function (euler) {
                    return (euler._x === this._x) && (euler._y === this._y) && (euler._z === this._z) && (euler._order === this._order);
                },
                fromArray: function (array) {
                    this._x = array[0];
                    this._y = array[1];
                    this._z = array[2];
                    if (array[3] !== undefined)
                        this._order = array[3];
                    this._onChangeCallback();
                    return this;
                },
                toArray: function (array, offset) {
                    if (array === undefined)
                        array = [];
                    if (offset === undefined)
                        offset = 0;
                    array[offset] = this._x;
                    array[offset + 1] = this._y;
                    array[offset + 2] = this._z;
                    array[offset + 3] = this._order;
                    return array;
                },
                toVector3: function (optionalResult) {
                    if (optionalResult) {
                        return optionalResult.set(this._x, this._y, this._z);
                    }
                    else {
                        return new Vector3(this._x, this._y, this._z);
                    }
                },
                _onChange: function (callback) {
                    this._onChangeCallback = callback;
                    return this;
                },
                _onChangeCallback: function () { }
            });
            Object.assign(Layers.prototype, {
                set: function (channel) {
                    this.mask = 1 << channel | 0;
                },
                enable: function (channel) {
                    this.mask |= 1 << channel | 0;
                },
                enableAll: function () {
                    this.mask = 0xffffffff | 0;
                },
                toggle: function (channel) {
                    this.mask ^= 1 << channel | 0;
                },
                disable: function (channel) {
                    this.mask &= ~(1 << channel | 0);
                },
                disableAll: function () {
                    this.mask = 0;
                },
                test: function (layers) {
                    return (this.mask & layers.mask) !== 0;
                }
            });
            _object3DId = 0;
            _v1$1 = new Vector3();
            _q1 = new Quaternion();
            _m1$1 = new Matrix4();
            _target = new Vector3();
            _position = new Vector3();
            _scale = new Vector3();
            _quaternion$2 = new Quaternion();
            _xAxis = new Vector3(1, 0, 0);
            _yAxis = new Vector3(0, 1, 0);
            _zAxis = new Vector3(0, 0, 1);
            _addedEvent = { type: 'added' };
            _removedEvent = { type: 'removed' };
            Object3D.DefaultUp = new Vector3(0, 1, 0);
            Object3D.DefaultMatrixAutoUpdate = true;
            Object3D.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
                constructor: Object3D,
                isObject3D: true,
                onBeforeRender: function () { },
                onAfterRender: function () { },
                applyMatrix4: function (matrix) {
                    if (this.matrixAutoUpdate)
                        this.updateMatrix();
                    this.matrix.premultiply(matrix);
                    this.matrix.decompose(this.position, this.quaternion, this.scale);
                },
                applyQuaternion: function (q) {
                    this.quaternion.premultiply(q);
                    return this;
                },
                setRotationFromAxisAngle: function (axis, angle) {
                    // assumes axis is normalized
                    this.quaternion.setFromAxisAngle(axis, angle);
                },
                setRotationFromEuler: function (euler) {
                    this.quaternion.setFromEuler(euler, true);
                },
                setRotationFromMatrix: function (m) {
                    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
                    this.quaternion.setFromRotationMatrix(m);
                },
                setRotationFromQuaternion: function (q) {
                    // assumes q is normalized
                    this.quaternion.copy(q);
                },
                rotateOnAxis: function (axis, angle) {
                    // rotate object on axis in object space
                    // axis is assumed to be normalized
                    _q1.setFromAxisAngle(axis, angle);
                    this.quaternion.multiply(_q1);
                    return this;
                },
                rotateOnWorldAxis: function (axis, angle) {
                    // rotate object on axis in world space
                    // axis is assumed to be normalized
                    // method assumes no rotated parent
                    _q1.setFromAxisAngle(axis, angle);
                    this.quaternion.premultiply(_q1);
                    return this;
                },
                rotateX: function (angle) {
                    return this.rotateOnAxis(_xAxis, angle);
                },
                rotateY: function (angle) {
                    return this.rotateOnAxis(_yAxis, angle);
                },
                rotateZ: function (angle) {
                    return this.rotateOnAxis(_zAxis, angle);
                },
                translateOnAxis: function (axis, distance) {
                    // translate object by distance along axis in object space
                    // axis is assumed to be normalized
                    _v1$1.copy(axis).applyQuaternion(this.quaternion);
                    this.position.add(_v1$1.multiplyScalar(distance));
                    return this;
                },
                translateX: function (distance) {
                    return this.translateOnAxis(_xAxis, distance);
                },
                translateY: function (distance) {
                    return this.translateOnAxis(_yAxis, distance);
                },
                translateZ: function (distance) {
                    return this.translateOnAxis(_zAxis, distance);
                },
                localToWorld: function (vector) {
                    return vector.applyMatrix4(this.matrixWorld);
                },
                worldToLocal: function (vector) {
                    return vector.applyMatrix4(_m1$1.getInverse(this.matrixWorld));
                },
                lookAt: function (x, y, z) {
                    // This method does not support objects having non-uniformly-scaled parent(s)
                    if (x.isVector3) {
                        _target.copy(x);
                    }
                    else {
                        _target.set(x, y, z);
                    }
                    var parent = this.parent;
                    this.updateWorldMatrix(true, false);
                    _position.setFromMatrixPosition(this.matrixWorld);
                    if (this.isCamera || this.isLight) {
                        _m1$1.lookAt(_position, _target, this.up);
                    }
                    else {
                        _m1$1.lookAt(_target, _position, this.up);
                    }
                    this.quaternion.setFromRotationMatrix(_m1$1);
                    if (parent) {
                        _m1$1.extractRotation(parent.matrixWorld);
                        _q1.setFromRotationMatrix(_m1$1);
                        this.quaternion.premultiply(_q1.inverse());
                    }
                },
                add: function (object) {
                    if (arguments.length > 1) {
                        for (var i = 0; i < arguments.length; i++) {
                            this.add(arguments[i]);
                        }
                        return this;
                    }
                    if (object === this) {
                        console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
                        return this;
                    }
                    if ((object && object.isObject3D)) {
                        if (object.parent !== null) {
                            object.parent.remove(object);
                        }
                        object.parent = this;
                        this.children.push(object);
                        object.dispatchEvent(_addedEvent);
                    }
                    else {
                        console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
                    }
                    return this;
                },
                remove: function (object) {
                    if (arguments.length > 1) {
                        for (var i = 0; i < arguments.length; i++) {
                            this.remove(arguments[i]);
                        }
                        return this;
                    }
                    var index = this.children.indexOf(object);
                    if (index !== -1) {
                        object.parent = null;
                        this.children.splice(index, 1);
                        object.dispatchEvent(_removedEvent);
                    }
                    return this;
                },
                attach: function (object) {
                    // adds object as a child of this, while maintaining the object's world transform
                    this.updateWorldMatrix(true, false);
                    _m1$1.getInverse(this.matrixWorld);
                    if (object.parent !== null) {
                        object.parent.updateWorldMatrix(true, false);
                        _m1$1.multiply(object.parent.matrixWorld);
                    }
                    object.applyMatrix4(_m1$1);
                    object.updateWorldMatrix(false, false);
                    this.add(object);
                    return this;
                },
                getObjectById: function (id) {
                    return this.getObjectByProperty('id', id);
                },
                getObjectByName: function (name) {
                    return this.getObjectByProperty('name', name);
                },
                getObjectByProperty: function (name, value) {
                    if (this[name] === value)
                        return this;
                    for (var i = 0, l = this.children.length; i < l; i++) {
                        var child = this.children[i];
                        var object = child.getObjectByProperty(name, value);
                        if (object !== undefined) {
                            return object;
                        }
                    }
                    return undefined;
                },
                getWorldPosition: function (target) {
                    if (target === undefined) {
                        console.warn('THREE.Object3D: .getWorldPosition() target is now required');
                        target = new Vector3();
                    }
                    this.updateMatrixWorld(true);
                    return target.setFromMatrixPosition(this.matrixWorld);
                },
                getWorldQuaternion: function (target) {
                    if (target === undefined) {
                        console.warn('THREE.Object3D: .getWorldQuaternion() target is now required');
                        target = new Quaternion();
                    }
                    this.updateMatrixWorld(true);
                    this.matrixWorld.decompose(_position, target, _scale);
                    return target;
                },
                getWorldScale: function (target) {
                    if (target === undefined) {
                        console.warn('THREE.Object3D: .getWorldScale() target is now required');
                        target = new Vector3();
                    }
                    this.updateMatrixWorld(true);
                    this.matrixWorld.decompose(_position, _quaternion$2, target);
                    return target;
                },
                getWorldDirection: function (target) {
                    if (target === undefined) {
                        console.warn('THREE.Object3D: .getWorldDirection() target is now required');
                        target = new Vector3();
                    }
                    this.updateMatrixWorld(true);
                    var e = this.matrixWorld.elements;
                    return target.set(e[8], e[9], e[10]).normalize();
                },
                raycast: function () { },
                traverse: function (callback) {
                    callback(this);
                    var children = this.children;
                    for (var i = 0, l = children.length; i < l; i++) {
                        children[i].traverse(callback);
                    }
                },
                traverseVisible: function (callback) {
                    if (this.visible === false)
                        return;
                    callback(this);
                    var children = this.children;
                    for (var i = 0, l = children.length; i < l; i++) {
                        children[i].traverseVisible(callback);
                    }
                },
                traverseAncestors: function (callback) {
                    var parent = this.parent;
                    if (parent !== null) {
                        callback(parent);
                        parent.traverseAncestors(callback);
                    }
                },
                updateMatrix: function () {
                    this.matrix.compose(this.position, this.quaternion, this.scale);
                    this.matrixWorldNeedsUpdate = true;
                },
                updateMatrixWorld: function (force) {
                    if (this.matrixAutoUpdate)
                        this.updateMatrix();
                    if (this.matrixWorldNeedsUpdate || force) {
                        if (this.parent === null) {
                            this.matrixWorld.copy(this.matrix);
                        }
                        else {
                            this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
                        }
                        this.matrixWorldNeedsUpdate = false;
                        force = true;
                    }
                    // update children
                    var children = this.children;
                    for (var i = 0, l = children.length; i < l; i++) {
                        children[i].updateMatrixWorld(force);
                    }
                },
                updateWorldMatrix: function (updateParents, updateChildren) {
                    var parent = this.parent;
                    if (updateParents === true && parent !== null) {
                        parent.updateWorldMatrix(true, false);
                    }
                    if (this.matrixAutoUpdate)
                        this.updateMatrix();
                    if (this.parent === null) {
                        this.matrixWorld.copy(this.matrix);
                    }
                    else {
                        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
                    }
                    // update children
                    if (updateChildren === true) {
                        var children = this.children;
                        for (var i = 0, l = children.length; i < l; i++) {
                            children[i].updateWorldMatrix(false, true);
                        }
                    }
                },
                toJSON: function (meta) {
                    // meta is a string when called from JSON.stringify
                    var isRootObject = (meta === undefined || typeof meta === 'string');
                    var output = {};
                    // meta is a hash used to collect geometries, materials.
                    // not providing it implies that this is the root object
                    // being serialized.
                    if (isRootObject) {
                        // initialize meta obj
                        meta = {
                            geometries: {},
                            materials: {},
                            textures: {},
                            images: {},
                            shapes: {}
                        };
                        output.metadata = {
                            version: 4.5,
                            type: 'Object',
                            generator: 'Object3D.toJSON'
                        };
                    }
                    // standard Object3D serialization
                    var object = {};
                    object.uuid = this.uuid;
                    object.type = this.type;
                    if (this.name !== '')
                        object.name = this.name;
                    if (this.castShadow === true)
                        object.castShadow = true;
                    if (this.receiveShadow === true)
                        object.receiveShadow = true;
                    if (this.visible === false)
                        object.visible = false;
                    if (this.frustumCulled === false)
                        object.frustumCulled = false;
                    if (this.renderOrder !== 0)
                        object.renderOrder = this.renderOrder;
                    if (JSON.stringify(this.userData) !== '{}')
                        object.userData = this.userData;
                    object.layers = this.layers.mask;
                    object.matrix = this.matrix.toArray();
                    if (this.matrixAutoUpdate === false)
                        object.matrixAutoUpdate = false;
                    // object specific properties
                    if (this.isInstancedMesh) {
                        object.type = 'InstancedMesh';
                        object.count = this.count;
                        object.instanceMatrix = this.instanceMatrix.toJSON();
                    }
                    //
                    function serialize(library, element) {
                        if (library[element.uuid] === undefined) {
                            library[element.uuid] = element.toJSON(meta);
                        }
                        return element.uuid;
                    }
                    if (this.isMesh || this.isLine || this.isPoints) {
                        object.geometry = serialize(meta.geometries, this.geometry);
                        var parameters = this.geometry.parameters;
                        if (parameters !== undefined && parameters.shapes !== undefined) {
                            var shapes = parameters.shapes;
                            if (Array.isArray(shapes)) {
                                for (var i = 0, l = shapes.length; i < l; i++) {
                                    var shape = shapes[i];
                                    serialize(meta.shapes, shape);
                                }
                            }
                            else {
                                serialize(meta.shapes, shapes);
                            }
                        }
                    }
                    if (this.material !== undefined) {
                        if (Array.isArray(this.material)) {
                            var uuids = [];
                            for (var i = 0, l = this.material.length; i < l; i++) {
                                uuids.push(serialize(meta.materials, this.material[i]));
                            }
                            object.material = uuids;
                        }
                        else {
                            object.material = serialize(meta.materials, this.material);
                        }
                    }
                    //
                    if (this.children.length > 0) {
                        object.children = [];
                        for (var i = 0; i < this.children.length; i++) {
                            object.children.push(this.children[i].toJSON(meta).object);
                        }
                    }
                    if (isRootObject) {
                        var geometries = extractFromCache(meta.geometries);
                        var materials = extractFromCache(meta.materials);
                        var textures = extractFromCache(meta.textures);
                        var images = extractFromCache(meta.images);
                        var shapes = extractFromCache(meta.shapes);
                        if (geometries.length > 0)
                            output.geometries = geometries;
                        if (materials.length > 0)
                            output.materials = materials;
                        if (textures.length > 0)
                            output.textures = textures;
                        if (images.length > 0)
                            output.images = images;
                        if (shapes.length > 0)
                            output.shapes = shapes;
                    }
                    output.object = object;
                    return output;
                    // extract data from the cache hash
                    // remove metadata on each item
                    // and return as array
                    function extractFromCache(cache) {
                        var values = [];
                        for (var key in cache) {
                            var data = cache[key];
                            delete data.metadata;
                            values.push(data);
                        }
                        return values;
                    }
                },
                clone: function (recursive) {
                    return new this.constructor().copy(this, recursive);
                },
                copy: function (source, recursive) {
                    if (recursive === undefined)
                        recursive = true;
                    this.name = source.name;
                    this.up.copy(source.up);
                    this.position.copy(source.position);
                    this.quaternion.copy(source.quaternion);
                    this.scale.copy(source.scale);
                    this.matrix.copy(source.matrix);
                    this.matrixWorld.copy(source.matrixWorld);
                    this.matrixAutoUpdate = source.matrixAutoUpdate;
                    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
                    this.layers.mask = source.layers.mask;
                    this.visible = source.visible;
                    this.castShadow = source.castShadow;
                    this.receiveShadow = source.receiveShadow;
                    this.frustumCulled = source.frustumCulled;
                    this.renderOrder = source.renderOrder;
                    this.userData = JSON.parse(JSON.stringify(source.userData));
                    if (recursive === true) {
                        for (var i = 0; i < source.children.length; i++) {
                            var child = source.children[i];
                            this.add(child.clone());
                        }
                    }
                    return this;
                }
            });
            Scene.prototype = Object.assign(Object.create(Object3D.prototype), {
                constructor: Scene,
                isScene: true,
                copy: function (source, recursive) {
                    Object3D.prototype.copy.call(this, source, recursive);
                    if (source.background !== null)
                        this.background = source.background.clone();
                    if (source.environment !== null)
                        this.environment = source.environment.clone();
                    if (source.fog !== null)
                        this.fog = source.fog.clone();
                    if (source.overrideMaterial !== null)
                        this.overrideMaterial = source.overrideMaterial.clone();
                    this.autoUpdate = source.autoUpdate;
                    this.matrixAutoUpdate = source.matrixAutoUpdate;
                    return this;
                },
                toJSON: function (meta) {
                    var data = Object3D.prototype.toJSON.call(this, meta);
                    if (this.background !== null)
                        data.object.background = this.background.toJSON(meta);
                    if (this.environment !== null)
                        data.object.environment = this.environment.toJSON(meta);
                    if (this.fog !== null)
                        data.object.fog = this.fog.toJSON();
                    return data;
                },
                dispose: function () {
                    this.dispatchEvent({ type: 'dispose' });
                }
            });
            _points = [
                new Vector3(),
                new Vector3(),
                new Vector3(),
                new Vector3(),
                new Vector3(),
                new Vector3(),
                new Vector3(),
                new Vector3()
            ];
            _vector$1 = new Vector3();
            _box = new Box3();
            // triangle centered vertices
            _v0 = new Vector3();
            _v1$2 = new Vector3();
            _v2 = new Vector3();
            // triangle edge vectors
            _f0 = new Vector3();
            _f1 = new Vector3();
            _f2 = new Vector3();
            _center = new Vector3();
            _extents = new Vector3();
            _triangleNormal = new Vector3();
            _testAxis = new Vector3();
            Object.assign(Box3.prototype, {
                isBox3: true,
                set: function (min, max) {
                    this.min.copy(min);
                    this.max.copy(max);
                    return this;
                },
                setFromArray: function (array) {
                    var minX = +Infinity;
                    var minY = +Infinity;
                    var minZ = +Infinity;
                    var maxX = -Infinity;
                    var maxY = -Infinity;
                    var maxZ = -Infinity;
                    for (var i = 0, l = array.length; i < l; i += 3) {
                        var x = array[i];
                        var y = array[i + 1];
                        var z = array[i + 2];
                        if (x < minX)
                            minX = x;
                        if (y < minY)
                            minY = y;
                        if (z < minZ)
                            minZ = z;
                        if (x > maxX)
                            maxX = x;
                        if (y > maxY)
                            maxY = y;
                        if (z > maxZ)
                            maxZ = z;
                    }
                    this.min.set(minX, minY, minZ);
                    this.max.set(maxX, maxY, maxZ);
                    return this;
                },
                setFromBufferAttribute: function (attribute) {
                    var minX = +Infinity;
                    var minY = +Infinity;
                    var minZ = +Infinity;
                    var maxX = -Infinity;
                    var maxY = -Infinity;
                    var maxZ = -Infinity;
                    for (var i = 0, l = attribute.count; i < l; i++) {
                        var x = attribute.getX(i);
                        var y = attribute.getY(i);
                        var z = attribute.getZ(i);
                        if (x < minX)
                            minX = x;
                        if (y < minY)
                            minY = y;
                        if (z < minZ)
                            minZ = z;
                        if (x > maxX)
                            maxX = x;
                        if (y > maxY)
                            maxY = y;
                        if (z > maxZ)
                            maxZ = z;
                    }
                    this.min.set(minX, minY, minZ);
                    this.max.set(maxX, maxY, maxZ);
                    return this;
                },
                setFromPoints: function (points) {
                    this.makeEmpty();
                    for (var i = 0, il = points.length; i < il; i++) {
                        this.expandByPoint(points[i]);
                    }
                    return this;
                },
                setFromCenterAndSize: function (center, size) {
                    var halfSize = _vector$1.copy(size).multiplyScalar(0.5);
                    this.min.copy(center).sub(halfSize);
                    this.max.copy(center).add(halfSize);
                    return this;
                },
                setFromObject: function (object) {
                    this.makeEmpty();
                    return this.expandByObject(object);
                },
                clone: function () {
                    return new this.constructor().copy(this);
                },
                copy: function (box) {
                    this.min.copy(box.min);
                    this.max.copy(box.max);
                    return this;
                },
                makeEmpty: function () {
                    this.min.x = this.min.y = this.min.z = +Infinity;
                    this.max.x = this.max.y = this.max.z = -Infinity;
                    return this;
                },
                isEmpty: function () {
                    // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
                    return (this.max.x < this.min.x) || (this.max.y < this.min.y) || (this.max.z < this.min.z);
                },
                getCenter: function (target) {
                    if (target === undefined) {
                        console.warn('THREE.Box3: .getCenter() target is now required');
                        target = new Vector3();
                    }
                    return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
                },
                getSize: function (target) {
                    if (target === undefined) {
                        console.warn('THREE.Box3: .getSize() target is now required');
                        target = new Vector3();
                    }
                    return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
                },
                expandByPoint: function (point) {
                    this.min.min(point);
                    this.max.max(point);
                    return this;
                },
                expandByVector: function (vector) {
                    this.min.sub(vector);
                    this.max.add(vector);
                    return this;
                },
                expandByScalar: function (scalar) {
                    this.min.addScalar(-scalar);
                    this.max.addScalar(scalar);
                    return this;
                },
                expandByObject: function (object) {
                    // Computes the world-axis-aligned bounding box of an object (including its children),
                    // accounting for both the object's, and children's, world transforms
                    object.updateWorldMatrix(false, false);
                    var geometry = object.geometry;
                    if (geometry !== undefined) {
                        if (geometry.boundingBox === null) {
                            geometry.computeBoundingBox();
                        }
                        _box.copy(geometry.boundingBox);
                        _box.applyMatrix4(object.matrixWorld);
                        this.expandByPoint(_box.min);
                        this.expandByPoint(_box.max);
                    }
                    var children = object.children;
                    for (var i = 0, l = children.length; i < l; i++) {
                        this.expandByObject(children[i]);
                    }
                    return this;
                },
                containsPoint: function (point) {
                    return point.x < this.min.x || point.x > this.max.x ||
                        point.y < this.min.y || point.y > this.max.y ||
                        point.z < this.min.z || point.z > this.max.z ? false : true;
                },
                containsBox: function (box) {
                    return this.min.x <= box.min.x && box.max.x <= this.max.x &&
                        this.min.y <= box.min.y && box.max.y <= this.max.y &&
                        this.min.z <= box.min.z && box.max.z <= this.max.z;
                },
                getParameter: function (point, target) {
                    // This can potentially have a divide by zero if the box
                    // has a size dimension of 0.
                    if (target === undefined) {
                        console.warn('THREE.Box3: .getParameter() target is now required');
                        target = new Vector3();
                    }
                    return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
                },
                intersectsBox: function (box) {
                    // using 6 splitting planes to rule out intersections.
                    return box.max.x < this.min.x || box.min.x > this.max.x ||
                        box.max.y < this.min.y || box.min.y > this.max.y ||
                        box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
                },
                intersectsSphere: function (sphere) {
                    // Find the point on the AABB closest to the sphere center.
                    this.clampPoint(sphere.center, _vector$1);
                    // If that point is inside the sphere, the AABB and sphere intersect.
                    return _vector$1.distanceToSquared(sphere.center) <= (sphere.radius * sphere.radius);
                },
                intersectsPlane: function (plane) {
                    // We compute the minimum and maximum dot product values. If those values
                    // are on the same side (back or front) of the plane, then there is no intersection.
                    var min, max;
                    if (plane.normal.x > 0) {
                        min = plane.normal.x * this.min.x;
                        max = plane.normal.x * this.max.x;
                    }
                    else {
                        min = plane.normal.x * this.max.x;
                        max = plane.normal.x * this.min.x;
                    }
                    if (plane.normal.y > 0) {
                        min += plane.normal.y * this.min.y;
                        max += plane.normal.y * this.max.y;
                    }
                    else {
                        min += plane.normal.y * this.max.y;
                        max += plane.normal.y * this.min.y;
                    }
                    if (plane.normal.z > 0) {
                        min += plane.normal.z * this.min.z;
                        max += plane.normal.z * this.max.z;
                    }
                    else {
                        min += plane.normal.z * this.max.z;
                        max += plane.normal.z * this.min.z;
                    }
                    return (min <= -plane.constant && max >= -plane.constant);
                },
                intersectsTriangle: function (triangle) {
                    if (this.isEmpty()) {
                        return false;
                    }
                    // compute box center and extents
                    this.getCenter(_center);
                    _extents.subVectors(this.max, _center);
                    // translate triangle to aabb origin
                    _v0.subVectors(triangle.a, _center);
                    _v1$2.subVectors(triangle.b, _center);
                    _v2.subVectors(triangle.c, _center);
                    // compute edge vectors for triangle
                    _f0.subVectors(_v1$2, _v0);
                    _f1.subVectors(_v2, _v1$2);
                    _f2.subVectors(_v0, _v2);
                    // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
                    // make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
                    // axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
                    var axes = [
                        0, -_f0.z, _f0.y, 0, -_f1.z, _f1.y, 0, -_f2.z, _f2.y,
                        _f0.z, 0, -_f0.x, _f1.z, 0, -_f1.x, _f2.z, 0, -_f2.x,
                        -_f0.y, _f0.x, 0, -_f1.y, _f1.x, 0, -_f2.y, _f2.x, 0
                    ];
                    if (!satForAxes(axes, _v0, _v1$2, _v2, _extents)) {
                        return false;
                    }
                    // test 3 face normals from the aabb
                    axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
                    if (!satForAxes(axes, _v0, _v1$2, _v2, _extents)) {
                        return false;
                    }
                    // finally testing the face normal of the triangle
                    // use already existing triangle edge vectors here
                    _triangleNormal.crossVectors(_f0, _f1);
                    axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
                    return satForAxes(axes, _v0, _v1$2, _v2, _extents);
                },
                clampPoint: function (point, target) {
                    if (target === undefined) {
                        console.warn('THREE.Box3: .clampPoint() target is now required');
                        target = new Vector3();
                    }
                    return target.copy(point).clamp(this.min, this.max);
                },
                distanceToPoint: function (point) {
                    var clampedPoint = _vector$1.copy(point).clamp(this.min, this.max);
                    return clampedPoint.sub(point).length();
                },
                getBoundingSphere: function (target) {
                    if (target === undefined) {
                        console.error('THREE.Box3: .getBoundingSphere() target is now required');
                        //target = new Sphere(); // removed to avoid cyclic dependency
                    }
                    this.getCenter(target.center);
                    target.radius = this.getSize(_vector$1).length() * 0.5;
                    return target;
                },
                intersect: function (box) {
                    this.min.max(box.min);
                    this.max.min(box.max);
                    // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
                    if (this.isEmpty())
                        this.makeEmpty();
                    return this;
                },
                union: function (box) {
                    this.min.min(box.min);
                    this.max.max(box.max);
                    return this;
                },
                applyMatrix4: function (matrix) {
                    // transform of empty box is an empty box.
                    if (this.isEmpty())
                        return this;
                    // NOTE: I am using a binary pattern to specify all 2^3 combinations below
                    _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000
                    _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001
                    _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010
                    _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011
                    _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100
                    _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101
                    _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110
                    _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111
                    this.setFromPoints(_points);
                    return this;
                },
                translate: function (offset) {
                    this.min.add(offset);
                    this.max.add(offset);
                    return this;
                },
                equals: function (box) {
                    return box.min.equals(this.min) && box.max.equals(this.max);
                }
            });
            _box$1 = new Box3();
            Object.assign(Sphere.prototype, {
                set: function (center, radius) {
                    this.center.copy(center);
                    this.radius = radius;
                    return this;
                },
                setFromPoints: function (points, optionalCenter) {
                    var center = this.center;
                    if (optionalCenter !== undefined) {
                        center.copy(optionalCenter);
                    }
                    else {
                        _box$1.setFromPoints(points).getCenter(center);
                    }
                    var maxRadiusSq = 0;
                    for (var i = 0, il = points.length; i < il; i++) {
                        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
                    }
                    this.radius = Math.sqrt(maxRadiusSq);
                    return this;
                },
                clone: function () {
                    return new this.constructor().copy(this);
                },
                copy: function (sphere) {
                    this.center.copy(sphere.center);
                    this.radius = sphere.radius;
                    return this;
                },
                empty: function () {
                    return (this.radius <= 0);
                },
                containsPoint: function (point) {
                    return (point.distanceToSquared(this.center) <= (this.radius * this.radius));
                },
                distanceToPoint: function (point) {
                    return (point.distanceTo(this.center) - this.radius);
                },
                intersectsSphere: function (sphere) {
                    var radiusSum = this.radius + sphere.radius;
                    return sphere.center.distanceToSquared(this.center) <= (radiusSum * radiusSum);
                },
                intersectsBox: function (box) {
                    return box.intersectsSphere(this);
                },
                intersectsPlane: function (plane) {
                    return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
                },
                clampPoint: function (point, target) {
                    var deltaLengthSq = this.center.distanceToSquared(point);
                    if (target === undefined) {
                        console.warn('THREE.Sphere: .clampPoint() target is now required');
                        target = new Vector3();
                    }
                    target.copy(point);
                    if (deltaLengthSq > (this.radius * this.radius)) {
                        target.sub(this.center).normalize();
                        target.multiplyScalar(this.radius).add(this.center);
                    }
                    return target;
                },
                getBoundingBox: function (target) {
                    if (target === undefined) {
                        console.warn('THREE.Sphere: .getBoundingBox() target is now required');
                        target = new Box3();
                    }
                    target.set(this.center, this.center);
                    target.expandByScalar(this.radius);
                    return target;
                },
                applyMatrix4: function (matrix) {
                    this.center.applyMatrix4(matrix);
                    this.radius = this.radius * matrix.getMaxScaleOnAxis();
                    return this;
                },
                translate: function (offset) {
                    this.center.add(offset);
                    return this;
                },
                equals: function (sphere) {
                    return sphere.center.equals(this.center) && (sphere.radius === this.radius);
                }
            });
            _vector$2 = new Vector3();
            _segCenter = new Vector3();
            _segDir = new Vector3();
            _diff = new Vector3();
            _edge1 = new Vector3();
            _edge2 = new Vector3();
            _normal = new Vector3();
            Object.assign(Ray.prototype, {
                set: function (origin, direction) {
                    this.origin.copy(origin);
                    this.direction.copy(direction);
                    return this;
                },
                clone: function () {
                    return new this.constructor().copy(this);
                },
                copy: function (ray) {
                    this.origin.copy(ray.origin);
                    this.direction.copy(ray.direction);
                    return this;
                },
                at: function (t, target) {
                    if (target === undefined) {
                        console.warn('THREE.Ray: .at() target is now required');
                        target = new Vector3();
                    }
                    return target.copy(this.direction).multiplyScalar(t).add(this.origin);
                },
                lookAt: function (v) {
                    this.direction.copy(v).sub(this.origin).normalize();
                    return this;
                },
                recast: function (t) {
                    this.origin.copy(this.at(t, _vector$2));
                    return this;
                },
                closestPointToPoint: function (point, target) {
                    if (target === undefined) {
                        console.warn('THREE.Ray: .closestPointToPoint() target is now required');
                        target = new Vector3();
                    }
                    target.subVectors(point, this.origin);
                    var directionDistance = target.dot(this.direction);
                    if (directionDistance < 0) {
                        return target.copy(this.origin);
                    }
                    return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
                },
                distanceToPoint: function (point) {
                    return Math.sqrt(this.distanceSqToPoint(point));
                },
                distanceSqToPoint: function (point) {
                    var directionDistance = _vector$2.subVectors(point, this.origin).dot(this.direction);
                    // point behind the ray
                    if (directionDistance < 0) {
                        return this.origin.distanceToSquared(point);
                    }
                    _vector$2.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
                    return _vector$2.distanceToSquared(point);
                },
                distanceSqToSegment: function (v0, v1, optionalPointOnRay, optionalPointOnSegment) {
                    // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
                    // It returns the min distance between the ray and the segment
                    // defined by v0 and v1
                    // It can also set two optional targets :
                    // - The closest point on the ray
                    // - The closest point on the segment
                    _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
                    _segDir.copy(v1).sub(v0).normalize();
                    _diff.copy(this.origin).sub(_segCenter);
                    var segExtent = v0.distanceTo(v1) * 0.5;
                    var a01 = -this.direction.dot(_segDir);
                    var b0 = _diff.dot(this.direction);
                    var b1 = -_diff.dot(_segDir);
                    var c = _diff.lengthSq();
                    var det = Math.abs(1 - a01 * a01);
                    var s0, s1, sqrDist, extDet;
                    if (det > 0) {
                        // The ray and segment are not parallel.
                        s0 = a01 * b1 - b0;
                        s1 = a01 * b0 - b1;
                        extDet = segExtent * det;
                        if (s0 >= 0) {
                            if (s1 >= -extDet) {
                                if (s1 <= extDet) {
                                    // region 0
                                    // Minimum at interior points of ray and segment.
                                    var invDet = 1 / det;
                                    s0 *= invDet;
                                    s1 *= invDet;
                                    sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
                                }
                                else {
                                    // region 1
                                    s1 = segExtent;
                                    s0 = Math.max(0, -(a01 * s1 + b0));
                                    sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                                }
                            }
                            else {
                                // region 5
                                s1 = -segExtent;
                                s0 = Math.max(0, -(a01 * s1 + b0));
                                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                            }
                        }
                        else {
                            if (s1 <= -extDet) {
                                // region 4
                                s0 = Math.max(0, -(-a01 * segExtent + b0));
                                s1 = (s0 > 0) ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                            }
                            else if (s1 <= extDet) {
                                // region 3
                                s0 = 0;
                                s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
                                sqrDist = s1 * (s1 + 2 * b1) + c;
                            }
                            else {
                                // region 2
                                s0 = Math.max(0, -(a01 * segExtent + b0));
                                s1 = (s0 > 0) ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                            }
                        }
                    }
                    else {
                        // Ray and segment are parallel.
                        s1 = (a01 > 0) ? -segExtent : segExtent;
                        s0 = Math.max(0, -(a01 * s1 + b0));
                        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                    }
                    if (optionalPointOnRay) {
                        optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
                    }
                    if (optionalPointOnSegment) {
                        optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);
                    }
                    return sqrDist;
                },
                intersectSphere: function (sphere, target) {
                    _vector$2.subVectors(sphere.center, this.origin);
                    var tca = _vector$2.dot(this.direction);
                    var d2 = _vector$2.dot(_vector$2) - tca * tca;
                    var radius2 = sphere.radius * sphere.radius;
                    if (d2 > radius2)
                        return null;
                    var thc = Math.sqrt(radius2 - d2);
                    // t0 = first intersect point - entrance on front of sphere
                    var t0 = tca - thc;
                    // t1 = second intersect point - exit point on back of sphere
                    var t1 = tca + thc;
                    // test to see if both t0 and t1 are behind the ray - if so, return null
                    if (t0 < 0 && t1 < 0)
                        return null;
                    // test to see if t0 is behind the ray:
                    // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
                    // in order to always return an intersect point that is in front of the ray.
                    if (t0 < 0)
                        return this.at(t1, target);
                    // else t0 is in front of the ray, so return the first collision point scaled by t0
                    return this.at(t0, target);
                },
                intersectsSphere: function (sphere) {
                    return this.distanceSqToPoint(sphere.center) <= (sphere.radius * sphere.radius);
                },
                distanceToPlane: function (plane) {
                    var denominator = plane.normal.dot(this.direction);
                    if (denominator === 0) {
                        // line is coplanar, return origin
                        if (plane.distanceToPoint(this.origin) === 0) {
                            return 0;
                        }
                        // Null is preferable to undefined since undefined means.... it is undefined
                        return null;
                    }
                    var t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
                    // Return if the ray never intersects the plane
                    return t >= 0 ? t : null;
                },
                intersectPlane: function (plane, target) {
                    var t = this.distanceToPlane(plane);
                    if (t === null) {
                        return null;
                    }
                    return this.at(t, target);
                },
                intersectsPlane: function (plane) {
                    // check if the ray lies on the plane first
                    var distToPoint = plane.distanceToPoint(this.origin);
                    if (distToPoint === 0) {
                        return true;
                    }
                    var denominator = plane.normal.dot(this.direction);
                    if (denominator * distToPoint < 0) {
                        return true;
                    }
                    // ray origin is behind the plane (and is pointing behind it)
                    return false;
                },
                intersectBox: function (box, target) {
                    var tmin, tmax, tymin, tymax, tzmin, tzmax;
                    var invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
                    var origin = this.origin;
                    if (invdirx >= 0) {
                        tmin = (box.min.x - origin.x) * invdirx;
                        tmax = (box.max.x - origin.x) * invdirx;
                    }
                    else {
                        tmin = (box.max.x - origin.x) * invdirx;
                        tmax = (box.min.x - origin.x) * invdirx;
                    }
                    if (invdiry >= 0) {
                        tymin = (box.min.y - origin.y) * invdiry;
                        tymax = (box.max.y - origin.y) * invdiry;
                    }
                    else {
                        tymin = (box.max.y - origin.y) * invdiry;
                        tymax = (box.min.y - origin.y) * invdiry;
                    }
                    if ((tmin > tymax) || (tymin > tmax))
                        return null;
                    // These lines also handle the case where tmin or tmax is NaN
                    // (result of 0 * Infinity). x !== x returns true if x is NaN
                    if (tymin > tmin || tmin !== tmin)
                        tmin = tymin;
                    if (tymax < tmax || tmax !== tmax)
                        tmax = tymax;
                    if (invdirz >= 0) {
                        tzmin = (box.min.z - origin.z) * invdirz;
                        tzmax = (box.max.z - origin.z) * invdirz;
                    }
                    else {
                        tzmin = (box.max.z - origin.z) * invdirz;
                        tzmax = (box.min.z - origin.z) * invdirz;
                    }
                    if ((tmin > tzmax) || (tzmin > tmax))
                        return null;
                    if (tzmin > tmin || tmin !== tmin)
                        tmin = tzmin;
                    if (tzmax < tmax || tmax !== tmax)
                        tmax = tzmax;
                    //return point closest to the ray (positive side)
                    if (tmax < 0)
                        return null;
                    return this.at(tmin >= 0 ? tmin : tmax, target);
                },
                intersectsBox: function (box) {
                    return this.intersectBox(box, _vector$2) !== null;
                },
                intersectTriangle: function (a, b, c, backfaceCulling, target) {
                    // Compute the offset origin, edges, and normal.
                    // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h
                    _edge1.subVectors(b, a);
                    _edge2.subVectors(c, a);
                    _normal.crossVectors(_edge1, _edge2);
                    // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
                    // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
                    //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
                    //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
                    //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
                    var DdN = this.direction.dot(_normal);
                    var sign;
                    if (DdN > 0) {
                        if (backfaceCulling)
                            return null;
                        sign = 1;
                    }
                    else if (DdN < 0) {
                        sign = -1;
                        DdN = -DdN;
                    }
                    else {
                        return null;
                    }
                    _diff.subVectors(this.origin, a);
                    var DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
                    // b1 < 0, no intersection
                    if (DdQxE2 < 0) {
                        return null;
                    }
                    var DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff));
                    // b2 < 0, no intersection
                    if (DdE1xQ < 0) {
                        return null;
                    }
                    // b1+b2 > 1, no intersection
                    if (DdQxE2 + DdE1xQ > DdN) {
                        return null;
                    }
                    // Line intersects triangle, check if ray does.
                    var QdN = -sign * _diff.dot(_normal);
                    // t < 0, no intersection
                    if (QdN < 0) {
                        return null;
                    }
                    // Ray intersects triangle.
                    return this.at(QdN / DdN, target);
                },
                applyMatrix4: function (matrix4) {
                    this.origin.applyMatrix4(matrix4);
                    this.direction.transformDirection(matrix4);
                    return this;
                },
                equals: function (ray) {
                    return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
                }
            });
            /**
             * @author bhouston / http://clara.io
             */
            _vector1 = new Vector3();
            _vector2 = new Vector3();
            _normalMatrix = new Matrix3();
            Object.assign(Plane.prototype, {
                isPlane: true,
                set: function (normal, constant) {
                    this.normal.copy(normal);
                    this.constant = constant;
                    return this;
                },
                setComponents: function (x, y, z, w) {
                    this.normal.set(x, y, z);
                    this.constant = w;
                    return this;
                },
                setFromNormalAndCoplanarPoint: function (normal, point) {
                    this.normal.copy(normal);
                    this.constant = -point.dot(this.normal);
                    return this;
                },
                setFromCoplanarPoints: function (a, b, c) {
                    var normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize();
                    // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?
                    this.setFromNormalAndCoplanarPoint(normal, a);
                    return this;
                },
                clone: function () {
                    return new this.constructor().copy(this);
                },
                copy: function (plane) {
                    this.normal.copy(plane.normal);
                    this.constant = plane.constant;
                    return this;
                },
                normalize: function () {
                    // Note: will lead to a divide by zero if the plane is invalid.
                    var inverseNormalLength = 1.0 / this.normal.length();
                    this.normal.multiplyScalar(inverseNormalLength);
                    this.constant *= inverseNormalLength;
                    return this;
                },
                negate: function () {
                    this.constant *= -1;
                    this.normal.negate();
                    return this;
                },
                distanceToPoint: function (point) {
                    return this.normal.dot(point) + this.constant;
                },
                distanceToSphere: function (sphere) {
                    return this.distanceToPoint(sphere.center) - sphere.radius;
                },
                projectPoint: function (point, target) {
                    if (target === undefined) {
                        console.warn('THREE.Plane: .projectPoint() target is now required');
                        target = new Vector3();
                    }
                    return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
                },
                intersectLine: function (line, target) {
                    if (target === undefined) {
                        console.warn('THREE.Plane: .intersectLine() target is now required');
                        target = new Vector3();
                    }
                    var direction = line.delta(_vector1);
                    var denominator = this.normal.dot(direction);
                    if (denominator === 0) {
                        // line is coplanar, return origin
                        if (this.distanceToPoint(line.start) === 0) {
                            return target.copy(line.start);
                        }
                        // Unsure if this is the correct method to handle this case.
                        return undefined;
                    }
                    var t = -(line.start.dot(this.normal) + this.constant) / denominator;
                    if (t < 0 || t > 1) {
                        return undefined;
                    }
                    return target.copy(direction).multiplyScalar(t).add(line.start);
                },
                intersectsLine: function (line) {
                    // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
                    var startSign = this.distanceToPoint(line.start);
                    var endSign = this.distanceToPoint(line.end);
                    return (startSign < 0 && endSign > 0) || (endSign < 0 && startSign > 0);
                },
                intersectsBox: function (box) {
                    return box.intersectsPlane(this);
                },
                intersectsSphere: function (sphere) {
                    return sphere.intersectsPlane(this);
                },
                coplanarPoint: function (target) {
                    if (target === undefined) {
                        console.warn('THREE.Plane: .coplanarPoint() target is now required');
                        target = new Vector3();
                    }
                    return target.copy(this.normal).multiplyScalar(-this.constant);
                },
                applyMatrix4: function (matrix, optionalNormalMatrix) {
                    var normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
                    var referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
                    var normal = this.normal.applyMatrix3(normalMatrix).normalize();
                    this.constant = -referencePoint.dot(normal);
                    return this;
                },
                translate: function (offset) {
                    this.constant -= offset.dot(this.normal);
                    return this;
                },
                equals: function (plane) {
                    return plane.normal.equals(this.normal) && (plane.constant === this.constant);
                }
            });
            /**
             * @author bhouston / http://clara.io
             * @author mrdoob / http://mrdoob.com/
             */
            _v0$1 = new Vector3();
            _v1$3 = new Vector3();
            _v2$1 = new Vector3();
            _v3 = new Vector3();
            _vab = new Vector3();
            _vac = new Vector3();
            _vbc = new Vector3();
            _vap = new Vector3();
            _vbp = new Vector3();
            _vcp = new Vector3();
            Object.assign(Triangle, {
                getNormal: function (a, b, c, target) {
                    if (target === undefined) {
                        console.warn('THREE.Triangle: .getNormal() target is now required');
                        target = new Vector3();
                    }
                    target.subVectors(c, b);
                    _v0$1.subVectors(a, b);
                    target.cross(_v0$1);
                    var targetLengthSq = target.lengthSq();
                    if (targetLengthSq > 0) {
                        return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
                    }
                    return target.set(0, 0, 0);
                },
                // static/instance method to calculate barycentric coordinates
                // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
                getBarycoord: function (point, a, b, c, target) {
                    _v0$1.subVectors(c, a);
                    _v1$3.subVectors(b, a);
                    _v2$1.subVectors(point, a);
                    var dot00 = _v0$1.dot(_v0$1);
                    var dot01 = _v0$1.dot(_v1$3);
                    var dot02 = _v0$1.dot(_v2$1);
                    var dot11 = _v1$3.dot(_v1$3);
                    var dot12 = _v1$3.dot(_v2$1);
                    var denom = (dot00 * dot11 - dot01 * dot01);
                    if (target === undefined) {
                        console.warn('THREE.Triangle: .getBarycoord() target is now required');
                        target = new Vector3();
                    }
                    // collinear or singular triangle
                    if (denom === 0) {
                        // arbitrary location outside of triangle?
                        // not sure if this is the best idea, maybe should be returning undefined
                        return target.set(-2, -1, -1);
                    }
                    var invDenom = 1 / denom;
                    var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
                    var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
                    // barycentric coordinates must always sum to 1
                    return target.set(1 - u - v, v, u);
                },
                containsPoint: function (point, a, b, c) {
                    Triangle.getBarycoord(point, a, b, c, _v3);
                    return (_v3.x >= 0) && (_v3.y >= 0) && ((_v3.x + _v3.y) <= 1);
                },
                getUV: function (point, p1, p2, p3, uv1, uv2, uv3, target) {
                    this.getBarycoord(point, p1, p2, p3, _v3);
                    target.set(0, 0);
                    target.addScaledVector(uv1, _v3.x);
                    target.addScaledVector(uv2, _v3.y);
                    target.addScaledVector(uv3, _v3.z);
                    return target;
                },
                isFrontFacing: function (a, b, c, direction) {
                    _v0$1.subVectors(c, b);
                    _v1$3.subVectors(a, b);
                    // strictly front facing
                    return (_v0$1.cross(_v1$3).dot(direction) < 0) ? true : false;
                }
            });
            Object.assign(Triangle.prototype, {
                set: function (a, b, c) {
                    this.a.copy(a);
                    this.b.copy(b);
                    this.c.copy(c);
                    return this;
                },
                setFromPointsAndIndices: function (points, i0, i1, i2) {
                    this.a.copy(points[i0]);
                    this.b.copy(points[i1]);
                    this.c.copy(points[i2]);
                    return this;
                },
                clone: function () {
                    return new this.constructor().copy(this);
                },
                copy: function (triangle) {
                    this.a.copy(triangle.a);
                    this.b.copy(triangle.b);
                    this.c.copy(triangle.c);
                    return this;
                },
                getArea: function () {
                    _v0$1.subVectors(this.c, this.b);
                    _v1$3.subVectors(this.a, this.b);
                    return _v0$1.cross(_v1$3).length() * 0.5;
                },
                getMidpoint: function (target) {
                    if (target === undefined) {
                        console.warn('THREE.Triangle: .getMidpoint() target is now required');
                        target = new Vector3();
                    }
                    return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
                },
                getNormal: function (target) {
                    return Triangle.getNormal(this.a, this.b, this.c, target);
                },
                getPlane: function (target) {
                    if (target === undefined) {
                        console.warn('THREE.Triangle: .getPlane() target is now required');
                        target = new Plane();
                    }
                    return target.setFromCoplanarPoints(this.a, this.b, this.c);
                },
                getBarycoord: function (point, target) {
                    return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
                },
                getUV: function (point, uv1, uv2, uv3, target) {
                    return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
                },
                containsPoint: function (point) {
                    return Triangle.containsPoint(point, this.a, this.b, this.c);
                },
                isFrontFacing: function (direction) {
                    return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
                },
                intersectsBox: function (box) {
                    return box.intersectsTriangle(this);
                },
                closestPointToPoint: function (p, target) {
                    if (target === undefined) {
                        console.warn('THREE.Triangle: .closestPointToPoint() target is now required');
                        target = new Vector3();
                    }
                    var a = this.a, b = this.b, c = this.c;
                    var v, w;
                    // algorithm thanks to Real-Time Collision Detection by Christer Ericson,
                    // published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
                    // under the accompanying license; see chapter 5.1.5 for detailed explanation.
                    // basically, we're distinguishing which of the voronoi regions of the triangle
                    // the point lies in with the minimum amount of redundant computation.
                    _vab.subVectors(b, a);
                    _vac.subVectors(c, a);
                    _vap.subVectors(p, a);
                    var d1 = _vab.dot(_vap);
                    var d2 = _vac.dot(_vap);
                    if (d1 <= 0 && d2 <= 0) {
                        // vertex region of A; barycentric coords (1, 0, 0)
                        return target.copy(a);
                    }
                    _vbp.subVectors(p, b);
                    var d3 = _vab.dot(_vbp);
                    var d4 = _vac.dot(_vbp);
                    if (d3 >= 0 && d4 <= d3) {
                        // vertex region of B; barycentric coords (0, 1, 0)
                        return target.copy(b);
                    }
                    var vc = d1 * d4 - d3 * d2;
                    if (vc <= 0 && d1 >= 0 && d3 <= 0) {
                        v = d1 / (d1 - d3);
                        // edge region of AB; barycentric coords (1-v, v, 0)
                        return target.copy(a).addScaledVector(_vab, v);
                    }
                    _vcp.subVectors(p, c);
                    var d5 = _vab.dot(_vcp);
                    var d6 = _vac.dot(_vcp);
                    if (d6 >= 0 && d5 <= d6) {
                        // vertex region of C; barycentric coords (0, 0, 1)
                        return target.copy(c);
                    }
                    var vb = d5 * d2 - d1 * d6;
                    if (vb <= 0 && d2 >= 0 && d6 <= 0) {
                        w = d2 / (d2 - d6);
                        // edge region of AC; barycentric coords (1-w, 0, w)
                        return target.copy(a).addScaledVector(_vac, w);
                    }
                    var va = d3 * d6 - d5 * d4;
                    if (va <= 0 && (d4 - d3) >= 0 && (d5 - d6) >= 0) {
                        _vbc.subVectors(c, b);
                        w = (d4 - d3) / ((d4 - d3) + (d5 - d6));
                        // edge region of BC; barycentric coords (0, 1-w, w)
                        return target.copy(b).addScaledVector(_vbc, w); // edge region of BC
                    }
                    // face region
                    var denom = 1 / (va + vb + vc);
                    // u = va * denom
                    v = vb * denom;
                    w = vc * denom;
                    return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);
                },
                equals: function (triangle) {
                    return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
                }
            });
            /**
             * @author mrdoob / http://mrdoob.com/
             */
            _colorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
                'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
                'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
                'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
                'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
                'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
                'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
                'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
                'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
                'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
                'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
                'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
                'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
                'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
                'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
                'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
                'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
                'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
                'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
                'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
                'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
                'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
                'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
                'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };
            _hslA = { h: 0, s: 0, l: 0 };
            _hslB = { h: 0, s: 0, l: 0 };
            Object.assign(Color.prototype, {
                isColor: true,
                r: 1, g: 1, b: 1,
                set: function (value) {
                    if (value && value.isColor) {
                        this.copy(value);
                    }
                    else if (typeof value === 'number') {
                        this.setHex(value);
                    }
                    else if (typeof value === 'string') {
                        this.setStyle(value);
                    }
                    return this;
                },
                setScalar: function (scalar) {
                    this.r = scalar;
                    this.g = scalar;
                    this.b = scalar;
                    return this;
                },
                setHex: function (hex) {
                    hex = Math.floor(hex);
                    this.r = (hex >> 16 & 255) / 255;
                    this.g = (hex >> 8 & 255) / 255;
                    this.b = (hex & 255) / 255;
                    return this;
                },
                setRGB: function (r, g, b) {
                    this.r = r;
                    this.g = g;
                    this.b = b;
                    return this;
                },
                setHSL: function (h, s, l) {
                    // h,s,l ranges are in 0.0 - 1.0
                    h = MathUtils.euclideanModulo(h, 1);
                    s = MathUtils.clamp(s, 0, 1);
                    l = MathUtils.clamp(l, 0, 1);
                    if (s === 0) {
                        this.r = this.g = this.b = l;
                    }
                    else {
                        var p = l <= 0.5 ? l * (1 + s) : l + s - (l * s);
                        var q = (2 * l) - p;
                        this.r = hue2rgb(q, p, h + 1 / 3);
                        this.g = hue2rgb(q, p, h);
                        this.b = hue2rgb(q, p, h - 1 / 3);
                    }
                    return this;
                },
                setStyle: function (style) {
                    function handleAlpha(string) {
                        if (string === undefined)
                            return;
                        if (parseFloat(string) < 1) {
                            console.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.');
                        }
                    }
                    var m;
                    if (m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(style)) {
                        // rgb / hsl
                        var color;
                        var name = m[1];
                        var components = m[2];
                        switch (name) {
                            case 'rgb':
                            case 'rgba':
                                if (color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                                    // rgb(255,0,0) rgba(255,0,0,0.5)
                                    this.r = Math.min(255, parseInt(color[1], 10)) / 255;
                                    this.g = Math.min(255, parseInt(color[2], 10)) / 255;
                                    this.b = Math.min(255, parseInt(color[3], 10)) / 255;
                                    handleAlpha(color[5]);
                                    return this;
                                }
                                if (color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                                    // rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
                                    this.r = Math.min(100, parseInt(color[1], 10)) / 100;
                                    this.g = Math.min(100, parseInt(color[2], 10)) / 100;
                                    this.b = Math.min(100, parseInt(color[3], 10)) / 100;
                                    handleAlpha(color[5]);
                                    return this;
                                }
                                break;
                            case 'hsl':
                            case 'hsla':
                                if (color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                                    // hsl(120,50%,50%) hsla(120,50%,50%,0.5)
                                    var h = parseFloat(color[1]) / 360;
                                    var s = parseInt(color[2], 10) / 100;
                                    var l = parseInt(color[3], 10) / 100;
                                    handleAlpha(color[5]);
                                    return this.setHSL(h, s, l);
                                }
                                break;
                        }
                    }
                    else if (m = /^\#([A-Fa-f0-9]+)$/.exec(style)) {
                        // hex color
                        var hex = m[1];
                        var size = hex.length;
                        if (size === 3) {
                            // #ff0
                            this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
                            this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
                            this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
                            return this;
                        }
                        else if (size === 6) {
                            // #ff0000
                            this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
                            this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
                            this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
                            return this;
                        }
                    }
                    if (style && style.length > 0) {
                        return this.setColorName(style);
                    }
                    return this;
                },
                setColorName: function (style) {
                    // color keywords
                    var hex = _colorKeywords[style];
                    if (hex !== undefined) {
                        // red
                        this.setHex(hex);
                    }
                    else {
                        // unknown color
                        console.warn('THREE.Color: Unknown color ' + style);
                    }
                    return this;
                },
                clone: function () {
                    return new this.constructor(this.r, this.g, this.b);
                },
                copy: function (color) {
                    this.r = color.r;
                    this.g = color.g;
                    this.b = color.b;
                    return this;
                },
                copyGammaToLinear: function (color, gammaFactor) {
                    if (gammaFactor === undefined)
                        gammaFactor = 2.0;
                    this.r = Math.pow(color.r, gammaFactor);
                    this.g = Math.pow(color.g, gammaFactor);
                    this.b = Math.pow(color.b, gammaFactor);
                    return this;
                },
                copyLinearToGamma: function (color, gammaFactor) {
                    if (gammaFactor === undefined)
                        gammaFactor = 2.0;
                    var safeInverse = (gammaFactor > 0) ? (1.0 / gammaFactor) : 1.0;
                    this.r = Math.pow(color.r, safeInverse);
                    this.g = Math.pow(color.g, safeInverse);
                    this.b = Math.pow(color.b, safeInverse);
                    return this;
                },
                convertGammaToLinear: function (gammaFactor) {
                    this.copyGammaToLinear(this, gammaFactor);
                    return this;
                },
                convertLinearToGamma: function (gammaFactor) {
                    this.copyLinearToGamma(this, gammaFactor);
                    return this;
                },
                copySRGBToLinear: function (color) {
                    this.r = SRGBToLinear(color.r);
                    this.g = SRGBToLinear(color.g);
                    this.b = SRGBToLinear(color.b);
                    return this;
                },
                copyLinearToSRGB: function (color) {
                    this.r = LinearToSRGB(color.r);
                    this.g = LinearToSRGB(color.g);
                    this.b = LinearToSRGB(color.b);
                    return this;
                },
                convertSRGBToLinear: function () {
                    this.copySRGBToLinear(this);
                    return this;
                },
                convertLinearToSRGB: function () {
                    this.copyLinearToSRGB(this);
                    return this;
                },
                getHex: function () {
                    return (this.r * 255) << 16 ^ (this.g * 255) << 8 ^ (this.b * 255) << 0;
                },
                getHexString: function () {
                    return ('000000' + this.getHex().toString(16)).slice(-6);
                },
                getHSL: function (target) {
                    // h,s,l ranges are in 0.0 - 1.0
                    if (target === undefined) {
                        console.warn('THREE.Color: .getHSL() target is now required');
                        target = { h: 0, s: 0, l: 0 };
                    }
                    var r = this.r, g = this.g, b = this.b;
                    var max = Math.max(r, g, b);
                    var min = Math.min(r, g, b);
                    var hue, saturation;
                    var lightness = (min + max) / 2.0;
                    if (min === max) {
                        hue = 0;
                        saturation = 0;
                    }
                    else {
                        var delta = max - min;
                        saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
                        switch (max) {
                            case r:
                                hue = (g - b) / delta + (g < b ? 6 : 0);
                                break;
                            case g:
                                hue = (b - r) / delta + 2;
                                break;
                            case b:
                                hue = (r - g) / delta + 4;
                                break;
                        }
                        hue /= 6;
                    }
                    target.h = hue;
                    target.s = saturation;
                    target.l = lightness;
                    return target;
                },
                getStyle: function () {
                    return 'rgb(' + ((this.r * 255) | 0) + ',' + ((this.g * 255) | 0) + ',' + ((this.b * 255) | 0) + ')';
                },
                offsetHSL: function (h, s, l) {
                    this.getHSL(_hslA);
                    _hslA.h += h;
                    _hslA.s += s;
                    _hslA.l += l;
                    this.setHSL(_hslA.h, _hslA.s, _hslA.l);
                    return this;
                },
                add: function (color) {
                    this.r += color.r;
                    this.g += color.g;
                    this.b += color.b;
                    return this;
                },
                addColors: function (color1, color2) {
                    this.r = color1.r + color2.r;
                    this.g = color1.g + color2.g;
                    this.b = color1.b + color2.b;
                    return this;
                },
                addScalar: function (s) {
                    this.r += s;
                    this.g += s;
                    this.b += s;
                    return this;
                },
                sub: function (color) {
                    this.r = Math.max(0, this.r - color.r);
                    this.g = Math.max(0, this.g - color.g);
                    this.b = Math.max(0, this.b - color.b);
                    return this;
                },
                multiply: function (color) {
                    this.r *= color.r;
                    this.g *= color.g;
                    this.b *= color.b;
                    return this;
                },
                multiplyScalar: function (s) {
                    this.r *= s;
                    this.g *= s;
                    this.b *= s;
                    return this;
                },
                lerp: function (color, alpha) {
                    this.r += (color.r - this.r) * alpha;
                    this.g += (color.g - this.g) * alpha;
                    this.b += (color.b - this.b) * alpha;
                    return this;
                },
                lerpHSL: function (color, alpha) {
                    this.getHSL(_hslA);
                    color.getHSL(_hslB);
                    var h = MathUtils.lerp(_hslA.h, _hslB.h, alpha);
                    var s = MathUtils.lerp(_hslA.s, _hslB.s, alpha);
                    var l = MathUtils.lerp(_hslA.l, _hslB.l, alpha);
                    this.setHSL(h, s, l);
                    return this;
                },
                equals: function (c) {
                    return (c.r === this.r) && (c.g === this.g) && (c.b === this.b);
                },
                fromArray: function (array, offset) {
                    if (offset === undefined)
                        offset = 0;
                    this.r = array[offset];
                    this.g = array[offset + 1];
                    this.b = array[offset + 2];
                    return this;
                },
                toArray: function (array, offset) {
                    if (array === undefined)
                        array = [];
                    if (offset === undefined)
                        offset = 0;
                    array[offset] = this.r;
                    array[offset + 1] = this.g;
                    array[offset + 2] = this.b;
                    return array;
                },
                toJSON: function () {
                    return this.getHex();
                }
            });
            Color.NAMES = _colorKeywords;
            Object.assign(Face3.prototype, {
                clone: function () {
                    return new this.constructor().copy(this);
                },
                copy: function (source) {
                    this.a = source.a;
                    this.b = source.b;
                    this.c = source.c;
                    this.normal.copy(source.normal);
                    this.color.copy(source.color);
                    this.materialIndex = source.materialIndex;
                    for (var i = 0, il = source.vertexNormals.length; i < il; i++) {
                        this.vertexNormals[i] = source.vertexNormals[i].clone();
                    }
                    for (var i = 0, il = source.vertexColors.length; i < il; i++) {
                        this.vertexColors[i] = source.vertexColors[i].clone();
                    }
                    return this;
                }
            });
            /**
             * @author mrdoob / http://mrdoob.com/
             * @author alteredq / http://alteredqualia.com/
             */
            materialId = 0;
            Material.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
                constructor: Material,
                isMaterial: true,
                onBeforeCompile: function () { },
                setValues: function (values) {
                    if (values === undefined)
                        return;
                    for (var key in values) {
                        var newValue = values[key];
                        if (newValue === undefined) {
                            console.warn("THREE.Material: '" + key + "' parameter is undefined.");
                            continue;
                        }
                        // for backward compatability if shading is set in the constructor
                        if (key === 'shading') {
                            console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
                            this.flatShading = (newValue === FlatShading) ? true : false;
                            continue;
                        }
                        var currentValue = this[key];
                        if (currentValue === undefined) {
                            console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
                            continue;
                        }
                        if (currentValue && currentValue.isColor) {
                            currentValue.set(newValue);
                        }
                        else if ((currentValue && currentValue.isVector3) && (newValue && newValue.isVector3)) {
                            currentValue.copy(newValue);
                        }
                        else {
                            this[key] = newValue;
                        }
                    }
                },
                toJSON: function (meta) {
                    var isRoot = (meta === undefined || typeof meta === 'string');
                    if (isRoot) {
                        meta = {
                            textures: {},
                            images: {}
                        };
                    }
                    var data = {
                        metadata: {
                            version: 4.5,
                            type: 'Material',
                            generator: 'Material.toJSON'
                        }
                    };
                    // standard Material serialization
                    data.uuid = this.uuid;
                    data.type = this.type;
                    if (this.name !== '')
                        data.name = this.name;
                    if (this.color && this.color.isColor)
                        data.color = this.color.getHex();
                    if (this.roughness !== undefined)
                        data.roughness = this.roughness;
                    if (this.metalness !== undefined)
                        data.metalness = this.metalness;
                    if (this.sheen && this.sheen.isColor)
                        data.sheen = this.sheen.getHex();
                    if (this.emissive && this.emissive.isColor)
                        data.emissive = this.emissive.getHex();
                    if (this.emissiveIntensity && this.emissiveIntensity !== 1)
                        data.emissiveIntensity = this.emissiveIntensity;
                    if (this.specular && this.specular.isColor)
                        data.specular = this.specular.getHex();
                    if (this.shininess !== undefined)
                        data.shininess = this.shininess;
                    if (this.clearcoat !== undefined)
                        data.clearcoat = this.clearcoat;
                    if (this.clearcoatRoughness !== undefined)
                        data.clearcoatRoughness = this.clearcoatRoughness;
                    if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
                        data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
                        data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
                    }
                    if (this.map && this.map.isTexture)
                        data.map = this.map.toJSON(meta).uuid;
                    if (this.matcap && this.matcap.isTexture)
                        data.matcap = this.matcap.toJSON(meta).uuid;
                    if (this.alphaMap && this.alphaMap.isTexture)
                        data.alphaMap = this.alphaMap.toJSON(meta).uuid;
                    if (this.lightMap && this.lightMap.isTexture)
                        data.lightMap = this.lightMap.toJSON(meta).uuid;
                    if (this.aoMap && this.aoMap.isTexture) {
                        data.aoMap = this.aoMap.toJSON(meta).uuid;
                        data.aoMapIntensity = this.aoMapIntensity;
                    }
                    if (this.bumpMap && this.bumpMap.isTexture) {
                        data.bumpMap = this.bumpMap.toJSON(meta).uuid;
                        data.bumpScale = this.bumpScale;
                    }
                    if (this.normalMap && this.normalMap.isTexture) {
                        data.normalMap = this.normalMap.toJSON(meta).uuid;
                        data.normalMapType = this.normalMapType;
                        data.normalScale = this.normalScale.toArray();
                    }
                    if (this.displacementMap && this.displacementMap.isTexture) {
                        data.displacementMap = this.displacementMap.toJSON(meta).uuid;
                        data.displacementScale = this.displacementScale;
                        data.displacementBias = this.displacementBias;
                    }
                    if (this.roughnessMap && this.roughnessMap.isTexture)
                        data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
                    if (this.metalnessMap && this.metalnessMap.isTexture)
                        data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
                    if (this.emissiveMap && this.emissiveMap.isTexture)
                        data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
                    if (this.specularMap && this.specularMap.isTexture)
                        data.specularMap = this.specularMap.toJSON(meta).uuid;
                    if (this.envMap && this.envMap.isTexture) {
                        data.envMap = this.envMap.toJSON(meta).uuid;
                        data.reflectivity = this.reflectivity; // Scale behind envMap
                        data.refractionRatio = this.refractionRatio;
                        if (this.combine !== undefined)
                            data.combine = this.combine;
                        if (this.envMapIntensity !== undefined)
                            data.envMapIntensity = this.envMapIntensity;
                    }
                    if (this.gradientMap && this.gradientMap.isTexture) {
                        data.gradientMap = this.gradientMap.toJSON(meta).uuid;
                    }
                    if (this.size !== undefined)
                        data.size = this.size;
                    if (this.sizeAttenuation !== undefined)
                        data.sizeAttenuation = this.sizeAttenuation;
                    if (this.blending !== NormalBlending)
                        data.blending = this.blending;
                    if (this.flatShading === true)
                        data.flatShading = this.flatShading;
                    if (this.side !== FrontSide)
                        data.side = this.side;
                    if (this.vertexColors !== NoColors)
                        data.vertexColors = this.vertexColors;
                    if (this.opacity < 1)
                        data.opacity = this.opacity;
                    if (this.transparent === true)
                        data.transparent = this.transparent;
                    data.depthFunc = this.depthFunc;
                    data.depthTest = this.depthTest;
                    data.depthWrite = this.depthWrite;
                    data.stencilWrite = this.stencilWrite;
                    data.stencilWriteMask = this.stencilWriteMask;
                    data.stencilFunc = this.stencilFunc;
                    data.stencilRef = this.stencilRef;
                    data.stencilFuncMask = this.stencilFuncMask;
                    data.stencilFail = this.stencilFail;
                    data.stencilZFail = this.stencilZFail;
                    data.stencilZPass = this.stencilZPass;
                    // rotation (SpriteMaterial)
                    if (this.rotation && this.rotation !== 0)
                        data.rotation = this.rotation;
                    if (this.polygonOffset === true)
                        data.polygonOffset = true;
                    if (this.polygonOffsetFactor !== 0)
                        data.polygonOffsetFactor = this.polygonOffsetFactor;
                    if (this.polygonOffsetUnits !== 0)
                        data.polygonOffsetUnits = this.polygonOffsetUnits;
                    if (this.linewidth && this.linewidth !== 1)
                        data.linewidth = this.linewidth;
                    if (this.dashSize !== undefined)
                        data.dashSize = this.dashSize;
                    if (this.gapSize !== undefined)
                        data.gapSize = this.gapSize;
                    if (this.scale !== undefined)
                        data.scale = this.scale;
                    if (this.dithering === true)
                        data.dithering = true;
                    if (this.alphaTest > 0)
                        data.alphaTest = this.alphaTest;
                    if (this.premultipliedAlpha === true)
                        data.premultipliedAlpha = this.premultipliedAlpha;
                    if (this.wireframe === true)
                        data.wireframe = this.wireframe;
                    if (this.wireframeLinewidth > 1)
                        data.wireframeLinewidth = this.wireframeLinewidth;
                    if (this.wireframeLinecap !== 'round')
                        data.wireframeLinecap = this.wireframeLinecap;
                    if (this.wireframeLinejoin !== 'round')
                        data.wireframeLinejoin = this.wireframeLinejoin;
                    if (this.morphTargets === true)
                        data.morphTargets = true;
                    if (this.morphNormals === true)
                        data.morphNormals = true;
                    if (this.skinning === true)
                        data.skinning = true;
                    if (this.visible === false)
                        data.visible = false;
                    if (this.toneMapped === false)
                        data.toneMapped = false;
                    if (JSON.stringify(this.userData) !== '{}')
                        data.userData = this.userData;
                    // TODO: Copied from Object3D.toJSON
                    function extractFromCache(cache) {
                        var values = [];
                        for (var key in cache) {
                            var data = cache[key];
                            delete data.metadata;
                            values.push(data);
                        }
                        return values;
                    }
                    if (isRoot) {
                        var textures = extractFromCache(meta.textures);
                        var images = extractFromCache(meta.images);
                        if (textures.length > 0)
                            data.textures = textures;
                        if (images.length > 0)
                            data.images = images;
                    }
                    return data;
                },
                clone: function () {
                    return new this.constructor().copy(this);
                },
                copy: function (source) {
                    this.name = source.name;
                    this.fog = source.fog;
                    this.blending = source.blending;
                    this.side = source.side;
                    this.flatShading = source.flatShading;
                    this.vertexTangents = source.vertexTangents;
                    this.vertexColors = source.vertexColors;
                    this.opacity = source.opacity;
                    this.transparent = source.transparent;
                    this.blendSrc = source.blendSrc;
                    this.blendDst = source.blendDst;
                    this.blendEquation = source.blendEquation;
                    this.blendSrcAlpha = source.blendSrcAlpha;
                    this.blendDstAlpha = source.blendDstAlpha;
                    this.blendEquationAlpha = source.blendEquationAlpha;
                    this.depthFunc = source.depthFunc;
                    this.depthTest = source.depthTest;
                    this.depthWrite = source.depthWrite;
                    this.stencilWriteMask = source.stencilWriteMask;
                    this.stencilFunc = source.stencilFunc;
                    this.stencilRef = source.stencilRef;
                    this.stencilFuncMask = source.stencilFuncMask;
                    this.stencilFail = source.stencilFail;
                    this.stencilZFail = source.stencilZFail;
                    this.stencilZPass = source.stencilZPass;
                    this.stencilWrite = source.stencilWrite;
                    var srcPlanes = source.clippingPlanes, dstPlanes = null;
                    if (srcPlanes !== null) {
                        var n = srcPlanes.length;
                        dstPlanes = new Array(n);
                        for (var i = 0; i !== n; ++i)
                            dstPlanes[i] = srcPlanes[i].clone();
                    }
                    this.clippingPlanes = dstPlanes;
                    this.clipIntersection = source.clipIntersection;
                    this.clipShadows = source.clipShadows;
                    this.shadowSide = source.shadowSide;
                    this.colorWrite = source.colorWrite;
                    this.precision = source.precision;
                    this.polygonOffset = source.polygonOffset;
                    this.polygonOffsetFactor = source.polygonOffsetFactor;
                    this.polygonOffsetUnits = source.polygonOffsetUnits;
                    this.dithering = source.dithering;
                    this.alphaTest = source.alphaTest;
                    this.premultipliedAlpha = source.premultipliedAlpha;
                    this.visible = source.visible;
                    this.toneMapped = source.toneMapped;
                    this.userData = JSON.parse(JSON.stringify(source.userData));
                    return this;
                },
                dispose: function () {
                    this.dispatchEvent({ type: 'dispose' });
                }
            });
            Object.defineProperty(Material.prototype, 'needsUpdate', {
                set: function (value) {
                    if (value === true)
                        this.version++;
                }
            });
            MeshBasicMaterial.prototype = Object.create(Material.prototype);
            MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;
            MeshBasicMaterial.prototype.isMeshBasicMaterial = true;
            MeshBasicMaterial.prototype.copy = function (source) {
                Material.prototype.copy.call(this, source);
                this.color.copy(source.color);
                this.map = source.map;
                this.lightMap = source.lightMap;
                this.lightMapIntensity = source.lightMapIntensity;
                this.aoMap = source.aoMap;
                this.aoMapIntensity = source.aoMapIntensity;
                this.specularMap = source.specularMap;
                this.alphaMap = source.alphaMap;
                this.envMap = source.envMap;
                this.combine = source.combine;
                this.reflectivity = source.reflectivity;
                this.refractionRatio = source.refractionRatio;
                this.wireframe = source.wireframe;
                this.wireframeLinewidth = source.wireframeLinewidth;
                this.wireframeLinecap = source.wireframeLinecap;
                this.wireframeLinejoin = source.wireframeLinejoin;
                this.skinning = source.skinning;
                this.morphTargets = source.morphTargets;
                return this;
            };
            /**
             * @author mrdoob / http://mrdoob.com/
             */
            _vector$3 = new Vector3();
            Object.defineProperty(BufferAttribute.prototype, 'needsUpdate', {
                set: function (value) {
                    if (value === true)
                        this.version++;
                }
            });
            Object.assign(BufferAttribute.prototype, {
                isBufferAttribute: true,
                onUploadCallback: function () { },
                setUsage: function (value) {
                    this.usage = value;
                    return this;
                },
                copy: function (source) {
                    this.name = source.name;
                    this.array = new source.array.constructor(source.array);
                    this.itemSize = source.itemSize;
                    this.count = source.count;
                    this.normalized = source.normalized;
                    this.usage = source.usage;
                    return this;
                },
                copyAt: function (index1, attribute, index2) {
                    index1 *= this.itemSize;
                    index2 *= attribute.itemSize;
                    for (var i = 0, l = this.itemSize; i < l; i++) {
                        this.array[index1 + i] = attribute.array[index2 + i];
                    }
                    return this;
                },
                copyArray: function (array) {
                    this.array.set(array);
                    return this;
                },
                copyColorsArray: function (colors) {
                    var array = this.array, offset = 0;
                    for (var i = 0, l = colors.length; i < l; i++) {
                        var color = colors[i];
                        if (color === undefined) {
                            console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined', i);
                            color = new Color();
                        }
                        array[offset++] = color.r;
                        array[offset++] = color.g;
                        array[offset++] = color.b;
                    }
                    return this;
                },
                copyVector2sArray: function (vectors) {
                    var array = this.array, offset = 0;
                    for (var i = 0, l = vectors.length; i < l; i++) {
                        var vector = vectors[i];
                        if (vector === undefined) {
                            console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i);
                            vector = new Vector2();
                        }
                        array[offset++] = vector.x;
                        array[offset++] = vector.y;
                    }
                    return this;
                },
                copyVector3sArray: function (vectors) {
                    var array = this.array, offset = 0;
                    for (var i = 0, l = vectors.length; i < l; i++) {
                        var vector = vectors[i];
                        if (vector === undefined) {
                            console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i);
                            vector = new Vector3();
                        }
                        array[offset++] = vector.x;
                        array[offset++] = vector.y;
                        array[offset++] = vector.z;
                    }
                    return this;
                },
                copyVector4sArray: function (vectors) {
                    var array = this.array, offset = 0;
                    for (var i = 0, l = vectors.length; i < l; i++) {
                        var vector = vectors[i];
                        if (vector === undefined) {
                            console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i);
                            vector = new Vector4();
                        }
                        array[offset++] = vector.x;
                        array[offset++] = vector.y;
                        array[offset++] = vector.z;
                        array[offset++] = vector.w;
                    }
                    return this;
                },
                applyMatrix3: function (m) {
                    for (var i = 0, l = this.count; i < l; i++) {
                        _vector$3.x = this.getX(i);
                        _vector$3.y = this.getY(i);
                        _vector$3.z = this.getZ(i);
                        _vector$3.applyMatrix3(m);
                        this.setXYZ(i, _vector$3.x, _vector$3.y, _vector$3.z);
                    }
                    return this;
                },
                applyMatrix4: function (m) {
                    for (var i = 0, l = this.count; i < l; i++) {
                        _vector$3.x = this.getX(i);
                        _vector$3.y = this.getY(i);
                        _vector$3.z = this.getZ(i);
                        _vector$3.applyMatrix4(m);
                        this.setXYZ(i, _vector$3.x, _vector$3.y, _vector$3.z);
                    }
                    return this;
                },
                applyNormalMatrix: function (m) {
                    for (var i = 0, l = this.count; i < l; i++) {
                        _vector$3.x = this.getX(i);
                        _vector$3.y = this.getY(i);
                        _vector$3.z = this.getZ(i);
                        _vector$3.applyNormalMatrix(m);
                        this.setXYZ(i, _vector$3.x, _vector$3.y, _vector$3.z);
                    }
                    return this;
                },
                transformDirection: function (m) {
                    for (var i = 0, l = this.count; i < l; i++) {
                        _vector$3.x = this.getX(i);
                        _vector$3.y = this.getY(i);
                        _vector$3.z = this.getZ(i);
                        _vector$3.transformDirection(m);
                        this.setXYZ(i, _vector$3.x, _vector$3.y, _vector$3.z);
                    }
                    return this;
                },
                set: function (value, offset) {
                    if (offset === undefined)
                        offset = 0;
                    this.array.set(value, offset);
                    return this;
                },
                getX: function (index) {
                    return this.array[index * this.itemSize];
                },
                setX: function (index, x) {
                    this.array[index * this.itemSize] = x;
                    return this;
                },
                getY: function (index) {
                    return this.array[index * this.itemSize + 1];
                },
                setY: function (index, y) {
                    this.array[index * this.itemSize + 1] = y;
                    return this;
                },
                getZ: function (index) {
                    return this.array[index * this.itemSize + 2];
                },
                setZ: function (index, z) {
                    this.array[index * this.itemSize + 2] = z;
                    return this;
                },
                getW: function (index) {
                    return this.array[index * this.itemSize + 3];
                },
                setW: function (index, w) {
                    this.array[index * this.itemSize + 3] = w;
                    return this;
                },
                setXY: function (index, x, y) {
                    index *= this.itemSize;
                    this.array[index + 0] = x;
                    this.array[index + 1] = y;
                    return this;
                },
                setXYZ: function (index, x, y, z) {
                    index *= this.itemSize;
                    this.array[index + 0] = x;
                    this.array[index + 1] = y;
                    this.array[index + 2] = z;
                    return this;
                },
                setXYZW: function (index, x, y, z, w) {
                    index *= this.itemSize;
                    this.array[index + 0] = x;
                    this.array[index + 1] = y;
                    this.array[index + 2] = z;
                    this.array[index + 3] = w;
                    return this;
                },
                onUpload: function (callback) {
                    this.onUploadCallback = callback;
                    return this;
                },
                clone: function () {
                    return new this.constructor(this.array, this.itemSize).copy(this);
                },
                toJSON: function () {
                    return {
                        itemSize: this.itemSize,
                        type: this.array.constructor.name,
                        array: Array.prototype.slice.call(this.array),
                        normalized: this.normalized
                    };
                }
            });
            Int8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
            Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;
            Uint8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
            Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;
            Uint8ClampedBufferAttribute.prototype = Object.create(BufferAttribute.prototype);
            Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;
            Int16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
            Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;
            Uint16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
            Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;
            Int32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
            Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;
            Uint32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
            Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;
            Float32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
            Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;
            Float64BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
            Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;
            Object.assign(DirectGeometry.prototype, {
                computeGroups: function (geometry) {
                    var group;
                    var groups = [];
                    var materialIndex = undefined;
                    var faces = geometry.faces;
                    for (var i = 0; i < faces.length; i++) {
                        var face = faces[i];
                        // materials
                        if (face.materialIndex !== materialIndex) {
                            materialIndex = face.materialIndex;
                            if (group !== undefined) {
                                group.count = (i * 3) - group.start;
                                groups.push(group);
                            }
                            group = {
                                start: i * 3,
                                materialIndex: materialIndex
                            };
                        }
                    }
                    if (group !== undefined) {
                        group.count = (i * 3) - group.start;
                        groups.push(group);
                    }
                    this.groups = groups;
                },
                fromGeometry: function (geometry) {
                    var faces = geometry.faces;
                    var vertices = geometry.vertices;
                    var faceVertexUvs = geometry.faceVertexUvs;
                    var hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;
                    var hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0;
                    // morphs
                    var morphTargets = geometry.morphTargets;
                    var morphTargetsLength = morphTargets.length;
                    var morphTargetsPosition;
                    if (morphTargetsLength > 0) {
                        morphTargetsPosition = [];
                        for (var i = 0; i < morphTargetsLength; i++) {
                            morphTargetsPosition[i] = {
                                name: morphTargets[i].name,
                                data: []
                            };
                        }
                        this.morphTargets.position = morphTargetsPosition;
                    }
                    var morphNormals = geometry.morphNormals;
                    var morphNormalsLength = morphNormals.length;
                    var morphTargetsNormal;
                    if (morphNormalsLength > 0) {
                        morphTargetsNormal = [];
                        for (var i = 0; i < morphNormalsLength; i++) {
                            morphTargetsNormal[i] = {
                                name: morphNormals[i].name,
                                data: []
                            };
                        }
                        this.morphTargets.normal = morphTargetsNormal;
                    }
                    // skins
                    var skinIndices = geometry.skinIndices;
                    var skinWeights = geometry.skinWeights;
                    var hasSkinIndices = skinIndices.length === vertices.length;
                    var hasSkinWeights = skinWeights.length === vertices.length;
                    //
                    if (vertices.length > 0 && faces.length === 0) {
                        console.error('THREE.DirectGeometry: Faceless geometries are not supported.');
                    }
                    for (var i = 0; i < faces.length; i++) {
                        var face = faces[i];
                        this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);
                        var vertexNormals = face.vertexNormals;
                        if (vertexNormals.length === 3) {
                            this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);
                        }
                        else {
                            var normal = face.normal;
                            this.normals.push(normal, normal, normal);
                        }
                        var vertexColors = face.vertexColors;
                        if (vertexColors.length === 3) {
                            this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);
                        }
                        else {
                            var color = face.color;
                            this.colors.push(color, color, color);
                        }
                        if (hasFaceVertexUv === true) {
                            var vertexUvs = faceVertexUvs[0][i];
                            if (vertexUvs !== undefined) {
                                this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
                            }
                            else {
                                console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i);
                                this.uvs.push(new Vector2(), new Vector2(), new Vector2());
                            }
                        }
                        if (hasFaceVertexUv2 === true) {
                            var vertexUvs = faceVertexUvs[1][i];
                            if (vertexUvs !== undefined) {
                                this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
                            }
                            else {
                                console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i);
                                this.uvs2.push(new Vector2(), new Vector2(), new Vector2());
                            }
                        }
                        // morphs
                        for (var j = 0; j < morphTargetsLength; j++) {
                            var morphTarget = morphTargets[j].vertices;
                            morphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);
                        }
                        for (var j = 0; j < morphNormalsLength; j++) {
                            var morphNormal = morphNormals[j].vertexNormals[i];
                            morphTargetsNormal[j].data.push(morphNormal.a, morphNormal.b, morphNormal.c);
                        }
                        // skins
                        if (hasSkinIndices) {
                            this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);
                        }
                        if (hasSkinWeights) {
                            this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);
                        }
                    }
                    this.computeGroups(geometry);
                    this.verticesNeedUpdate = geometry.verticesNeedUpdate;
                    this.normalsNeedUpdate = geometry.normalsNeedUpdate;
                    this.colorsNeedUpdate = geometry.colorsNeedUpdate;
                    this.uvsNeedUpdate = geometry.uvsNeedUpdate;
                    this.groupsNeedUpdate = geometry.groupsNeedUpdate;
                    if (geometry.boundingSphere !== null) {
                        this.boundingSphere = geometry.boundingSphere.clone();
                    }
                    if (geometry.boundingBox !== null) {
                        this.boundingBox = geometry.boundingBox.clone();
                    }
                    return this;
                }
            });
            /**
             * @author alteredq / http://alteredqualia.com/
             * @author mrdoob / http://mrdoob.com/
             */
            _bufferGeometryId = 1; // BufferGeometry uses odd numbers as Id
            _m1$2 = new Matrix4();
            _obj = new Object3D();
            _offset = new Vector3();
            _box$2 = new Box3();
            _boxMorphTargets = new Box3();
            _vector$4 = new Vector3();
            BufferGeometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
                constructor: BufferGeometry,
                isBufferGeometry: true,
                getIndex: function () {
                    return this.index;
                },
                setIndex: function (index) {
                    if (Array.isArray(index)) {
                        this.index = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
                    }
                    else {
                        this.index = index;
                    }
                },
                getAttribute: function (name) {
                    return this.attributes[name];
                },
                setAttribute: function (name, attribute) {
                    this.attributes[name] = attribute;
                    return this;
                },
                deleteAttribute: function (name) {
                    delete this.attributes[name];
                    return this;
                },
                addGroup: function (start, count, materialIndex) {
                    this.groups.push({
                        start: start,
                        count: count,
                        materialIndex: materialIndex !== undefined ? materialIndex : 0
                    });
                },
                clearGroups: function () {
                    this.groups = [];
                },
                setDrawRange: function (start, count) {
                    this.drawRange.start = start;
                    this.drawRange.count = count;
                },
                applyMatrix4: function (matrix) {
                    var position = this.attributes.position;
                    if (position !== undefined) {
                        position.applyMatrix4(matrix);
                        position.needsUpdate = true;
                    }
                    var normal = this.attributes.normal;
                    if (normal !== undefined) {
                        var normalMatrix = new Matrix3().getNormalMatrix(matrix);
                        normal.applyNormalMatrix(normalMatrix);
                        normal.needsUpdate = true;
                    }
                    var tangent = this.attributes.tangent;
                    if (tangent !== undefined) {
                        tangent.transformDirection(matrix);
                        tangent.needsUpdate = true;
                    }
                    if (this.boundingBox !== null) {
                        this.computeBoundingBox();
                    }
                    if (this.boundingSphere !== null) {
                        this.computeBoundingSphere();
                    }
                    return this;
                },
                rotateX: function (angle) {
                    // rotate geometry around world x-axis
                    _m1$2.makeRotationX(angle);
                    this.applyMatrix4(_m1$2);
                    return this;
                },
                rotateY: function (angle) {
                    // rotate geometry around world y-axis
                    _m1$2.makeRotationY(angle);
                    this.applyMatrix4(_m1$2);
                    return this;
                },
                rotateZ: function (angle) {
                    // rotate geometry around world z-axis
                    _m1$2.makeRotationZ(angle);
                    this.applyMatrix4(_m1$2);
                    return this;
                },
                translate: function (x, y, z) {
                    // translate geometry
                    _m1$2.makeTranslation(x, y, z);
                    this.applyMatrix4(_m1$2);
                    return this;
                },
                scale: function (x, y, z) {
                    // scale geometry
                    _m1$2.makeScale(x, y, z);
                    this.applyMatrix4(_m1$2);
                    return this;
                },
                lookAt: function (vector) {
                    _obj.lookAt(vector);
                    _obj.updateMatrix();
                    this.applyMatrix4(_obj.matrix);
                    return this;
                },
                center: function () {
                    this.computeBoundingBox();
                    this.boundingBox.getCenter(_offset).negate();
                    this.translate(_offset.x, _offset.y, _offset.z);
                    return this;
                },
                setFromObject: function (object) {
                    // console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );
                    var geometry = object.geometry;
                    if (object.isPoints || object.isLine) {
                        var positions = new Float32BufferAttribute(geometry.vertices.length * 3, 3);
                        var colors = new Float32BufferAttribute(geometry.colors.length * 3, 3);
                        this.setAttribute('position', positions.copyVector3sArray(geometry.vertices));
                        this.setAttribute('color', colors.copyColorsArray(geometry.colors));
                        if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {
                            var lineDistances = new Float32BufferAttribute(geometry.lineDistances.length, 1);
                            this.setAttribute('lineDistance', lineDistances.copyArray(geometry.lineDistances));
                        }
                        if (geometry.boundingSphere !== null) {
                            this.boundingSphere = geometry.boundingSphere.clone();
                        }
                        if (geometry.boundingBox !== null) {
                            this.boundingBox = geometry.boundingBox.clone();
                        }
                    }
                    else if (object.isMesh) {
                        if (geometry && geometry.isGeometry) {
                            this.fromGeometry(geometry);
                        }
                    }
                    return this;
                },
                setFromPoints: function (points) {
                    var position = [];
                    for (var i = 0, l = points.length; i < l; i++) {
                        var point = points[i];
                        position.push(point.x, point.y, point.z || 0);
                    }
                    this.setAttribute('position', new Float32BufferAttribute(position, 3));
                    return this;
                },
                updateFromObject: function (object) {
                    var geometry = object.geometry;
                    if (object.isMesh) {
                        var direct = geometry.__directGeometry;
                        if (geometry.elementsNeedUpdate === true) {
                            direct = undefined;
                            geometry.elementsNeedUpdate = false;
                        }
                        if (direct === undefined) {
                            return this.fromGeometry(geometry);
                        }
                        direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
                        direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
                        direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
                        direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
                        direct.groupsNeedUpdate = geometry.groupsNeedUpdate;
                        geometry.verticesNeedUpdate = false;
                        geometry.normalsNeedUpdate = false;
                        geometry.colorsNeedUpdate = false;
                        geometry.uvsNeedUpdate = false;
                        geometry.groupsNeedUpdate = false;
                        geometry = direct;
                    }
                    var attribute;
                    if (geometry.verticesNeedUpdate === true) {
                        attribute = this.attributes.position;
                        if (attribute !== undefined) {
                            attribute.copyVector3sArray(geometry.vertices);
                            attribute.needsUpdate = true;
                        }
                        geometry.verticesNeedUpdate = false;
                    }
                    if (geometry.normalsNeedUpdate === true) {
                        attribute = this.attributes.normal;
                        if (attribute !== undefined) {
                            attribute.copyVector3sArray(geometry.normals);
                            attribute.needsUpdate = true;
                        }
                        geometry.normalsNeedUpdate = false;
                    }
                    if (geometry.colorsNeedUpdate === true) {
                        attribute = this.attributes.color;
                        if (attribute !== undefined) {
                            attribute.copyColorsArray(geometry.colors);
                            attribute.needsUpdate = true;
                        }
                        geometry.colorsNeedUpdate = false;
                    }
                    if (geometry.uvsNeedUpdate) {
                        attribute = this.attributes.uv;
                        if (attribute !== undefined) {
                            attribute.copyVector2sArray(geometry.uvs);
                            attribute.needsUpdate = true;
                        }
                        geometry.uvsNeedUpdate = false;
                    }
                    if (geometry.lineDistancesNeedUpdate) {
                        attribute = this.attributes.lineDistance;
                        if (attribute !== undefined) {
                            attribute.copyArray(geometry.lineDistances);
                            attribute.needsUpdate = true;
                        }
                        geometry.lineDistancesNeedUpdate = false;
                    }
                    if (geometry.groupsNeedUpdate) {
                        geometry.computeGroups(object.geometry);
                        this.groups = geometry.groups;
                        geometry.groupsNeedUpdate = false;
                    }
                    return this;
                },
                fromGeometry: function (geometry) {
                    geometry.__directGeometry = new DirectGeometry().fromGeometry(geometry);
                    return this.fromDirectGeometry(geometry.__directGeometry);
                },
                fromDirectGeometry: function (geometry) {
                    var positions = new Float32Array(geometry.vertices.length * 3);
                    this.setAttribute('position', new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));
                    if (geometry.normals.length > 0) {
                        var normals = new Float32Array(geometry.normals.length * 3);
                        this.setAttribute('normal', new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));
                    }
                    if (geometry.colors.length > 0) {
                        var colors = new Float32Array(geometry.colors.length * 3);
                        this.setAttribute('color', new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));
                    }
                    if (geometry.uvs.length > 0) {
                        var uvs = new Float32Array(geometry.uvs.length * 2);
                        this.setAttribute('uv', new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));
                    }
                    if (geometry.uvs2.length > 0) {
                        var uvs2 = new Float32Array(geometry.uvs2.length * 2);
                        this.setAttribute('uv2', new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));
                    }
                    // groups
                    this.groups = geometry.groups;
                    // morphs
                    for (var name in geometry.morphTargets) {
                        var array = [];
                        var morphTargets = geometry.morphTargets[name];
                        for (var i = 0, l = morphTargets.length; i < l; i++) {
                            var morphTarget = morphTargets[i];
                            var attribute = new Float32BufferAttribute(morphTarget.data.length * 3, 3);
                            attribute.name = morphTarget.name;
                            array.push(attribute.copyVector3sArray(morphTarget.data));
                        }
                        this.morphAttributes[name] = array;
                    }
                    // skinning
                    if (geometry.skinIndices.length > 0) {
                        var skinIndices = new Float32BufferAttribute(geometry.skinIndices.length * 4, 4);
                        this.setAttribute('skinIndex', skinIndices.copyVector4sArray(geometry.skinIndices));
                    }
                    if (geometry.skinWeights.length > 0) {
                        var skinWeights = new Float32BufferAttribute(geometry.skinWeights.length * 4, 4);
                        this.setAttribute('skinWeight', skinWeights.copyVector4sArray(geometry.skinWeights));
                    }
                    //
                    if (geometry.boundingSphere !== null) {
                        this.boundingSphere = geometry.boundingSphere.clone();
                    }
                    if (geometry.boundingBox !== null) {
                        this.boundingBox = geometry.boundingBox.clone();
                    }
                    return this;
                },
                computeBoundingBox: function () {
                    if (this.boundingBox === null) {
                        this.boundingBox = new Box3();
                    }
                    var position = this.attributes.position;
                    var morphAttributesPosition = this.morphAttributes.position;
                    if (position !== undefined) {
                        this.boundingBox.setFromBufferAttribute(position);
                        // process morph attributes if present
                        if (morphAttributesPosition) {
                            for (var i = 0, il = morphAttributesPosition.length; i < il; i++) {
                                var morphAttribute = morphAttributesPosition[i];
                                _box$2.setFromBufferAttribute(morphAttribute);
                                if (this.morphTargetsRelative) {
                                    _vector$4.addVectors(this.boundingBox.min, _box$2.min);
                                    this.boundingBox.expandByPoint(_vector$4);
                                    _vector$4.addVectors(this.boundingBox.max, _box$2.max);
                                    this.boundingBox.expandByPoint(_vector$4);
                                }
                                else {
                                    this.boundingBox.expandByPoint(_box$2.min);
                                    this.boundingBox.expandByPoint(_box$2.max);
                                }
                            }
                        }
                    }
                    else {
                        this.boundingBox.makeEmpty();
                    }
                    if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
                        console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
                    }
                },
                computeBoundingSphere: function () {
                    if (this.boundingSphere === null) {
                        this.boundingSphere = new Sphere();
                    }
                    var position = this.attributes.position;
                    var morphAttributesPosition = this.morphAttributes.position;
                    if (position) {
                        // first, find the center of the bounding sphere
                        var center = this.boundingSphere.center;
                        _box$2.setFromBufferAttribute(position);
                        // process morph attributes if present
                        if (morphAttributesPosition) {
                            for (var i = 0, il = morphAttributesPosition.length; i < il; i++) {
                                var morphAttribute = morphAttributesPosition[i];
                                _boxMorphTargets.setFromBufferAttribute(morphAttribute);
                                if (this.morphTargetsRelative) {
                                    _vector$4.addVectors(_box$2.min, _boxMorphTargets.min);
                                    _box$2.expandByPoint(_vector$4);
                                    _vector$4.addVectors(_box$2.max, _boxMorphTargets.max);
                                    _box$2.expandByPoint(_vector$4);
                                }
                                else {
                                    _box$2.expandByPoint(_boxMorphTargets.min);
                                    _box$2.expandByPoint(_boxMorphTargets.max);
                                }
                            }
                        }
                        _box$2.getCenter(center);
                        // second, try to find a boundingSphere with a radius smaller than the
                        // boundingSphere of the boundingBox: sqrt(3) smaller in the best case
                        var maxRadiusSq = 0;
                        for (var i = 0, il = position.count; i < il; i++) {
                            _vector$4.fromBufferAttribute(position, i);
                            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$4));
                        }
                        // process morph attributes if present
                        if (morphAttributesPosition) {
                            for (var i = 0, il = morphAttributesPosition.length; i < il; i++) {
                                var morphAttribute = morphAttributesPosition[i];
                                var morphTargetsRelative = this.morphTargetsRelative;
                                for (var j = 0, jl = morphAttribute.count; j < jl; j++) {
                                    _vector$4.fromBufferAttribute(morphAttribute, j);
                                    if (morphTargetsRelative) {
                                        _offset.fromBufferAttribute(position, j);
                                        _vector$4.add(_offset);
                                    }
                                    maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$4));
                                }
                            }
                        }
                        this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
                        if (isNaN(this.boundingSphere.radius)) {
                            console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
                        }
                    }
                },
                computeFaceNormals: function () {
                    // backwards compatibility
                },
                computeVertexNormals: function () {
                    var index = this.index;
                    var attributes = this.attributes;
                    if (attributes.position) {
                        var positions = attributes.position.array;
                        if (attributes.normal === undefined) {
                            this.setAttribute('normal', new BufferAttribute(new Float32Array(positions.length), 3));
                        }
                        else {
                            // reset existing normals to zero
                            var array = attributes.normal.array;
                            for (var i = 0, il = array.length; i < il; i++) {
                                array[i] = 0;
                            }
                        }
                        var normals = attributes.normal.array;
                        var vA, vB, vC;
                        var pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
                        var cb = new Vector3(), ab = new Vector3();
                        // indexed elements
                        if (index) {
                            var indices = index.array;
                            for (var i = 0, il = index.count; i < il; i += 3) {
                                vA = indices[i + 0] * 3;
                                vB = indices[i + 1] * 3;
                                vC = indices[i + 2] * 3;
                                pA.fromArray(positions, vA);
                                pB.fromArray(positions, vB);
                                pC.fromArray(positions, vC);
                                cb.subVectors(pC, pB);
                                ab.subVectors(pA, pB);
                                cb.cross(ab);
                                normals[vA] += cb.x;
                                normals[vA + 1] += cb.y;
                                normals[vA + 2] += cb.z;
                                normals[vB] += cb.x;
                                normals[vB + 1] += cb.y;
                                normals[vB + 2] += cb.z;
                                normals[vC] += cb.x;
                                normals[vC + 1] += cb.y;
                                normals[vC + 2] += cb.z;
                            }
                        }
                        else {
                            // non-indexed elements (unconnected triangle soup)
                            for (var i = 0, il = positions.length; i < il; i += 9) {
                                pA.fromArray(positions, i);
                                pB.fromArray(positions, i + 3);
                                pC.fromArray(positions, i + 6);
                                cb.subVectors(pC, pB);
                                ab.subVectors(pA, pB);
                                cb.cross(ab);
                                normals[i] = cb.x;
                                normals[i + 1] = cb.y;
                                normals[i + 2] = cb.z;
                                normals[i + 3] = cb.x;
                                normals[i + 4] = cb.y;
                                normals[i + 5] = cb.z;
                                normals[i + 6] = cb.x;
                                normals[i + 7] = cb.y;
                                normals[i + 8] = cb.z;
                            }
                        }
                        this.normalizeNormals();
                        attributes.normal.needsUpdate = true;
                    }
                },
                merge: function (geometry, offset) {
                    if (!(geometry && geometry.isBufferGeometry)) {
                        console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry);
                        return;
                    }
                    if (offset === undefined) {
                        offset = 0;
                        console.warn('THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. '
                            + 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.');
                    }
                    var attributes = this.attributes;
                    for (var key in attributes) {
                        if (geometry.attributes[key] === undefined)
                            continue;
                        var attribute1 = attributes[key];
                        var attributeArray1 = attribute1.array;
                        var attribute2 = geometry.attributes[key];
                        var attributeArray2 = attribute2.array;
                        var attributeOffset = attribute2.itemSize * offset;
                        var length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);
                        for (var i = 0, j = attributeOffset; i < length; i++, j++) {
                            attributeArray1[j] = attributeArray2[i];
                        }
                    }
                    return this;
                },
                normalizeNormals: function () {
                    var normals = this.attributes.normal;
                    for (var i = 0, il = normals.count; i < il; i++) {
                        _vector$4.x = normals.getX(i);
                        _vector$4.y = normals.getY(i);
                        _vector$4.z = normals.getZ(i);
                        _vector$4.normalize();
                        normals.setXYZ(i, _vector$4.x, _vector$4.y, _vector$4.z);
                    }
                },
                toNonIndexed: function () {
                    function convertBufferAttribute(attribute, indices) {
                        var array = attribute.array;
                        var itemSize = attribute.itemSize;
                        var array2 = new array.constructor(indices.length * itemSize);
                        var index = 0, index2 = 0;
                        for (var i = 0, l = indices.length; i < l; i++) {
                            index = indices[i] * itemSize;
                            for (var j = 0; j < itemSize; j++) {
                                array2[index2++] = array[index++];
                            }
                        }
                        return new BufferAttribute(array2, itemSize);
                    }
                    //
                    if (this.index === null) {
                        console.warn('THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.');
                        return this;
                    }
                    var geometry2 = new BufferGeometry();
                    var indices = this.index.array;
                    var attributes = this.attributes;
                    // attributes
                    for (var name in attributes) {
                        var attribute = attributes[name];
                        var newAttribute = convertBufferAttribute(attribute, indices);
                        geometry2.setAttribute(name, newAttribute);
                    }
                    // morph attributes
                    var morphAttributes = this.morphAttributes;
                    for (name in morphAttributes) {
                        var morphArray = [];
                        var morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes
                        for (var i = 0, il = morphAttribute.length; i < il; i++) {
                            var attribute = morphAttribute[i];
                            var newAttribute = convertBufferAttribute(attribute, indices);
                            morphArray.push(newAttribute);
                        }
                        geometry2.morphAttributes[name] = morphArray;
                    }
                    geometry2.morphTargetsRelative = this.morphTargetsRelative;
                    // groups
                    var groups = this.groups;
                    for (var i = 0, l = groups.length; i < l; i++) {
                        var group = groups[i];
                        geometry2.addGroup(group.start, group.count, group.materialIndex);
                    }
                    return geometry2;
                },
                toJSON: function () {
                    var data = {
                        metadata: {
                            version: 4.5,
                            type: 'BufferGeometry',
                            generator: 'BufferGeometry.toJSON'
                        }
                    };
                    // standard BufferGeometry serialization
                    data.uuid = this.uuid;
                    data.type = this.type;
                    if (this.name !== '')
                        data.name = this.name;
                    if (Object.keys(this.userData).length > 0)
                        data.userData = this.userData;
                    if (this.parameters !== undefined) {
                        var parameters = this.parameters;
                        for (var key in parameters) {
                            if (parameters[key] !== undefined)
                                data[key] = parameters[key];
                        }
                        return data;
                    }
                    data.data = { attributes: {} };
                    var index = this.index;
                    if (index !== null) {
                        data.data.index = {
                            type: index.array.constructor.name,
                            array: Array.prototype.slice.call(index.array)
                        };
                    }
                    var attributes = this.attributes;
                    for (var key in attributes) {
                        var attribute = attributes[key];
                        var attributeData = attribute.toJSON();
                        if (attribute.name !== '')
                            attributeData.name = attribute.name;
                        data.data.attributes[key] = attributeData;
                    }
                    var morphAttributes = {};
                    var hasMorphAttributes = false;
                    for (var key in this.morphAttributes) {
                        var attributeArray = this.morphAttributes[key];
                        var array = [];
                        for (var i = 0, il = attributeArray.length; i < il; i++) {
                            var attribute = attributeArray[i];
                            var attributeData = attribute.toJSON();
                            if (attribute.name !== '')
                                attributeData.name = attribute.name;
                            array.push(attributeData);
                        }
                        if (array.length > 0) {
                            morphAttributes[key] = array;
                            hasMorphAttributes = true;
                        }
                    }
                    if (hasMorphAttributes) {
                        data.data.morphAttributes = morphAttributes;
                        data.data.morphTargetsRelative = this.morphTargetsRelative;
                    }
                    var groups = this.groups;
                    if (groups.length > 0) {
                        data.data.groups = JSON.parse(JSON.stringify(groups));
                    }
                    var boundingSphere = this.boundingSphere;
                    if (boundingSphere !== null) {
                        data.data.boundingSphere = {
                            center: boundingSphere.center.toArray(),
                            radius: boundingSphere.radius
                        };
                    }
                    return data;
                },
                clone: function () {
                    /*
                     // Handle primitives
            
                     var parameters = this.parameters;
            
                     if ( parameters !== undefined ) {
            
                     var values = [];
            
                     for ( var key in parameters ) {
            
                     values.push( parameters[ key ] );
            
                     }
            
                     var geometry = Object.create( this.constructor.prototype );
                     this.constructor.apply( geometry, values );
                     return geometry;
            
                     }
            
                     return new this.constructor().copy( this );
                     */
                    return new BufferGeometry().copy(this);
                },
                copy: function (source) {
                    var name, i, l;
                    // reset
                    this.index = null;
                    this.attributes = {};
                    this.morphAttributes = {};
                    this.groups = [];
                    this.boundingBox = null;
                    this.boundingSphere = null;
                    // name
                    this.name = source.name;
                    // index
                    var index = source.index;
                    if (index !== null) {
                        this.setIndex(index.clone());
                    }
                    // attributes
                    var attributes = source.attributes;
                    for (name in attributes) {
                        var attribute = attributes[name];
                        this.setAttribute(name, attribute.clone());
                    }
                    // morph attributes
                    var morphAttributes = source.morphAttributes;
                    for (name in morphAttributes) {
                        var array = [];
                        var morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes
                        for (i = 0, l = morphAttribute.length; i < l; i++) {
                            array.push(morphAttribute[i].clone());
                        }
                        this.morphAttributes[name] = array;
                    }
                    this.morphTargetsRelative = source.morphTargetsRelative;
                    // groups
                    var groups = source.groups;
                    for (i = 0, l = groups.length; i < l; i++) {
                        var group = groups[i];
                        this.addGroup(group.start, group.count, group.materialIndex);
                    }
                    // bounding box
                    var boundingBox = source.boundingBox;
                    if (boundingBox !== null) {
                        this.boundingBox = boundingBox.clone();
                    }
                    // bounding sphere
                    var boundingSphere = source.boundingSphere;
                    if (boundingSphere !== null) {
                        this.boundingSphere = boundingSphere.clone();
                    }
                    // draw range
                    this.drawRange.start = source.drawRange.start;
                    this.drawRange.count = source.drawRange.count;
                    // user data
                    this.userData = source.userData;
                    return this;
                },
                dispose: function () {
                    this.dispatchEvent({ type: 'dispose' });
                }
            });
            /**
             * @author mrdoob / http://mrdoob.com/
             * @author alteredq / http://alteredqualia.com/
             * @author mikael emtinger / http://gomo.se/
             * @author jonobr1 / http://jonobr1.com/
             */
            _inverseMatrix = new Matrix4();
            _ray = new Ray();
            _sphere = new Sphere();
            _vA = new Vector3();
            _vB = new Vector3();
            _vC = new Vector3();
            _tempA = new Vector3();
            _tempB = new Vector3();
            _tempC = new Vector3();
            _morphA = new Vector3();
            _morphB = new Vector3();
            _morphC = new Vector3();
            _uvA = new Vector2();
            _uvB = new Vector2();
            _uvC = new Vector2();
            _intersectionPoint = new Vector3();
            _intersectionPointWorld = new Vector3();
            Mesh.prototype = Object.assign(Object.create(Object3D.prototype), {
                constructor: Mesh,
                isMesh: true,
                copy: function (source) {
                    Object3D.prototype.copy.call(this, source);
                    if (source.morphTargetInfluences !== undefined) {
                        this.morphTargetInfluences = source.morphTargetInfluences.slice();
                    }
                    if (source.morphTargetDictionary !== undefined) {
                        this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
                    }
                    return this;
                },
                updateMorphTargets: function () {
                    var geometry = this.geometry;
                    var m, ml, name;
                    if (geometry.isBufferGeometry) {
                        var morphAttributes = geometry.morphAttributes;
                        var keys = Object.keys(morphAttributes);
                        if (keys.length > 0) {
                            var morphAttribute = morphAttributes[keys[0]];
                            if (morphAttribute !== undefined) {
                                this.morphTargetInfluences = [];
                                this.morphTargetDictionary = {};
                                for (m = 0, ml = morphAttribute.length; m < ml; m++) {
                                    name = morphAttribute[m].name || String(m);
                                    this.morphTargetInfluences.push(0);
                                    this.morphTargetDictionary[name] = m;
                                }
                            }
                        }
                    }
                    else {
                        var morphTargets = geometry.morphTargets;
                        if (morphTargets !== undefined && morphTargets.length > 0) {
                            console.error('THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
                        }
                    }
                },
                raycast: function (raycaster, intersects) {
                    var geometry = this.geometry;
                    var material = this.material;
                    var matrixWorld = this.matrixWorld;
                    if (material === undefined)
                        return;
                    // Checking boundingSphere distance to ray
                    if (geometry.boundingSphere === null)
                        geometry.computeBoundingSphere();
                    _sphere.copy(geometry.boundingSphere);
                    _sphere.applyMatrix4(matrixWorld);
                    if (raycaster.ray.intersectsSphere(_sphere) === false)
                        return;
                    //
                    _inverseMatrix.getInverse(matrixWorld);
                    _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);
                    // Check boundingBox before continuing
                    if (geometry.boundingBox !== null) {
                        if (_ray.intersectsBox(geometry.boundingBox) === false)
                            return;
                    }
                    var intersection;
                    if (geometry.isBufferGeometry) {
                        var a, b, c;
                        var index = geometry.index;
                        var position = geometry.attributes.position;
                        var morphPosition = geometry.morphAttributes.position;
                        var morphTargetsRelative = geometry.morphTargetsRelative;
                        var uv = geometry.attributes.uv;
                        var uv2 = geometry.attributes.uv2;
                        var groups = geometry.groups;
                        var drawRange = geometry.drawRange;
                        var i, j, il, jl;
                        var group, groupMaterial;
                        var start, end;
                        if (index !== null) {
                            // indexed buffer geometry
                            if (Array.isArray(material)) {
                                for (i = 0, il = groups.length; i < il; i++) {
                                    group = groups[i];
                                    groupMaterial = material[group.materialIndex];
                                    start = Math.max(group.start, drawRange.start);
                                    end = Math.min((group.start + group.count), (drawRange.start + drawRange.count));
                                    for (j = start, jl = end; j < jl; j += 3) {
                                        a = index.getX(j);
                                        b = index.getX(j + 1);
                                        c = index.getX(j + 2);
                                        intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
                                        if (intersection) {
                                            intersection.faceIndex = Math.floor(j / 3); // triangle number in indexed buffer semantics
                                            intersection.face.materialIndex = group.materialIndex;
                                            intersects.push(intersection);
                                        }
                                    }
                                }
                            }
                            else {
                                start = Math.max(0, drawRange.start);
                                end = Math.min(index.count, (drawRange.start + drawRange.count));
                                for (i = start, il = end; i < il; i += 3) {
                                    a = index.getX(i);
                                    b = index.getX(i + 1);
                                    c = index.getX(i + 2);
                                    intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
                                    if (intersection) {
                                        intersection.faceIndex = Math.floor(i / 3); // triangle number in indexed buffer semantics
                                        intersects.push(intersection);
                                    }
                                }
                            }
                        }
                        else if (position !== undefined) {
                            // non-indexed buffer geometry
                            if (Array.isArray(material)) {
                                for (i = 0, il = groups.length; i < il; i++) {
                                    group = groups[i];
                                    groupMaterial = material[group.materialIndex];
                                    start = Math.max(group.start, drawRange.start);
                                    end = Math.min((group.start + group.count), (drawRange.start + drawRange.count));
                                    for (j = start, jl = end; j < jl; j += 3) {
                                        a = j;
                                        b = j + 1;
                                        c = j + 2;
                                        intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
                                        if (intersection) {
                                            intersection.faceIndex = Math.floor(j / 3); // triangle number in non-indexed buffer semantics
                                            intersection.face.materialIndex = group.materialIndex;
                                            intersects.push(intersection);
                                        }
                                    }
                                }
                            }
                            else {
                                start = Math.max(0, drawRange.start);
                                end = Math.min(position.count, (drawRange.start + drawRange.count));
                                for (i = start, il = end; i < il; i += 3) {
                                    a = i;
                                    b = i + 1;
                                    c = i + 2;
                                    intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
                                    if (intersection) {
                                        intersection.faceIndex = Math.floor(i / 3); // triangle number in non-indexed buffer semantics
                                        intersects.push(intersection);
                                    }
                                }
                            }
                        }
                    }
                    else if (geometry.isGeometry) {
                        var fvA, fvB, fvC;
                        var isMultiMaterial = Array.isArray(material);
                        var vertices = geometry.vertices;
                        var faces = geometry.faces;
                        var uvs;
                        var faceVertexUvs = geometry.faceVertexUvs[0];
                        if (faceVertexUvs.length > 0)
                            uvs = faceVertexUvs;
                        for (var f = 0, fl = faces.length; f < fl; f++) {
                            var face = faces[f];
                            var faceMaterial = isMultiMaterial ? material[face.materialIndex] : material;
                            if (faceMaterial === undefined)
                                continue;
                            fvA = vertices[face.a];
                            fvB = vertices[face.b];
                            fvC = vertices[face.c];
                            intersection = checkIntersection(this, faceMaterial, raycaster, _ray, fvA, fvB, fvC, _intersectionPoint);
                            if (intersection) {
                                if (uvs && uvs[f]) {
                                    var uvs_f = uvs[f];
                                    _uvA.copy(uvs_f[0]);
                                    _uvB.copy(uvs_f[1]);
                                    _uvC.copy(uvs_f[2]);
                                    intersection.uv = Triangle.getUV(_intersectionPoint, fvA, fvB, fvC, _uvA, _uvB, _uvC, new Vector2());
                                }
                                intersection.face = face;
                                intersection.faceIndex = f;
                                intersects.push(intersection);
                            }
                        }
                    }
                },
                clone: function () {
                    return new this.constructor(this.geometry, this.material).copy(this);
                }
            });
            /**
             * @author mrdoob / http://mrdoob.com/
             * @author kile / http://kile.stravaganza.org/
             * @author alteredq / http://alteredqualia.com/
             * @author mikael emtinger / http://gomo.se/
             * @author zz85 / http://www.lab4games.net/zz85/blog
             * @author bhouston / http://clara.io
             */
            _geometryId = 0; // Geometry uses even numbers as Id
            _m1$3 = new Matrix4();
            _obj$1 = new Object3D();
            _offset$1 = new Vector3();
            Geometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
                constructor: Geometry,
                isGeometry: true,
                applyMatrix4: function (matrix) {
                    var normalMatrix = new Matrix3().getNormalMatrix(matrix);
                    for (var i = 0, il = this.vertices.length; i < il; i++) {
                        var vertex = this.vertices[i];
                        vertex.applyMatrix4(matrix);
                    }
                    for (var i = 0, il = this.faces.length; i < il; i++) {
                        var face = this.faces[i];
                        face.normal.applyMatrix3(normalMatrix).normalize();
                        for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {
                            face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();
                        }
                    }
                    if (this.boundingBox !== null) {
                        this.computeBoundingBox();
                    }
                    if (this.boundingSphere !== null) {
                        this.computeBoundingSphere();
                    }
                    this.verticesNeedUpdate = true;
                    this.normalsNeedUpdate = true;
                    return this;
                },
                rotateX: function (angle) {
                    // rotate geometry around world x-axis
                    _m1$3.makeRotationX(angle);
                    this.applyMatrix4(_m1$3);
                    return this;
                },
                rotateY: function (angle) {
                    // rotate geometry around world y-axis
                    _m1$3.makeRotationY(angle);
                    this.applyMatrix4(_m1$3);
                    return this;
                },
                rotateZ: function (angle) {
                    // rotate geometry around world z-axis
                    _m1$3.makeRotationZ(angle);
                    this.applyMatrix4(_m1$3);
                    return this;
                },
                translate: function (x, y, z) {
                    // translate geometry
                    _m1$3.makeTranslation(x, y, z);
                    this.applyMatrix4(_m1$3);
                    return this;
                },
                scale: function (x, y, z) {
                    // scale geometry
                    _m1$3.makeScale(x, y, z);
                    this.applyMatrix4(_m1$3);
                    return this;
                },
                lookAt: function (vector) {
                    _obj$1.lookAt(vector);
                    _obj$1.updateMatrix();
                    this.applyMatrix4(_obj$1.matrix);
                    return this;
                },
                fromBufferGeometry: function (geometry) {
                    var scope = this;
                    var indices = geometry.index !== null ? geometry.index.array : undefined;
                    var attributes = geometry.attributes;
                    if (attributes.position === undefined) {
                        console.error('THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.');
                        return this;
                    }
                    var positions = attributes.position.array;
                    var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
                    var colors = attributes.color !== undefined ? attributes.color.array : undefined;
                    var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
                    var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;
                    if (uvs2 !== undefined)
                        this.faceVertexUvs[1] = [];
                    for (var i = 0; i < positions.length; i += 3) {
                        scope.vertices.push(new Vector3().fromArray(positions, i));
                        if (colors !== undefined) {
                            scope.colors.push(new Color().fromArray(colors, i));
                        }
                    }
                    function addFace(a, b, c, materialIndex) {
                        var vertexColors = (colors === undefined) ? [] : [
                            scope.colors[a].clone(),
                            scope.colors[b].clone(),
                            scope.colors[c].clone()
                        ];
                        var vertexNormals = (normals === undefined) ? [] : [
                            new Vector3().fromArray(normals, a * 3),
                            new Vector3().fromArray(normals, b * 3),
                            new Vector3().fromArray(normals, c * 3)
                        ];
                        var face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);
                        scope.faces.push(face);
                        if (uvs !== undefined) {
                            scope.faceVertexUvs[0].push([
                                new Vector2().fromArray(uvs, a * 2),
                                new Vector2().fromArray(uvs, b * 2),
                                new Vector2().fromArray(uvs, c * 2)
                            ]);
                        }
                        if (uvs2 !== undefined) {
                            scope.faceVertexUvs[1].push([
                                new Vector2().fromArray(uvs2, a * 2),
                                new Vector2().fromArray(uvs2, b * 2),
                                new Vector2().fromArray(uvs2, c * 2)
                            ]);
                        }
                    }
                    var groups = geometry.groups;
                    if (groups.length > 0) {
                        for (var i = 0; i < groups.length; i++) {
                            var group = groups[i];
                            var start = group.start;
                            var count = group.count;
                            for (var j = start, jl = start + count; j < jl; j += 3) {
                                if (indices !== undefined) {
                                    addFace(indices[j], indices[j + 1], indices[j + 2], group.materialIndex);
                                }
                                else {
                                    addFace(j, j + 1, j + 2, group.materialIndex);
                                }
                            }
                        }
                    }
                    else {
                        if (indices !== undefined) {
                            for (var i = 0; i < indices.length; i += 3) {
                                addFace(indices[i], indices[i + 1], indices[i + 2]);
                            }
                        }
                        else {
                            for (var i = 0; i < positions.length / 3; i += 3) {
                                addFace(i, i + 1, i + 2);
                            }
                        }
                    }
                    this.computeFaceNormals();
                    if (geometry.boundingBox !== null) {
                        this.boundingBox = geometry.boundingBox.clone();
                    }
                    if (geometry.boundingSphere !== null) {
                        this.boundingSphere = geometry.boundingSphere.clone();
                    }
                    return this;
                },
                center: function () {
                    this.computeBoundingBox();
                    this.boundingBox.getCenter(_offset$1).negate();
                    this.translate(_offset$1.x, _offset$1.y, _offset$1.z);
                    return this;
                },
                normalize: function () {
                    this.computeBoundingSphere();
                    var center = this.boundingSphere.center;
                    var radius = this.boundingSphere.radius;
                    var s = radius === 0 ? 1 : 1.0 / radius;
                    var matrix = new Matrix4();
                    matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);
                    this.applyMatrix4(matrix);
                    return this;
                },
                computeFaceNormals: function () {
                    var cb = new Vector3(), ab = new Vector3();
                    for (var f = 0, fl = this.faces.length; f < fl; f++) {
                        var face = this.faces[f];
                        var vA = this.vertices[face.a];
                        var vB = this.vertices[face.b];
                        var vC = this.vertices[face.c];
                        cb.subVectors(vC, vB);
                        ab.subVectors(vA, vB);
                        cb.cross(ab);
                        cb.normalize();
                        face.normal.copy(cb);
                    }
                },
                computeVertexNormals: function (areaWeighted) {
                    if (areaWeighted === undefined)
                        areaWeighted = true;
                    var v, vl, f, fl, face, vertices;
                    vertices = new Array(this.vertices.length);
                    for (v = 0, vl = this.vertices.length; v < vl; v++) {
                        vertices[v] = new Vector3();
                    }
                    if (areaWeighted) {
                        // vertex normals weighted by triangle areas
                        // http://www.iquilezles.org/www/articles/normals/normals.htm
                        var vA, vB, vC;
                        var cb = new Vector3(), ab = new Vector3();
                        for (f = 0, fl = this.faces.length; f < fl; f++) {
                            face = this.faces[f];
                            vA = this.vertices[face.a];
                            vB = this.vertices[face.b];
                            vC = this.vertices[face.c];
                            cb.subVectors(vC, vB);
                            ab.subVectors(vA, vB);
                            cb.cross(ab);
                            vertices[face.a].add(cb);
                            vertices[face.b].add(cb);
                            vertices[face.c].add(cb);
                        }
                    }
                    else {
                        this.computeFaceNormals();
                        for (f = 0, fl = this.faces.length; f < fl; f++) {
                            face = this.faces[f];
                            vertices[face.a].add(face.normal);
                            vertices[face.b].add(face.normal);
                            vertices[face.c].add(face.normal);
                        }
                    }
                    for (v = 0, vl = this.vertices.length; v < vl; v++) {
                        vertices[v].normalize();
                    }
                    for (f = 0, fl = this.faces.length; f < fl; f++) {
                        face = this.faces[f];
                        var vertexNormals = face.vertexNormals;
                        if (vertexNormals.length === 3) {
                            vertexNormals[0].copy(vertices[face.a]);
                            vertexNormals[1].copy(vertices[face.b]);
                            vertexNormals[2].copy(vertices[face.c]);
                        }
                        else {
                            vertexNormals[0] = vertices[face.a].clone();
                            vertexNormals[1] = vertices[face.b].clone();
                            vertexNormals[2] = vertices[face.c].clone();
                        }
                    }
                    if (this.faces.length > 0) {
                        this.normalsNeedUpdate = true;
                    }
                },
                computeFlatVertexNormals: function () {
                    var f, fl, face;
                    this.computeFaceNormals();
                    for (f = 0, fl = this.faces.length; f < fl; f++) {
                        face = this.faces[f];
                        var vertexNormals = face.vertexNormals;
                        if (vertexNormals.length === 3) {
                            vertexNormals[0].copy(face.normal);
                            vertexNormals[1].copy(face.normal);
                            vertexNormals[2].copy(face.normal);
                        }
                        else {
                            vertexNormals[0] = face.normal.clone();
                            vertexNormals[1] = face.normal.clone();
                            vertexNormals[2] = face.normal.clone();
                        }
                    }
                    if (this.faces.length > 0) {
                        this.normalsNeedUpdate = true;
                    }
                },
                computeMorphNormals: function () {
                    var i, il, f, fl, face;
                    // save original normals
                    // - create temp variables on first access
                    //   otherwise just copy (for faster repeated calls)
                    for (f = 0, fl = this.faces.length; f < fl; f++) {
                        face = this.faces[f];
                        if (!face.__originalFaceNormal) {
                            face.__originalFaceNormal = face.normal.clone();
                        }
                        else {
                            face.__originalFaceNormal.copy(face.normal);
                        }
                        if (!face.__originalVertexNormals)
                            face.__originalVertexNormals = [];
                        for (i = 0, il = face.vertexNormals.length; i < il; i++) {
                            if (!face.__originalVertexNormals[i]) {
                                face.__originalVertexNormals[i] = face.vertexNormals[i].clone();
                            }
                            else {
                                face.__originalVertexNormals[i].copy(face.vertexNormals[i]);
                            }
                        }
                    }
                    // use temp geometry to compute face and vertex normals for each morph
                    var tmpGeo = new Geometry();
                    tmpGeo.faces = this.faces;
                    for (i = 0, il = this.morphTargets.length; i < il; i++) {
                        // create on first access
                        if (!this.morphNormals[i]) {
                            this.morphNormals[i] = {};
                            this.morphNormals[i].faceNormals = [];
                            this.morphNormals[i].vertexNormals = [];
                            var dstNormalsFace = this.morphNormals[i].faceNormals;
                            var dstNormalsVertex = this.morphNormals[i].vertexNormals;
                            var faceNormal, vertexNormals;
                            for (f = 0, fl = this.faces.length; f < fl; f++) {
                                faceNormal = new Vector3();
                                vertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };
                                dstNormalsFace.push(faceNormal);
                                dstNormalsVertex.push(vertexNormals);
                            }
                        }
                        var morphNormals = this.morphNormals[i];
                        // set vertices to morph target
                        tmpGeo.vertices = this.morphTargets[i].vertices;
                        // compute morph normals
                        tmpGeo.computeFaceNormals();
                        tmpGeo.computeVertexNormals();
                        // store morph normals
                        var faceNormal, vertexNormals;
                        for (f = 0, fl = this.faces.length; f < fl; f++) {
                            face = this.faces[f];
                            faceNormal = morphNormals.faceNormals[f];
                            vertexNormals = morphNormals.vertexNormals[f];
                            faceNormal.copy(face.normal);
                            vertexNormals.a.copy(face.vertexNormals[0]);
                            vertexNormals.b.copy(face.vertexNormals[1]);
                            vertexNormals.c.copy(face.vertexNormals[2]);
                        }
                    }
                    // restore original normals
                    for (f = 0, fl = this.faces.length; f < fl; f++) {
                        face = this.faces[f];
                        face.normal = face.__originalFaceNormal;
                        face.vertexNormals = face.__originalVertexNormals;
                    }
                },
                computeBoundingBox: function () {
                    if (this.boundingBox === null) {
                        this.boundingBox = new Box3();
                    }
                    this.boundingBox.setFromPoints(this.vertices);
                },
                computeBoundingSphere: function () {
                    if (this.boundingSphere === null) {
                        this.boundingSphere = new Sphere();
                    }
                    this.boundingSphere.setFromPoints(this.vertices);
                },
                merge: function (geometry, matrix, materialIndexOffset) {
                    if (!(geometry && geometry.isGeometry)) {
                        console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry);
                        return;
                    }
                    var normalMatrix, vertexOffset = this.vertices.length, vertices1 = this.vertices, vertices2 = geometry.vertices, faces1 = this.faces, faces2 = geometry.faces, colors1 = this.colors, colors2 = geometry.colors;
                    if (materialIndexOffset === undefined)
                        materialIndexOffset = 0;
                    if (matrix !== undefined) {
                        normalMatrix = new Matrix3().getNormalMatrix(matrix);
                    }
                    // vertices
                    for (var i = 0, il = vertices2.length; i < il; i++) {
                        var vertex = vertices2[i];
                        var vertexCopy = vertex.clone();
                        if (matrix !== undefined)
                            vertexCopy.applyMatrix4(matrix);
                        vertices1.push(vertexCopy);
                    }
                    // colors
                    for (var i = 0, il = colors2.length; i < il; i++) {
                        colors1.push(colors2[i].clone());
                    }
                    // faces
                    for (i = 0, il = faces2.length; i < il; i++) {
                        var face = faces2[i], faceCopy, normal, color, faceVertexNormals = face.vertexNormals, faceVertexColors = face.vertexColors;
                        faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);
                        faceCopy.normal.copy(face.normal);
                        if (normalMatrix !== undefined) {
                            faceCopy.normal.applyMatrix3(normalMatrix).normalize();
                        }
                        for (var j = 0, jl = faceVertexNormals.length; j < jl; j++) {
                            normal = faceVertexNormals[j].clone();
                            if (normalMatrix !== undefined) {
                                normal.applyMatrix3(normalMatrix).normalize();
                            }
                            faceCopy.vertexNormals.push(normal);
                        }
                        faceCopy.color.copy(face.color);
                        for (var j = 0, jl = faceVertexColors.length; j < jl; j++) {
                            color = faceVertexColors[j];
                            faceCopy.vertexColors.push(color.clone());
                        }
                        faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
                        faces1.push(faceCopy);
                    }
                    // uvs
                    for (var i = 0, il = geometry.faceVertexUvs.length; i < il; i++) {
                        var faceVertexUvs2 = geometry.faceVertexUvs[i];
                        if (this.faceVertexUvs[i] === undefined)
                            this.faceVertexUvs[i] = [];
                        for (var j = 0, jl = faceVertexUvs2.length; j < jl; j++) {
                            var uvs2 = faceVertexUvs2[j], uvsCopy = [];
                            for (var k = 0, kl = uvs2.length; k < kl; k++) {
                                uvsCopy.push(uvs2[k].clone());
                            }
                            this.faceVertexUvs[i].push(uvsCopy);
                        }
                    }
                },
                mergeMesh: function (mesh) {
                    if (!(mesh && mesh.isMesh)) {
                        console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh);
                        return;
                    }
                    if (mesh.matrixAutoUpdate)
                        mesh.updateMatrix();
                    this.merge(mesh.geometry, mesh.matrix);
                },
                /*
                 * Checks for duplicate vertices with hashmap.
                 * Duplicated vertices are removed
                 * and faces' vertices are updated.
                 */
                mergeVertices: function () {
                    var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
                    var unique = [], changes = [];
                    var v, key;
                    var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
                    var precision = Math.pow(10, precisionPoints);
                    var i, il, face;
                    var indices, j, jl;
                    for (i = 0, il = this.vertices.length; i < il; i++) {
                        v = this.vertices[i];
                        key = Math.round(v.x * precision) + '_' + Math.round(v.y * precision) + '_' + Math.round(v.z * precision);
                        if (verticesMap[key] === undefined) {
                            verticesMap[key] = i;
                            unique.push(this.vertices[i]);
                            changes[i] = unique.length - 1;
                        }
                        else {
                            //console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
                            changes[i] = changes[verticesMap[key]];
                        }
                    }
                    // if faces are completely degenerate after merging vertices, we
                    // have to remove them from the geometry.
                    var faceIndicesToRemove = [];
                    for (i = 0, il = this.faces.length; i < il; i++) {
                        face = this.faces[i];
                        face.a = changes[face.a];
                        face.b = changes[face.b];
                        face.c = changes[face.c];
                        indices = [face.a, face.b, face.c];
                        // if any duplicate vertices are found in a Face3
                        // we have to remove the face as nothing can be saved
                        for (var n = 0; n < 3; n++) {
                            if (indices[n] === indices[(n + 1) % 3]) {
                                faceIndicesToRemove.push(i);
                                break;
                            }
                        }
                    }
                    for (i = faceIndicesToRemove.length - 1; i >= 0; i--) {
                        var idx = faceIndicesToRemove[i];
                        this.faces.splice(idx, 1);
                        for (j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {
                            this.faceVertexUvs[j].splice(idx, 1);
                        }
                    }
                    // Use unique set of vertices
                    var diff = this.vertices.length - unique.length;
                    this.vertices = unique;
                    return diff;
                },
                setFromPoints: function (points) {
                    this.vertices = [];
                    for (var i = 0, l = points.length; i < l; i++) {
                        var point = points[i];
                        this.vertices.push(new Vector3(point.x, point.y, point.z || 0));
                    }
                    return this;
                },
                sortFacesByMaterialIndex: function () {
                    var faces = this.faces;
                    var length = faces.length;
                    // tag faces
                    for (var i = 0; i < length; i++) {
                        faces[i]._id = i;
                    }
                    // sort faces
                    function materialIndexSort(a, b) {
                        return a.materialIndex - b.materialIndex;
                    }
                    faces.sort(materialIndexSort);
                    // sort uvs
                    var uvs1 = this.faceVertexUvs[0];
                    var uvs2 = this.faceVertexUvs[1];
                    var newUvs1, newUvs2;
                    if (uvs1 && uvs1.length === length)
                        newUvs1 = [];
                    if (uvs2 && uvs2.length === length)
                        newUvs2 = [];
                    for (var i = 0; i < length; i++) {
                        var id = faces[i]._id;
                        if (newUvs1)
                            newUvs1.push(uvs1[id]);
                        if (newUvs2)
                            newUvs2.push(uvs2[id]);
                    }
                    if (newUvs1)
                        this.faceVertexUvs[0] = newUvs1;
                    if (newUvs2)
                        this.faceVertexUvs[1] = newUvs2;
                },
                toJSON: function () {
                    var data = {
                        metadata: {
                            version: 4.5,
                            type: 'Geometry',
                            generator: 'Geometry.toJSON'
                        }
                    };
                    // standard Geometry serialization
                    data.uuid = this.uuid;
                    data.type = this.type;
                    if (this.name !== '')
                        data.name = this.name;
                    if (this.parameters !== undefined) {
                        var parameters = this.parameters;
                        for (var key in parameters) {
                            if (parameters[key] !== undefined)
                                data[key] = parameters[key];
                        }
                        return data;
                    }
                    var vertices = [];
                    for (var i = 0; i < this.vertices.length; i++) {
                        var vertex = this.vertices[i];
                        vertices.push(vertex.x, vertex.y, vertex.z);
                    }
                    var faces = [];
                    var normals = [];
                    var normalsHash = {};
                    var colors = [];
                    var colorsHash = {};
                    var uvs = [];
                    var uvsHash = {};
                    for (var i = 0; i < this.faces.length; i++) {
                        var face = this.faces[i];
                        var hasMaterial = true;
                        var hasFaceUv = false; // deprecated
                        var hasFaceVertexUv = this.faceVertexUvs[0][i] !== undefined;
                        var hasFaceNormal = face.normal.length() > 0;
                        var hasFaceVertexNormal = face.vertexNormals.length > 0;
                        var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
                        var hasFaceVertexColor = face.vertexColors.length > 0;
                        var faceType = 0;
                        faceType = setBit(faceType, 0, 0); // isQuad
                        faceType = setBit(faceType, 1, hasMaterial);
                        faceType = setBit(faceType, 2, hasFaceUv);
                        faceType = setBit(faceType, 3, hasFaceVertexUv);
                        faceType = setBit(faceType, 4, hasFaceNormal);
                        faceType = setBit(faceType, 5, hasFaceVertexNormal);
                        faceType = setBit(faceType, 6, hasFaceColor);
                        faceType = setBit(faceType, 7, hasFaceVertexColor);
                        faces.push(faceType);
                        faces.push(face.a, face.b, face.c);
                        faces.push(face.materialIndex);
                        if (hasFaceVertexUv) {
                            var faceVertexUvs = this.faceVertexUvs[0][i];
                            faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));
                        }
                        if (hasFaceNormal) {
                            faces.push(getNormalIndex(face.normal));
                        }
                        if (hasFaceVertexNormal) {
                            var vertexNormals = face.vertexNormals;
                            faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));
                        }
                        if (hasFaceColor) {
                            faces.push(getColorIndex(face.color));
                        }
                        if (hasFaceVertexColor) {
                            var vertexColors = face.vertexColors;
                            faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));
                        }
                    }
                    function setBit(value, position, enabled) {
                        return enabled ? value | (1 << position) : value & (~(1 << position));
                    }
                    function getNormalIndex(normal) {
                        var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();
                        if (normalsHash[hash] !== undefined) {
                            return normalsHash[hash];
                        }
                        normalsHash[hash] = normals.length / 3;
                        normals.push(normal.x, normal.y, normal.z);
                        return normalsHash[hash];
                    }
                    function getColorIndex(color) {
                        var hash = color.r.toString() + color.g.toString() + color.b.toString();
                        if (colorsHash[hash] !== undefined) {
                            return colorsHash[hash];
                        }
                        colorsHash[hash] = colors.length;
                        colors.push(color.getHex());
                        return colorsHash[hash];
                    }
                    function getUvIndex(uv) {
                        var hash = uv.x.toString() + uv.y.toString();
                        if (uvsHash[hash] !== undefined) {
                            return uvsHash[hash];
                        }
                        uvsHash[hash] = uvs.length / 2;
                        uvs.push(uv.x, uv.y);
                        return uvsHash[hash];
                    }
                    data.data = {};
                    data.data.vertices = vertices;
                    data.data.normals = normals;
                    if (colors.length > 0)
                        data.data.colors = colors;
                    if (uvs.length > 0)
                        data.data.uvs = [uvs]; // temporal backward compatibility
                    data.data.faces = faces;
                    return data;
                },
                clone: function () {
                    /*
                     // Handle primitives
            
                     var parameters = this.parameters;
            
                     if ( parameters !== undefined ) {
            
                     var values = [];
            
                     for ( var key in parameters ) {
            
                     values.push( parameters[ key ] );
            
                     }
            
                     var geometry = Object.create( this.constructor.prototype );
                     this.constructor.apply( geometry, values );
                     return geometry;
            
                     }
            
                     return new this.constructor().copy( this );
                     */
                    return new Geometry().copy(this);
                },
                copy: function (source) {
                    var i, il, j, jl, k, kl;
                    // reset
                    this.vertices = [];
                    this.colors = [];
                    this.faces = [];
                    this.faceVertexUvs = [[]];
                    this.morphTargets = [];
                    this.morphNormals = [];
                    this.skinWeights = [];
                    this.skinIndices = [];
                    this.lineDistances = [];
                    this.boundingBox = null;
                    this.boundingSphere = null;
                    // name
                    this.name = source.name;
                    // vertices
                    var vertices = source.vertices;
                    for (i = 0, il = vertices.length; i < il; i++) {
                        this.vertices.push(vertices[i].clone());
                    }
                    // colors
                    var colors = source.colors;
                    for (i = 0, il = colors.length; i < il; i++) {
                        this.colors.push(colors[i].clone());
                    }
                    // faces
                    var faces = source.faces;
                    for (i = 0, il = faces.length; i < il; i++) {
                        this.faces.push(faces[i].clone());
                    }
                    // face vertex uvs
                    for (i = 0, il = source.faceVertexUvs.length; i < il; i++) {
                        var faceVertexUvs = source.faceVertexUvs[i];
                        if (this.faceVertexUvs[i] === undefined) {
                            this.faceVertexUvs[i] = [];
                        }
                        for (j = 0, jl = faceVertexUvs.length; j < jl; j++) {
                            var uvs = faceVertexUvs[j], uvsCopy = [];
                            for (k = 0, kl = uvs.length; k < kl; k++) {
                                var uv = uvs[k];
                                uvsCopy.push(uv.clone());
                            }
                            this.faceVertexUvs[i].push(uvsCopy);
                        }
                    }
                    // morph targets
                    var morphTargets = source.morphTargets;
                    for (i = 0, il = morphTargets.length; i < il; i++) {
                        var morphTarget = {};
                        morphTarget.name = morphTargets[i].name;
                        // vertices
                        if (morphTargets[i].vertices !== undefined) {
                            morphTarget.vertices = [];
                            for (j = 0, jl = morphTargets[i].vertices.length; j < jl; j++) {
                                morphTarget.vertices.push(morphTargets[i].vertices[j].clone());
                            }
                        }
                        // normals
                        if (morphTargets[i].normals !== undefined) {
                            morphTarget.normals = [];
                            for (j = 0, jl = morphTargets[i].normals.length; j < jl; j++) {
                                morphTarget.normals.push(morphTargets[i].normals[j].clone());
                            }
                        }
                        this.morphTargets.push(morphTarget);
                    }
                    // morph normals
                    var morphNormals = source.morphNormals;
                    for (i = 0, il = morphNormals.length; i < il; i++) {
                        var morphNormal = {};
                        // vertex normals
                        if (morphNormals[i].vertexNormals !== undefined) {
                            morphNormal.vertexNormals = [];
                            for (j = 0, jl = morphNormals[i].vertexNormals.length; j < jl; j++) {
                                var srcVertexNormal = morphNormals[i].vertexNormals[j];
                                var destVertexNormal = {};
                                destVertexNormal.a = srcVertexNormal.a.clone();
                                destVertexNormal.b = srcVertexNormal.b.clone();
                                destVertexNormal.c = srcVertexNormal.c.clone();
                                morphNormal.vertexNormals.push(destVertexNormal);
                            }
                        }
                        // face normals
                        if (morphNormals[i].faceNormals !== undefined) {
                            morphNormal.faceNormals = [];
                            for (j = 0, jl = morphNormals[i].faceNormals.length; j < jl; j++) {
                                morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());
                            }
                        }
                        this.morphNormals.push(morphNormal);
                    }
                    // skin weights
                    var skinWeights = source.skinWeights;
                    for (i = 0, il = skinWeights.length; i < il; i++) {
                        this.skinWeights.push(skinWeights[i].clone());
                    }
                    // skin indices
                    var skinIndices = source.skinIndices;
                    for (i = 0, il = skinIndices.length; i < il; i++) {
                        this.skinIndices.push(skinIndices[i].clone());
                    }
                    // line distances
                    var lineDistances = source.lineDistances;
                    for (i = 0, il = lineDistances.length; i < il; i++) {
                        this.lineDistances.push(lineDistances[i]);
                    }
                    // bounding box
                    var boundingBox = source.boundingBox;
                    if (boundingBox !== null) {
                        this.boundingBox = boundingBox.clone();
                    }
                    // bounding sphere
                    var boundingSphere = source.boundingSphere;
                    if (boundingSphere !== null) {
                        this.boundingSphere = boundingSphere.clone();
                    }
                    // update flags
                    this.elementsNeedUpdate = source.elementsNeedUpdate;
                    this.verticesNeedUpdate = source.verticesNeedUpdate;
                    this.uvsNeedUpdate = source.uvsNeedUpdate;
                    this.normalsNeedUpdate = source.normalsNeedUpdate;
                    this.colorsNeedUpdate = source.colorsNeedUpdate;
                    this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
                    this.groupsNeedUpdate = source.groupsNeedUpdate;
                    return this;
                },
                dispose: function () {
                    this.dispatchEvent({ type: 'dispose' });
                }
            });
            /**
             * @author mrdoob / http://mrdoob.com/
             * @author Mugen87 / https://github.com/Mugen87
             */
            // BoxGeometry
            BoxGeometry = class BoxGeometry extends Geometry {
                constructor(width, height, depth, widthSegments, heightSegments, depthSegments) {
                    super();
                    this.type = 'BoxGeometry';
                    this.parameters = {
                        width: width,
                        height: height,
                        depth: depth,
                        widthSegments: widthSegments,
                        heightSegments: heightSegments,
                        depthSegments: depthSegments
                    };
                    this.fromBufferGeometry(new BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments));
                    this.mergeVertices();
                }
            };
            exports_14("BoxGeometry", BoxGeometry);
            exports_14("CubeGeometry", BoxGeometry);
            // BoxBufferGeometry
            BoxBufferGeometry = class BoxBufferGeometry extends BufferGeometry {
                constructor(width, height, depth, widthSegments, heightSegments, depthSegments) {
                    super();
                    this.type = 'BoxBufferGeometry';
                    this.parameters = {
                        width: width,
                        height: height,
                        depth: depth,
                        widthSegments: widthSegments,
                        heightSegments: heightSegments,
                        depthSegments: depthSegments
                    };
                    var scope = this;
                    width = width || 1;
                    height = height || 1;
                    depth = depth || 1;
                    // segments
                    widthSegments = Math.floor(widthSegments) || 1;
                    heightSegments = Math.floor(heightSegments) || 1;
                    depthSegments = Math.floor(depthSegments) || 1;
                    // buffers
                    var indices = [];
                    var vertices = [];
                    var normals = [];
                    var uvs = [];
                    // helper variables
                    var numberOfVertices = 0;
                    var groupStart = 0;
                    // build each side of the box geometry
                    buildPlane('z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0); // px
                    buildPlane('z', 'y', 'x', 1, -1, depth, height, -width, depthSegments, heightSegments, 1); // nx
                    buildPlane('x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2); // py
                    buildPlane('x', 'z', 'y', 1, -1, width, depth, -height, widthSegments, depthSegments, 3); // ny
                    buildPlane('x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4); // pz
                    buildPlane('x', 'y', 'z', -1, -1, width, height, -depth, widthSegments, heightSegments, 5); // nz
                    // build geometry
                    this.setIndex(indices);
                    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
                    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
                    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
                    function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {
                        var segmentWidth = width / gridX;
                        var segmentHeight = height / gridY;
                        var widthHalf = width / 2;
                        var heightHalf = height / 2;
                        var depthHalf = depth / 2;
                        var gridX1 = gridX + 1;
                        var gridY1 = gridY + 1;
                        var vertexCounter = 0;
                        var groupCount = 0;
                        var ix, iy;
                        var vector = new Vector3();
                        // generate vertices, normals and uvs
                        for (iy = 0; iy < gridY1; iy++) {
                            var y = iy * segmentHeight - heightHalf;
                            for (ix = 0; ix < gridX1; ix++) {
                                var x = ix * segmentWidth - widthHalf;
                                // set values to correct vector component
                                vector[u] = x * udir;
                                vector[v] = y * vdir;
                                vector[w] = depthHalf;
                                // now apply vector to vertex buffer
                                vertices.push(vector.x, vector.y, vector.z);
                                // set values to correct vector component
                                vector[u] = 0;
                                vector[v] = 0;
                                vector[w] = depth > 0 ? 1 : -1;
                                // now apply vector to normal buffer
                                normals.push(vector.x, vector.y, vector.z);
                                // uvs
                                uvs.push(ix / gridX);
                                uvs.push(1 - (iy / gridY));
                                // counters
                                vertexCounter += 1;
                            }
                        }
                        // indices
                        // 1. you need three indices to draw a single face
                        // 2. a single segment consists of two faces
                        // 3. so we need to generate six (2*3) indices per segment
                        for (iy = 0; iy < gridY; iy++) {
                            for (ix = 0; ix < gridX; ix++) {
                                var a = numberOfVertices + ix + gridX1 * iy;
                                var b = numberOfVertices + ix + gridX1 * (iy + 1);
                                var c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
                                var d = numberOfVertices + (ix + 1) + gridX1 * iy;
                                // faces
                                indices.push(a, b, d);
                                indices.push(b, c, d);
                                // increase counter
                                groupCount += 6;
                            }
                        }
                        // add a group to the geometry. this will ensure multi material support
                        scope.addGroup(groupStart, groupCount, materialIndex);
                        // calculate new start value for groups
                        groupStart += groupCount;
                        // update total number of vertices
                        numberOfVertices += vertexCounter;
                    }
                }
            };
            exports_14("BoxBufferGeometry", BoxBufferGeometry);
            // Legacy
            UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };
            exports_14("UniformsUtils", UniformsUtils);
            default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
            default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
            ShaderMaterial.prototype = Object.create(Material.prototype);
            ShaderMaterial.prototype.constructor = ShaderMaterial;
            ShaderMaterial.prototype.isShaderMaterial = true;
            ShaderMaterial.prototype.copy = function (source) {
                Material.prototype.copy.call(this, source);
                this.fragmentShader = source.fragmentShader;
                this.vertexShader = source.vertexShader;
                this.uniforms = cloneUniforms(source.uniforms);
                this.defines = Object.assign({}, source.defines);
                this.wireframe = source.wireframe;
                this.wireframeLinewidth = source.wireframeLinewidth;
                this.lights = source.lights;
                this.clipping = source.clipping;
                this.skinning = source.skinning;
                this.morphTargets = source.morphTargets;
                this.morphNormals = source.morphNormals;
                this.extensions = source.extensions;
                return this;
            };
            ShaderMaterial.prototype.toJSON = function (meta) {
                var data = Material.prototype.toJSON.call(this, meta);
                data.uniforms = {};
                for (var name in this.uniforms) {
                    var uniform = this.uniforms[name];
                    var value = uniform.value;
                    if (value && value.isTexture) {
                        data.uniforms[name] = {
                            type: 't',
                            value: value.toJSON(meta).uuid
                        };
                    }
                    else if (value && value.isColor) {
                        data.uniforms[name] = {
                            type: 'c',
                            value: value.getHex()
                        };
                    }
                    else if (value && value.isVector2) {
                        data.uniforms[name] = {
                            type: 'v2',
                            value: value.toArray()
                        };
                    }
                    else if (value && value.isVector3) {
                        data.uniforms[name] = {
                            type: 'v3',
                            value: value.toArray()
                        };
                    }
                    else if (value && value.isVector4) {
                        data.uniforms[name] = {
                            type: 'v4',
                            value: value.toArray()
                        };
                    }
                    else if (value && value.isMatrix3) {
                        data.uniforms[name] = {
                            type: 'm3',
                            value: value.toArray()
                        };
                    }
                    else if (value && value.isMatrix4) {
                        data.uniforms[name] = {
                            type: 'm4',
                            value: value.toArray()
                        };
                    }
                    else {
                        data.uniforms[name] = {
                            value: value
                        };
                        // note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far
                    }
                }
                if (Object.keys(this.defines).length > 0)
                    data.defines = this.defines;
                data.vertexShader = this.vertexShader;
                data.fragmentShader = this.fragmentShader;
                var extensions = {};
                for (var key in this.extensions) {
                    if (this.extensions[key] === true)
                        extensions[key] = true;
                }
                if (Object.keys(extensions).length > 0)
                    data.extensions = extensions;
                return data;
            };
            Camera.prototype = Object.assign(Object.create(Object3D.prototype), {
                constructor: Camera,
                isCamera: true,
                copy: function (source, recursive) {
                    Object3D.prototype.copy.call(this, source, recursive);
                    this.matrixWorldInverse.copy(source.matrixWorldInverse);
                    this.projectionMatrix.copy(source.projectionMatrix);
                    this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
                    return this;
                },
                getWorldDirection: function (target) {
                    if (target === undefined) {
                        console.warn('THREE.Camera: .getWorldDirection() target is now required');
                        target = new Vector3();
                    }
                    this.updateMatrixWorld(true);
                    var e = this.matrixWorld.elements;
                    return target.set(-e[8], -e[9], -e[10]).normalize();
                },
                updateMatrixWorld: function (force) {
                    Object3D.prototype.updateMatrixWorld.call(this, force);
                    this.matrixWorldInverse.getInverse(this.matrixWorld);
                },
                updateWorldMatrix: function (updateParents, updateChildren) {
                    Object3D.prototype.updateWorldMatrix.call(this, updateParents, updateChildren);
                    this.matrixWorldInverse.getInverse(this.matrixWorld);
                },
                clone: function () {
                    return new this.constructor().copy(this);
                }
            });
            PerspectiveCamera.prototype = Object.assign(Object.create(Camera.prototype), {
                constructor: PerspectiveCamera,
                isPerspectiveCamera: true,
                copy: function (source, recursive) {
                    Camera.prototype.copy.call(this, source, recursive);
                    this.fov = source.fov;
                    this.zoom = source.zoom;
                    this.near = source.near;
                    this.far = source.far;
                    this.focus = source.focus;
                    this.aspect = source.aspect;
                    this.view = source.view === null ? null : Object.assign({}, source.view);
                    this.filmGauge = source.filmGauge;
                    this.filmOffset = source.filmOffset;
                    return this;
                },
                /**
                 * Sets the FOV by focal length in respect to the current .filmGauge.
                 *
                 * The default film gauge is 35, so that the focal length can be specified for
                 * a 35mm (full frame) camera.
                 *
                 * Values for focal length and film gauge must have the same unit.
                 */
                setFocalLength: function (focalLength) {
                    // see http://www.bobatkins.com/photography/technical/field_of_view.html
                    var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
                    this.fov = MathUtils.RAD2DEG * 2 * Math.atan(vExtentSlope);
                    this.updateProjectionMatrix();
                },
                /**
                 * Calculates the focal length from the current .fov and .filmGauge.
                 */
                getFocalLength: function () {
                    var vExtentSlope = Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov);
                    return 0.5 * this.getFilmHeight() / vExtentSlope;
                },
                getEffectiveFOV: function () {
                    return MathUtils.RAD2DEG * 2 * Math.atan(Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov) / this.zoom);
                },
                getFilmWidth: function () {
                    // film not completely covered in portrait format (aspect < 1)
                    return this.filmGauge * Math.min(this.aspect, 1);
                },
                getFilmHeight: function () {
                    // film not completely covered in landscape format (aspect > 1)
                    return this.filmGauge / Math.max(this.aspect, 1);
                },
                /**
                 * Sets an offset in a larger frustum. This is useful for multi-window or
                 * multi-monitor/multi-machine setups.
                 *
                 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
                 * the monitors are in grid like this
                 *
                 *   +---+---+---+
                 *   | A | B | C |
                 *   +---+---+---+
                 *   | D | E | F |
                 *   +---+---+---+
                 *
                 * then for each monitor you would call it like this
                 *
                 *   var w = 1920;
                 *   var h = 1080;
                 *   var fullWidth = w * 3;
                 *   var fullHeight = h * 2;
                 *
                 *   --A--
                 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
                 *   --B--
                 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
                 *   --C--
                 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
                 *   --D--
                 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
                 *   --E--
                 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
                 *   --F--
                 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
                 *
                 *   Note there is no reason monitors have to be the same size or in a grid.
                 */
                setViewOffset: function (fullWidth, fullHeight, x, y, width, height) {
                    this.aspect = fullWidth / fullHeight;
                    if (this.view === null) {
                        this.view = {
                            enabled: true,
                            fullWidth: 1,
                            fullHeight: 1,
                            offsetX: 0,
                            offsetY: 0,
                            width: 1,
                            height: 1
                        };
                    }
                    this.view.enabled = true;
                    this.view.fullWidth = fullWidth;
                    this.view.fullHeight = fullHeight;
                    this.view.offsetX = x;
                    this.view.offsetY = y;
                    this.view.width = width;
                    this.view.height = height;
                    this.updateProjectionMatrix();
                },
                clearViewOffset: function () {
                    if (this.view !== null) {
                        this.view.enabled = false;
                    }
                    this.updateProjectionMatrix();
                },
                updateProjectionMatrix: function () {
                    var near = this.near, top = near * Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov) / this.zoom, height = 2 * top, width = this.aspect * height, left = -0.5 * width, view = this.view;
                    if (this.view !== null && this.view.enabled) {
                        var fullWidth = view.fullWidth, fullHeight = view.fullHeight;
                        left += view.offsetX * width / fullWidth;
                        top -= view.offsetY * height / fullHeight;
                        width *= view.width / fullWidth;
                        height *= view.height / fullHeight;
                    }
                    var skew = this.filmOffset;
                    if (skew !== 0)
                        left += near * skew / this.getFilmWidth();
                    this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
                    this.projectionMatrixInverse.getInverse(this.projectionMatrix);
                },
                toJSON: function (meta) {
                    var data = Object3D.prototype.toJSON.call(this, meta);
                    data.object.fov = this.fov;
                    data.object.zoom = this.zoom;
                    data.object.near = this.near;
                    data.object.far = this.far;
                    data.object.focus = this.focus;
                    data.object.aspect = this.aspect;
                    if (this.view !== null)
                        data.object.view = Object.assign({}, this.view);
                    data.object.filmGauge = this.filmGauge;
                    data.object.filmOffset = this.filmOffset;
                    return data;
                }
            });
            /**
             * Camera for rendering cube maps
             *	- renders scene into axis-aligned cube
             *
             * @author alteredq / http://alteredqualia.com/
             */
            fov = 90, aspect = 1;
            CubeCamera.prototype = Object.create(Object3D.prototype);
            CubeCamera.prototype.constructor = CubeCamera;
            WebGLCubeRenderTarget.prototype = Object.create(WebGLRenderTarget.prototype);
            WebGLCubeRenderTarget.prototype.constructor = WebGLCubeRenderTarget;
            WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;
            WebGLCubeRenderTarget.prototype.fromEquirectangularTexture = function (renderer, texture) {
                this.texture.type = texture.type;
                this.texture.format = texture.format;
                this.texture.encoding = texture.encoding;
                var scene = new Scene();
                var shader = {
                    uniforms: {
                        tEquirect: { value: null },
                    },
                    vertexShader: [
                        "varying vec3 vWorldDirection;",
                        "vec3 transformDirection( in vec3 dir, in mat4 matrix ) {",
                        "	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );",
                        "}",
                        "void main() {",
                        "	vWorldDirection = transformDirection( position, modelMatrix );",
                        "	#include <begin_vertex>",
                        "	#include <project_vertex>",
                        "}"
                    ].join('\n'),
                    fragmentShader: [
                        "uniform sampler2D tEquirect;",
                        "varying vec3 vWorldDirection;",
                        "#define RECIPROCAL_PI 0.31830988618",
                        "#define RECIPROCAL_PI2 0.15915494",
                        "void main() {",
                        "	vec3 direction = normalize( vWorldDirection );",
                        "	vec2 sampleUV;",
                        "	sampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;",
                        "	sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;",
                        "	gl_FragColor = texture2D( tEquirect, sampleUV );",
                        "}"
                    ].join('\n'),
                };
                var material = new ShaderMaterial({
                    type: 'CubemapFromEquirect',
                    uniforms: cloneUniforms(shader.uniforms),
                    vertexShader: shader.vertexShader,
                    fragmentShader: shader.fragmentShader,
                    side: BackSide,
                    blending: NoBlending
                });
                material.uniforms.tEquirect.value = texture;
                var mesh = new Mesh(new BoxBufferGeometry(5, 5, 5), material);
                scene.add(mesh);
                var camera = new CubeCamera(1, 10, 1);
                camera.renderTarget = this;
                camera.renderTarget.texture.name = 'CubeCameraTexture';
                camera.update(renderer, scene);
                mesh.geometry.dispose();
                mesh.material.dispose();
                return this;
            };
            DataTexture.prototype = Object.create(Texture.prototype);
            DataTexture.prototype.constructor = DataTexture;
            DataTexture.prototype.isDataTexture = true;
            /**
             * @author mrdoob / http://mrdoob.com/
             * @author alteredq / http://alteredqualia.com/
             * @author bhouston / http://clara.io
             */
            _sphere$1 = new Sphere();
            _vector$5 = new Vector3();
            Object.assign(Frustum.prototype, {
                set: function (p0, p1, p2, p3, p4, p5) {
                    var planes = this.planes;
                    planes[0].copy(p0);
                    planes[1].copy(p1);
                    planes[2].copy(p2);
                    planes[3].copy(p3);
                    planes[4].copy(p4);
                    planes[5].copy(p5);
                    return this;
                },
                clone: function () {
                    return new this.constructor().copy(this);
                },
                copy: function (frustum) {
                    var planes = this.planes;
                    for (var i = 0; i < 6; i++) {
                        planes[i].copy(frustum.planes[i]);
                    }
                    return this;
                },
                setFromProjectionMatrix: function (m) {
                    var planes = this.planes;
                    var me = m.elements;
                    var me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
                    var me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
                    var me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
                    var me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
                    planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
                    planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
                    planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
                    planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
                    planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
                    planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
                    return this;
                },
                intersectsObject: function (object) {
                    var geometry = object.geometry;
                    if (geometry.boundingSphere === null)
                        geometry.computeBoundingSphere();
                    _sphere$1.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
                    return this.intersectsSphere(_sphere$1);
                },
                intersectsSprite: function (sprite) {
                    _sphere$1.center.set(0, 0, 0);
                    _sphere$1.radius = 0.7071067811865476;
                    _sphere$1.applyMatrix4(sprite.matrixWorld);
                    return this.intersectsSphere(_sphere$1);
                },
                intersectsSphere: function (sphere) {
                    var planes = this.planes;
                    var center = sphere.center;
                    var negRadius = -sphere.radius;
                    for (var i = 0; i < 6; i++) {
                        var distance = planes[i].distanceToPoint(center);
                        if (distance < negRadius) {
                            return false;
                        }
                    }
                    return true;
                },
                intersectsBox: function (box) {
                    var planes = this.planes;
                    for (var i = 0; i < 6; i++) {
                        var plane = planes[i];
                        // corner at max distance
                        _vector$5.x = plane.normal.x > 0 ? box.max.x : box.min.x;
                        _vector$5.y = plane.normal.y > 0 ? box.max.y : box.min.y;
                        _vector$5.z = plane.normal.z > 0 ? box.max.z : box.min.z;
                        if (plane.distanceToPoint(_vector$5) < 0) {
                            return false;
                        }
                    }
                    return true;
                },
                containsPoint: function (point) {
                    var planes = this.planes;
                    for (var i = 0; i < 6; i++) {
                        if (planes[i].distanceToPoint(point) < 0) {
                            return false;
                        }
                    }
                    return true;
                }
            });
            /**
             * Uniforms library for shared webgl shaders
             */
            UniformsLib = {
                common: {
                    diffuse: { value: new Color(0xeeeeee) },
                    opacity: { value: 1.0 },
                    map: { value: null },
                    uvTransform: { value: new Matrix3() },
                    uv2Transform: { value: new Matrix3() },
                    alphaMap: { value: null },
                },
                specularmap: {
                    specularMap: { value: null },
                },
                envmap: {
                    envMap: { value: null },
                    flipEnvMap: { value: -1 },
                    reflectivity: { value: 1.0 },
                    refractionRatio: { value: 0.98 },
                    maxMipLevel: { value: 0 }
                },
                aomap: {
                    aoMap: { value: null },
                    aoMapIntensity: { value: 1 }
                },
                lightmap: {
                    lightMap: { value: null },
                    lightMapIntensity: { value: 1 }
                },
                emissivemap: {
                    emissiveMap: { value: null }
                },
                bumpmap: {
                    bumpMap: { value: null },
                    bumpScale: { value: 1 }
                },
                normalmap: {
                    normalMap: { value: null },
                    normalScale: { value: new Vector2(1, 1) }
                },
                displacementmap: {
                    displacementMap: { value: null },
                    displacementScale: { value: 1 },
                    displacementBias: { value: 0 }
                },
                roughnessmap: {
                    roughnessMap: { value: null }
                },
                metalnessmap: {
                    metalnessMap: { value: null }
                },
                gradientmap: {
                    gradientMap: { value: null }
                },
                fog: {
                    fogDensity: { value: 0.00025 },
                    fogNear: { value: 1 },
                    fogFar: { value: 2000 },
                    fogColor: { value: new Color(0xffffff) }
                },
                lights: {
                    ambientLightColor: { value: [] },
                    lightProbe: { value: [] },
                    directionalLights: { value: [], properties: {
                            direction: {},
                            color: {},
                            shadow: {},
                            shadowBias: {},
                            shadowRadius: {},
                            shadowMapSize: {}
                        } },
                    directionalShadowMap: { value: [] },
                    directionalShadowMatrix: { value: [] },
                    spotLights: { value: [], properties: {
                            color: {},
                            position: {},
                            direction: {},
                            distance: {},
                            coneCos: {},
                            penumbraCos: {},
                            decay: {},
                            shadow: {},
                            shadowBias: {},
                            shadowRadius: {},
                            shadowMapSize: {}
                        } },
                    spotShadowMap: { value: [] },
                    spotShadowMatrix: { value: [] },
                    pointLights: { value: [], properties: {
                            color: {},
                            position: {},
                            decay: {},
                            distance: {},
                            shadow: {},
                            shadowBias: {},
                            shadowRadius: {},
                            shadowMapSize: {},
                            shadowCameraNear: {},
                            shadowCameraFar: {}
                        } },
                    pointShadowMap: { value: [] },
                    pointShadowMatrix: { value: [] },
                    hemisphereLights: { value: [], properties: {
                            direction: {},
                            skyColor: {},
                            groundColor: {}
                        } },
                    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
                    rectAreaLights: { value: [], properties: {
                            color: {},
                            position: {},
                            width: {},
                            height: {}
                        } }
                },
                points: {
                    diffuse: { value: new Color(0xeeeeee) },
                    opacity: { value: 1.0 },
                    size: { value: 1.0 },
                    scale: { value: 1.0 },
                    map: { value: null },
                    alphaMap: { value: null },
                    uvTransform: { value: new Matrix3() }
                },
                sprite: {
                    diffuse: { value: new Color(0xeeeeee) },
                    opacity: { value: 1.0 },
                    center: { value: new Vector2(0.5, 0.5) },
                    rotation: { value: 0.0 },
                    map: { value: null },
                    alphaMap: { value: null },
                    uvTransform: { value: new Matrix3() }
                }
            };
            exports_14("UniformsLib", UniformsLib);
            PlaneGeometry.prototype = Object.create(Geometry.prototype);
            PlaneGeometry.prototype.constructor = PlaneGeometry;
            PlaneBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
            PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;
            alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";
            alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";
            alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif";
            aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif";
            aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";
            begin_vertex = "vec3 transformed = vec3( position );";
            beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";
            bsdfs = "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha  = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif";
            bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";
            clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";
            clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
            clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif";
            clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif";
            color_fragment = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";
            color_pars_fragment = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";
            color_pars_vertex = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";
            color_vertex = "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif";
            common = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n  return m[ 2 ][ 3 ] == - 1.0;\n}";
            cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_maxMipLevel 8.0\n#define cubeUV_minMipLevel 4.0\n#define cubeUV_maxTileSize 256.0\n#define cubeUV_minTileSize 16.0\nfloat getFace(vec3 direction) {\n    vec3 absDirection = abs(direction);\n    float face = -1.0;\n    if (absDirection.x > absDirection.z) {\n      if (absDirection.x > absDirection.y)\n        face = direction.x > 0.0 ? 0.0 : 3.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    } else {\n      if (absDirection.z > absDirection.y)\n        face = direction.z > 0.0 ? 2.0 : 5.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    }\n    return face;\n}\nvec2 getUV(vec3 direction, float face) {\n    vec2 uv;\n    if (face == 0.0) {\n      uv = vec2(-direction.z, direction.y) / abs(direction.x);\n    } else if (face == 1.0) {\n      uv = vec2(direction.x, -direction.z) / abs(direction.y);\n    } else if (face == 2.0) {\n      uv = direction.xy / abs(direction.z);\n    } else if (face == 3.0) {\n      uv = vec2(direction.z, direction.y) / abs(direction.x);\n    } else if (face == 4.0) {\n      uv = direction.xz / abs(direction.y);\n    } else {\n      uv = vec2(-direction.x, direction.y) / abs(direction.z);\n    }\n    return 0.5 * (uv + 1.0);\n}\nvec3 bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\n  float face = getFace(direction);\n  float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);\n  mipInt = max(mipInt, cubeUV_minMipLevel);\n  float faceSize = exp2(mipInt);\n  float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\n  vec2 uv = getUV(direction, face) * (faceSize - 1.0);\n  vec2 f = fract(uv);\n  uv += 0.5 - f;\n  if (face > 2.0) {\n    uv.y += faceSize;\n    face -= 3.0;\n  }\n  uv.x += face * faceSize;\n  if(mipInt < cubeUV_maxMipLevel){\n    uv.y += 2.0 * cubeUV_maxTileSize;\n  }\n  uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n  uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\n  uv *= texelSize;\n  vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x += texelSize;\n  vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.y += texelSize;\n  vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x -= texelSize;\n  vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  vec3 tm = mix(tl, tr, f.x);\n  vec3 bm = mix(bl, br, f.x);\n  return mix(tm, bm, f.y);\n}\n#define r0 1.0\n#define v0 0.339\n#define m0 -2.0\n#define r1 0.8\n#define v1 0.276\n#define m1 -1.0\n#define r4 0.4\n#define v4 0.046\n#define m4 2.0\n#define r5 0.305\n#define v5 0.016\n#define m5 3.0\n#define r6 0.21\n#define v6 0.0038\n#define m6 4.0\nfloat roughnessToMip(float roughness) {\n  float mip = 0.0;\n  if (roughness >= r1) {\n    mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;\n  } else if (roughness >= r4) {\n    mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;\n  } else if (roughness >= r5) {\n    mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;\n  } else if (roughness >= r6) {\n    mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;\n  } else {\n    mip = -2.0 * log2(1.16 * roughness);  }\n  return mip;\n}\nvec4 textureCubeUV(sampler2D envMap, vec3 sampleDir, float roughness) {\n  float mip = clamp(roughnessToMip(roughness), m0, cubeUV_maxMipLevel);\n  float mipF = fract(mip);\n  float mipInt = floor(mip);\n  vec3 color0 = bilinearCubeUV(envMap, sampleDir, mipInt);\n  if (mipF == 0.0) {\n    return vec4(color0, 1.0);\n  } else {\n    vec3 color1 = bilinearCubeUV(envMap, sampleDir, mipInt + 1.0);\n    return vec4(mix(color0, color1, mipF), 1.0);\n  }\n}\n#endif";
            defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\ttransformedNormal = mat3( instanceMatrix ) * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";
            displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";
            displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";
            emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
            emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";
            encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
            encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}";
            envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\t\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t}  else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";
            envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";
            envmap_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";
            envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";
            envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) { \n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";
            fog_vertex = "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif";
            fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif";
            fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
            fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";
            gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}";
            lightmap_fragment = "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif";
            lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";
            lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif";
            lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif";
            envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t  vec3 reflectVec = reflect( -viewDir, normal );\n\t\t  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif";
            lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
            lights_toon_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)";
            lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
            lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)";
            lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = saturate( clearcoat );\tmaterial.clearcoatRoughness = max( clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif";
            lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
            lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tdirectLight.color *= all( bvec3( pointLight.shadow, directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tdirectLight.color *= all( bvec3( spotLight.shadow, directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectLight.color *= all( bvec3( directionalLight.shadow, directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
            lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif";
            lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";
            logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
            logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";
            logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";
            logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif";
            map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif";
            map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";
            map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
            map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";
            metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";
            metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";
            morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif";
            morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";
            morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif";
            normal_fragment_begin = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;";
            normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif";
            normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif";
            clearcoat_normal_fragment_begin = "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif";
            clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif";
            clearcoat_normalmap_pars_fragment = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif";
            packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";
            premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";
            project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
            dithering_fragment = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
            dithering_pars_fragment = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";
            roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";
            roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";
            shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";
            shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";
            shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif";
            shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= all( bvec2( directionalLight.shadow, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= all( bvec2( spotLight.shadow, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= all( bvec2( pointLight.shadow, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}";
            skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
            skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif";
            skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
            skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";
            specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";
            specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";
            tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
            tonemapping_pars_fragment = "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}";
            uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif";
            uv_pars_vertex = "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif";
            uv_vertex = "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";
            uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";
            uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif";
            uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";
            worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";
            background_frag = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
            background_vert = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
            cube_frag = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
            cube_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";
            depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}";
            depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}";
            distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";
            distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";
            equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
            equirect_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";
            linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";
            linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
            meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";
            meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";
            meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
            meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
            meshmatcap_frag = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";
            meshmatcap_vert = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";
            meshtoon_frag = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
            meshtoon_vert = "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
            meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
            meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
            meshphysical_frag = "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSPARENCY\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSPARENCY\n\tuniform float transparency;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSPARENCY\n\t\tdiffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
            meshphysical_vert = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
            normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";
            normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";
            points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";
            points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";
            shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";
            shadow_vert = "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
            sprite_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";
            sprite_vert = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
            ShaderChunk = {
                alphamap_fragment: alphamap_fragment,
                alphamap_pars_fragment: alphamap_pars_fragment,
                alphatest_fragment: alphatest_fragment,
                aomap_fragment: aomap_fragment,
                aomap_pars_fragment: aomap_pars_fragment,
                begin_vertex: begin_vertex,
                beginnormal_vertex: beginnormal_vertex,
                bsdfs: bsdfs,
                bumpmap_pars_fragment: bumpmap_pars_fragment,
                clipping_planes_fragment: clipping_planes_fragment,
                clipping_planes_pars_fragment: clipping_planes_pars_fragment,
                clipping_planes_pars_vertex: clipping_planes_pars_vertex,
                clipping_planes_vertex: clipping_planes_vertex,
                color_fragment: color_fragment,
                color_pars_fragment: color_pars_fragment,
                color_pars_vertex: color_pars_vertex,
                color_vertex: color_vertex,
                common: common,
                cube_uv_reflection_fragment: cube_uv_reflection_fragment,
                defaultnormal_vertex: defaultnormal_vertex,
                displacementmap_pars_vertex: displacementmap_pars_vertex,
                displacementmap_vertex: displacementmap_vertex,
                emissivemap_fragment: emissivemap_fragment,
                emissivemap_pars_fragment: emissivemap_pars_fragment,
                encodings_fragment: encodings_fragment,
                encodings_pars_fragment: encodings_pars_fragment,
                envmap_fragment: envmap_fragment,
                envmap_common_pars_fragment: envmap_common_pars_fragment,
                envmap_pars_fragment: envmap_pars_fragment,
                envmap_pars_vertex: envmap_pars_vertex,
                envmap_physical_pars_fragment: envmap_physical_pars_fragment,
                envmap_vertex: envmap_vertex,
                fog_vertex: fog_vertex,
                fog_pars_vertex: fog_pars_vertex,
                fog_fragment: fog_fragment,
                fog_pars_fragment: fog_pars_fragment,
                gradientmap_pars_fragment: gradientmap_pars_fragment,
                lightmap_fragment: lightmap_fragment,
                lightmap_pars_fragment: lightmap_pars_fragment,
                lights_lambert_vertex: lights_lambert_vertex,
                lights_pars_begin: lights_pars_begin,
                lights_toon_fragment: lights_toon_fragment,
                lights_toon_pars_fragment: lights_toon_pars_fragment,
                lights_phong_fragment: lights_phong_fragment,
                lights_phong_pars_fragment: lights_phong_pars_fragment,
                lights_physical_fragment: lights_physical_fragment,
                lights_physical_pars_fragment: lights_physical_pars_fragment,
                lights_fragment_begin: lights_fragment_begin,
                lights_fragment_maps: lights_fragment_maps,
                lights_fragment_end: lights_fragment_end,
                logdepthbuf_fragment: logdepthbuf_fragment,
                logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
                logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
                logdepthbuf_vertex: logdepthbuf_vertex,
                map_fragment: map_fragment,
                map_pars_fragment: map_pars_fragment,
                map_particle_fragment: map_particle_fragment,
                map_particle_pars_fragment: map_particle_pars_fragment,
                metalnessmap_fragment: metalnessmap_fragment,
                metalnessmap_pars_fragment: metalnessmap_pars_fragment,
                morphnormal_vertex: morphnormal_vertex,
                morphtarget_pars_vertex: morphtarget_pars_vertex,
                morphtarget_vertex: morphtarget_vertex,
                normal_fragment_begin: normal_fragment_begin,
                normal_fragment_maps: normal_fragment_maps,
                normalmap_pars_fragment: normalmap_pars_fragment,
                clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
                clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
                clearcoat_normalmap_pars_fragment: clearcoat_normalmap_pars_fragment,
                packing: packing,
                premultiplied_alpha_fragment: premultiplied_alpha_fragment,
                project_vertex: project_vertex,
                dithering_fragment: dithering_fragment,
                dithering_pars_fragment: dithering_pars_fragment,
                roughnessmap_fragment: roughnessmap_fragment,
                roughnessmap_pars_fragment: roughnessmap_pars_fragment,
                shadowmap_pars_fragment: shadowmap_pars_fragment,
                shadowmap_pars_vertex: shadowmap_pars_vertex,
                shadowmap_vertex: shadowmap_vertex,
                shadowmask_pars_fragment: shadowmask_pars_fragment,
                skinbase_vertex: skinbase_vertex,
                skinning_pars_vertex: skinning_pars_vertex,
                skinning_vertex: skinning_vertex,
                skinnormal_vertex: skinnormal_vertex,
                specularmap_fragment: specularmap_fragment,
                specularmap_pars_fragment: specularmap_pars_fragment,
                tonemapping_fragment: tonemapping_fragment,
                tonemapping_pars_fragment: tonemapping_pars_fragment,
                uv_pars_fragment: uv_pars_fragment,
                uv_pars_vertex: uv_pars_vertex,
                uv_vertex: uv_vertex,
                uv2_pars_fragment: uv2_pars_fragment,
                uv2_pars_vertex: uv2_pars_vertex,
                uv2_vertex: uv2_vertex,
                worldpos_vertex: worldpos_vertex,
                background_frag: background_frag,
                background_vert: background_vert,
                cube_frag: cube_frag,
                cube_vert: cube_vert,
                depth_frag: depth_frag,
                depth_vert: depth_vert,
                distanceRGBA_frag: distanceRGBA_frag,
                distanceRGBA_vert: distanceRGBA_vert,
                equirect_frag: equirect_frag,
                equirect_vert: equirect_vert,
                linedashed_frag: linedashed_frag,
                linedashed_vert: linedashed_vert,
                meshbasic_frag: meshbasic_frag,
                meshbasic_vert: meshbasic_vert,
                meshlambert_frag: meshlambert_frag,
                meshlambert_vert: meshlambert_vert,
                meshmatcap_frag: meshmatcap_frag,
                meshmatcap_vert: meshmatcap_vert,
                meshtoon_frag: meshtoon_frag,
                meshtoon_vert: meshtoon_vert,
                meshphong_frag: meshphong_frag,
                meshphong_vert: meshphong_vert,
                meshphysical_frag: meshphysical_frag,
                meshphysical_vert: meshphysical_vert,
                normal_frag: normal_frag,
                normal_vert: normal_vert,
                points_frag: points_frag,
                points_vert: points_vert,
                shadow_frag: shadow_frag,
                shadow_vert: shadow_vert,
                sprite_frag: sprite_frag,
                sprite_vert: sprite_vert
            };
            exports_14("ShaderChunk", ShaderChunk);
            /**
             * @author alteredq / http://alteredqualia.com/
             * @author mrdoob / http://mrdoob.com/
             * @author mikael emtinger / http://gomo.se/
             */
            ShaderLib = {
                basic: {
                    uniforms: mergeUniforms([
                        UniformsLib.common,
                        UniformsLib.specularmap,
                        UniformsLib.envmap,
                        UniformsLib.aomap,
                        UniformsLib.lightmap,
                        UniformsLib.fog
                    ]),
                    vertexShader: ShaderChunk.meshbasic_vert,
                    fragmentShader: ShaderChunk.meshbasic_frag
                },
                lambert: {
                    uniforms: mergeUniforms([
                        UniformsLib.common,
                        UniformsLib.specularmap,
                        UniformsLib.envmap,
                        UniformsLib.aomap,
                        UniformsLib.lightmap,
                        UniformsLib.emissivemap,
                        UniformsLib.fog,
                        UniformsLib.lights,
                        {
                            emissive: { value: new Color(0x000000) }
                        }
                    ]),
                    vertexShader: ShaderChunk.meshlambert_vert,
                    fragmentShader: ShaderChunk.meshlambert_frag
                },
                phong: {
                    uniforms: mergeUniforms([
                        UniformsLib.common,
                        UniformsLib.specularmap,
                        UniformsLib.envmap,
                        UniformsLib.aomap,
                        UniformsLib.lightmap,
                        UniformsLib.emissivemap,
                        UniformsLib.bumpmap,
                        UniformsLib.normalmap,
                        UniformsLib.displacementmap,
                        UniformsLib.fog,
                        UniformsLib.lights,
                        {
                            emissive: { value: new Color(0x000000) },
                            specular: { value: new Color(0x111111) },
                            shininess: { value: 30 }
                        }
                    ]),
                    vertexShader: ShaderChunk.meshphong_vert,
                    fragmentShader: ShaderChunk.meshphong_frag
                },
                standard: {
                    uniforms: mergeUniforms([
                        UniformsLib.common,
                        UniformsLib.envmap,
                        UniformsLib.aomap,
                        UniformsLib.lightmap,
                        UniformsLib.emissivemap,
                        UniformsLib.bumpmap,
                        UniformsLib.normalmap,
                        UniformsLib.displacementmap,
                        UniformsLib.roughnessmap,
                        UniformsLib.metalnessmap,
                        UniformsLib.fog,
                        UniformsLib.lights,
                        {
                            emissive: { value: new Color(0x000000) },
                            roughness: { value: 0.5 },
                            metalness: { value: 0.5 },
                            envMapIntensity: { value: 1 } // temporary
                        }
                    ]),
                    vertexShader: ShaderChunk.meshphysical_vert,
                    fragmentShader: ShaderChunk.meshphysical_frag
                },
                toon: {
                    uniforms: mergeUniforms([
                        UniformsLib.common,
                        UniformsLib.specularmap,
                        UniformsLib.aomap,
                        UniformsLib.lightmap,
                        UniformsLib.emissivemap,
                        UniformsLib.bumpmap,
                        UniformsLib.normalmap,
                        UniformsLib.displacementmap,
                        UniformsLib.gradientmap,
                        UniformsLib.fog,
                        UniformsLib.lights,
                        {
                            emissive: { value: new Color(0x000000) },
                            specular: { value: new Color(0x111111) },
                            shininess: { value: 30 }
                        }
                    ]),
                    vertexShader: ShaderChunk.meshtoon_vert,
                    fragmentShader: ShaderChunk.meshtoon_frag
                },
                matcap: {
                    uniforms: mergeUniforms([
                        UniformsLib.common,
                        UniformsLib.bumpmap,
                        UniformsLib.normalmap,
                        UniformsLib.displacementmap,
                        UniformsLib.fog,
                        {
                            matcap: { value: null }
                        }
                    ]),
                    vertexShader: ShaderChunk.meshmatcap_vert,
                    fragmentShader: ShaderChunk.meshmatcap_frag
                },
                points: {
                    uniforms: mergeUniforms([
                        UniformsLib.points,
                        UniformsLib.fog
                    ]),
                    vertexShader: ShaderChunk.points_vert,
                    fragmentShader: ShaderChunk.points_frag
                },
                dashed: {
                    uniforms: mergeUniforms([
                        UniformsLib.common,
                        UniformsLib.fog,
                        {
                            scale: { value: 1 },
                            dashSize: { value: 1 },
                            totalSize: { value: 2 }
                        }
                    ]),
                    vertexShader: ShaderChunk.linedashed_vert,
                    fragmentShader: ShaderChunk.linedashed_frag
                },
                depth: {
                    uniforms: mergeUniforms([
                        UniformsLib.common,
                        UniformsLib.displacementmap
                    ]),
                    vertexShader: ShaderChunk.depth_vert,
                    fragmentShader: ShaderChunk.depth_frag
                },
                normal: {
                    uniforms: mergeUniforms([
                        UniformsLib.common,
                        UniformsLib.bumpmap,
                        UniformsLib.normalmap,
                        UniformsLib.displacementmap,
                        {
                            opacity: { value: 1.0 }
                        }
                    ]),
                    vertexShader: ShaderChunk.normal_vert,
                    fragmentShader: ShaderChunk.normal_frag
                },
                sprite: {
                    uniforms: mergeUniforms([
                        UniformsLib.sprite,
                        UniformsLib.fog
                    ]),
                    vertexShader: ShaderChunk.sprite_vert,
                    fragmentShader: ShaderChunk.sprite_frag
                },
                background: {
                    uniforms: {
                        uvTransform: { value: new Matrix3() },
                        t2D: { value: null },
                    },
                    vertexShader: ShaderChunk.background_vert,
                    fragmentShader: ShaderChunk.background_frag
                },
                /* -------------------------------------------------------------------------
                //	Cube map shader
                 ------------------------------------------------------------------------- */
                cube: {
                    uniforms: mergeUniforms([
                        UniformsLib.envmap,
                        {
                            opacity: { value: 1.0 }
                        }
                    ]),
                    vertexShader: ShaderChunk.cube_vert,
                    fragmentShader: ShaderChunk.cube_frag
                },
                equirect: {
                    uniforms: {
                        tEquirect: { value: null },
                    },
                    vertexShader: ShaderChunk.equirect_vert,
                    fragmentShader: ShaderChunk.equirect_frag
                },
                distanceRGBA: {
                    uniforms: mergeUniforms([
                        UniformsLib.common,
                        UniformsLib.displacementmap,
                        {
                            referencePosition: { value: new Vector3() },
                            nearDistance: { value: 1 },
                            farDistance: { value: 1000 }
                        }
                    ]),
                    vertexShader: ShaderChunk.distanceRGBA_vert,
                    fragmentShader: ShaderChunk.distanceRGBA_frag
                },
                shadow: {
                    uniforms: mergeUniforms([
                        UniformsLib.lights,
                        UniformsLib.fog,
                        {
                            color: { value: new Color(0x00000) },
                            opacity: { value: 1.0 }
                        },
                    ]),
                    vertexShader: ShaderChunk.shadow_vert,
                    fragmentShader: ShaderChunk.shadow_frag
                }
            };
            exports_14("ShaderLib", ShaderLib);
            ShaderLib.physical = {
                uniforms: mergeUniforms([
                    ShaderLib.standard.uniforms,
                    {
                        transparency: { value: 0 },
                        clearcoat: { value: 0 },
                        clearcoatRoughness: { value: 0 },
                        sheen: { value: new Color(0x000000) },
                        clearcoatNormalScale: { value: new Vector2(1, 1) },
                        clearcoatNormalMap: { value: null },
                    }
                ]),
                vertexShader: ShaderChunk.meshphysical_vert,
                fragmentShader: ShaderChunk.meshphysical_frag
            };
            CubeTexture.prototype = Object.create(Texture.prototype);
            CubeTexture.prototype.constructor = CubeTexture;
            CubeTexture.prototype.isCubeTexture = true;
            Object.defineProperty(CubeTexture.prototype, 'images', {
                get: function () {
                    return this.image;
                },
                set: function (value) {
                    this.image = value;
                }
            });
            DataTexture2DArray.prototype = Object.create(Texture.prototype);
            DataTexture2DArray.prototype.constructor = DataTexture2DArray;
            DataTexture2DArray.prototype.isDataTexture2DArray = true;
            DataTexture3D.prototype = Object.create(Texture.prototype);
            DataTexture3D.prototype.constructor = DataTexture3D;
            DataTexture3D.prototype.isDataTexture3D = true;
            /**
             * @author tschw
             * @author Mugen87 / https://github.com/Mugen87
             * @author mrdoob / http://mrdoob.com/
             *
             * Uniforms of a program.
             * Those form a tree structure with a special top-level container for the root,
             * which you get by calling 'new WebGLUniforms( gl, program )'.
             *
             *
             * Properties of inner nodes including the top-level container:
             *
             * .seq - array of nested uniforms
             * .map - nested uniforms by name
             *
             *
             * Methods of all nodes except the top-level container:
             *
             * .setValue( gl, value, [textures] )
             *
             * 		uploads a uniform value(s)
             *  	the 'textures' parameter is needed for sampler uniforms
             *
             *
             * Static methods of the top-level container (textures factorizations):
             *
             * .upload( gl, seq, values, textures )
             *
             * 		sets uniforms in 'seq' to 'values[id].value'
             *
             * .seqWithValue( seq, values ) : filteredSeq
             *
             * 		filters 'seq' entries with corresponding entry in values
             *
             *
             * Methods of the top-level container (textures factorizations):
             *
             * .setValue( gl, name, value, textures )
             *
             * 		sets uniform with  name 'name' to 'value'
             *
             * .setOptional( gl, obj, prop )
             *
             * 		like .set for an optional property of the object
             *
             */
            emptyTexture = new Texture();
            emptyTexture2dArray = new DataTexture2DArray();
            emptyTexture3d = new DataTexture3D();
            emptyCubeTexture = new CubeTexture();
            // --- Utilities ---
            // Array Caches (provide typed arrays for temporary by size)
            arrayCacheF32 = [];
            arrayCacheI32 = [];
            // Float32Array caches used for uploading Matrix uniforms
            mat4array = new Float32Array(16);
            mat3array = new Float32Array(9);
            mat2array = new Float32Array(4);
            PureArrayUniform.prototype.updateCache = function (data) {
                var cache = this.cache;
                if (data instanceof Float32Array && cache.length !== data.length) {
                    this.cache = new Float32Array(data.length);
                }
                copyArray(cache, data);
            };
            StructuredUniform.prototype.setValue = function (gl, value, textures) {
                var seq = this.seq;
                for (var i = 0, n = seq.length; i !== n; ++i) {
                    var u = seq[i];
                    u.setValue(gl, value[u.id], textures);
                }
            };
            // --- Top-level ---
            // Parser - builds up the property tree from the path strings
            RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;
            WebGLUniforms.prototype.setValue = function (gl, name, value, textures) {
                var u = this.map[name];
                if (u !== undefined)
                    u.setValue(gl, value, textures);
            };
            WebGLUniforms.prototype.setOptional = function (gl, object, name) {
                var v = object[name];
                if (v !== undefined)
                    this.setValue(gl, name, v);
            };
            // Static interface
            WebGLUniforms.upload = function (gl, seq, values, textures) {
                for (var i = 0, n = seq.length; i !== n; ++i) {
                    var u = seq[i], v = values[u.id];
                    if (v.needsUpdate !== false) {
                        // note: always updating when .needsUpdate is undefined
                        u.setValue(gl, v.value, textures);
                    }
                }
            };
            WebGLUniforms.seqWithValue = function (seq, values) {
                var r = [];
                for (var i = 0, n = seq.length; i !== n; ++i) {
                    var u = seq[i];
                    if (u.id in values)
                        r.push(u);
                }
                return r;
            };
            /**
             * @author mrdoob / http://mrdoob.com/
             */
            programIdCount = 0;
            // Resolve Includes
            includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
            // Unroll Loops
            loopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
            nextVersion = 0;
            MeshDepthMaterial.prototype = Object.create(Material.prototype);
            MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;
            MeshDepthMaterial.prototype.isMeshDepthMaterial = true;
            MeshDepthMaterial.prototype.copy = function (source) {
                Material.prototype.copy.call(this, source);
                this.depthPacking = source.depthPacking;
                this.skinning = source.skinning;
                this.morphTargets = source.morphTargets;
                this.map = source.map;
                this.alphaMap = source.alphaMap;
                this.displacementMap = source.displacementMap;
                this.displacementScale = source.displacementScale;
                this.displacementBias = source.displacementBias;
                this.wireframe = source.wireframe;
                this.wireframeLinewidth = source.wireframeLinewidth;
                return this;
            };
            MeshDistanceMaterial.prototype = Object.create(Material.prototype);
            MeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;
            MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;
            MeshDistanceMaterial.prototype.copy = function (source) {
                Material.prototype.copy.call(this, source);
                this.referencePosition.copy(source.referencePosition);
                this.nearDistance = source.nearDistance;
                this.farDistance = source.farDistance;
                this.skinning = source.skinning;
                this.morphTargets = source.morphTargets;
                this.map = source.map;
                this.alphaMap = source.alphaMap;
                this.displacementMap = source.displacementMap;
                this.displacementScale = source.displacementScale;
                this.displacementBias = source.displacementBias;
                return this;
            };
            vsm_frag = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n  float mean = 0.0;\n  float squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );\n  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n    #ifdef HORIZONAL_PASS\n      vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n      mean += distribution.x;\n      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n    #else\n      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );\n      mean += depth;\n      squared_mean += depth * depth;\n    #endif\n  }\n  mean = mean * HALF_SAMPLE_RATE;\n  squared_mean = squared_mean * HALF_SAMPLE_RATE;\n  float std_dev = sqrt( squared_mean - mean * mean );\n  gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
            vsm_vert = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";
            WebGLMultiviewRenderTarget.prototype = Object.assign(Object.create(WebGLRenderTarget.prototype), {
                constructor: WebGLMultiviewRenderTarget,
                isWebGLMultiviewRenderTarget: true,
                copy: function (source) {
                    WebGLRenderTarget.prototype.copy.call(this, source);
                    this.numViews = source.numViews;
                    return this;
                },
                setNumViews: function (numViews) {
                    if (this.numViews !== numViews) {
                        this.numViews = numViews;
                        this.dispose();
                    }
                    return this;
                }
            });
            ArrayCamera.prototype = Object.assign(Object.create(PerspectiveCamera.prototype), {
                constructor: ArrayCamera,
                isArrayCamera: true
            });
            Group.prototype = Object.assign(Object.create(Object3D.prototype), {
                constructor: Group,
                isGroup: true
            });
            Object.assign(WebXRManager.prototype, EventDispatcher.prototype);
            Object.assign(FogExp2.prototype, {
                isFogExp2: true,
                clone: function () {
                    return new FogExp2(this.color, this.density);
                },
                toJSON: function ( /* meta */) {
                    return {
                        type: 'FogExp2',
                        color: this.color.getHex(),
                        density: this.density
                    };
                }
            });
            Object.assign(Fog.prototype, {
                isFog: true,
                clone: function () {
                    return new Fog(this.color, this.near, this.far);
                },
                toJSON: function ( /* meta */) {
                    return {
                        type: 'Fog',
                        color: this.color.getHex(),
                        near: this.near,
                        far: this.far
                    };
                }
            });
            Object.defineProperty(InterleavedBuffer.prototype, 'needsUpdate', {
                set: function (value) {
                    if (value === true)
                        this.version++;
                }
            });
            Object.assign(InterleavedBuffer.prototype, {
                isInterleavedBuffer: true,
                onUploadCallback: function () { },
                setUsage: function (value) {
                    this.usage = value;
                    return this;
                },
                copy: function (source) {
                    this.array = new source.array.constructor(source.array);
                    this.count = source.count;
                    this.stride = source.stride;
                    this.usage = source.usage;
                    return this;
                },
                copyAt: function (index1, attribute, index2) {
                    index1 *= this.stride;
                    index2 *= attribute.stride;
                    for (var i = 0, l = this.stride; i < l; i++) {
                        this.array[index1 + i] = attribute.array[index2 + i];
                    }
                    return this;
                },
                set: function (value, offset) {
                    if (offset === undefined)
                        offset = 0;
                    this.array.set(value, offset);
                    return this;
                },
                clone: function () {
                    return new this.constructor().copy(this);
                },
                onUpload: function (callback) {
                    this.onUploadCallback = callback;
                    return this;
                }
            });
            /**
             * @author benaadams / https://twitter.com/ben_a_adams
             */
            _vector$6 = new Vector3();
            Object.defineProperties(InterleavedBufferAttribute.prototype, {
                count: {
                    get: function () {
                        return this.data.count;
                    }
                },
                array: {
                    get: function () {
                        return this.data.array;
                    }
                }
            });
            Object.assign(InterleavedBufferAttribute.prototype, {
                isInterleavedBufferAttribute: true,
                applyMatrix4: function (m) {
                    for (var i = 0, l = this.data.count; i < l; i++) {
                        _vector$6.x = this.getX(i);
                        _vector$6.y = this.getY(i);
                        _vector$6.z = this.getZ(i);
                        _vector$6.applyMatrix4(m);
                        this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
                    }
                    return this;
                },
                setX: function (index, x) {
                    this.data.array[index * this.data.stride + this.offset] = x;
                    return this;
                },
                setY: function (index, y) {
                    this.data.array[index * this.data.stride + this.offset + 1] = y;
                    return this;
                },
                setZ: function (index, z) {
                    this.data.array[index * this.data.stride + this.offset + 2] = z;
                    return this;
                },
                setW: function (index, w) {
                    this.data.array[index * this.data.stride + this.offset + 3] = w;
                    return this;
                },
                getX: function (index) {
                    return this.data.array[index * this.data.stride + this.offset];
                },
                getY: function (index) {
                    return this.data.array[index * this.data.stride + this.offset + 1];
                },
                getZ: function (index) {
                    return this.data.array[index * this.data.stride + this.offset + 2];
                },
                getW: function (index) {
                    return this.data.array[index * this.data.stride + this.offset + 3];
                },
                setXY: function (index, x, y) {
                    index = index * this.data.stride + this.offset;
                    this.data.array[index + 0] = x;
                    this.data.array[index + 1] = y;
                    return this;
                },
                setXYZ: function (index, x, y, z) {
                    index = index * this.data.stride + this.offset;
                    this.data.array[index + 0] = x;
                    this.data.array[index + 1] = y;
                    this.data.array[index + 2] = z;
                    return this;
                },
                setXYZW: function (index, x, y, z, w) {
                    index = index * this.data.stride + this.offset;
                    this.data.array[index + 0] = x;
                    this.data.array[index + 1] = y;
                    this.data.array[index + 2] = z;
                    this.data.array[index + 3] = w;
                    return this;
                }
            });
            SpriteMaterial.prototype = Object.create(Material.prototype);
            SpriteMaterial.prototype.constructor = SpriteMaterial;
            SpriteMaterial.prototype.isSpriteMaterial = true;
            SpriteMaterial.prototype.copy = function (source) {
                Material.prototype.copy.call(this, source);
                this.color.copy(source.color);
                this.map = source.map;
                this.alphaMap = source.alphaMap;
                this.rotation = source.rotation;
                this.sizeAttenuation = source.sizeAttenuation;
                return this;
            };
            _intersectPoint = new Vector3();
            _worldScale = new Vector3();
            _mvPosition = new Vector3();
            _alignedPosition = new Vector2();
            _rotatedPosition = new Vector2();
            _viewWorldMatrix = new Matrix4();
            _vA$1 = new Vector3();
            _vB$1 = new Vector3();
            _vC$1 = new Vector3();
            _uvA$1 = new Vector2();
            _uvB$1 = new Vector2();
            _uvC$1 = new Vector2();
            Sprite.prototype = Object.assign(Object.create(Object3D.prototype), {
                constructor: Sprite,
                isSprite: true,
                raycast: function (raycaster, intersects) {
                    if (raycaster.camera === null) {
                        console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
                    }
                    _worldScale.setFromMatrixScale(this.matrixWorld);
                    _viewWorldMatrix.copy(raycaster.camera.matrixWorld);
                    this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);
                    _mvPosition.setFromMatrixPosition(this.modelViewMatrix);
                    if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {
                        _worldScale.multiplyScalar(-_mvPosition.z);
                    }
                    var rotation = this.material.rotation;
                    var sin, cos;
                    if (rotation !== 0) {
                        cos = Math.cos(rotation);
                        sin = Math.sin(rotation);
                    }
                    var center = this.center;
                    transformVertex(_vA$1.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
                    transformVertex(_vB$1.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
                    transformVertex(_vC$1.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
                    _uvA$1.set(0, 0);
                    _uvB$1.set(1, 0);
                    _uvC$1.set(1, 1);
                    // check first triangle
                    var intersect = raycaster.ray.intersectTriangle(_vA$1, _vB$1, _vC$1, false, _intersectPoint);
                    if (intersect === null) {
                        // check second triangle
                        transformVertex(_vB$1.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
                        _uvB$1.set(0, 1);
                        intersect = raycaster.ray.intersectTriangle(_vA$1, _vC$1, _vB$1, false, _intersectPoint);
                        if (intersect === null) {
                            return;
                        }
                    }
                    var distance = raycaster.ray.origin.distanceTo(_intersectPoint);
                    if (distance < raycaster.near || distance > raycaster.far)
                        return;
                    intersects.push({
                        distance: distance,
                        point: _intersectPoint.clone(),
                        uv: Triangle.getUV(_intersectPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2()),
                        face: null,
                        object: this
                    });
                },
                clone: function () {
                    return new this.constructor(this.material).copy(this);
                },
                copy: function (source) {
                    Object3D.prototype.copy.call(this, source);
                    if (source.center !== undefined)
                        this.center.copy(source.center);
                    return this;
                }
            });
            /**
             * @author mikael emtinger / http://gomo.se/
             * @author alteredq / http://alteredqualia.com/
             * @author mrdoob / http://mrdoob.com/
             */
            _v1$4 = new Vector3();
            _v2$2 = new Vector3();
            LOD.prototype = Object.assign(Object.create(Object3D.prototype), {
                constructor: LOD,
                isLOD: true,
                copy: function (source) {
                    Object3D.prototype.copy.call(this, source, false);
                    var levels = source.levels;
                    for (var i = 0, l = levels.length; i < l; i++) {
                        var level = levels[i];
                        this.addLevel(level.object.clone(), level.distance);
                    }
                    this.autoUpdate = source.autoUpdate;
                    return this;
                },
                addLevel: function (object, distance) {
                    if (distance === undefined)
                        distance = 0;
                    distance = Math.abs(distance);
                    var levels = this.levels;
                    for (var l = 0; l < levels.length; l++) {
                        if (distance < levels[l].distance) {
                            break;
                        }
                    }
                    levels.splice(l, 0, { distance: distance, object: object });
                    this.add(object);
                    return this;
                },
                getObjectForDistance: function (distance) {
                    var levels = this.levels;
                    if (levels.length > 0) {
                        for (var i = 1, l = levels.length; i < l; i++) {
                            if (distance < levels[i].distance) {
                                break;
                            }
                        }
                        return levels[i - 1].object;
                    }
                    return null;
                },
                raycast: function (raycaster, intersects) {
                    var levels = this.levels;
                    if (levels.length > 0) {
                        _v1$4.setFromMatrixPosition(this.matrixWorld);
                        var distance = raycaster.ray.origin.distanceTo(_v1$4);
                        this.getObjectForDistance(distance).raycast(raycaster, intersects);
                    }
                },
                update: function (camera) {
                    var levels = this.levels;
                    if (levels.length > 1) {
                        _v1$4.setFromMatrixPosition(camera.matrixWorld);
                        _v2$2.setFromMatrixPosition(this.matrixWorld);
                        var distance = _v1$4.distanceTo(_v2$2);
                        levels[0].object.visible = true;
                        for (var i = 1, l = levels.length; i < l; i++) {
                            if (distance >= levels[i].distance) {
                                levels[i - 1].object.visible = false;
                                levels[i].object.visible = true;
                            }
                            else {
                                break;
                            }
                        }
                        for (; i < l; i++) {
                            levels[i].object.visible = false;
                        }
                    }
                },
                toJSON: function (meta) {
                    var data = Object3D.prototype.toJSON.call(this, meta);
                    if (this.autoUpdate === false)
                        data.object.autoUpdate = false;
                    data.object.levels = [];
                    var levels = this.levels;
                    for (var i = 0, l = levels.length; i < l; i++) {
                        var level = levels[i];
                        data.object.levels.push({
                            object: level.object.uuid,
                            distance: level.distance
                        });
                    }
                    return data;
                }
            });
            SkinnedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
                constructor: SkinnedMesh,
                isSkinnedMesh: true,
                bind: function (skeleton, bindMatrix) {
                    this.skeleton = skeleton;
                    if (bindMatrix === undefined) {
                        this.updateMatrixWorld(true);
                        this.skeleton.calculateInverses();
                        bindMatrix = this.matrixWorld;
                    }
                    this.bindMatrix.copy(bindMatrix);
                    this.bindMatrixInverse.getInverse(bindMatrix);
                },
                pose: function () {
                    this.skeleton.pose();
                },
                normalizeSkinWeights: function () {
                    var vector = new Vector4();
                    var skinWeight = this.geometry.attributes.skinWeight;
                    for (var i = 0, l = skinWeight.count; i < l; i++) {
                        vector.x = skinWeight.getX(i);
                        vector.y = skinWeight.getY(i);
                        vector.z = skinWeight.getZ(i);
                        vector.w = skinWeight.getW(i);
                        var scale = 1.0 / vector.manhattanLength();
                        if (scale !== Infinity) {
                            vector.multiplyScalar(scale);
                        }
                        else {
                            vector.set(1, 0, 0, 0); // do something reasonable
                        }
                        skinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w);
                    }
                },
                updateMatrixWorld: function (force) {
                    Mesh.prototype.updateMatrixWorld.call(this, force);
                    if (this.bindMode === 'attached') {
                        this.bindMatrixInverse.getInverse(this.matrixWorld);
                    }
                    else if (this.bindMode === 'detached') {
                        this.bindMatrixInverse.getInverse(this.bindMatrix);
                    }
                    else {
                        console.warn('THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode);
                    }
                },
                clone: function () {
                    return new this.constructor(this.geometry, this.material).copy(this);
                }
            });
            /**
             * @author mikael emtinger / http://gomo.se/
             * @author alteredq / http://alteredqualia.com/
             * @author michael guerrero / http://realitymeltdown.com
             * @author ikerr / http://verold.com
             */
            _offsetMatrix = new Matrix4();
            _identityMatrix = new Matrix4();
            Object.assign(Skeleton.prototype, {
                calculateInverses: function () {
                    this.boneInverses = [];
                    for (var i = 0, il = this.bones.length; i < il; i++) {
                        var inverse = new Matrix4();
                        if (this.bones[i]) {
                            inverse.getInverse(this.bones[i].matrixWorld);
                        }
                        this.boneInverses.push(inverse);
                    }
                },
                pose: function () {
                    var bone, i, il;
                    // recover the bind-time world matrices
                    for (i = 0, il = this.bones.length; i < il; i++) {
                        bone = this.bones[i];
                        if (bone) {
                            bone.matrixWorld.getInverse(this.boneInverses[i]);
                        }
                    }
                    // compute the local matrices, positions, rotations and scales
                    for (i = 0, il = this.bones.length; i < il; i++) {
                        bone = this.bones[i];
                        if (bone) {
                            if (bone.parent && bone.parent.isBone) {
                                bone.matrix.getInverse(bone.parent.matrixWorld);
                                bone.matrix.multiply(bone.matrixWorld);
                            }
                            else {
                                bone.matrix.copy(bone.matrixWorld);
                            }
                            bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
                        }
                    }
                },
                update: function () {
                    var bones = this.bones;
                    var boneInverses = this.boneInverses;
                    var boneMatrices = this.boneMatrices;
                    var boneTexture = this.boneTexture;
                    // flatten bone matrices to array
                    for (var i = 0, il = bones.length; i < il; i++) {
                        // compute the offset between the current and the original transform
                        var matrix = bones[i] ? bones[i].matrixWorld : _identityMatrix;
                        _offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);
                        _offsetMatrix.toArray(boneMatrices, i * 16);
                    }
                    if (boneTexture !== undefined) {
                        boneTexture.needsUpdate = true;
                    }
                },
                clone: function () {
                    return new Skeleton(this.bones, this.boneInverses);
                },
                getBoneByName: function (name) {
                    for (var i = 0, il = this.bones.length; i < il; i++) {
                        var bone = this.bones[i];
                        if (bone.name === name) {
                            return bone;
                        }
                    }
                    return undefined;
                }
            });
            Bone.prototype = Object.assign(Object.create(Object3D.prototype), {
                constructor: Bone,
                isBone: true
            });
            /**
             * @author mrdoob / http://mrdoob.com/
             */
            _instanceLocalMatrix = new Matrix4();
            _instanceWorldMatrix = new Matrix4();
            _instanceIntersects = [];
            _mesh = new Mesh();
            InstancedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
                constructor: InstancedMesh,
                isInstancedMesh: true,
                getMatrixAt: function (index, matrix) {
                    matrix.fromArray(this.instanceMatrix.array, index * 16);
                },
                raycast: function (raycaster, intersects) {
                    var matrixWorld = this.matrixWorld;
                    var raycastTimes = this.count;
                    _mesh.geometry = this.geometry;
                    _mesh.material = this.material;
                    if (_mesh.material === undefined)
                        return;
                    for (var instanceId = 0; instanceId < raycastTimes; instanceId++) {
                        // calculate the world matrix for each instance
                        this.getMatrixAt(instanceId, _instanceLocalMatrix);
                        _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);
                        // the mesh represents this single instance
                        _mesh.matrixWorld = _instanceWorldMatrix;
                        _mesh.raycast(raycaster, _instanceIntersects);
                        // process the result of raycast
                        if (_instanceIntersects.length > 0) {
                            _instanceIntersects[0].instanceId = instanceId;
                            _instanceIntersects[0].object = this;
                            intersects.push(_instanceIntersects[0]);
                            _instanceIntersects.length = 0;
                        }
                    }
                },
                setMatrixAt: function (index, matrix) {
                    matrix.toArray(this.instanceMatrix.array, index * 16);
                },
                updateMorphTargets: function () {
                }
            });
            LineBasicMaterial.prototype = Object.create(Material.prototype);
            LineBasicMaterial.prototype.constructor = LineBasicMaterial;
            LineBasicMaterial.prototype.isLineBasicMaterial = true;
            LineBasicMaterial.prototype.copy = function (source) {
                Material.prototype.copy.call(this, source);
                this.color.copy(source.color);
                this.linewidth = source.linewidth;
                this.linecap = source.linecap;
                this.linejoin = source.linejoin;
                return this;
            };
            /**
             * @author mrdoob / http://mrdoob.com/
             */
            _start = new Vector3();
            _end = new Vector3();
            _inverseMatrix$1 = new Matrix4();
            _ray$1 = new Ray();
            _sphere$2 = new Sphere();
            Line.prototype = Object.assign(Object.create(Object3D.prototype), {
                constructor: Line,
                isLine: true,
                computeLineDistances: function () {
                    var geometry = this.geometry;
                    if (geometry.isBufferGeometry) {
                        // we assume non-indexed geometry
                        if (geometry.index === null) {
                            var positionAttribute = geometry.attributes.position;
                            var lineDistances = [0];
                            for (var i = 1, l = positionAttribute.count; i < l; i++) {
                                _start.fromBufferAttribute(positionAttribute, i - 1);
                                _end.fromBufferAttribute(positionAttribute, i);
                                lineDistances[i] = lineDistances[i - 1];
                                lineDistances[i] += _start.distanceTo(_end);
                            }
                            geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));
                        }
                        else {
                            console.warn('THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
                        }
                    }
                    else if (geometry.isGeometry) {
                        var vertices = geometry.vertices;
                        var lineDistances = geometry.lineDistances;
                        lineDistances[0] = 0;
                        for (var i = 1, l = vertices.length; i < l; i++) {
                            lineDistances[i] = lineDistances[i - 1];
                            lineDistances[i] += vertices[i - 1].distanceTo(vertices[i]);
                        }
                    }
                    return this;
                },
                raycast: function (raycaster, intersects) {
                    var precision = raycaster.linePrecision;
                    var geometry = this.geometry;
                    var matrixWorld = this.matrixWorld;
                    // Checking boundingSphere distance to ray
                    if (geometry.boundingSphere === null)
                        geometry.computeBoundingSphere();
                    _sphere$2.copy(geometry.boundingSphere);
                    _sphere$2.applyMatrix4(matrixWorld);
                    _sphere$2.radius += precision;
                    if (raycaster.ray.intersectsSphere(_sphere$2) === false)
                        return;
                    //
                    _inverseMatrix$1.getInverse(matrixWorld);
                    _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);
                    var localPrecision = precision / ((this.scale.x + this.scale.y + this.scale.z) / 3);
                    var localPrecisionSq = localPrecision * localPrecision;
                    var vStart = new Vector3();
                    var vEnd = new Vector3();
                    var interSegment = new Vector3();
                    var interRay = new Vector3();
                    var step = (this && this.isLineSegments) ? 2 : 1;
                    if (geometry.isBufferGeometry) {
                        var index = geometry.index;
                        var attributes = geometry.attributes;
                        var positions = attributes.position.array;
                        if (index !== null) {
                            var indices = index.array;
                            for (var i = 0, l = indices.length - 1; i < l; i += step) {
                                var a = indices[i];
                                var b = indices[i + 1];
                                vStart.fromArray(positions, a * 3);
                                vEnd.fromArray(positions, b * 3);
                                var distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                                if (distSq > localPrecisionSq)
                                    continue;
                                interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation
                                var distance = raycaster.ray.origin.distanceTo(interRay);
                                if (distance < raycaster.near || distance > raycaster.far)
                                    continue;
                                intersects.push({
                                    distance: distance,
                                    // What do we want? intersection point on the ray or on the segment??
                                    // point: raycaster.ray.at( distance ),
                                    point: interSegment.clone().applyMatrix4(this.matrixWorld),
                                    index: i,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                });
                            }
                        }
                        else {
                            for (var i = 0, l = positions.length / 3 - 1; i < l; i += step) {
                                vStart.fromArray(positions, 3 * i);
                                vEnd.fromArray(positions, 3 * i + 3);
                                var distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                                if (distSq > localPrecisionSq)
                                    continue;
                                interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation
                                var distance = raycaster.ray.origin.distanceTo(interRay);
                                if (distance < raycaster.near || distance > raycaster.far)
                                    continue;
                                intersects.push({
                                    distance: distance,
                                    // What do we want? intersection point on the ray or on the segment??
                                    // point: raycaster.ray.at( distance ),
                                    point: interSegment.clone().applyMatrix4(this.matrixWorld),
                                    index: i,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                });
                            }
                        }
                    }
                    else if (geometry.isGeometry) {
                        var vertices = geometry.vertices;
                        var nbVertices = vertices.length;
                        for (var i = 0; i < nbVertices - 1; i += step) {
                            var distSq = _ray$1.distanceSqToSegment(vertices[i], vertices[i + 1], interRay, interSegment);
                            if (distSq > localPrecisionSq)
                                continue;
                            interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation
                            var distance = raycaster.ray.origin.distanceTo(interRay);
                            if (distance < raycaster.near || distance > raycaster.far)
                                continue;
                            intersects.push({
                                distance: distance,
                                // What do we want? intersection point on the ray or on the segment??
                                // point: raycaster.ray.at( distance ),
                                point: interSegment.clone().applyMatrix4(this.matrixWorld),
                                index: i,
                                face: null,
                                faceIndex: null,
                                object: this
                            });
                        }
                    }
                },
                clone: function () {
                    return new this.constructor(this.geometry, this.material).copy(this);
                }
            });
            /**
             * @author mrdoob / http://mrdoob.com/
             */
            _start$1 = new Vector3();
            _end$1 = new Vector3();
            LineSegments.prototype = Object.assign(Object.create(Line.prototype), {
                constructor: LineSegments,
                isLineSegments: true,
                computeLineDistances: function () {
                    var geometry = this.geometry;
                    if (geometry.isBufferGeometry) {
                        // we assume non-indexed geometry
                        if (geometry.index === null) {
                            var positionAttribute = geometry.attributes.position;
                            var lineDistances = [];
                            for (var i = 0, l = positionAttribute.count; i < l; i += 2) {
                                _start$1.fromBufferAttribute(positionAttribute, i);
                                _end$1.fromBufferAttribute(positionAttribute, i + 1);
                                lineDistances[i] = (i === 0) ? 0 : lineDistances[i - 1];
                                lineDistances[i + 1] = lineDistances[i] + _start$1.distanceTo(_end$1);
                            }
                            geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));
                        }
                        else {
                            console.warn('THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
                        }
                    }
                    else if (geometry.isGeometry) {
                        var vertices = geometry.vertices;
                        var lineDistances = geometry.lineDistances;
                        for (var i = 0, l = vertices.length; i < l; i += 2) {
                            _start$1.copy(vertices[i]);
                            _end$1.copy(vertices[i + 1]);
                            lineDistances[i] = (i === 0) ? 0 : lineDistances[i - 1];
                            lineDistances[i + 1] = lineDistances[i] + _start$1.distanceTo(_end$1);
                        }
                    }
                    return this;
                }
            });
            LineLoop.prototype = Object.assign(Object.create(Line.prototype), {
                constructor: LineLoop,
                isLineLoop: true,
            });
            PointsMaterial.prototype = Object.create(Material.prototype);
            PointsMaterial.prototype.constructor = PointsMaterial;
            PointsMaterial.prototype.isPointsMaterial = true;
            PointsMaterial.prototype.copy = function (source) {
                Material.prototype.copy.call(this, source);
                this.color.copy(source.color);
                this.map = source.map;
                this.alphaMap = source.alphaMap;
                this.size = source.size;
                this.sizeAttenuation = source.sizeAttenuation;
                this.morphTargets = source.morphTargets;
                return this;
            };
            /**
             * @author alteredq / http://alteredqualia.com/
             */
            _inverseMatrix$2 = new Matrix4();
            _ray$2 = new Ray();
            _sphere$3 = new Sphere();
            _position$1 = new Vector3();
            Points.prototype = Object.assign(Object.create(Object3D.prototype), {
                constructor: Points,
                isPoints: true,
                raycast: function (raycaster, intersects) {
                    var geometry = this.geometry;
                    var matrixWorld = this.matrixWorld;
                    var threshold = raycaster.params.Points.threshold;
                    // Checking boundingSphere distance to ray
                    if (geometry.boundingSphere === null)
                        geometry.computeBoundingSphere();
                    _sphere$3.copy(geometry.boundingSphere);
                    _sphere$3.applyMatrix4(matrixWorld);
                    _sphere$3.radius += threshold;
                    if (raycaster.ray.intersectsSphere(_sphere$3) === false)
                        return;
                    //
                    _inverseMatrix$2.getInverse(matrixWorld);
                    _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);
                    var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
                    var localThresholdSq = localThreshold * localThreshold;
                    if (geometry.isBufferGeometry) {
                        var index = geometry.index;
                        var attributes = geometry.attributes;
                        var positions = attributes.position.array;
                        if (index !== null) {
                            var indices = index.array;
                            for (var i = 0, il = indices.length; i < il; i++) {
                                var a = indices[i];
                                _position$1.fromArray(positions, a * 3);
                                testPoint(_position$1, a, localThresholdSq, matrixWorld, raycaster, intersects, this);
                            }
                        }
                        else {
                            for (var i = 0, l = positions.length / 3; i < l; i++) {
                                _position$1.fromArray(positions, i * 3);
                                testPoint(_position$1, i, localThresholdSq, matrixWorld, raycaster, intersects, this);
                            }
                        }
                    }
                    else {
                        var vertices = geometry.vertices;
                        for (var i = 0, l = vertices.length; i < l; i++) {
                            testPoint(vertices[i], i, localThresholdSq, matrixWorld, raycaster, intersects, this);
                        }
                    }
                },
                updateMorphTargets: function () {
                    var geometry = this.geometry;
                    var m, ml, name;
                    if (geometry.isBufferGeometry) {
                        var morphAttributes = geometry.morphAttributes;
                        var keys = Object.keys(morphAttributes);
                        if (keys.length > 0) {
                            var morphAttribute = morphAttributes[keys[0]];
                            if (morphAttribute !== undefined) {
                                this.morphTargetInfluences = [];
                                this.morphTargetDictionary = {};
                                for (m = 0, ml = morphAttribute.length; m < ml; m++) {
                                    name = morphAttribute[m].name || String(m);
                                    this.morphTargetInfluences.push(0);
                                    this.morphTargetDictionary[name] = m;
                                }
                            }
                        }
                    }
                    else {
                        var morphTargets = geometry.morphTargets;
                        if (morphTargets !== undefined && morphTargets.length > 0) {
                            console.error('THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');
                        }
                    }
                },
                clone: function () {
                    return new this.constructor(this.geometry, this.material).copy(this);
                }
            });
            VideoTexture.prototype = Object.assign(Object.create(Texture.prototype), {
                constructor: VideoTexture,
                isVideoTexture: true,
                update: function () {
                    var video = this.image;
                    if (video.readyState >= video.HAVE_CURRENT_DATA) {
                        this.needsUpdate = true;
                    }
                }
            });
            CompressedTexture.prototype = Object.create(Texture.prototype);
            CompressedTexture.prototype.constructor = CompressedTexture;
            CompressedTexture.prototype.isCompressedTexture = true;
            CanvasTexture.prototype = Object.create(Texture.prototype);
            CanvasTexture.prototype.constructor = CanvasTexture;
            CanvasTexture.prototype.isCanvasTexture = true;
            DepthTexture.prototype = Object.create(Texture.prototype);
            DepthTexture.prototype.constructor = DepthTexture;
            DepthTexture.prototype.isDepthTexture = true;
            WireframeGeometry.prototype = Object.create(BufferGeometry.prototype);
            WireframeGeometry.prototype.constructor = WireframeGeometry;
            ParametricGeometry.prototype = Object.create(Geometry.prototype);
            ParametricGeometry.prototype.constructor = ParametricGeometry;
            ParametricBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
            ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;
            PolyhedronGeometry.prototype = Object.create(Geometry.prototype);
            PolyhedronGeometry.prototype.constructor = PolyhedronGeometry;
            PolyhedronBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
            PolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;
            TetrahedronGeometry.prototype = Object.create(Geometry.prototype);
            TetrahedronGeometry.prototype.constructor = TetrahedronGeometry;
            TetrahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
            TetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;
            OctahedronGeometry.prototype = Object.create(Geometry.prototype);
            OctahedronGeometry.prototype.constructor = OctahedronGeometry;
            OctahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
            OctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;
            IcosahedronGeometry.prototype = Object.create(Geometry.prototype);
            IcosahedronGeometry.prototype.constructor = IcosahedronGeometry;
            IcosahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
            IcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;
            DodecahedronGeometry.prototype = Object.create(Geometry.prototype);
            DodecahedronGeometry.prototype.constructor = DodecahedronGeometry;
            DodecahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
            DodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;
            TubeGeometry.prototype = Object.create(Geometry.prototype);
            TubeGeometry.prototype.constructor = TubeGeometry;
            TubeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
            TubeBufferGeometry.prototype.constructor = TubeBufferGeometry;
            TubeBufferGeometry.prototype.toJSON = function () {
                var data = BufferGeometry.prototype.toJSON.call(this);
                data.path = this.parameters.path.toJSON();
                return data;
            };
            TorusKnotGeometry.prototype = Object.create(Geometry.prototype);
            TorusKnotGeometry.prototype.constructor = TorusKnotGeometry;
            TorusKnotBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
            TorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;
            TorusGeometry.prototype = Object.create(Geometry.prototype);
            TorusGeometry.prototype.constructor = TorusGeometry;
            TorusBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
            TorusBufferGeometry.prototype.constructor = TorusBufferGeometry;
            /**
             * @author Mugen87 / https://github.com/Mugen87
             * Port from https://github.com/mapbox/earcut (v2.1.5)
             */
            Earcut = {
                triangulate: function (data, holeIndices, dim) {
                    dim = dim || 2;
                    var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
                    if (!outerNode || outerNode.next === outerNode.prev)
                        return triangles;
                    var minX, minY, maxX, maxY, x, y, invSize;
                    if (hasHoles)
                        outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
                    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
                    if (data.length > 80 * dim) {
                        minX = maxX = data[0];
                        minY = maxY = data[1];
                        for (var i = dim; i < outerLen; i += dim) {
                            x = data[i];
                            y = data[i + 1];
                            if (x < minX)
                                minX = x;
                            if (y < minY)
                                minY = y;
                            if (x > maxX)
                                maxX = x;
                            if (y > maxY)
                                maxY = y;
                        }
                        // minX, minY and invSize are later used to transform coords into integers for z-order calculation
                        invSize = Math.max(maxX - minX, maxY - minY);
                        invSize = invSize !== 0 ? 1 / invSize : 0;
                    }
                    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
                    return triangles;
                }
            };
            /**
             * @author zz85 / http://www.lab4games.net/zz85/blog
             */
            ShapeUtils = {
                // calculate area of the contour polygon
                area: function (contour) {
                    var n = contour.length;
                    var a = 0.0;
                    for (var p = n - 1, q = 0; q < n; p = q++) {
                        a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
                    }
                    return a * 0.5;
                },
                isClockWise: function (pts) {
                    return ShapeUtils.area(pts) < 0;
                },
                triangulateShape: function (contour, holes) {
                    var vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
                    var holeIndices = []; // array of hole indices
                    var faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]
                    removeDupEndPts(contour);
                    addContour(vertices, contour);
                    //
                    var holeIndex = contour.length;
                    holes.forEach(removeDupEndPts);
                    for (var i = 0; i < holes.length; i++) {
                        holeIndices.push(holeIndex);
                        holeIndex += holes[i].length;
                        addContour(vertices, holes[i]);
                    }
                    //
                    var triangles = Earcut.triangulate(vertices, holeIndices);
                    //
                    for (var i = 0; i < triangles.length; i += 3) {
                        faces.push(triangles.slice(i, i + 3));
                    }
                    return faces;
                }
            };
            exports_14("ShapeUtils", ShapeUtils);
            ExtrudeGeometry.prototype = Object.create(Geometry.prototype);
            ExtrudeGeometry.prototype.constructor = ExtrudeGeometry;
            ExtrudeGeometry.prototype.toJSON = function () {
                var data = Geometry.prototype.toJSON.call(this);
                var shapes = this.parameters.shapes;
                var options = this.parameters.options;
                return toJSON(shapes, options, data);
            };
            ExtrudeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
            ExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry;
            ExtrudeBufferGeometry.prototype.toJSON = function () {
                var data = BufferGeometry.prototype.toJSON.call(this);
                var shapes = this.parameters.shapes;
                var options = this.parameters.options;
                return toJSON(shapes, options, data);
            };
            //
            WorldUVGenerator = {
                generateTopUV: function (geometry, vertices, indexA, indexB, indexC) {
                    var a_x = vertices[indexA * 3];
                    var a_y = vertices[indexA * 3 + 1];
                    var b_x = vertices[indexB * 3];
                    var b_y = vertices[indexB * 3 + 1];
                    var c_x = vertices[indexC * 3];
                    var c_y = vertices[indexC * 3 + 1];
                    return [
                        new Vector2(a_x, a_y),
                        new Vector2(b_x, b_y),
                        new Vector2(c_x, c_y)
                    ];
                },
                generateSideWallUV: function (geometry, vertices, indexA, indexB, indexC, indexD) {
                    var a_x = vertices[indexA * 3];
                    var a_y = vertices[indexA * 3 + 1];
                    var a_z = vertices[indexA * 3 + 2];
                    var b_x = vertices[indexB * 3];
                    var b_y = vertices[indexB * 3 + 1];
                    var b_z = vertices[indexB * 3 + 2];
                    var c_x = vertices[indexC * 3];
                    var c_y = vertices[indexC * 3 + 1];
                    var c_z = vertices[indexC * 3 + 2];
                    var d_x = vertices[indexD * 3];
                    var d_y = vertices[indexD * 3 + 1];
                    var d_z = vertices[indexD * 3 + 2];
                    if (Math.abs(a_y - b_y) < 0.01) {
                        return [
                            new Vector2(a_x, 1 - a_z),
                            new Vector2(b_x, 1 - b_z),
                            new Vector2(c_x, 1 - c_z),
                            new Vector2(d_x, 1 - d_z)
                        ];
                    }
                    else {
                        return [
                            new Vector2(a_y, 1 - a_z),
                            new Vector2(b_y, 1 - b_z),
                            new Vector2(c_y, 1 - c_z),
                            new Vector2(d_y, 1 - d_z)
                        ];
                    }
                }
            };
            TextGeometry.prototype = Object.create(Geometry.prototype);
            TextGeometry.prototype.constructor = TextGeometry;
            TextBufferGeometry.prototype = Object.create(ExtrudeBufferGeometry.prototype);
            TextBufferGeometry.prototype.constructor = TextBufferGeometry;
            SphereGeometry.prototype = Object.create(Geometry.prototype);
            SphereGeometry.prototype.constructor = SphereGeometry;
            SphereBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
            SphereBufferGeometry.prototype.constructor = SphereBufferGeometry;
            RingGeometry.prototype = Object.create(Geometry.prototype);
            RingGeometry.prototype.constructor = RingGeometry;
            RingBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
            RingBufferGeometry.prototype.constructor = RingBufferGeometry;
            LatheGeometry.prototype = Object.create(Geometry.prototype);
            LatheGeometry.prototype.constructor = LatheGeometry;
            LatheBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
            LatheBufferGeometry.prototype.constructor = LatheBufferGeometry;
            ShapeGeometry.prototype = Object.create(Geometry.prototype);
            ShapeGeometry.prototype.constructor = ShapeGeometry;
            ShapeGeometry.prototype.toJSON = function () {
                var data = Geometry.prototype.toJSON.call(this);
                var shapes = this.parameters.shapes;
                return toJSON$1(shapes, data);
            };
            ShapeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
            ShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;
            ShapeBufferGeometry.prototype.toJSON = function () {
                var data = BufferGeometry.prototype.toJSON.call(this);
                var shapes = this.parameters.shapes;
                return toJSON$1(shapes, data);
            };
            EdgesGeometry.prototype = Object.create(BufferGeometry.prototype);
            EdgesGeometry.prototype.constructor = EdgesGeometry;
            CylinderGeometry.prototype = Object.create(Geometry.prototype);
            CylinderGeometry.prototype.constructor = CylinderGeometry;
            CylinderBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
            CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;
            ConeGeometry.prototype = Object.create(CylinderGeometry.prototype);
            ConeGeometry.prototype.constructor = ConeGeometry;
            ConeBufferGeometry.prototype = Object.create(CylinderBufferGeometry.prototype);
            ConeBufferGeometry.prototype.constructor = ConeBufferGeometry;
            CircleGeometry.prototype = Object.create(Geometry.prototype);
            CircleGeometry.prototype.constructor = CircleGeometry;
            CircleBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
            CircleBufferGeometry.prototype.constructor = CircleBufferGeometry;
            Geometries = Object.freeze({
                __proto__: null,
                WireframeGeometry: WireframeGeometry,
                ParametricGeometry: ParametricGeometry,
                ParametricBufferGeometry: ParametricBufferGeometry,
                TetrahedronGeometry: TetrahedronGeometry,
                TetrahedronBufferGeometry: TetrahedronBufferGeometry,
                OctahedronGeometry: OctahedronGeometry,
                OctahedronBufferGeometry: OctahedronBufferGeometry,
                IcosahedronGeometry: IcosahedronGeometry,
                IcosahedronBufferGeometry: IcosahedronBufferGeometry,
                DodecahedronGeometry: DodecahedronGeometry,
                DodecahedronBufferGeometry: DodecahedronBufferGeometry,
                PolyhedronGeometry: PolyhedronGeometry,
                PolyhedronBufferGeometry: PolyhedronBufferGeometry,
                TubeGeometry: TubeGeometry,
                TubeBufferGeometry: TubeBufferGeometry,
                TorusKnotGeometry: TorusKnotGeometry,
                TorusKnotBufferGeometry: TorusKnotBufferGeometry,
                TorusGeometry: TorusGeometry,
                TorusBufferGeometry: TorusBufferGeometry,
                TextGeometry: TextGeometry,
                TextBufferGeometry: TextBufferGeometry,
                SphereGeometry: SphereGeometry,
                SphereBufferGeometry: SphereBufferGeometry,
                RingGeometry: RingGeometry,
                RingBufferGeometry: RingBufferGeometry,
                PlaneGeometry: PlaneGeometry,
                PlaneBufferGeometry: PlaneBufferGeometry,
                LatheGeometry: LatheGeometry,
                LatheBufferGeometry: LatheBufferGeometry,
                ShapeGeometry: ShapeGeometry,
                ShapeBufferGeometry: ShapeBufferGeometry,
                ExtrudeGeometry: ExtrudeGeometry,
                ExtrudeBufferGeometry: ExtrudeBufferGeometry,
                EdgesGeometry: EdgesGeometry,
                ConeGeometry: ConeGeometry,
                ConeBufferGeometry: ConeBufferGeometry,
                CylinderGeometry: CylinderGeometry,
                CylinderBufferGeometry: CylinderBufferGeometry,
                CircleGeometry: CircleGeometry,
                CircleBufferGeometry: CircleBufferGeometry,
                BoxGeometry: BoxGeometry,
                BoxBufferGeometry: BoxBufferGeometry
            });
            ShadowMaterial.prototype = Object.create(Material.prototype);
            ShadowMaterial.prototype.constructor = ShadowMaterial;
            ShadowMaterial.prototype.isShadowMaterial = true;
            ShadowMaterial.prototype.copy = function (source) {
                Material.prototype.copy.call(this, source);
                this.color.copy(source.color);
                return this;
            };
            RawShaderMaterial.prototype = Object.create(ShaderMaterial.prototype);
            RawShaderMaterial.prototype.constructor = RawShaderMaterial;
            RawShaderMaterial.prototype.isRawShaderMaterial = true;
            MeshStandardMaterial.prototype = Object.create(Material.prototype);
            MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;
            MeshStandardMaterial.prototype.isMeshStandardMaterial = true;
            MeshStandardMaterial.prototype.copy = function (source) {
                Material.prototype.copy.call(this, source);
                this.defines = { 'STANDARD': '' };
                this.color.copy(source.color);
                this.roughness = source.roughness;
                this.metalness = source.metalness;
                this.map = source.map;
                this.lightMap = source.lightMap;
                this.lightMapIntensity = source.lightMapIntensity;
                this.aoMap = source.aoMap;
                this.aoMapIntensity = source.aoMapIntensity;
                this.emissive.copy(source.emissive);
                this.emissiveMap = source.emissiveMap;
                this.emissiveIntensity = source.emissiveIntensity;
                this.bumpMap = source.bumpMap;
                this.bumpScale = source.bumpScale;
                this.normalMap = source.normalMap;
                this.normalMapType = source.normalMapType;
                this.normalScale.copy(source.normalScale);
                this.displacementMap = source.displacementMap;
                this.displacementScale = source.displacementScale;
                this.displacementBias = source.displacementBias;
                this.roughnessMap = source.roughnessMap;
                this.metalnessMap = source.metalnessMap;
                this.alphaMap = source.alphaMap;
                this.envMap = source.envMap;
                this.envMapIntensity = source.envMapIntensity;
                this.refractionRatio = source.refractionRatio;
                this.wireframe = source.wireframe;
                this.wireframeLinewidth = source.wireframeLinewidth;
                this.wireframeLinecap = source.wireframeLinecap;
                this.wireframeLinejoin = source.wireframeLinejoin;
                this.skinning = source.skinning;
                this.morphTargets = source.morphTargets;
                this.morphNormals = source.morphNormals;
                return this;
            };
            MeshPhysicalMaterial.prototype = Object.create(MeshStandardMaterial.prototype);
            MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;
            MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;
            MeshPhysicalMaterial.prototype.copy = function (source) {
                MeshStandardMaterial.prototype.copy.call(this, source);
                this.defines = {
                    'STANDARD': '',
                    'PHYSICAL': ''
                };
                this.reflectivity = source.reflectivity;
                this.clearcoat = source.clearcoat;
                this.clearcoatRoughness = source.clearcoatRoughness;
                if (source.sheen)
                    this.sheen = (this.sheen || new Color()).copy(source.sheen);
                else
                    this.sheen = null;
                this.clearcoatNormalMap = source.clearcoatNormalMap;
                this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
                this.transparency = source.transparency;
                return this;
            };
            MeshPhongMaterial.prototype = Object.create(Material.prototype);
            MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;
            MeshPhongMaterial.prototype.isMeshPhongMaterial = true;
            MeshPhongMaterial.prototype.copy = function (source) {
                Material.prototype.copy.call(this, source);
                this.color.copy(source.color);
                this.specular.copy(source.specular);
                this.shininess = source.shininess;
                this.map = source.map;
                this.lightMap = source.lightMap;
                this.lightMapIntensity = source.lightMapIntensity;
                this.aoMap = source.aoMap;
                this.aoMapIntensity = source.aoMapIntensity;
                this.emissive.copy(source.emissive);
                this.emissiveMap = source.emissiveMap;
                this.emissiveIntensity = source.emissiveIntensity;
                this.bumpMap = source.bumpMap;
                this.bumpScale = source.bumpScale;
                this.normalMap = source.normalMap;
                this.normalMapType = source.normalMapType;
                this.normalScale.copy(source.normalScale);
                this.displacementMap = source.displacementMap;
                this.displacementScale = source.displacementScale;
                this.displacementBias = source.displacementBias;
                this.specularMap = source.specularMap;
                this.alphaMap = source.alphaMap;
                this.envMap = source.envMap;
                this.combine = source.combine;
                this.reflectivity = source.reflectivity;
                this.refractionRatio = source.refractionRatio;
                this.wireframe = source.wireframe;
                this.wireframeLinewidth = source.wireframeLinewidth;
                this.wireframeLinecap = source.wireframeLinecap;
                this.wireframeLinejoin = source.wireframeLinejoin;
                this.skinning = source.skinning;
                this.morphTargets = source.morphTargets;
                this.morphNormals = source.morphNormals;
                return this;
            };
            MeshToonMaterial.prototype = Object.create(Material.prototype);
            MeshToonMaterial.prototype.constructor = MeshToonMaterial;
            MeshToonMaterial.prototype.isMeshToonMaterial = true;
            MeshToonMaterial.prototype.copy = function (source) {
                Material.prototype.copy.call(this, source);
                this.color.copy(source.color);
                this.specular.copy(source.specular);
                this.shininess = source.shininess;
                this.map = source.map;
                this.gradientMap = source.gradientMap;
                this.lightMap = source.lightMap;
                this.lightMapIntensity = source.lightMapIntensity;
                this.aoMap = source.aoMap;
                this.aoMapIntensity = source.aoMapIntensity;
                this.emissive.copy(source.emissive);
                this.emissiveMap = source.emissiveMap;
                this.emissiveIntensity = source.emissiveIntensity;
                this.bumpMap = source.bumpMap;
                this.bumpScale = source.bumpScale;
                this.normalMap = source.normalMap;
                this.normalMapType = source.normalMapType;
                this.normalScale.copy(source.normalScale);
                this.displacementMap = source.displacementMap;
                this.displacementScale = source.displacementScale;
                this.displacementBias = source.displacementBias;
                this.specularMap = source.specularMap;
                this.alphaMap = source.alphaMap;
                this.wireframe = source.wireframe;
                this.wireframeLinewidth = source.wireframeLinewidth;
                this.wireframeLinecap = source.wireframeLinecap;
                this.wireframeLinejoin = source.wireframeLinejoin;
                this.skinning = source.skinning;
                this.morphTargets = source.morphTargets;
                this.morphNormals = source.morphNormals;
                return this;
            };
            MeshNormalMaterial.prototype = Object.create(Material.prototype);
            MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;
            MeshNormalMaterial.prototype.isMeshNormalMaterial = true;
            MeshNormalMaterial.prototype.copy = function (source) {
                Material.prototype.copy.call(this, source);
                this.bumpMap = source.bumpMap;
                this.bumpScale = source.bumpScale;
                this.normalMap = source.normalMap;
                this.normalMapType = source.normalMapType;
                this.normalScale.copy(source.normalScale);
                this.displacementMap = source.displacementMap;
                this.displacementScale = source.displacementScale;
                this.displacementBias = source.displacementBias;
                this.wireframe = source.wireframe;
                this.wireframeLinewidth = source.wireframeLinewidth;
                this.skinning = source.skinning;
                this.morphTargets = source.morphTargets;
                this.morphNormals = source.morphNormals;
                return this;
            };
            MeshLambertMaterial.prototype = Object.create(Material.prototype);
            MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;
            MeshLambertMaterial.prototype.isMeshLambertMaterial = true;
            MeshLambertMaterial.prototype.copy = function (source) {
                Material.prototype.copy.call(this, source);
                this.color.copy(source.color);
                this.map = source.map;
                this.lightMap = source.lightMap;
                this.lightMapIntensity = source.lightMapIntensity;
                this.aoMap = source.aoMap;
                this.aoMapIntensity = source.aoMapIntensity;
                this.emissive.copy(source.emissive);
                this.emissiveMap = source.emissiveMap;
                this.emissiveIntensity = source.emissiveIntensity;
                this.specularMap = source.specularMap;
                this.alphaMap = source.alphaMap;
                this.envMap = source.envMap;
                this.combine = source.combine;
                this.reflectivity = source.reflectivity;
                this.refractionRatio = source.refractionRatio;
                this.wireframe = source.wireframe;
                this.wireframeLinewidth = source.wireframeLinewidth;
                this.wireframeLinecap = source.wireframeLinecap;
                this.wireframeLinejoin = source.wireframeLinejoin;
                this.skinning = source.skinning;
                this.morphTargets = source.morphTargets;
                this.morphNormals = source.morphNormals;
                return this;
            };
            MeshMatcapMaterial.prototype = Object.create(Material.prototype);
            MeshMatcapMaterial.prototype.constructor = MeshMatcapMaterial;
            MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;
            MeshMatcapMaterial.prototype.copy = function (source) {
                Material.prototype.copy.call(this, source);
                this.defines = { 'MATCAP': '' };
                this.color.copy(source.color);
                this.matcap = source.matcap;
                this.map = source.map;
                this.bumpMap = source.bumpMap;
                this.bumpScale = source.bumpScale;
                this.normalMap = source.normalMap;
                this.normalMapType = source.normalMapType;
                this.normalScale.copy(source.normalScale);
                this.displacementMap = source.displacementMap;
                this.displacementScale = source.displacementScale;
                this.displacementBias = source.displacementBias;
                this.alphaMap = source.alphaMap;
                this.skinning = source.skinning;
                this.morphTargets = source.morphTargets;
                this.morphNormals = source.morphNormals;
                return this;
            };
            LineDashedMaterial.prototype = Object.create(LineBasicMaterial.prototype);
            LineDashedMaterial.prototype.constructor = LineDashedMaterial;
            LineDashedMaterial.prototype.isLineDashedMaterial = true;
            LineDashedMaterial.prototype.copy = function (source) {
                LineBasicMaterial.prototype.copy.call(this, source);
                this.scale = source.scale;
                this.dashSize = source.dashSize;
                this.gapSize = source.gapSize;
                return this;
            };
            Materials = Object.freeze({
                __proto__: null,
                ShadowMaterial: ShadowMaterial,
                SpriteMaterial: SpriteMaterial,
                RawShaderMaterial: RawShaderMaterial,
                ShaderMaterial: ShaderMaterial,
                PointsMaterial: PointsMaterial,
                MeshPhysicalMaterial: MeshPhysicalMaterial,
                MeshStandardMaterial: MeshStandardMaterial,
                MeshPhongMaterial: MeshPhongMaterial,
                MeshToonMaterial: MeshToonMaterial,
                MeshNormalMaterial: MeshNormalMaterial,
                MeshLambertMaterial: MeshLambertMaterial,
                MeshDepthMaterial: MeshDepthMaterial,
                MeshDistanceMaterial: MeshDistanceMaterial,
                MeshBasicMaterial: MeshBasicMaterial,
                MeshMatcapMaterial: MeshMatcapMaterial,
                LineDashedMaterial: LineDashedMaterial,
                LineBasicMaterial: LineBasicMaterial,
                Material: Material
            });
            /**
             * @author tschw
             * @author Ben Houston / http://clara.io/
             * @author David Sarno / http://lighthaus.us/
             */
            AnimationUtils = {
                // same as Array.prototype.slice, but also works on typed arrays
                arraySlice: function (array, from, to) {
                    if (AnimationUtils.isTypedArray(array)) {
                        // in ios9 array.subarray(from, undefined) will return empty array
                        // but array.subarray(from) or array.subarray(from, len) is correct
                        return new array.constructor(array.subarray(from, to !== undefined ? to : array.length));
                    }
                    return array.slice(from, to);
                },
                // converts an array to a specific type
                convertArray: function (array, type, forceClone) {
                    if (!array || // let 'undefined' and 'null' pass
                        !forceClone && array.constructor === type)
                        return array;
                    if (typeof type.BYTES_PER_ELEMENT === 'number') {
                        return new type(array); // create typed array
                    }
                    return Array.prototype.slice.call(array); // create Array
                },
                isTypedArray: function (object) {
                    return ArrayBuffer.isView(object) &&
                        !(object instanceof DataView);
                },
                // returns an array by which times and values can be sorted
                getKeyframeOrder: function (times) {
                    function compareTime(i, j) {
                        return times[i] - times[j];
                    }
                    var n = times.length;
                    var result = new Array(n);
                    for (var i = 0; i !== n; ++i)
                        result[i] = i;
                    result.sort(compareTime);
                    return result;
                },
                // uses the array previously returned by 'getKeyframeOrder' to sort data
                sortedArray: function (values, stride, order) {
                    var nValues = values.length;
                    var result = new values.constructor(nValues);
                    for (var i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {
                        var srcOffset = order[i] * stride;
                        for (var j = 0; j !== stride; ++j) {
                            result[dstOffset++] = values[srcOffset + j];
                        }
                    }
                    return result;
                },
                // function for parsing AOS keyframe formats
                flattenJSON: function (jsonKeys, times, values, valuePropertyName) {
                    var i = 1, key = jsonKeys[0];
                    while (key !== undefined && key[valuePropertyName] === undefined) {
                        key = jsonKeys[i++];
                    }
                    if (key === undefined)
                        return; // no data
                    var value = key[valuePropertyName];
                    if (value === undefined)
                        return; // no data
                    if (Array.isArray(value)) {
                        do {
                            value = key[valuePropertyName];
                            if (value !== undefined) {
                                times.push(key.time);
                                values.push.apply(values, value); // push all elements
                            }
                            key = jsonKeys[i++];
                        } while (key !== undefined);
                    }
                    else if (value.toArray !== undefined) {
                        // ...assume THREE.Math-ish
                        do {
                            value = key[valuePropertyName];
                            if (value !== undefined) {
                                times.push(key.time);
                                value.toArray(values, values.length);
                            }
                            key = jsonKeys[i++];
                        } while (key !== undefined);
                    }
                    else {
                        // otherwise push as-is
                        do {
                            value = key[valuePropertyName];
                            if (value !== undefined) {
                                times.push(key.time);
                                values.push(value);
                            }
                            key = jsonKeys[i++];
                        } while (key !== undefined);
                    }
                },
                subclip: function (sourceClip, name, startFrame, endFrame, fps) {
                    fps = fps || 30;
                    var clip = sourceClip.clone();
                    clip.name = name;
                    var tracks = [];
                    for (var i = 0; i < clip.tracks.length; ++i) {
                        var track = clip.tracks[i];
                        var valueSize = track.getValueSize();
                        var times = [];
                        var values = [];
                        for (var j = 0; j < track.times.length; ++j) {
                            var frame = track.times[j] * fps;
                            if (frame < startFrame || frame >= endFrame)
                                continue;
                            times.push(track.times[j]);
                            for (var k = 0; k < valueSize; ++k) {
                                values.push(track.values[j * valueSize + k]);
                            }
                        }
                        if (times.length === 0)
                            continue;
                        track.times = AnimationUtils.convertArray(times, track.times.constructor);
                        track.values = AnimationUtils.convertArray(values, track.values.constructor);
                        tracks.push(track);
                    }
                    clip.tracks = tracks;
                    // find minimum .times value across all tracks in the trimmed clip
                    var minStartTime = Infinity;
                    for (var i = 0; i < clip.tracks.length; ++i) {
                        if (minStartTime > clip.tracks[i].times[0]) {
                            minStartTime = clip.tracks[i].times[0];
                        }
                    }
                    // shift all tracks such that clip begins at t=0
                    for (var i = 0; i < clip.tracks.length; ++i) {
                        clip.tracks[i].shift(-1 * minStartTime);
                    }
                    clip.resetDuration();
                    return clip;
                }
            };
            exports_14("AnimationUtils", AnimationUtils);
            Object.assign(Interpolant.prototype, {
                evaluate: function (t) {
                    var pp = this.parameterPositions, i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];
                    validate_interval: {
                        seek: {
                            var right;
                            linear_scan: {
                                //- See http://jsperf.com/comparison-to-undefined/3
                                //- slower code:
                                //-
                                //- 				if ( t >= t1 || t1 === undefined ) {
                                forward_scan: if (!(t < t1)) {
                                    for (var giveUpAt = i1 + 2;;) {
                                        if (t1 === undefined) {
                                            if (t < t0)
                                                break forward_scan;
                                            // after end
                                            i1 = pp.length;
                                            this._cachedIndex = i1;
                                            return this.afterEnd_(i1 - 1, t, t0);
                                        }
                                        if (i1 === giveUpAt)
                                            break; // this loop
                                        t0 = t1;
                                        t1 = pp[++i1];
                                        if (t < t1) {
                                            // we have arrived at the sought interval
                                            break seek;
                                        }
                                    }
                                    // prepare binary search on the right side of the index
                                    right = pp.length;
                                    break linear_scan;
                                }
                                //- slower code:
                                //-					if ( t < t0 || t0 === undefined ) {
                                if (!(t >= t0)) {
                                    // looping?
                                    var t1global = pp[1];
                                    if (t < t1global) {
                                        i1 = 2; // + 1, using the scan for the details
                                        t0 = t1global;
                                    }
                                    // linear reverse scan
                                    for (var giveUpAt = i1 - 2;;) {
                                        if (t0 === undefined) {
                                            // before start
                                            this._cachedIndex = 0;
                                            return this.beforeStart_(0, t, t1);
                                        }
                                        if (i1 === giveUpAt)
                                            break; // this loop
                                        t1 = t0;
                                        t0 = pp[--i1 - 1];
                                        if (t >= t0) {
                                            // we have arrived at the sought interval
                                            break seek;
                                        }
                                    }
                                    // prepare binary search on the left side of the index
                                    right = i1;
                                    i1 = 0;
                                    break linear_scan;
                                }
                                // the interval is valid
                                break validate_interval;
                            } // linear scan
                            // binary search
                            while (i1 < right) {
                                var mid = (i1 + right) >>> 1;
                                if (t < pp[mid]) {
                                    right = mid;
                                }
                                else {
                                    i1 = mid + 1;
                                }
                            }
                            t1 = pp[i1];
                            t0 = pp[i1 - 1];
                            // check boundary cases, again
                            if (t0 === undefined) {
                                this._cachedIndex = 0;
                                return this.beforeStart_(0, t, t1);
                            }
                            if (t1 === undefined) {
                                i1 = pp.length;
                                this._cachedIndex = i1;
                                return this.afterEnd_(i1 - 1, t0, t);
                            }
                        } // seek
                        this._cachedIndex = i1;
                        this.intervalChanged_(i1, t0, t1);
                    } // validate_interval
                    return this.interpolate_(i1, t0, t, t1);
                },
                settings: null,
                // Note: The indirection allows central control of many interpolants.
                // --- Protected interface
                DefaultSettings_: {},
                getSettings_: function () {
                    return this.settings || this.DefaultSettings_;
                },
                copySampleValue_: function (index) {
                    // copies a sample value to the result buffer
                    var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index * stride;
                    for (var i = 0; i !== stride; ++i) {
                        result[i] = values[offset + i];
                    }
                    return result;
                },
                // Template methods for derived classes:
                interpolate_: function ( /* i1, t0, t, t1 */) {
                    throw new Error('call to abstract method');
                    // implementations shall return this.resultBuffer
                },
                intervalChanged_: function ( /* i1, t0, t1 */) {
                    // empty
                }
            });
            //!\ DECLARE ALIAS AFTER assign prototype !
            Object.assign(Interpolant.prototype, {
                //( 0, t, t0 ), returns this.resultBuffer
                beforeStart_: Interpolant.prototype.copySampleValue_,
                //( N-1, tN-1, t ), returns this.resultBuffer
                afterEnd_: Interpolant.prototype.copySampleValue_,
            });
            CubicInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
                constructor: CubicInterpolant,
                DefaultSettings_: {
                    endingStart: ZeroCurvatureEnding,
                    endingEnd: ZeroCurvatureEnding
                },
                intervalChanged_: function (i1, t0, t1) {
                    var pp = this.parameterPositions, iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
                    if (tPrev === undefined) {
                        switch (this.getSettings_().endingStart) {
                            case ZeroSlopeEnding:
                                // f'(t0) = 0
                                iPrev = i1;
                                tPrev = 2 * t0 - t1;
                                break;
                            case WrapAroundEnding:
                                // use the other end of the curve
                                iPrev = pp.length - 2;
                                tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
                                break;
                            default: // ZeroCurvatureEnding
                                // f''(t0) = 0 a.k.a. Natural Spline
                                iPrev = i1;
                                tPrev = t1;
                        }
                    }
                    if (tNext === undefined) {
                        switch (this.getSettings_().endingEnd) {
                            case ZeroSlopeEnding:
                                // f'(tN) = 0
                                iNext = i1;
                                tNext = 2 * t1 - t0;
                                break;
                            case WrapAroundEnding:
                                // use the other end of the curve
                                iNext = 1;
                                tNext = t1 + pp[1] - pp[0];
                                break;
                            default: // ZeroCurvatureEnding
                                // f''(tN) = 0, a.k.a. Natural Spline
                                iNext = i1 - 1;
                                tNext = t0;
                        }
                    }
                    var halfDt = (t1 - t0) * 0.5, stride = this.valueSize;
                    this._weightPrev = halfDt / (t0 - tPrev);
                    this._weightNext = halfDt / (tNext - t1);
                    this._offsetPrev = iPrev * stride;
                    this._offsetNext = iNext * stride;
                },
                interpolate_: function (i1, t0, t, t1) {
                    var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p = (t - t0) / (t1 - t0), pp = p * p, ppp = pp * p;
                    // evaluate polynomials
                    var sP = -wP * ppp + 2 * wP * pp - wP * p;
                    var s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
                    var s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
                    var sN = wN * ppp - wN * pp;
                    // combine data linearly
                    for (var i = 0; i !== stride; ++i) {
                        result[i] =
                            sP * values[oP + i] +
                                s0 * values[o0 + i] +
                                s1 * values[o1 + i] +
                                sN * values[oN + i];
                    }
                    return result;
                }
            });
            LinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
                constructor: LinearInterpolant,
                interpolate_: function (i1, t0, t, t1) {
                    var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t - t0) / (t1 - t0), weight0 = 1 - weight1;
                    for (var i = 0; i !== stride; ++i) {
                        result[i] =
                            values[offset0 + i] * weight0 +
                                values[offset1 + i] * weight1;
                    }
                    return result;
                }
            });
            DiscreteInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
                constructor: DiscreteInterpolant,
                interpolate_: function (i1 /*, t0, t, t1 */) {
                    return this.copySampleValue_(i1 - 1);
                }
            });
            // Static methods
            Object.assign(KeyframeTrack, {
                // Serialization (in static context, because of constructor invocation
                // and automatic invocation of .toJSON):
                toJSON: function (track) {
                    var trackType = track.constructor;
                    var json;
                    // derived classes can define a static toJSON method
                    if (trackType.toJSON !== undefined) {
                        json = trackType.toJSON(track);
                    }
                    else {
                        // by default, we assume the data can be serialized as-is
                        json = {
                            'name': track.name,
                            'times': AnimationUtils.convertArray(track.times, Array),
                            'values': AnimationUtils.convertArray(track.values, Array)
                        };
                        var interpolation = track.getInterpolation();
                        if (interpolation !== track.DefaultInterpolation) {
                            json.interpolation = interpolation;
                        }
                    }
                    json.type = track.ValueTypeName; // mandatory
                    return json;
                }
            });
            Object.assign(KeyframeTrack.prototype, {
                constructor: KeyframeTrack,
                TimeBufferType: Float32Array,
                ValueBufferType: Float32Array,
                DefaultInterpolation: InterpolateLinear,
                InterpolantFactoryMethodDiscrete: function (result) {
                    return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
                },
                InterpolantFactoryMethodLinear: function (result) {
                    return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
                },
                InterpolantFactoryMethodSmooth: function (result) {
                    return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
                },
                setInterpolation: function (interpolation) {
                    var factoryMethod;
                    switch (interpolation) {
                        case InterpolateDiscrete:
                            factoryMethod = this.InterpolantFactoryMethodDiscrete;
                            break;
                        case InterpolateLinear:
                            factoryMethod = this.InterpolantFactoryMethodLinear;
                            break;
                        case InterpolateSmooth:
                            factoryMethod = this.InterpolantFactoryMethodSmooth;
                            break;
                    }
                    if (factoryMethod === undefined) {
                        var message = "unsupported interpolation for " +
                            this.ValueTypeName + " keyframe track named " + this.name;
                        if (this.createInterpolant === undefined) {
                            // fall back to default, unless the default itself is messed up
                            if (interpolation !== this.DefaultInterpolation) {
                                this.setInterpolation(this.DefaultInterpolation);
                            }
                            else {
                                throw new Error(message); // fatal, in this case
                            }
                        }
                        console.warn('THREE.KeyframeTrack:', message);
                        return this;
                    }
                    this.createInterpolant = factoryMethod;
                    return this;
                },
                getInterpolation: function () {
                    switch (this.createInterpolant) {
                        case this.InterpolantFactoryMethodDiscrete:
                            return InterpolateDiscrete;
                        case this.InterpolantFactoryMethodLinear:
                            return InterpolateLinear;
                        case this.InterpolantFactoryMethodSmooth:
                            return InterpolateSmooth;
                    }
                },
                getValueSize: function () {
                    return this.values.length / this.times.length;
                },
                // move all keyframes either forwards or backwards in time
                shift: function (timeOffset) {
                    if (timeOffset !== 0.0) {
                        var times = this.times;
                        for (var i = 0, n = times.length; i !== n; ++i) {
                            times[i] += timeOffset;
                        }
                    }
                    return this;
                },
                // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
                scale: function (timeScale) {
                    if (timeScale !== 1.0) {
                        var times = this.times;
                        for (var i = 0, n = times.length; i !== n; ++i) {
                            times[i] *= timeScale;
                        }
                    }
                    return this;
                },
                // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
                // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
                trim: function (startTime, endTime) {
                    var times = this.times, nKeys = times.length, from = 0, to = nKeys - 1;
                    while (from !== nKeys && times[from] < startTime) {
                        ++from;
                    }
                    while (to !== -1 && times[to] > endTime) {
                        --to;
                    }
                    ++to; // inclusive -> exclusive bound
                    if (from !== 0 || to !== nKeys) {
                        // empty tracks are forbidden, so keep at least one keyframe
                        if (from >= to)
                            to = Math.max(to, 1), from = to - 1;
                        var stride = this.getValueSize();
                        this.times = AnimationUtils.arraySlice(times, from, to);
                        this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);
                    }
                    return this;
                },
                // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
                validate: function () {
                    var valid = true;
                    var valueSize = this.getValueSize();
                    if (valueSize - Math.floor(valueSize) !== 0) {
                        console.error('THREE.KeyframeTrack: Invalid value size in track.', this);
                        valid = false;
                    }
                    var times = this.times, values = this.values, nKeys = times.length;
                    if (nKeys === 0) {
                        console.error('THREE.KeyframeTrack: Track is empty.', this);
                        valid = false;
                    }
                    var prevTime = null;
                    for (var i = 0; i !== nKeys; i++) {
                        var currTime = times[i];
                        if (typeof currTime === 'number' && isNaN(currTime)) {
                            console.error('THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime);
                            valid = false;
                            break;
                        }
                        if (prevTime !== null && prevTime > currTime) {
                            console.error('THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime);
                            valid = false;
                            break;
                        }
                        prevTime = currTime;
                    }
                    if (values !== undefined) {
                        if (AnimationUtils.isTypedArray(values)) {
                            for (var i = 0, n = values.length; i !== n; ++i) {
                                var value = values[i];
                                if (isNaN(value)) {
                                    console.error('THREE.KeyframeTrack: Value is not a valid number.', this, i, value);
                                    valid = false;
                                    break;
                                }
                            }
                        }
                    }
                    return valid;
                },
                // removes equivalent sequential keys as common in morph target sequences
                // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
                optimize: function () {
                    // times or values may be shared with other tracks, so overwriting is unsafe
                    var times = AnimationUtils.arraySlice(this.times), values = AnimationUtils.arraySlice(this.values), stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, writeIndex = 1, lastIndex = times.length - 1;
                    for (var i = 1; i < lastIndex; ++i) {
                        var keep = false;
                        var time = times[i];
                        var timeNext = times[i + 1];
                        // remove adjacent keyframes scheduled at the same time
                        if (time !== timeNext && (i !== 1 || time !== time[0])) {
                            if (!smoothInterpolation) {
                                // remove unnecessary keyframes same as their neighbors
                                var offset = i * stride, offsetP = offset - stride, offsetN = offset + stride;
                                for (var j = 0; j !== stride; ++j) {
                                    var value = values[offset + j];
                                    if (value !== values[offsetP + j] ||
                                        value !== values[offsetN + j]) {
                                        keep = true;
                                        break;
                                    }
                                }
                            }
                            else {
                                keep = true;
                            }
                        }
                        // in-place compaction
                        if (keep) {
                            if (i !== writeIndex) {
                                times[writeIndex] = times[i];
                                var readOffset = i * stride, writeOffset = writeIndex * stride;
                                for (var j = 0; j !== stride; ++j) {
                                    values[writeOffset + j] = values[readOffset + j];
                                }
                            }
                            ++writeIndex;
                        }
                    }
                    // flush last keyframe (compaction looks ahead)
                    if (lastIndex > 0) {
                        times[writeIndex] = times[lastIndex];
                        for (var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {
                            values[writeOffset + j] = values[readOffset + j];
                        }
                        ++writeIndex;
                    }
                    if (writeIndex !== times.length) {
                        this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
                        this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
                    }
                    else {
                        this.times = times;
                        this.values = values;
                    }
                    return this;
                },
                clone: function () {
                    var times = AnimationUtils.arraySlice(this.times, 0);
                    var values = AnimationUtils.arraySlice(this.values, 0);
                    var TypedKeyframeTrack = this.constructor;
                    var track = new TypedKeyframeTrack(this.name, times, values);
                    // Interpolant argument to constructor is not saved, so copy the factory method directly.
                    track.createInterpolant = this.createInterpolant;
                    return track;
                }
            });
            BooleanKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
                constructor: BooleanKeyframeTrack,
                ValueTypeName: 'bool',
                ValueBufferType: Array,
                DefaultInterpolation: InterpolateDiscrete,
                InterpolantFactoryMethodLinear: undefined,
                InterpolantFactoryMethodSmooth: undefined
                // Note: Actually this track could have a optimized / compressed
                // representation of a single value and a custom interpolant that
                // computes "firstValue ^ isOdd( index )".
            });
            ColorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
                constructor: ColorKeyframeTrack,
                ValueTypeName: 'color'
                // ValueBufferType is inherited
                // DefaultInterpolation is inherited
                // Note: Very basic implementation and nothing special yet.
                // However, this is the place for color space parameterization.
            });
            NumberKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
                constructor: NumberKeyframeTrack,
                ValueTypeName: 'number'
                // ValueBufferType is inherited
                // DefaultInterpolation is inherited
            });
            QuaternionLinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
                constructor: QuaternionLinearInterpolant,
                interpolate_: function (i1, t0, t, t1) {
                    var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = i1 * stride, alpha = (t - t0) / (t1 - t0);
                    for (var end = offset + stride; offset !== end; offset += 4) {
                        Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
                    }
                    return result;
                }
            });
            QuaternionKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
                constructor: QuaternionKeyframeTrack,
                ValueTypeName: 'quaternion',
                // ValueBufferType is inherited
                DefaultInterpolation: InterpolateLinear,
                InterpolantFactoryMethodLinear: function (result) {
                    return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
                },
                InterpolantFactoryMethodSmooth: undefined // not yet implemented
            });
            StringKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
                constructor: StringKeyframeTrack,
                ValueTypeName: 'string',
                ValueBufferType: Array,
                DefaultInterpolation: InterpolateDiscrete,
                InterpolantFactoryMethodLinear: undefined,
                InterpolantFactoryMethodSmooth: undefined
            });
            VectorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
                constructor: VectorKeyframeTrack,
                ValueTypeName: 'vector'
                // ValueBufferType is inherited
                // DefaultInterpolation is inherited
            });
            Object.assign(AnimationClip, {
                parse: function (json) {
                    var tracks = [], jsonTracks = json.tracks, frameTime = 1.0 / (json.fps || 1.0);
                    for (var i = 0, n = jsonTracks.length; i !== n; ++i) {
                        tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));
                    }
                    return new AnimationClip(json.name, json.duration, tracks);
                },
                toJSON: function (clip) {
                    var tracks = [], clipTracks = clip.tracks;
                    var json = {
                        'name': clip.name,
                        'duration': clip.duration,
                        'tracks': tracks,
                        'uuid': clip.uuid
                    };
                    for (var i = 0, n = clipTracks.length; i !== n; ++i) {
                        tracks.push(KeyframeTrack.toJSON(clipTracks[i]));
                    }
                    return json;
                },
                CreateFromMorphTargetSequence: function (name, morphTargetSequence, fps, noLoop) {
                    var numMorphTargets = morphTargetSequence.length;
                    var tracks = [];
                    for (var i = 0; i < numMorphTargets; i++) {
                        var times = [];
                        var values = [];
                        times.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets);
                        values.push(0, 1, 0);
                        var order = AnimationUtils.getKeyframeOrder(times);
                        times = AnimationUtils.sortedArray(times, 1, order);
                        values = AnimationUtils.sortedArray(values, 1, order);
                        // if there is a key at the first frame, duplicate it as the
                        // last frame as well for perfect loop.
                        if (!noLoop && times[0] === 0) {
                            times.push(numMorphTargets);
                            values.push(values[0]);
                        }
                        tracks.push(new NumberKeyframeTrack('.morphTargetInfluences[' + morphTargetSequence[i].name + ']', times, values).scale(1.0 / fps));
                    }
                    return new AnimationClip(name, -1, tracks);
                },
                findByName: function (objectOrClipArray, name) {
                    var clipArray = objectOrClipArray;
                    if (!Array.isArray(objectOrClipArray)) {
                        var o = objectOrClipArray;
                        clipArray = o.geometry && o.geometry.animations || o.animations;
                    }
                    for (var i = 0; i < clipArray.length; i++) {
                        if (clipArray[i].name === name) {
                            return clipArray[i];
                        }
                    }
                    return null;
                },
                CreateClipsFromMorphTargetSequences: function (morphTargets, fps, noLoop) {
                    var animationToMorphTargets = {};
                    // tested with https://regex101.com/ on trick sequences
                    // such flamingo_flyA_003, flamingo_run1_003, crdeath0059
                    var pattern = /^([\w-]*?)([\d]+)$/;
                    // sort morph target names into animation groups based
                    // patterns like Walk_001, Walk_002, Run_001, Run_002
                    for (var i = 0, il = morphTargets.length; i < il; i++) {
                        var morphTarget = morphTargets[i];
                        var parts = morphTarget.name.match(pattern);
                        if (parts && parts.length > 1) {
                            var name = parts[1];
                            var animationMorphTargets = animationToMorphTargets[name];
                            if (!animationMorphTargets) {
                                animationToMorphTargets[name] = animationMorphTargets = [];
                            }
                            animationMorphTargets.push(morphTarget);
                        }
                    }
                    var clips = [];
                    for (var name in animationToMorphTargets) {
                        clips.push(AnimationClip.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
                    }
                    return clips;
                },
                // parse the animation.hierarchy format
                parseAnimation: function (animation, bones) {
                    if (!animation) {
                        console.error('THREE.AnimationClip: No animation in JSONLoader data.');
                        return null;
                    }
                    var addNonemptyTrack = function (trackType, trackName, animationKeys, propertyName, destTracks) {
                        // only return track if there are actually keys.
                        if (animationKeys.length !== 0) {
                            var times = [];
                            var values = [];
                            AnimationUtils.flattenJSON(animationKeys, times, values, propertyName);
                            // empty keys are filtered out, so check again
                            if (times.length !== 0) {
                                destTracks.push(new trackType(trackName, times, values));
                            }
                        }
                    };
                    var tracks = [];
                    var clipName = animation.name || 'default';
                    // automatic length determination in AnimationClip.
                    var duration = animation.length || -1;
                    var fps = animation.fps || 30;
                    var hierarchyTracks = animation.hierarchy || [];
                    for (var h = 0; h < hierarchyTracks.length; h++) {
                        var animationKeys = hierarchyTracks[h].keys;
                        // skip empty tracks
                        if (!animationKeys || animationKeys.length === 0)
                            continue;
                        // process morph targets
                        if (animationKeys[0].morphTargets) {
                            // figure out all morph targets used in this track
                            var morphTargetNames = {};
                            for (var k = 0; k < animationKeys.length; k++) {
                                if (animationKeys[k].morphTargets) {
                                    for (var m = 0; m < animationKeys[k].morphTargets.length; m++) {
                                        morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
                                    }
                                }
                            }
                            // create a track for each morph target with all zero
                            // morphTargetInfluences except for the keys in which
                            // the morphTarget is named.
                            for (var morphTargetName in morphTargetNames) {
                                var times = [];
                                var values = [];
                                for (var m = 0; m !== animationKeys[k].morphTargets.length; ++m) {
                                    var animationKey = animationKeys[k];
                                    times.push(animationKey.time);
                                    values.push((animationKey.morphTarget === morphTargetName) ? 1 : 0);
                                }
                                tracks.push(new NumberKeyframeTrack('.morphTargetInfluence[' + morphTargetName + ']', times, values));
                            }
                            duration = morphTargetNames.length * (fps || 1.0);
                        }
                        else {
                            // ...assume skeletal animation
                            var boneName = '.bones[' + bones[h].name + ']';
                            addNonemptyTrack(VectorKeyframeTrack, boneName + '.position', animationKeys, 'pos', tracks);
                            addNonemptyTrack(QuaternionKeyframeTrack, boneName + '.quaternion', animationKeys, 'rot', tracks);
                            addNonemptyTrack(VectorKeyframeTrack, boneName + '.scale', animationKeys, 'scl', tracks);
                        }
                    }
                    if (tracks.length === 0) {
                        return null;
                    }
                    var clip = new AnimationClip(clipName, duration, tracks);
                    return clip;
                }
            });
            Object.assign(AnimationClip.prototype, {
                resetDuration: function () {
                    var tracks = this.tracks, duration = 0;
                    for (var i = 0, n = tracks.length; i !== n; ++i) {
                        var track = this.tracks[i];
                        duration = Math.max(duration, track.times[track.times.length - 1]);
                    }
                    this.duration = duration;
                    return this;
                },
                trim: function () {
                    for (var i = 0; i < this.tracks.length; i++) {
                        this.tracks[i].trim(0, this.duration);
                    }
                    return this;
                },
                validate: function () {
                    var valid = true;
                    for (var i = 0; i < this.tracks.length; i++) {
                        valid = valid && this.tracks[i].validate();
                    }
                    return valid;
                },
                optimize: function () {
                    for (var i = 0; i < this.tracks.length; i++) {
                        this.tracks[i].optimize();
                    }
                    return this;
                },
                clone: function () {
                    var tracks = [];
                    for (var i = 0; i < this.tracks.length; i++) {
                        tracks.push(this.tracks[i].clone());
                    }
                    return new AnimationClip(this.name, this.duration, tracks);
                }
            });
            /**
             * @author mrdoob / http://mrdoob.com/
             */
            Cache = {
                enabled: false,
                files: {},
                add: function (key, file) {
                    if (this.enabled === false)
                        return;
                    // console.log( 'THREE.Cache', 'Adding key:', key );
                    this.files[key] = file;
                },
                get: function (key) {
                    if (this.enabled === false)
                        return;
                    // console.log( 'THREE.Cache', 'Checking key:', key );
                    return this.files[key];
                },
                remove: function (key) {
                    delete this.files[key];
                },
                clear: function () {
                    this.files = {};
                }
            };
            exports_14("Cache", Cache);
            DefaultLoadingManager = new LoadingManager();
            exports_14("DefaultLoadingManager", DefaultLoadingManager);
            Object.assign(Loader.prototype, {
                load: function ( /* url, onLoad, onProgress, onError */) { },
                parse: function ( /* data */) { },
                setCrossOrigin: function (crossOrigin) {
                    this.crossOrigin = crossOrigin;
                    return this;
                },
                setPath: function (path) {
                    this.path = path;
                    return this;
                },
                setResourcePath: function (resourcePath) {
                    this.resourcePath = resourcePath;
                    return this;
                }
            });
            /**
             * @author mrdoob / http://mrdoob.com/
             */
            loading = {};
            FileLoader.prototype = Object.assign(Object.create(Loader.prototype), {
                constructor: FileLoader,
                load: function (url, onLoad, onProgress, onError) {
                    if (url === undefined)
                        url = '';
                    if (this.path !== undefined)
                        url = this.path + url;
                    url = this.manager.resolveURL(url);
                    var scope = this;
                    var cached = Cache.get(url);
                    if (cached !== undefined) {
                        scope.manager.itemStart(url);
                        setTimeout(function () {
                            if (onLoad)
                                onLoad(cached);
                            scope.manager.itemEnd(url);
                        }, 0);
                        return cached;
                    }
                    // Check if request is duplicate
                    if (loading[url] !== undefined) {
                        loading[url].push({
                            onLoad: onLoad,
                            onProgress: onProgress,
                            onError: onError
                        });
                        return;
                    }
                    // Check for data: URI
                    var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
                    var dataUriRegexResult = url.match(dataUriRegex);
                    // Safari can not handle Data URIs through XMLHttpRequest so process manually
                    if (dataUriRegexResult) {
                        var mimeType = dataUriRegexResult[1];
                        var isBase64 = !!dataUriRegexResult[2];
                        var data = dataUriRegexResult[3];
                        data = decodeURIComponent(data);
                        if (isBase64)
                            data = atob(data);
                        try {
                            var response;
                            var responseType = (this.responseType || '').toLowerCase();
                            switch (responseType) {
                                case 'arraybuffer':
                                case 'blob':
                                    var view = new Uint8Array(data.length);
                                    for (var i = 0; i < data.length; i++) {
                                        view[i] = data.charCodeAt(i);
                                    }
                                    if (responseType === 'blob') {
                                        response = new Blob([view.buffer], { type: mimeType });
                                    }
                                    else {
                                        response = view.buffer;
                                    }
                                    break;
                                case 'document':
                                    var parser = new DOMParser();
                                    response = parser.parseFromString(data, mimeType);
                                    break;
                                case 'json':
                                    response = JSON.parse(data);
                                    break;
                                default: // 'text' or other
                                    response = data;
                                    break;
                            }
                            // Wait for next browser tick like standard XMLHttpRequest event dispatching does
                            setTimeout(function () {
                                if (onLoad)
                                    onLoad(response);
                                scope.manager.itemEnd(url);
                            }, 0);
                        }
                        catch (error) {
                            // Wait for next browser tick like standard XMLHttpRequest event dispatching does
                            setTimeout(function () {
                                if (onError)
                                    onError(error);
                                scope.manager.itemError(url);
                                scope.manager.itemEnd(url);
                            }, 0);
                        }
                    }
                    else {
                        // Initialise array for duplicate requests
                        loading[url] = [];
                        loading[url].push({
                            onLoad: onLoad,
                            onProgress: onProgress,
                            onError: onError
                        });
                        var request = new XMLHttpRequest();
                        request.open('GET', url, true);
                        request.addEventListener('load', function (event) {
                            var response = this.response;
                            var callbacks = loading[url];
                            delete loading[url];
                            if (this.status === 200 || this.status === 0) {
                                // Some browsers return HTTP Status 0 when using non-http protocol
                                // e.g. 'file://' or 'data://'. Handle as success.
                                if (this.status === 0)
                                    console.warn('THREE.FileLoader: HTTP Status 0 received.');
                                // Add to cache only on HTTP success, so that we do not cache
                                // error response bodies as proper responses to requests.
                                Cache.add(url, response);
                                for (var i = 0, il = callbacks.length; i < il; i++) {
                                    var callback = callbacks[i];
                                    if (callback.onLoad)
                                        callback.onLoad(response);
                                }
                                scope.manager.itemEnd(url);
                            }
                            else {
                                for (var i = 0, il = callbacks.length; i < il; i++) {
                                    var callback = callbacks[i];
                                    if (callback.onError)
                                        callback.onError(event);
                                }
                                scope.manager.itemError(url);
                                scope.manager.itemEnd(url);
                            }
                        }, false);
                        request.addEventListener('progress', function (event) {
                            var callbacks = loading[url];
                            for (var i = 0, il = callbacks.length; i < il; i++) {
                                var callback = callbacks[i];
                                if (callback.onProgress)
                                    callback.onProgress(event);
                            }
                        }, false);
                        request.addEventListener('error', function (event) {
                            var callbacks = loading[url];
                            delete loading[url];
                            for (var i = 0, il = callbacks.length; i < il; i++) {
                                var callback = callbacks[i];
                                if (callback.onError)
                                    callback.onError(event);
                            }
                            scope.manager.itemError(url);
                            scope.manager.itemEnd(url);
                        }, false);
                        request.addEventListener('abort', function (event) {
                            var callbacks = loading[url];
                            delete loading[url];
                            for (var i = 0, il = callbacks.length; i < il; i++) {
                                var callback = callbacks[i];
                                if (callback.onError)
                                    callback.onError(event);
                            }
                            scope.manager.itemError(url);
                            scope.manager.itemEnd(url);
                        }, false);
                        if (this.responseType !== undefined)
                            request.responseType = this.responseType;
                        if (this.withCredentials !== undefined)
                            request.withCredentials = this.withCredentials;
                        if (request.overrideMimeType)
                            request.overrideMimeType(this.mimeType !== undefined ? this.mimeType : 'text/plain');
                        for (var header in this.requestHeader) {
                            request.setRequestHeader(header, this.requestHeader[header]);
                        }
                        request.send(null);
                    }
                    scope.manager.itemStart(url);
                    return request;
                },
                setResponseType: function (value) {
                    this.responseType = value;
                    return this;
                },
                setWithCredentials: function (value) {
                    this.withCredentials = value;
                    return this;
                },
                setMimeType: function (value) {
                    this.mimeType = value;
                    return this;
                },
                setRequestHeader: function (value) {
                    this.requestHeader = value;
                    return this;
                }
            });
            AnimationLoader.prototype = Object.assign(Object.create(Loader.prototype), {
                constructor: AnimationLoader,
                load: function (url, onLoad, onProgress, onError) {
                    var scope = this;
                    var loader = new FileLoader(scope.manager);
                    loader.setPath(scope.path);
                    loader.load(url, function (text) {
                        onLoad(scope.parse(JSON.parse(text)));
                    }, onProgress, onError);
                },
                parse: function (json) {
                    var animations = [];
                    for (var i = 0; i < json.length; i++) {
                        var clip = AnimationClip.parse(json[i]);
                        animations.push(clip);
                    }
                    return animations;
                }
            });
            CompressedTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
                constructor: CompressedTextureLoader,
                load: function (url, onLoad, onProgress, onError) {
                    var scope = this;
                    var images = [];
                    var texture = new CompressedTexture();
                    texture.image = images;
                    var loader = new FileLoader(this.manager);
                    loader.setPath(this.path);
                    loader.setResponseType('arraybuffer');
                    function loadTexture(i) {
                        loader.load(url[i], function (buffer) {
                            var texDatas = scope.parse(buffer, true);
                            images[i] = {
                                width: texDatas.width,
                                height: texDatas.height,
                                format: texDatas.format,
                                mipmaps: texDatas.mipmaps
                            };
                            loaded += 1;
                            if (loaded === 6) {
                                if (texDatas.mipmapCount === 1)
                                    texture.minFilter = LinearFilter;
                                texture.format = texDatas.format;
                                texture.needsUpdate = true;
                                if (onLoad)
                                    onLoad(texture);
                            }
                        }, onProgress, onError);
                    }
                    if (Array.isArray(url)) {
                        var loaded = 0;
                        for (var i = 0, il = url.length; i < il; ++i) {
                            loadTexture(i);
                        }
                    }
                    else {
                        // compressed cubemap texture stored in a single DDS file
                        loader.load(url, function (buffer) {
                            var texDatas = scope.parse(buffer, true);
                            if (texDatas.isCubemap) {
                                var faces = texDatas.mipmaps.length / texDatas.mipmapCount;
                                for (var f = 0; f < faces; f++) {
                                    images[f] = { mipmaps: [] };
                                    for (var i = 0; i < texDatas.mipmapCount; i++) {
                                        images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);
                                        images[f].format = texDatas.format;
                                        images[f].width = texDatas.width;
                                        images[f].height = texDatas.height;
                                    }
                                }
                            }
                            else {
                                texture.image.width = texDatas.width;
                                texture.image.height = texDatas.height;
                                texture.mipmaps = texDatas.mipmaps;
                            }
                            if (texDatas.mipmapCount === 1) {
                                texture.minFilter = LinearFilter;
                            }
                            texture.format = texDatas.format;
                            texture.needsUpdate = true;
                            if (onLoad)
                                onLoad(texture);
                        }, onProgress, onError);
                    }
                    return texture;
                }
            });
            DataTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
                constructor: DataTextureLoader,
                load: function (url, onLoad, onProgress, onError) {
                    var scope = this;
                    var texture = new DataTexture();
                    var loader = new FileLoader(this.manager);
                    loader.setResponseType('arraybuffer');
                    loader.setPath(this.path);
                    loader.load(url, function (buffer) {
                        var texData = scope.parse(buffer);
                        if (!texData)
                            return;
                        if (texData.image !== undefined) {
                            texture.image = texData.image;
                        }
                        else if (texData.data !== undefined) {
                            texture.image.width = texData.width;
                            texture.image.height = texData.height;
                            texture.image.data = texData.data;
                        }
                        texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;
                        texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;
                        texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;
                        texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;
                        texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;
                        if (texData.format !== undefined) {
                            texture.format = texData.format;
                        }
                        if (texData.type !== undefined) {
                            texture.type = texData.type;
                        }
                        if (texData.mipmaps !== undefined) {
                            texture.mipmaps = texData.mipmaps;
                            texture.minFilter = LinearMipmapLinearFilter; // presumably...
                        }
                        if (texData.mipmapCount === 1) {
                            texture.minFilter = LinearFilter;
                        }
                        texture.needsUpdate = true;
                        if (onLoad)
                            onLoad(texture, texData);
                    }, onProgress, onError);
                    return texture;
                }
            });
            ImageLoader.prototype = Object.assign(Object.create(Loader.prototype), {
                constructor: ImageLoader,
                load: function (url, onLoad, onProgress, onError) {
                    if (this.path !== undefined)
                        url = this.path + url;
                    url = this.manager.resolveURL(url);
                    var scope = this;
                    var cached = Cache.get(url);
                    if (cached !== undefined) {
                        scope.manager.itemStart(url);
                        setTimeout(function () {
                            if (onLoad)
                                onLoad(cached);
                            scope.manager.itemEnd(url);
                        }, 0);
                        return cached;
                    }
                    var image = document.createElementNS('http://www.w3.org/1999/xhtml', 'img');
                    function onImageLoad() {
                        image.removeEventListener('load', onImageLoad, false);
                        image.removeEventListener('error', onImageError, false);
                        Cache.add(url, this);
                        if (onLoad)
                            onLoad(this);
                        scope.manager.itemEnd(url);
                    }
                    function onImageError(event) {
                        image.removeEventListener('load', onImageLoad, false);
                        image.removeEventListener('error', onImageError, false);
                        if (onError)
                            onError(event);
                        scope.manager.itemError(url);
                        scope.manager.itemEnd(url);
                    }
                    image.addEventListener('load', onImageLoad, false);
                    image.addEventListener('error', onImageError, false);
                    if (url.substr(0, 5) !== 'data:') {
                        if (this.crossOrigin !== undefined)
                            image.crossOrigin = this.crossOrigin;
                    }
                    scope.manager.itemStart(url);
                    image.src = url;
                    return image;
                }
            });
            CubeTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
                constructor: CubeTextureLoader,
                load: function (urls, onLoad, onProgress, onError) {
                    var texture = new CubeTexture();
                    var loader = new ImageLoader(this.manager);
                    loader.setCrossOrigin(this.crossOrigin);
                    loader.setPath(this.path);
                    var loaded = 0;
                    function loadTexture(i) {
                        loader.load(urls[i], function (image) {
                            texture.images[i] = image;
                            loaded++;
                            if (loaded === 6) {
                                texture.needsUpdate = true;
                                if (onLoad)
                                    onLoad(texture);
                            }
                        }, undefined, onError);
                    }
                    for (var i = 0; i < urls.length; ++i) {
                        loadTexture(i);
                    }
                    return texture;
                }
            });
            TextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
                constructor: TextureLoader,
                load: function (url, onLoad, onProgress, onError) {
                    var texture = new Texture();
                    var loader = new ImageLoader(this.manager);
                    loader.setCrossOrigin(this.crossOrigin);
                    loader.setPath(this.path);
                    loader.load(url, function (image) {
                        texture.image = image;
                        // JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
                        var isJPEG = url.search(/\.jpe?g($|\?)/i) > 0 || url.search(/^data\:image\/jpeg/) === 0;
                        texture.format = isJPEG ? RGBFormat : RGBAFormat;
                        texture.needsUpdate = true;
                        if (onLoad !== undefined) {
                            onLoad(texture);
                        }
                    }, onProgress, onError);
                    return texture;
                }
            });
            Object.assign(Curve.prototype, {
                // Virtual base class method to overwrite and implement in subclasses
                //	- t [0 .. 1]
                getPoint: function ( /* t, optionalTarget */) {
                    console.warn('THREE.Curve: .getPoint() not implemented.');
                    return null;
                },
                // Get point at relative position in curve according to arc length
                // - u [0 .. 1]
                getPointAt: function (u, optionalTarget) {
                    var t = this.getUtoTmapping(u);
                    return this.getPoint(t, optionalTarget);
                },
                // Get sequence of points using getPoint( t )
                getPoints: function (divisions) {
                    if (divisions === undefined)
                        divisions = 5;
                    var points = [];
                    for (var d = 0; d <= divisions; d++) {
                        points.push(this.getPoint(d / divisions));
                    }
                    return points;
                },
                // Get sequence of points using getPointAt( u )
                getSpacedPoints: function (divisions) {
                    if (divisions === undefined)
                        divisions = 5;
                    var points = [];
                    for (var d = 0; d <= divisions; d++) {
                        points.push(this.getPointAt(d / divisions));
                    }
                    return points;
                },
                // Get total curve arc length
                getLength: function () {
                    var lengths = this.getLengths();
                    return lengths[lengths.length - 1];
                },
                // Get list of cumulative segment lengths
                getLengths: function (divisions) {
                    if (divisions === undefined)
                        divisions = this.arcLengthDivisions;
                    if (this.cacheArcLengths &&
                        (this.cacheArcLengths.length === divisions + 1) &&
                        !this.needsUpdate) {
                        return this.cacheArcLengths;
                    }
                    this.needsUpdate = false;
                    var cache = [];
                    var current, last = this.getPoint(0);
                    var p, sum = 0;
                    cache.push(0);
                    for (p = 1; p <= divisions; p++) {
                        current = this.getPoint(p / divisions);
                        sum += current.distanceTo(last);
                        cache.push(sum);
                        last = current;
                    }
                    this.cacheArcLengths = cache;
                    return cache; // { sums: cache, sum: sum }; Sum is in the last element.
                },
                updateArcLengths: function () {
                    this.needsUpdate = true;
                    this.getLengths();
                },
                // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
                getUtoTmapping: function (u, distance) {
                    var arcLengths = this.getLengths();
                    var i = 0, il = arcLengths.length;
                    var targetArcLength; // The targeted u distance value to get
                    if (distance) {
                        targetArcLength = distance;
                    }
                    else {
                        targetArcLength = u * arcLengths[il - 1];
                    }
                    // binary search for the index with largest value smaller than target u distance
                    var low = 0, high = il - 1, comparison;
                    while (low <= high) {
                        i = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats
                        comparison = arcLengths[i] - targetArcLength;
                        if (comparison < 0) {
                            low = i + 1;
                        }
                        else if (comparison > 0) {
                            high = i - 1;
                        }
                        else {
                            high = i;
                            break;
                            // DONE
                        }
                    }
                    i = high;
                    if (arcLengths[i] === targetArcLength) {
                        return i / (il - 1);
                    }
                    // we could get finer grain at lengths, or use simple interpolation between two points
                    var lengthBefore = arcLengths[i];
                    var lengthAfter = arcLengths[i + 1];
                    var segmentLength = lengthAfter - lengthBefore;
                    // determine where we are between the 'before' and 'after' points
                    var segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
                    // add that fractional amount to t
                    var t = (i + segmentFraction) / (il - 1);
                    return t;
                },
                // Returns a unit vector tangent at t
                // In case any sub curve does not implement its tangent derivation,
                // 2 points a small delta apart will be used to find its gradient
                // which seems to give a reasonable approximation
                getTangent: function (t) {
                    var delta = 0.0001;
                    var t1 = t - delta;
                    var t2 = t + delta;
                    // Capping in case of danger
                    if (t1 < 0)
                        t1 = 0;
                    if (t2 > 1)
                        t2 = 1;
                    var pt1 = this.getPoint(t1);
                    var pt2 = this.getPoint(t2);
                    var vec = pt2.clone().sub(pt1);
                    return vec.normalize();
                },
                getTangentAt: function (u) {
                    var t = this.getUtoTmapping(u);
                    return this.getTangent(t);
                },
                computeFrenetFrames: function (segments, closed) {
                    // see http://www.cs.indiana.edu/pub/techreports/TR425.pdf
                    var normal = new Vector3();
                    var tangents = [];
                    var normals = [];
                    var binormals = [];
                    var vec = new Vector3();
                    var mat = new Matrix4();
                    var i, u, theta;
                    // compute the tangent vectors for each segment on the curve
                    for (i = 0; i <= segments; i++) {
                        u = i / segments;
                        tangents[i] = this.getTangentAt(u);
                        tangents[i].normalize();
                    }
                    // select an initial normal vector perpendicular to the first tangent vector,
                    // and in the direction of the minimum tangent xyz component
                    normals[0] = new Vector3();
                    binormals[0] = new Vector3();
                    var min = Number.MAX_VALUE;
                    var tx = Math.abs(tangents[0].x);
                    var ty = Math.abs(tangents[0].y);
                    var tz = Math.abs(tangents[0].z);
                    if (tx <= min) {
                        min = tx;
                        normal.set(1, 0, 0);
                    }
                    if (ty <= min) {
                        min = ty;
                        normal.set(0, 1, 0);
                    }
                    if (tz <= min) {
                        normal.set(0, 0, 1);
                    }
                    vec.crossVectors(tangents[0], normal).normalize();
                    normals[0].crossVectors(tangents[0], vec);
                    binormals[0].crossVectors(tangents[0], normals[0]);
                    // compute the slowly-varying normal and binormal vectors for each segment on the curve
                    for (i = 1; i <= segments; i++) {
                        normals[i] = normals[i - 1].clone();
                        binormals[i] = binormals[i - 1].clone();
                        vec.crossVectors(tangents[i - 1], tangents[i]);
                        if (vec.length() > Number.EPSILON) {
                            vec.normalize();
                            theta = Math.acos(MathUtils.clamp(tangents[i - 1].dot(tangents[i]), -1, 1)); // clamp for floating pt errors
                            normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
                        }
                        binormals[i].crossVectors(tangents[i], normals[i]);
                    }
                    // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same
                    if (closed === true) {
                        theta = Math.acos(MathUtils.clamp(normals[0].dot(normals[segments]), -1, 1));
                        theta /= segments;
                        if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
                            theta = -theta;
                        }
                        for (i = 1; i <= segments; i++) {
                            // twist a little...
                            normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
                            binormals[i].crossVectors(tangents[i], normals[i]);
                        }
                    }
                    return {
                        tangents: tangents,
                        normals: normals,
                        binormals: binormals
                    };
                },
                clone: function () {
                    return new this.constructor().copy(this);
                },
                copy: function (source) {
                    this.arcLengthDivisions = source.arcLengthDivisions;
                    return this;
                },
                toJSON: function () {
                    var data = {
                        metadata: {
                            version: 4.5,
                            type: 'Curve',
                            generator: 'Curve.toJSON'
                        }
                    };
                    data.arcLengthDivisions = this.arcLengthDivisions;
                    data.type = this.type;
                    return data;
                },
                fromJSON: function (json) {
                    this.arcLengthDivisions = json.arcLengthDivisions;
                    return this;
                }
            });
            EllipseCurve.prototype = Object.create(Curve.prototype);
            EllipseCurve.prototype.constructor = EllipseCurve;
            EllipseCurve.prototype.isEllipseCurve = true;
            EllipseCurve.prototype.getPoint = function (t, optionalTarget) {
                var point = optionalTarget || new Vector2();
                var twoPi = Math.PI * 2;
                var deltaAngle = this.aEndAngle - this.aStartAngle;
                var samePoints = Math.abs(deltaAngle) < Number.EPSILON;
                // ensures that deltaAngle is 0 .. 2 PI
                while (deltaAngle < 0)
                    deltaAngle += twoPi;
                while (deltaAngle > twoPi)
                    deltaAngle -= twoPi;
                if (deltaAngle < Number.EPSILON) {
                    if (samePoints) {
                        deltaAngle = 0;
                    }
                    else {
                        deltaAngle = twoPi;
                    }
                }
                if (this.aClockwise === true && !samePoints) {
                    if (deltaAngle === twoPi) {
                        deltaAngle = -twoPi;
                    }
                    else {
                        deltaAngle = deltaAngle - twoPi;
                    }
                }
                var angle = this.aStartAngle + t * deltaAngle;
                var x = this.aX + this.xRadius * Math.cos(angle);
                var y = this.aY + this.yRadius * Math.sin(angle);
                if (this.aRotation !== 0) {
                    var cos = Math.cos(this.aRotation);
                    var sin = Math.sin(this.aRotation);
                    var tx = x - this.aX;
                    var ty = y - this.aY;
                    // Rotate the point about the center of the ellipse.
                    x = tx * cos - ty * sin + this.aX;
                    y = tx * sin + ty * cos + this.aY;
                }
                return point.set(x, y);
            };
            EllipseCurve.prototype.copy = function (source) {
                Curve.prototype.copy.call(this, source);
                this.aX = source.aX;
                this.aY = source.aY;
                this.xRadius = source.xRadius;
                this.yRadius = source.yRadius;
                this.aStartAngle = source.aStartAngle;
                this.aEndAngle = source.aEndAngle;
                this.aClockwise = source.aClockwise;
                this.aRotation = source.aRotation;
                return this;
            };
            EllipseCurve.prototype.toJSON = function () {
                var data = Curve.prototype.toJSON.call(this);
                data.aX = this.aX;
                data.aY = this.aY;
                data.xRadius = this.xRadius;
                data.yRadius = this.yRadius;
                data.aStartAngle = this.aStartAngle;
                data.aEndAngle = this.aEndAngle;
                data.aClockwise = this.aClockwise;
                data.aRotation = this.aRotation;
                return data;
            };
            EllipseCurve.prototype.fromJSON = function (json) {
                Curve.prototype.fromJSON.call(this, json);
                this.aX = json.aX;
                this.aY = json.aY;
                this.xRadius = json.xRadius;
                this.yRadius = json.yRadius;
                this.aStartAngle = json.aStartAngle;
                this.aEndAngle = json.aEndAngle;
                this.aClockwise = json.aClockwise;
                this.aRotation = json.aRotation;
                return this;
            };
            ArcCurve.prototype = Object.create(EllipseCurve.prototype);
            ArcCurve.prototype.constructor = ArcCurve;
            ArcCurve.prototype.isArcCurve = true;
            //
            tmp = new Vector3();
            px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();
            CatmullRomCurve3.prototype = Object.create(Curve.prototype);
            CatmullRomCurve3.prototype.constructor = CatmullRomCurve3;
            CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;
            CatmullRomCurve3.prototype.getPoint = function (t, optionalTarget) {
                var point = optionalTarget || new Vector3();
                var points = this.points;
                var l = points.length;
                var p = (l - (this.closed ? 0 : 1)) * t;
                var intPoint = Math.floor(p);
                var weight = p - intPoint;
                if (this.closed) {
                    intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
                }
                else if (weight === 0 && intPoint === l - 1) {
                    intPoint = l - 2;
                    weight = 1;
                }
                var p0, p1, p2, p3; // 4 points
                if (this.closed || intPoint > 0) {
                    p0 = points[(intPoint - 1) % l];
                }
                else {
                    // extrapolate first point
                    tmp.subVectors(points[0], points[1]).add(points[0]);
                    p0 = tmp;
                }
                p1 = points[intPoint % l];
                p2 = points[(intPoint + 1) % l];
                if (this.closed || intPoint + 2 < l) {
                    p3 = points[(intPoint + 2) % l];
                }
                else {
                    // extrapolate last point
                    tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
                    p3 = tmp;
                }
                if (this.curveType === 'centripetal' || this.curveType === 'chordal') {
                    // init Centripetal / Chordal Catmull-Rom
                    var pow = this.curveType === 'chordal' ? 0.5 : 0.25;
                    var dt0 = Math.pow(p0.distanceToSquared(p1), pow);
                    var dt1 = Math.pow(p1.distanceToSquared(p2), pow);
                    var dt2 = Math.pow(p2.distanceToSquared(p3), pow);
                    // safety check for repeated points
                    if (dt1 < 1e-4)
                        dt1 = 1.0;
                    if (dt0 < 1e-4)
                        dt0 = dt1;
                    if (dt2 < 1e-4)
                        dt2 = dt1;
                    px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
                    py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
                    pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
                }
                else if (this.curveType === 'catmullrom') {
                    px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
                    py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
                    pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);
                }
                point.set(px.calc(weight), py.calc(weight), pz.calc(weight));
                return point;
            };
            CatmullRomCurve3.prototype.copy = function (source) {
                Curve.prototype.copy.call(this, source);
                this.points = [];
                for (var i = 0, l = source.points.length; i < l; i++) {
                    var point = source.points[i];
                    this.points.push(point.clone());
                }
                this.closed = source.closed;
                this.curveType = source.curveType;
                this.tension = source.tension;
                return this;
            };
            CatmullRomCurve3.prototype.toJSON = function () {
                var data = Curve.prototype.toJSON.call(this);
                data.points = [];
                for (var i = 0, l = this.points.length; i < l; i++) {
                    var point = this.points[i];
                    data.points.push(point.toArray());
                }
                data.closed = this.closed;
                data.curveType = this.curveType;
                data.tension = this.tension;
                return data;
            };
            CatmullRomCurve3.prototype.fromJSON = function (json) {
                Curve.prototype.fromJSON.call(this, json);
                this.points = [];
                for (var i = 0, l = json.points.length; i < l; i++) {
                    var point = json.points[i];
                    this.points.push(new Vector3().fromArray(point));
                }
                this.closed = json.closed;
                this.curveType = json.curveType;
                this.tension = json.tension;
                return this;
            };
            CubicBezierCurve.prototype = Object.create(Curve.prototype);
            CubicBezierCurve.prototype.constructor = CubicBezierCurve;
            CubicBezierCurve.prototype.isCubicBezierCurve = true;
            CubicBezierCurve.prototype.getPoint = function (t, optionalTarget) {
                var point = optionalTarget || new Vector2();
                var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
                point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y));
                return point;
            };
            CubicBezierCurve.prototype.copy = function (source) {
                Curve.prototype.copy.call(this, source);
                this.v0.copy(source.v0);
                this.v1.copy(source.v1);
                this.v2.copy(source.v2);
                this.v3.copy(source.v3);
                return this;
            };
            CubicBezierCurve.prototype.toJSON = function () {
                var data = Curve.prototype.toJSON.call(this);
                data.v0 = this.v0.toArray();
                data.v1 = this.v1.toArray();
                data.v2 = this.v2.toArray();
                data.v3 = this.v3.toArray();
                return data;
            };
            CubicBezierCurve.prototype.fromJSON = function (json) {
                Curve.prototype.fromJSON.call(this, json);
                this.v0.fromArray(json.v0);
                this.v1.fromArray(json.v1);
                this.v2.fromArray(json.v2);
                this.v3.fromArray(json.v3);
                return this;
            };
            CubicBezierCurve3.prototype = Object.create(Curve.prototype);
            CubicBezierCurve3.prototype.constructor = CubicBezierCurve3;
            CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;
            CubicBezierCurve3.prototype.getPoint = function (t, optionalTarget) {
                var point = optionalTarget || new Vector3();
                var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
                point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y), CubicBezier(t, v0.z, v1.z, v2.z, v3.z));
                return point;
            };
            CubicBezierCurve3.prototype.copy = function (source) {
                Curve.prototype.copy.call(this, source);
                this.v0.copy(source.v0);
                this.v1.copy(source.v1);
                this.v2.copy(source.v2);
                this.v3.copy(source.v3);
                return this;
            };
            CubicBezierCurve3.prototype.toJSON = function () {
                var data = Curve.prototype.toJSON.call(this);
                data.v0 = this.v0.toArray();
                data.v1 = this.v1.toArray();
                data.v2 = this.v2.toArray();
                data.v3 = this.v3.toArray();
                return data;
            };
            CubicBezierCurve3.prototype.fromJSON = function (json) {
                Curve.prototype.fromJSON.call(this, json);
                this.v0.fromArray(json.v0);
                this.v1.fromArray(json.v1);
                this.v2.fromArray(json.v2);
                this.v3.fromArray(json.v3);
                return this;
            };
            LineCurve.prototype = Object.create(Curve.prototype);
            LineCurve.prototype.constructor = LineCurve;
            LineCurve.prototype.isLineCurve = true;
            LineCurve.prototype.getPoint = function (t, optionalTarget) {
                var point = optionalTarget || new Vector2();
                if (t === 1) {
                    point.copy(this.v2);
                }
                else {
                    point.copy(this.v2).sub(this.v1);
                    point.multiplyScalar(t).add(this.v1);
                }
                return point;
            };
            // Line curve is linear, so we can overwrite default getPointAt
            LineCurve.prototype.getPointAt = function (u, optionalTarget) {
                return this.getPoint(u, optionalTarget);
            };
            LineCurve.prototype.getTangent = function ( /* t */) {
                var tangent = this.v2.clone().sub(this.v1);
                return tangent.normalize();
            };
            LineCurve.prototype.copy = function (source) {
                Curve.prototype.copy.call(this, source);
                this.v1.copy(source.v1);
                this.v2.copy(source.v2);
                return this;
            };
            LineCurve.prototype.toJSON = function () {
                var data = Curve.prototype.toJSON.call(this);
                data.v1 = this.v1.toArray();
                data.v2 = this.v2.toArray();
                return data;
            };
            LineCurve.prototype.fromJSON = function (json) {
                Curve.prototype.fromJSON.call(this, json);
                this.v1.fromArray(json.v1);
                this.v2.fromArray(json.v2);
                return this;
            };
            LineCurve3.prototype = Object.create(Curve.prototype);
            LineCurve3.prototype.constructor = LineCurve3;
            LineCurve3.prototype.isLineCurve3 = true;
            LineCurve3.prototype.getPoint = function (t, optionalTarget) {
                var point = optionalTarget || new Vector3();
                if (t === 1) {
                    point.copy(this.v2);
                }
                else {
                    point.copy(this.v2).sub(this.v1);
                    point.multiplyScalar(t).add(this.v1);
                }
                return point;
            };
            // Line curve is linear, so we can overwrite default getPointAt
            LineCurve3.prototype.getPointAt = function (u, optionalTarget) {
                return this.getPoint(u, optionalTarget);
            };
            LineCurve3.prototype.copy = function (source) {
                Curve.prototype.copy.call(this, source);
                this.v1.copy(source.v1);
                this.v2.copy(source.v2);
                return this;
            };
            LineCurve3.prototype.toJSON = function () {
                var data = Curve.prototype.toJSON.call(this);
                data.v1 = this.v1.toArray();
                data.v2 = this.v2.toArray();
                return data;
            };
            LineCurve3.prototype.fromJSON = function (json) {
                Curve.prototype.fromJSON.call(this, json);
                this.v1.fromArray(json.v1);
                this.v2.fromArray(json.v2);
                return this;
            };
            QuadraticBezierCurve.prototype = Object.create(Curve.prototype);
            QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;
            QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;
            QuadraticBezierCurve.prototype.getPoint = function (t, optionalTarget) {
                var point = optionalTarget || new Vector2();
                var v0 = this.v0, v1 = this.v1, v2 = this.v2;
                point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y));
                return point;
            };
            QuadraticBezierCurve.prototype.copy = function (source) {
                Curve.prototype.copy.call(this, source);
                this.v0.copy(source.v0);
                this.v1.copy(source.v1);
                this.v2.copy(source.v2);
                return this;
            };
            QuadraticBezierCurve.prototype.toJSON = function () {
                var data = Curve.prototype.toJSON.call(this);
                data.v0 = this.v0.toArray();
                data.v1 = this.v1.toArray();
                data.v2 = this.v2.toArray();
                return data;
            };
            QuadraticBezierCurve.prototype.fromJSON = function (json) {
                Curve.prototype.fromJSON.call(this, json);
                this.v0.fromArray(json.v0);
                this.v1.fromArray(json.v1);
                this.v2.fromArray(json.v2);
                return this;
            };
            QuadraticBezierCurve3.prototype = Object.create(Curve.prototype);
            QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;
            QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;
            QuadraticBezierCurve3.prototype.getPoint = function (t, optionalTarget) {
                var point = optionalTarget || new Vector3();
                var v0 = this.v0, v1 = this.v1, v2 = this.v2;
                point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y), QuadraticBezier(t, v0.z, v1.z, v2.z));
                return point;
            };
            QuadraticBezierCurve3.prototype.copy = function (source) {
                Curve.prototype.copy.call(this, source);
                this.v0.copy(source.v0);
                this.v1.copy(source.v1);
                this.v2.copy(source.v2);
                return this;
            };
            QuadraticBezierCurve3.prototype.toJSON = function () {
                var data = Curve.prototype.toJSON.call(this);
                data.v0 = this.v0.toArray();
                data.v1 = this.v1.toArray();
                data.v2 = this.v2.toArray();
                return data;
            };
            QuadraticBezierCurve3.prototype.fromJSON = function (json) {
                Curve.prototype.fromJSON.call(this, json);
                this.v0.fromArray(json.v0);
                this.v1.fromArray(json.v1);
                this.v2.fromArray(json.v2);
                return this;
            };
            SplineCurve.prototype = Object.create(Curve.prototype);
            SplineCurve.prototype.constructor = SplineCurve;
            SplineCurve.prototype.isSplineCurve = true;
            SplineCurve.prototype.getPoint = function (t, optionalTarget) {
                var point = optionalTarget || new Vector2();
                var points = this.points;
                var p = (points.length - 1) * t;
                var intPoint = Math.floor(p);
                var weight = p - intPoint;
                var p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
                var p1 = points[intPoint];
                var p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
                var p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
                point.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));
                return point;
            };
            SplineCurve.prototype.copy = function (source) {
                Curve.prototype.copy.call(this, source);
                this.points = [];
                for (var i = 0, l = source.points.length; i < l; i++) {
                    var point = source.points[i];
                    this.points.push(point.clone());
                }
                return this;
            };
            SplineCurve.prototype.toJSON = function () {
                var data = Curve.prototype.toJSON.call(this);
                data.points = [];
                for (var i = 0, l = this.points.length; i < l; i++) {
                    var point = this.points[i];
                    data.points.push(point.toArray());
                }
                return data;
            };
            SplineCurve.prototype.fromJSON = function (json) {
                Curve.prototype.fromJSON.call(this, json);
                this.points = [];
                for (var i = 0, l = json.points.length; i < l; i++) {
                    var point = json.points[i];
                    this.points.push(new Vector2().fromArray(point));
                }
                return this;
            };
            Curves = Object.freeze({
                __proto__: null,
                ArcCurve: ArcCurve,
                CatmullRomCurve3: CatmullRomCurve3,
                CubicBezierCurve: CubicBezierCurve,
                CubicBezierCurve3: CubicBezierCurve3,
                EllipseCurve: EllipseCurve,
                LineCurve: LineCurve,
                LineCurve3: LineCurve3,
                QuadraticBezierCurve: QuadraticBezierCurve,
                QuadraticBezierCurve3: QuadraticBezierCurve3,
                SplineCurve: SplineCurve
            });
            CurvePath.prototype = Object.assign(Object.create(Curve.prototype), {
                constructor: CurvePath,
                add: function (curve) {
                    this.curves.push(curve);
                },
                closePath: function () {
                    // Add a line curve if start and end of lines are not connected
                    var startPoint = this.curves[0].getPoint(0);
                    var endPoint = this.curves[this.curves.length - 1].getPoint(1);
                    if (!startPoint.equals(endPoint)) {
                        this.curves.push(new LineCurve(endPoint, startPoint));
                    }
                },
                // To get accurate point with reference to
                // entire path distance at time t,
                // following has to be done:
                // 1. Length of each sub path have to be known
                // 2. Locate and identify type of curve
                // 3. Get t for the curve
                // 4. Return curve.getPointAt(t')
                getPoint: function (t) {
                    var d = t * this.getLength();
                    var curveLengths = this.getCurveLengths();
                    var i = 0;
                    // To think about boundaries points.
                    while (i < curveLengths.length) {
                        if (curveLengths[i] >= d) {
                            var diff = curveLengths[i] - d;
                            var curve = this.curves[i];
                            var segmentLength = curve.getLength();
                            var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
                            return curve.getPointAt(u);
                        }
                        i++;
                    }
                    return null;
                    // loop where sum != 0, sum > d , sum+1 <d
                },
                // We cannot use the default THREE.Curve getPoint() with getLength() because in
                // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
                // getPoint() depends on getLength
                getLength: function () {
                    var lens = this.getCurveLengths();
                    return lens[lens.length - 1];
                },
                // cacheLengths must be recalculated.
                updateArcLengths: function () {
                    this.needsUpdate = true;
                    this.cacheLengths = null;
                    this.getCurveLengths();
                },
                // Compute lengths and cache them
                // We cannot overwrite getLengths() because UtoT mapping uses it.
                getCurveLengths: function () {
                    // We use cache values if curves and cache array are same length
                    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
                        return this.cacheLengths;
                    }
                    // Get length of sub-curve
                    // Push sums into cached array
                    var lengths = [], sums = 0;
                    for (var i = 0, l = this.curves.length; i < l; i++) {
                        sums += this.curves[i].getLength();
                        lengths.push(sums);
                    }
                    this.cacheLengths = lengths;
                    return lengths;
                },
                getSpacedPoints: function (divisions) {
                    if (divisions === undefined)
                        divisions = 40;
                    var points = [];
                    for (var i = 0; i <= divisions; i++) {
                        points.push(this.getPoint(i / divisions));
                    }
                    if (this.autoClose) {
                        points.push(points[0]);
                    }
                    return points;
                },
                getPoints: function (divisions) {
                    divisions = divisions || 12;
                    var points = [], last;
                    for (var i = 0, curves = this.curves; i < curves.length; i++) {
                        var curve = curves[i];
                        var resolution = (curve && curve.isEllipseCurve) ? divisions * 2
                            : (curve && (curve.isLineCurve || curve.isLineCurve3)) ? 1
                                : (curve && curve.isSplineCurve) ? divisions * curve.points.length
                                    : divisions;
                        var pts = curve.getPoints(resolution);
                        for (var j = 0; j < pts.length; j++) {
                            var point = pts[j];
                            if (last && last.equals(point))
                                continue; // ensures no consecutive points are duplicates
                            points.push(point);
                            last = point;
                        }
                    }
                    if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
                        points.push(points[0]);
                    }
                    return points;
                },
                copy: function (source) {
                    Curve.prototype.copy.call(this, source);
                    this.curves = [];
                    for (var i = 0, l = source.curves.length; i < l; i++) {
                        var curve = source.curves[i];
                        this.curves.push(curve.clone());
                    }
                    this.autoClose = source.autoClose;
                    return this;
                },
                toJSON: function () {
                    var data = Curve.prototype.toJSON.call(this);
                    data.autoClose = this.autoClose;
                    data.curves = [];
                    for (var i = 0, l = this.curves.length; i < l; i++) {
                        var curve = this.curves[i];
                        data.curves.push(curve.toJSON());
                    }
                    return data;
                },
                fromJSON: function (json) {
                    Curve.prototype.fromJSON.call(this, json);
                    this.autoClose = json.autoClose;
                    this.curves = [];
                    for (var i = 0, l = json.curves.length; i < l; i++) {
                        var curve = json.curves[i];
                        this.curves.push(new Curves[curve.type]().fromJSON(curve));
                    }
                    return this;
                }
            });
            Path.prototype = Object.assign(Object.create(CurvePath.prototype), {
                constructor: Path,
                setFromPoints: function (points) {
                    this.moveTo(points[0].x, points[0].y);
                    for (var i = 1, l = points.length; i < l; i++) {
                        this.lineTo(points[i].x, points[i].y);
                    }
                    return this;
                },
                moveTo: function (x, y) {
                    this.currentPoint.set(x, y); // TODO consider referencing vectors instead of copying?
                    return this;
                },
                lineTo: function (x, y) {
                    var curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
                    this.curves.push(curve);
                    this.currentPoint.set(x, y);
                    return this;
                },
                quadraticCurveTo: function (aCPx, aCPy, aX, aY) {
                    var curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
                    this.curves.push(curve);
                    this.currentPoint.set(aX, aY);
                    return this;
                },
                bezierCurveTo: function (aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
                    var curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
                    this.curves.push(curve);
                    this.currentPoint.set(aX, aY);
                    return this;
                },
                splineThru: function (pts /*Array of Vector*/) {
                    var npts = [this.currentPoint.clone()].concat(pts);
                    var curve = new SplineCurve(npts);
                    this.curves.push(curve);
                    this.currentPoint.copy(pts[pts.length - 1]);
                    return this;
                },
                arc: function (aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
                    var x0 = this.currentPoint.x;
                    var y0 = this.currentPoint.y;
                    this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
                    return this;
                },
                absarc: function (aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
                    this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
                    return this;
                },
                ellipse: function (aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
                    var x0 = this.currentPoint.x;
                    var y0 = this.currentPoint.y;
                    this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
                    return this;
                },
                absellipse: function (aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
                    var curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
                    if (this.curves.length > 0) {
                        // if a previous curve is present, attempt to join
                        var firstPoint = curve.getPoint(0);
                        if (!firstPoint.equals(this.currentPoint)) {
                            this.lineTo(firstPoint.x, firstPoint.y);
                        }
                    }
                    this.curves.push(curve);
                    var lastPoint = curve.getPoint(1);
                    this.currentPoint.copy(lastPoint);
                    return this;
                },
                copy: function (source) {
                    CurvePath.prototype.copy.call(this, source);
                    this.currentPoint.copy(source.currentPoint);
                    return this;
                },
                toJSON: function () {
                    var data = CurvePath.prototype.toJSON.call(this);
                    data.currentPoint = this.currentPoint.toArray();
                    return data;
                },
                fromJSON: function (json) {
                    CurvePath.prototype.fromJSON.call(this, json);
                    this.currentPoint.fromArray(json.currentPoint);
                    return this;
                }
            });
            Shape.prototype = Object.assign(Object.create(Path.prototype), {
                constructor: Shape,
                getPointsHoles: function (divisions) {
                    var holesPts = [];
                    for (var i = 0, l = this.holes.length; i < l; i++) {
                        holesPts[i] = this.holes[i].getPoints(divisions);
                    }
                    return holesPts;
                },
                // get points of shape and holes (keypoints based on segments parameter)
                extractPoints: function (divisions) {
                    return {
                        shape: this.getPoints(divisions),
                        holes: this.getPointsHoles(divisions)
                    };
                },
                copy: function (source) {
                    Path.prototype.copy.call(this, source);
                    this.holes = [];
                    for (var i = 0, l = source.holes.length; i < l; i++) {
                        var hole = source.holes[i];
                        this.holes.push(hole.clone());
                    }
                    return this;
                },
                toJSON: function () {
                    var data = Path.prototype.toJSON.call(this);
                    data.uuid = this.uuid;
                    data.holes = [];
                    for (var i = 0, l = this.holes.length; i < l; i++) {
                        var hole = this.holes[i];
                        data.holes.push(hole.toJSON());
                    }
                    return data;
                },
                fromJSON: function (json) {
                    Path.prototype.fromJSON.call(this, json);
                    this.uuid = json.uuid;
                    this.holes = [];
                    for (var i = 0, l = json.holes.length; i < l; i++) {
                        var hole = json.holes[i];
                        this.holes.push(new Path().fromJSON(hole));
                    }
                    return this;
                }
            });
            Light.prototype = Object.assign(Object.create(Object3D.prototype), {
                constructor: Light,
                isLight: true,
                copy: function (source) {
                    Object3D.prototype.copy.call(this, source);
                    this.color.copy(source.color);
                    this.intensity = source.intensity;
                    return this;
                },
                toJSON: function (meta) {
                    var data = Object3D.prototype.toJSON.call(this, meta);
                    data.object.color = this.color.getHex();
                    data.object.intensity = this.intensity;
                    if (this.groundColor !== undefined)
                        data.object.groundColor = this.groundColor.getHex();
                    if (this.distance !== undefined)
                        data.object.distance = this.distance;
                    if (this.angle !== undefined)
                        data.object.angle = this.angle;
                    if (this.decay !== undefined)
                        data.object.decay = this.decay;
                    if (this.penumbra !== undefined)
                        data.object.penumbra = this.penumbra;
                    if (this.shadow !== undefined)
                        data.object.shadow = this.shadow.toJSON();
                    return data;
                }
            });
            HemisphereLight.prototype = Object.assign(Object.create(Light.prototype), {
                constructor: HemisphereLight,
                isHemisphereLight: true,
                copy: function (source) {
                    Light.prototype.copy.call(this, source);
                    this.groundColor.copy(source.groundColor);
                    return this;
                }
            });
            Object.assign(LightShadow.prototype, {
                _projScreenMatrix: new Matrix4(),
                _lightPositionWorld: new Vector3(),
                _lookTarget: new Vector3(),
                getViewportCount: function () {
                    return this._viewportCount;
                },
                getFrustum: function () {
                    return this._frustum;
                },
                updateMatrices: function (light) {
                    var shadowCamera = this.camera, shadowMatrix = this.matrix, projScreenMatrix = this._projScreenMatrix, lookTarget = this._lookTarget, lightPositionWorld = this._lightPositionWorld;
                    lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
                    shadowCamera.position.copy(lightPositionWorld);
                    lookTarget.setFromMatrixPosition(light.target.matrixWorld);
                    shadowCamera.lookAt(lookTarget);
                    shadowCamera.updateMatrixWorld();
                    projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
                    this._frustum.setFromProjectionMatrix(projScreenMatrix);
                    shadowMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
                    shadowMatrix.multiply(shadowCamera.projectionMatrix);
                    shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
                },
                getViewport: function (viewportIndex) {
                    return this._viewports[viewportIndex];
                },
                getFrameExtents: function () {
                    return this._frameExtents;
                },
                copy: function (source) {
                    this.camera = source.camera.clone();
                    this.bias = source.bias;
                    this.radius = source.radius;
                    this.mapSize.copy(source.mapSize);
                    return this;
                },
                clone: function () {
                    return new this.constructor().copy(this);
                },
                toJSON: function () {
                    var object = {};
                    if (this.bias !== 0)
                        object.bias = this.bias;
                    if (this.radius !== 1)
                        object.radius = this.radius;
                    if (this.mapSize.x !== 512 || this.mapSize.y !== 512)
                        object.mapSize = this.mapSize.toArray();
                    object.camera = this.camera.toJSON(false).object;
                    delete object.camera.matrix;
                    return object;
                }
            });
            SpotLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
                constructor: SpotLightShadow,
                isSpotLightShadow: true,
                updateMatrices: function (light) {
                    var camera = this.camera;
                    var fov = MathUtils.RAD2DEG * 2 * light.angle;
                    var aspect = this.mapSize.width / this.mapSize.height;
                    var far = light.distance || camera.far;
                    if (fov !== camera.fov || aspect !== camera.aspect || far !== camera.far) {
                        camera.fov = fov;
                        camera.aspect = aspect;
                        camera.far = far;
                        camera.updateProjectionMatrix();
                    }
                    LightShadow.prototype.updateMatrices.call(this, light);
                }
            });
            SpotLight.prototype = Object.assign(Object.create(Light.prototype), {
                constructor: SpotLight,
                isSpotLight: true,
                copy: function (source) {
                    Light.prototype.copy.call(this, source);
                    this.distance = source.distance;
                    this.angle = source.angle;
                    this.penumbra = source.penumbra;
                    this.decay = source.decay;
                    this.target = source.target.clone();
                    this.shadow = source.shadow.clone();
                    return this;
                }
            });
            PointLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
                constructor: PointLightShadow,
                isPointLightShadow: true,
                updateMatrices: function (light, viewportIndex) {
                    if (viewportIndex === undefined)
                        viewportIndex = 0;
                    var camera = this.camera, shadowMatrix = this.matrix, lightPositionWorld = this._lightPositionWorld, lookTarget = this._lookTarget, projScreenMatrix = this._projScreenMatrix;
                    lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
                    camera.position.copy(lightPositionWorld);
                    lookTarget.copy(camera.position);
                    lookTarget.add(this._cubeDirections[viewportIndex]);
                    camera.up.copy(this._cubeUps[viewportIndex]);
                    camera.lookAt(lookTarget);
                    camera.updateMatrixWorld();
                    shadowMatrix.makeTranslation(-lightPositionWorld.x, -lightPositionWorld.y, -lightPositionWorld.z);
                    projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
                    this._frustum.setFromProjectionMatrix(projScreenMatrix);
                }
            });
            PointLight.prototype = Object.assign(Object.create(Light.prototype), {
                constructor: PointLight,
                isPointLight: true,
                copy: function (source) {
                    Light.prototype.copy.call(this, source);
                    this.distance = source.distance;
                    this.decay = source.decay;
                    this.shadow = source.shadow.clone();
                    return this;
                }
            });
            OrthographicCamera.prototype = Object.assign(Object.create(Camera.prototype), {
                constructor: OrthographicCamera,
                isOrthographicCamera: true,
                copy: function (source, recursive) {
                    Camera.prototype.copy.call(this, source, recursive);
                    this.left = source.left;
                    this.right = source.right;
                    this.top = source.top;
                    this.bottom = source.bottom;
                    this.near = source.near;
                    this.far = source.far;
                    this.zoom = source.zoom;
                    this.view = source.view === null ? null : Object.assign({}, source.view);
                    return this;
                },
                setViewOffset: function (fullWidth, fullHeight, x, y, width, height) {
                    if (this.view === null) {
                        this.view = {
                            enabled: true,
                            fullWidth: 1,
                            fullHeight: 1,
                            offsetX: 0,
                            offsetY: 0,
                            width: 1,
                            height: 1
                        };
                    }
                    this.view.enabled = true;
                    this.view.fullWidth = fullWidth;
                    this.view.fullHeight = fullHeight;
                    this.view.offsetX = x;
                    this.view.offsetY = y;
                    this.view.width = width;
                    this.view.height = height;
                    this.updateProjectionMatrix();
                },
                clearViewOffset: function () {
                    if (this.view !== null) {
                        this.view.enabled = false;
                    }
                    this.updateProjectionMatrix();
                },
                updateProjectionMatrix: function () {
                    var dx = (this.right - this.left) / (2 * this.zoom);
                    var dy = (this.top - this.bottom) / (2 * this.zoom);
                    var cx = (this.right + this.left) / 2;
                    var cy = (this.top + this.bottom) / 2;
                    var left = cx - dx;
                    var right = cx + dx;
                    var top = cy + dy;
                    var bottom = cy - dy;
                    if (this.view !== null && this.view.enabled) {
                        var scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
                        var scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                        left += scaleW * this.view.offsetX;
                        right = left + scaleW * this.view.width;
                        top -= scaleH * this.view.offsetY;
                        bottom = top - scaleH * this.view.height;
                    }
                    this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
                    this.projectionMatrixInverse.getInverse(this.projectionMatrix);
                },
                toJSON: function (meta) {
                    var data = Object3D.prototype.toJSON.call(this, meta);
                    data.object.zoom = this.zoom;
                    data.object.left = this.left;
                    data.object.right = this.right;
                    data.object.top = this.top;
                    data.object.bottom = this.bottom;
                    data.object.near = this.near;
                    data.object.far = this.far;
                    if (this.view !== null)
                        data.object.view = Object.assign({}, this.view);
                    return data;
                }
            });
            DirectionalLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
                constructor: DirectionalLightShadow,
                isDirectionalLightShadow: true,
                updateMatrices: function (light) {
                    LightShadow.prototype.updateMatrices.call(this, light);
                }
            });
            DirectionalLight.prototype = Object.assign(Object.create(Light.prototype), {
                constructor: DirectionalLight,
                isDirectionalLight: true,
                copy: function (source) {
                    Light.prototype.copy.call(this, source);
                    this.target = source.target.clone();
                    this.shadow = source.shadow.clone();
                    return this;
                }
            });
            AmbientLight.prototype = Object.assign(Object.create(Light.prototype), {
                constructor: AmbientLight,
                isAmbientLight: true
            });
            RectAreaLight.prototype = Object.assign(Object.create(Light.prototype), {
                constructor: RectAreaLight,
                isRectAreaLight: true,
                copy: function (source) {
                    Light.prototype.copy.call(this, source);
                    this.width = source.width;
                    this.height = source.height;
                    return this;
                },
                toJSON: function (meta) {
                    var data = Light.prototype.toJSON.call(this, meta);
                    data.object.width = this.width;
                    data.object.height = this.height;
                    return data;
                }
            });
            MaterialLoader.prototype = Object.assign(Object.create(Loader.prototype), {
                constructor: MaterialLoader,
                load: function (url, onLoad, onProgress, onError) {
                    var scope = this;
                    var loader = new FileLoader(scope.manager);
                    loader.setPath(scope.path);
                    loader.load(url, function (text) {
                        onLoad(scope.parse(JSON.parse(text)));
                    }, onProgress, onError);
                },
                parse: function (json) {
                    var textures = this.textures;
                    function getTexture(name) {
                        if (textures[name] === undefined) {
                            console.warn('THREE.MaterialLoader: Undefined texture', name);
                        }
                        return textures[name];
                    }
                    var material = new Materials[json.type]();
                    if (json.uuid !== undefined)
                        material.uuid = json.uuid;
                    if (json.name !== undefined)
                        material.name = json.name;
                    if (json.color !== undefined)
                        material.color.setHex(json.color);
                    if (json.roughness !== undefined)
                        material.roughness = json.roughness;
                    if (json.metalness !== undefined)
                        material.metalness = json.metalness;
                    if (json.sheen !== undefined)
                        material.sheen = new Color().setHex(json.sheen);
                    if (json.emissive !== undefined)
                        material.emissive.setHex(json.emissive);
                    if (json.specular !== undefined)
                        material.specular.setHex(json.specular);
                    if (json.shininess !== undefined)
                        material.shininess = json.shininess;
                    if (json.clearcoat !== undefined)
                        material.clearcoat = json.clearcoat;
                    if (json.clearcoatRoughness !== undefined)
                        material.clearcoatRoughness = json.clearcoatRoughness;
                    if (json.vertexColors !== undefined)
                        material.vertexColors = json.vertexColors;
                    if (json.fog !== undefined)
                        material.fog = json.fog;
                    if (json.flatShading !== undefined)
                        material.flatShading = json.flatShading;
                    if (json.blending !== undefined)
                        material.blending = json.blending;
                    if (json.combine !== undefined)
                        material.combine = json.combine;
                    if (json.side !== undefined)
                        material.side = json.side;
                    if (json.opacity !== undefined)
                        material.opacity = json.opacity;
                    if (json.transparent !== undefined)
                        material.transparent = json.transparent;
                    if (json.alphaTest !== undefined)
                        material.alphaTest = json.alphaTest;
                    if (json.depthTest !== undefined)
                        material.depthTest = json.depthTest;
                    if (json.depthWrite !== undefined)
                        material.depthWrite = json.depthWrite;
                    if (json.colorWrite !== undefined)
                        material.colorWrite = json.colorWrite;
                    if (json.stencilWrite !== undefined)
                        material.stencilWrite = json.stencilWrite;
                    if (json.stencilWriteMask !== undefined)
                        material.stencilWriteMask = json.stencilWriteMask;
                    if (json.stencilFunc !== undefined)
                        material.stencilFunc = json.stencilFunc;
                    if (json.stencilRef !== undefined)
                        material.stencilRef = json.stencilRef;
                    if (json.stencilFuncMask !== undefined)
                        material.stencilFuncMask = json.stencilFuncMask;
                    if (json.stencilFail !== undefined)
                        material.stencilFail = json.stencilFail;
                    if (json.stencilZFail !== undefined)
                        material.stencilZFail = json.stencilZFail;
                    if (json.stencilZPass !== undefined)
                        material.stencilZPass = json.stencilZPass;
                    if (json.wireframe !== undefined)
                        material.wireframe = json.wireframe;
                    if (json.wireframeLinewidth !== undefined)
                        material.wireframeLinewidth = json.wireframeLinewidth;
                    if (json.wireframeLinecap !== undefined)
                        material.wireframeLinecap = json.wireframeLinecap;
                    if (json.wireframeLinejoin !== undefined)
                        material.wireframeLinejoin = json.wireframeLinejoin;
                    if (json.rotation !== undefined)
                        material.rotation = json.rotation;
                    if (json.linewidth !== 1)
                        material.linewidth = json.linewidth;
                    if (json.dashSize !== undefined)
                        material.dashSize = json.dashSize;
                    if (json.gapSize !== undefined)
                        material.gapSize = json.gapSize;
                    if (json.scale !== undefined)
                        material.scale = json.scale;
                    if (json.polygonOffset !== undefined)
                        material.polygonOffset = json.polygonOffset;
                    if (json.polygonOffsetFactor !== undefined)
                        material.polygonOffsetFactor = json.polygonOffsetFactor;
                    if (json.polygonOffsetUnits !== undefined)
                        material.polygonOffsetUnits = json.polygonOffsetUnits;
                    if (json.skinning !== undefined)
                        material.skinning = json.skinning;
                    if (json.morphTargets !== undefined)
                        material.morphTargets = json.morphTargets;
                    if (json.morphNormals !== undefined)
                        material.morphNormals = json.morphNormals;
                    if (json.dithering !== undefined)
                        material.dithering = json.dithering;
                    if (json.visible !== undefined)
                        material.visible = json.visible;
                    if (json.toneMapped !== undefined)
                        material.toneMapped = json.toneMapped;
                    if (json.userData !== undefined)
                        material.userData = json.userData;
                    // Shader Material
                    if (json.uniforms !== undefined) {
                        for (var name in json.uniforms) {
                            var uniform = json.uniforms[name];
                            material.uniforms[name] = {};
                            switch (uniform.type) {
                                case 't':
                                    material.uniforms[name].value = getTexture(uniform.value);
                                    break;
                                case 'c':
                                    material.uniforms[name].value = new Color().setHex(uniform.value);
                                    break;
                                case 'v2':
                                    material.uniforms[name].value = new Vector2().fromArray(uniform.value);
                                    break;
                                case 'v3':
                                    material.uniforms[name].value = new Vector3().fromArray(uniform.value);
                                    break;
                                case 'v4':
                                    material.uniforms[name].value = new Vector4().fromArray(uniform.value);
                                    break;
                                case 'm3':
                                    material.uniforms[name].value = new Matrix3().fromArray(uniform.value);
                                case 'm4':
                                    material.uniforms[name].value = new Matrix4().fromArray(uniform.value);
                                    break;
                                default:
                                    material.uniforms[name].value = uniform.value;
                            }
                        }
                    }
                    if (json.defines !== undefined)
                        material.defines = json.defines;
                    if (json.vertexShader !== undefined)
                        material.vertexShader = json.vertexShader;
                    if (json.fragmentShader !== undefined)
                        material.fragmentShader = json.fragmentShader;
                    if (json.extensions !== undefined) {
                        for (var key in json.extensions) {
                            material.extensions[key] = json.extensions[key];
                        }
                    }
                    // Deprecated
                    if (json.shading !== undefined)
                        material.flatShading = json.shading === 1; // THREE.FlatShading
                    // for PointsMaterial
                    if (json.size !== undefined)
                        material.size = json.size;
                    if (json.sizeAttenuation !== undefined)
                        material.sizeAttenuation = json.sizeAttenuation;
                    // maps
                    if (json.map !== undefined)
                        material.map = getTexture(json.map);
                    if (json.matcap !== undefined)
                        material.matcap = getTexture(json.matcap);
                    if (json.alphaMap !== undefined) {
                        material.alphaMap = getTexture(json.alphaMap);
                        material.transparent = true;
                    }
                    if (json.bumpMap !== undefined)
                        material.bumpMap = getTexture(json.bumpMap);
                    if (json.bumpScale !== undefined)
                        material.bumpScale = json.bumpScale;
                    if (json.normalMap !== undefined)
                        material.normalMap = getTexture(json.normalMap);
                    if (json.normalMapType !== undefined)
                        material.normalMapType = json.normalMapType;
                    if (json.normalScale !== undefined) {
                        var normalScale = json.normalScale;
                        if (Array.isArray(normalScale) === false) {
                            // Blender exporter used to export a scalar. See #7459
                            normalScale = [normalScale, normalScale];
                        }
                        material.normalScale = new Vector2().fromArray(normalScale);
                    }
                    if (json.displacementMap !== undefined)
                        material.displacementMap = getTexture(json.displacementMap);
                    if (json.displacementScale !== undefined)
                        material.displacementScale = json.displacementScale;
                    if (json.displacementBias !== undefined)
                        material.displacementBias = json.displacementBias;
                    if (json.roughnessMap !== undefined)
                        material.roughnessMap = getTexture(json.roughnessMap);
                    if (json.metalnessMap !== undefined)
                        material.metalnessMap = getTexture(json.metalnessMap);
                    if (json.emissiveMap !== undefined)
                        material.emissiveMap = getTexture(json.emissiveMap);
                    if (json.emissiveIntensity !== undefined)
                        material.emissiveIntensity = json.emissiveIntensity;
                    if (json.specularMap !== undefined)
                        material.specularMap = getTexture(json.specularMap);
                    if (json.envMap !== undefined)
                        material.envMap = getTexture(json.envMap);
                    if (json.envMapIntensity !== undefined)
                        material.envMapIntensity = json.envMapIntensity;
                    if (json.reflectivity !== undefined)
                        material.reflectivity = json.reflectivity;
                    if (json.refractionRatio !== undefined)
                        material.refractionRatio = json.refractionRatio;
                    if (json.lightMap !== undefined)
                        material.lightMap = getTexture(json.lightMap);
                    if (json.lightMapIntensity !== undefined)
                        material.lightMapIntensity = json.lightMapIntensity;
                    if (json.aoMap !== undefined)
                        material.aoMap = getTexture(json.aoMap);
                    if (json.aoMapIntensity !== undefined)
                        material.aoMapIntensity = json.aoMapIntensity;
                    if (json.gradientMap !== undefined)
                        material.gradientMap = getTexture(json.gradientMap);
                    if (json.clearcoatNormalMap !== undefined)
                        material.clearcoatNormalMap = getTexture(json.clearcoatNormalMap);
                    if (json.clearcoatNormalScale !== undefined)
                        material.clearcoatNormalScale = new Vector2().fromArray(json.clearcoatNormalScale);
                    return material;
                },
                setTextures: function (value) {
                    this.textures = value;
                    return this;
                }
            });
            /**
             * @author Don McCurdy / https://www.donmccurdy.com
             */
            LoaderUtils = {
                decodeText: function (array) {
                    if (typeof TextDecoder !== 'undefined') {
                        return new TextDecoder().decode(array);
                    }
                    // Avoid the String.fromCharCode.apply(null, array) shortcut, which
                    // throws a "maximum call stack size exceeded" error for large arrays.
                    var s = '';
                    for (var i = 0, il = array.length; i < il; i++) {
                        // Implicitly assumes little-endian.
                        s += String.fromCharCode(array[i]);
                    }
                    try {
                        // merges multi-byte utf-8 characters.
                        return decodeURIComponent(escape(s));
                    }
                    catch (e) { // see #16358
                        return s;
                    }
                },
                extractUrlBase: function (url) {
                    var index = url.lastIndexOf('/');
                    if (index === -1)
                        return './';
                    return url.substr(0, index + 1);
                }
            };
            exports_14("LoaderUtils", LoaderUtils);
            InstancedBufferGeometry.prototype = Object.assign(Object.create(BufferGeometry.prototype), {
                constructor: InstancedBufferGeometry,
                isInstancedBufferGeometry: true,
                copy: function (source) {
                    BufferGeometry.prototype.copy.call(this, source);
                    this.maxInstancedCount = source.maxInstancedCount;
                    return this;
                },
                clone: function () {
                    return new this.constructor().copy(this);
                },
                toJSON: function () {
                    var data = BufferGeometry.prototype.toJSON.call(this);
                    data.maxInstancedCount = this.maxInstancedCount;
                    data.isInstancedBufferGeometry = true;
                    return data;
                }
            });
            InstancedBufferAttribute.prototype = Object.assign(Object.create(BufferAttribute.prototype), {
                constructor: InstancedBufferAttribute,
                isInstancedBufferAttribute: true,
                copy: function (source) {
                    BufferAttribute.prototype.copy.call(this, source);
                    this.meshPerAttribute = source.meshPerAttribute;
                    return this;
                },
                toJSON: function () {
                    var data = BufferAttribute.prototype.toJSON.call(this);
                    data.meshPerAttribute = this.meshPerAttribute;
                    data.isInstancedBufferAttribute = true;
                    return data;
                }
            });
            BufferGeometryLoader.prototype = Object.assign(Object.create(Loader.prototype), {
                constructor: BufferGeometryLoader,
                load: function (url, onLoad, onProgress, onError) {
                    var scope = this;
                    var loader = new FileLoader(scope.manager);
                    loader.setPath(scope.path);
                    loader.load(url, function (text) {
                        onLoad(scope.parse(JSON.parse(text)));
                    }, onProgress, onError);
                },
                parse: function (json) {
                    var geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();
                    var index = json.data.index;
                    if (index !== undefined) {
                        var typedArray = new TYPED_ARRAYS[index.type](index.array);
                        geometry.setIndex(new BufferAttribute(typedArray, 1));
                    }
                    var attributes = json.data.attributes;
                    for (var key in attributes) {
                        var attribute = attributes[key];
                        var typedArray = new TYPED_ARRAYS[attribute.type](attribute.array);
                        var bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
                        var bufferAttribute = new bufferAttributeConstr(typedArray, attribute.itemSize, attribute.normalized);
                        if (attribute.name !== undefined)
                            bufferAttribute.name = attribute.name;
                        geometry.setAttribute(key, bufferAttribute);
                    }
                    var morphAttributes = json.data.morphAttributes;
                    if (morphAttributes) {
                        for (var key in morphAttributes) {
                            var attributeArray = morphAttributes[key];
                            var array = [];
                            for (var i = 0, il = attributeArray.length; i < il; i++) {
                                var attribute = attributeArray[i];
                                var typedArray = new TYPED_ARRAYS[attribute.type](attribute.array);
                                var bufferAttribute = new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized);
                                if (attribute.name !== undefined)
                                    bufferAttribute.name = attribute.name;
                                array.push(bufferAttribute);
                            }
                            geometry.morphAttributes[key] = array;
                        }
                    }
                    var morphTargetsRelative = json.data.morphTargetsRelative;
                    if (morphTargetsRelative) {
                        geometry.morphTargetsRelative = true;
                    }
                    var groups = json.data.groups || json.data.drawcalls || json.data.offsets;
                    if (groups !== undefined) {
                        for (var i = 0, n = groups.length; i !== n; ++i) {
                            var group = groups[i];
                            geometry.addGroup(group.start, group.count, group.materialIndex);
                        }
                    }
                    var boundingSphere = json.data.boundingSphere;
                    if (boundingSphere !== undefined) {
                        var center = new Vector3();
                        if (boundingSphere.center !== undefined) {
                            center.fromArray(boundingSphere.center);
                        }
                        geometry.boundingSphere = new Sphere(center, boundingSphere.radius);
                    }
                    if (json.name)
                        geometry.name = json.name;
                    if (json.userData)
                        geometry.userData = json.userData;
                    return geometry;
                }
            });
            TYPED_ARRAYS = {
                Int8Array: Int8Array,
                Uint8Array: Uint8Array,
                // Workaround for IE11 pre KB2929437. See #11440
                Uint8ClampedArray: typeof Uint8ClampedArray !== 'undefined' ? Uint8ClampedArray : Uint8Array,
                Int16Array: Int16Array,
                Uint16Array: Uint16Array,
                Int32Array: Int32Array,
                Uint32Array: Uint32Array,
                Float32Array: Float32Array,
                Float64Array: Float64Array
            };
            ObjectLoader.prototype = Object.assign(Object.create(Loader.prototype), {
                constructor: ObjectLoader,
                load: function (url, onLoad, onProgress, onError) {
                    var scope = this;
                    var path = (this.path === '') ? LoaderUtils.extractUrlBase(url) : this.path;
                    this.resourcePath = this.resourcePath || path;
                    var loader = new FileLoader(scope.manager);
                    loader.setPath(this.path);
                    loader.load(url, function (text) {
                        var json = null;
                        try {
                            json = JSON.parse(text);
                        }
                        catch (error) {
                            if (onError !== undefined)
                                onError(error);
                            console.error('THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message);
                            return;
                        }
                        var metadata = json.metadata;
                        if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry') {
                            console.error('THREE.ObjectLoader: Can\'t load ' + url);
                            return;
                        }
                        scope.parse(json, onLoad);
                    }, onProgress, onError);
                },
                parse: function (json, onLoad) {
                    var shapes = this.parseShape(json.shapes);
                    var geometries = this.parseGeometries(json.geometries, shapes);
                    var images = this.parseImages(json.images, function () {
                        if (onLoad !== undefined)
                            onLoad(object);
                    });
                    var textures = this.parseTextures(json.textures, images);
                    var materials = this.parseMaterials(json.materials, textures);
                    var object = this.parseObject(json.object, geometries, materials);
                    if (json.animations) {
                        object.animations = this.parseAnimations(json.animations);
                    }
                    if (json.images === undefined || json.images.length === 0) {
                        if (onLoad !== undefined)
                            onLoad(object);
                    }
                    return object;
                },
                parseShape: function (json) {
                    var shapes = {};
                    if (json !== undefined) {
                        for (var i = 0, l = json.length; i < l; i++) {
                            var shape = new Shape().fromJSON(json[i]);
                            shapes[shape.uuid] = shape;
                        }
                    }
                    return shapes;
                },
                parseGeometries: function (json, shapes) {
                    var geometries = {};
                    if (json !== undefined) {
                        var bufferGeometryLoader = new BufferGeometryLoader();
                        for (var i = 0, l = json.length; i < l; i++) {
                            var geometry;
                            var data = json[i];
                            switch (data.type) {
                                case 'PlaneGeometry':
                                case 'PlaneBufferGeometry':
                                    geometry = new Geometries[data.type](data.width, data.height, data.widthSegments, data.heightSegments);
                                    break;
                                case 'BoxGeometry':
                                case 'BoxBufferGeometry':
                                case 'CubeGeometry': // backwards compatible
                                    geometry = new Geometries[data.type](data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
                                    break;
                                case 'CircleGeometry':
                                case 'CircleBufferGeometry':
                                    geometry = new Geometries[data.type](data.radius, data.segments, data.thetaStart, data.thetaLength);
                                    break;
                                case 'CylinderGeometry':
                                case 'CylinderBufferGeometry':
                                    geometry = new Geometries[data.type](data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
                                    break;
                                case 'ConeGeometry':
                                case 'ConeBufferGeometry':
                                    geometry = new Geometries[data.type](data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
                                    break;
                                case 'SphereGeometry':
                                case 'SphereBufferGeometry':
                                    geometry = new Geometries[data.type](data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
                                    break;
                                case 'DodecahedronGeometry':
                                case 'DodecahedronBufferGeometry':
                                case 'IcosahedronGeometry':
                                case 'IcosahedronBufferGeometry':
                                case 'OctahedronGeometry':
                                case 'OctahedronBufferGeometry':
                                case 'TetrahedronGeometry':
                                case 'TetrahedronBufferGeometry':
                                    geometry = new Geometries[data.type](data.radius, data.detail);
                                    break;
                                case 'RingGeometry':
                                case 'RingBufferGeometry':
                                    geometry = new Geometries[data.type](data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
                                    break;
                                case 'TorusGeometry':
                                case 'TorusBufferGeometry':
                                    geometry = new Geometries[data.type](data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
                                    break;
                                case 'TorusKnotGeometry':
                                case 'TorusKnotBufferGeometry':
                                    geometry = new Geometries[data.type](data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
                                    break;
                                case 'TubeGeometry':
                                case 'TubeBufferGeometry':
                                    // This only works for built-in curves (e.g. CatmullRomCurve3).
                                    // User defined curves or instances of CurvePath will not be deserialized.
                                    geometry = new Geometries[data.type](new Curves[data.path.type]().fromJSON(data.path), data.tubularSegments, data.radius, data.radialSegments, data.closed);
                                    break;
                                case 'LatheGeometry':
                                case 'LatheBufferGeometry':
                                    geometry = new Geometries[data.type](data.points, data.segments, data.phiStart, data.phiLength);
                                    break;
                                case 'PolyhedronGeometry':
                                case 'PolyhedronBufferGeometry':
                                    geometry = new Geometries[data.type](data.vertices, data.indices, data.radius, data.details);
                                    break;
                                case 'ShapeGeometry':
                                case 'ShapeBufferGeometry':
                                    var geometryShapes = [];
                                    for (var j = 0, jl = data.shapes.length; j < jl; j++) {
                                        var shape = shapes[data.shapes[j]];
                                        geometryShapes.push(shape);
                                    }
                                    geometry = new Geometries[data.type](geometryShapes, data.curveSegments);
                                    break;
                                case 'ExtrudeGeometry':
                                case 'ExtrudeBufferGeometry':
                                    var geometryShapes = [];
                                    for (var j = 0, jl = data.shapes.length; j < jl; j++) {
                                        var shape = shapes[data.shapes[j]];
                                        geometryShapes.push(shape);
                                    }
                                    var extrudePath = data.options.extrudePath;
                                    if (extrudePath !== undefined) {
                                        data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
                                    }
                                    geometry = new Geometries[data.type](geometryShapes, data.options);
                                    break;
                                case 'BufferGeometry':
                                case 'InstancedBufferGeometry':
                                    geometry = bufferGeometryLoader.parse(data);
                                    break;
                                case 'Geometry':
                                    if ('THREE' in window && 'LegacyJSONLoader' in THREE) {
                                        var geometryLoader = new THREE.LegacyJSONLoader();
                                        geometry = geometryLoader.parse(data, this.resourcePath).geometry;
                                    }
                                    else {
                                        console.error('THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".');
                                    }
                                    break;
                                default:
                                    console.warn('THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"');
                                    continue;
                            }
                            geometry.uuid = data.uuid;
                            if (data.name !== undefined)
                                geometry.name = data.name;
                            if (geometry.isBufferGeometry === true && data.userData !== undefined)
                                geometry.userData = data.userData;
                            geometries[data.uuid] = geometry;
                        }
                    }
                    return geometries;
                },
                parseMaterials: function (json, textures) {
                    var cache = {}; // MultiMaterial
                    var materials = {};
                    if (json !== undefined) {
                        var loader = new MaterialLoader();
                        loader.setTextures(textures);
                        for (var i = 0, l = json.length; i < l; i++) {
                            var data = json[i];
                            if (data.type === 'MultiMaterial') {
                                // Deprecated
                                var array = [];
                                for (var j = 0; j < data.materials.length; j++) {
                                    var material = data.materials[j];
                                    if (cache[material.uuid] === undefined) {
                                        cache[material.uuid] = loader.parse(material);
                                    }
                                    array.push(cache[material.uuid]);
                                }
                                materials[data.uuid] = array;
                            }
                            else {
                                if (cache[data.uuid] === undefined) {
                                    cache[data.uuid] = loader.parse(data);
                                }
                                materials[data.uuid] = cache[data.uuid];
                            }
                        }
                    }
                    return materials;
                },
                parseAnimations: function (json) {
                    var animations = [];
                    for (var i = 0; i < json.length; i++) {
                        var data = json[i];
                        var clip = AnimationClip.parse(data);
                        if (data.uuid !== undefined)
                            clip.uuid = data.uuid;
                        animations.push(clip);
                    }
                    return animations;
                },
                parseImages: function (json, onLoad) {
                    var scope = this;
                    var images = {};
                    function loadImage(url) {
                        scope.manager.itemStart(url);
                        return loader.load(url, function () {
                            scope.manager.itemEnd(url);
                        }, undefined, function () {
                            scope.manager.itemError(url);
                            scope.manager.itemEnd(url);
                        });
                    }
                    if (json !== undefined && json.length > 0) {
                        var manager = new LoadingManager(onLoad);
                        var loader = new ImageLoader(manager);
                        loader.setCrossOrigin(this.crossOrigin);
                        for (var i = 0, il = json.length; i < il; i++) {
                            var image = json[i];
                            var url = image.url;
                            if (Array.isArray(url)) {
                                // load array of images e.g CubeTexture
                                images[image.uuid] = [];
                                for (var j = 0, jl = url.length; j < jl; j++) {
                                    var currentUrl = url[j];
                                    var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(currentUrl) ? currentUrl : scope.resourcePath + currentUrl;
                                    images[image.uuid].push(loadImage(path));
                                }
                            }
                            else {
                                // load single image
                                var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(image.url) ? image.url : scope.resourcePath + image.url;
                                images[image.uuid] = loadImage(path);
                            }
                        }
                    }
                    return images;
                },
                parseTextures: function (json, images) {
                    function parseConstant(value, type) {
                        if (typeof value === 'number')
                            return value;
                        console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value);
                        return type[value];
                    }
                    var textures = {};
                    if (json !== undefined) {
                        for (var i = 0, l = json.length; i < l; i++) {
                            var data = json[i];
                            if (data.image === undefined) {
                                console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
                            }
                            if (images[data.image] === undefined) {
                                console.warn('THREE.ObjectLoader: Undefined image', data.image);
                            }
                            var texture;
                            if (Array.isArray(images[data.image])) {
                                texture = new CubeTexture(images[data.image]);
                            }
                            else {
                                texture = new Texture(images[data.image]);
                            }
                            texture.needsUpdate = true;
                            texture.uuid = data.uuid;
                            if (data.name !== undefined)
                                texture.name = data.name;
                            if (data.mapping !== undefined)
                                texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);
                            if (data.offset !== undefined)
                                texture.offset.fromArray(data.offset);
                            if (data.repeat !== undefined)
                                texture.repeat.fromArray(data.repeat);
                            if (data.center !== undefined)
                                texture.center.fromArray(data.center);
                            if (data.rotation !== undefined)
                                texture.rotation = data.rotation;
                            if (data.wrap !== undefined) {
                                texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);
                                texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);
                            }
                            if (data.format !== undefined)
                                texture.format = data.format;
                            if (data.type !== undefined)
                                texture.type = data.type;
                            if (data.encoding !== undefined)
                                texture.encoding = data.encoding;
                            if (data.minFilter !== undefined)
                                texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);
                            if (data.magFilter !== undefined)
                                texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);
                            if (data.anisotropy !== undefined)
                                texture.anisotropy = data.anisotropy;
                            if (data.flipY !== undefined)
                                texture.flipY = data.flipY;
                            if (data.premultiplyAlpha !== undefined)
                                texture.premultiplyAlpha = data.premultiplyAlpha;
                            if (data.unpackAlignment !== undefined)
                                texture.unpackAlignment = data.unpackAlignment;
                            textures[data.uuid] = texture;
                        }
                    }
                    return textures;
                },
                parseObject: function (data, geometries, materials) {
                    var object;
                    function getGeometry(name) {
                        if (geometries[name] === undefined) {
                            console.warn('THREE.ObjectLoader: Undefined geometry', name);
                        }
                        return geometries[name];
                    }
                    function getMaterial(name) {
                        if (name === undefined)
                            return undefined;
                        if (Array.isArray(name)) {
                            var array = [];
                            for (var i = 0, l = name.length; i < l; i++) {
                                var uuid = name[i];
                                if (materials[uuid] === undefined) {
                                    console.warn('THREE.ObjectLoader: Undefined material', uuid);
                                }
                                array.push(materials[uuid]);
                            }
                            return array;
                        }
                        if (materials[name] === undefined) {
                            console.warn('THREE.ObjectLoader: Undefined material', name);
                        }
                        return materials[name];
                    }
                    switch (data.type) {
                        case 'Scene':
                            object = new Scene();
                            if (data.background !== undefined) {
                                if (Number.isInteger(data.background)) {
                                    object.background = new Color(data.background);
                                }
                            }
                            if (data.fog !== undefined) {
                                if (data.fog.type === 'Fog') {
                                    object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);
                                }
                                else if (data.fog.type === 'FogExp2') {
                                    object.fog = new FogExp2(data.fog.color, data.fog.density);
                                }
                            }
                            break;
                        case 'PerspectiveCamera':
                            object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
                            if (data.focus !== undefined)
                                object.focus = data.focus;
                            if (data.zoom !== undefined)
                                object.zoom = data.zoom;
                            if (data.filmGauge !== undefined)
                                object.filmGauge = data.filmGauge;
                            if (data.filmOffset !== undefined)
                                object.filmOffset = data.filmOffset;
                            if (data.view !== undefined)
                                object.view = Object.assign({}, data.view);
                            break;
                        case 'OrthographicCamera':
                            object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
                            if (data.zoom !== undefined)
                                object.zoom = data.zoom;
                            if (data.view !== undefined)
                                object.view = Object.assign({}, data.view);
                            break;
                        case 'AmbientLight':
                            object = new AmbientLight(data.color, data.intensity);
                            break;
                        case 'DirectionalLight':
                            object = new DirectionalLight(data.color, data.intensity);
                            break;
                        case 'PointLight':
                            object = new PointLight(data.color, data.intensity, data.distance, data.decay);
                            break;
                        case 'RectAreaLight':
                            object = new RectAreaLight(data.color, data.intensity, data.width, data.height);
                            break;
                        case 'SpotLight':
                            object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
                            break;
                        case 'HemisphereLight':
                            object = new HemisphereLight(data.color, data.groundColor, data.intensity);
                            break;
                        case 'SkinnedMesh':
                            console.warn('THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.');
                        case 'Mesh':
                            var geometry = getGeometry(data.geometry);
                            var material = getMaterial(data.material);
                            if (geometry.bones && geometry.bones.length > 0) {
                                object = new SkinnedMesh(geometry, material);
                            }
                            else {
                                object = new Mesh(geometry, material);
                            }
                            break;
                        case 'InstancedMesh':
                            var geometry = getGeometry(data.geometry);
                            var material = getMaterial(data.material);
                            var count = data.count;
                            var instanceMatrix = data.instanceMatrix;
                            object = new InstancedMesh(geometry, material, count);
                            object.instanceMatrix = new BufferAttribute(new Float32Array(instanceMatrix.array), 16);
                            break;
                        case 'LOD':
                            object = new LOD();
                            break;
                        case 'Line':
                            object = new Line(getGeometry(data.geometry), getMaterial(data.material), data.mode);
                            break;
                        case 'LineLoop':
                            object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));
                            break;
                        case 'LineSegments':
                            object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
                            break;
                        case 'PointCloud':
                        case 'Points':
                            object = new Points(getGeometry(data.geometry), getMaterial(data.material));
                            break;
                        case 'Sprite':
                            object = new Sprite(getMaterial(data.material));
                            break;
                        case 'Group':
                            object = new Group();
                            break;
                        default:
                            object = new Object3D();
                    }
                    object.uuid = data.uuid;
                    if (data.name !== undefined)
                        object.name = data.name;
                    if (data.matrix !== undefined) {
                        object.matrix.fromArray(data.matrix);
                        if (data.matrixAutoUpdate !== undefined)
                            object.matrixAutoUpdate = data.matrixAutoUpdate;
                        if (object.matrixAutoUpdate)
                            object.matrix.decompose(object.position, object.quaternion, object.scale);
                    }
                    else {
                        if (data.position !== undefined)
                            object.position.fromArray(data.position);
                        if (data.rotation !== undefined)
                            object.rotation.fromArray(data.rotation);
                        if (data.quaternion !== undefined)
                            object.quaternion.fromArray(data.quaternion);
                        if (data.scale !== undefined)
                            object.scale.fromArray(data.scale);
                    }
                    if (data.castShadow !== undefined)
                        object.castShadow = data.castShadow;
                    if (data.receiveShadow !== undefined)
                        object.receiveShadow = data.receiveShadow;
                    if (data.shadow) {
                        if (data.shadow.bias !== undefined)
                            object.shadow.bias = data.shadow.bias;
                        if (data.shadow.radius !== undefined)
                            object.shadow.radius = data.shadow.radius;
                        if (data.shadow.mapSize !== undefined)
                            object.shadow.mapSize.fromArray(data.shadow.mapSize);
                        if (data.shadow.camera !== undefined)
                            object.shadow.camera = this.parseObject(data.shadow.camera);
                    }
                    if (data.visible !== undefined)
                        object.visible = data.visible;
                    if (data.frustumCulled !== undefined)
                        object.frustumCulled = data.frustumCulled;
                    if (data.renderOrder !== undefined)
                        object.renderOrder = data.renderOrder;
                    if (data.userData !== undefined)
                        object.userData = data.userData;
                    if (data.layers !== undefined)
                        object.layers.mask = data.layers;
                    if (data.children !== undefined) {
                        var children = data.children;
                        for (var i = 0; i < children.length; i++) {
                            object.add(this.parseObject(children[i], geometries, materials));
                        }
                    }
                    if (data.type === 'LOD') {
                        if (data.autoUpdate !== undefined)
                            object.autoUpdate = data.autoUpdate;
                        var levels = data.levels;
                        for (var l = 0; l < levels.length; l++) {
                            var level = levels[l];
                            var child = object.getObjectByProperty('uuid', level.object);
                            if (child !== undefined) {
                                object.addLevel(child, level.distance);
                            }
                        }
                    }
                    return object;
                }
            });
            TEXTURE_MAPPING = {
                UVMapping: UVMapping,
                CubeReflectionMapping: CubeReflectionMapping,
                CubeRefractionMapping: CubeRefractionMapping,
                EquirectangularReflectionMapping: EquirectangularReflectionMapping,
                EquirectangularRefractionMapping: EquirectangularRefractionMapping,
                SphericalReflectionMapping: SphericalReflectionMapping,
                CubeUVReflectionMapping: CubeUVReflectionMapping,
                CubeUVRefractionMapping: CubeUVRefractionMapping
            };
            TEXTURE_WRAPPING = {
                RepeatWrapping: RepeatWrapping,
                ClampToEdgeWrapping: ClampToEdgeWrapping,
                MirroredRepeatWrapping: MirroredRepeatWrapping
            };
            TEXTURE_FILTER = {
                NearestFilter: NearestFilter,
                NearestMipmapNearestFilter: NearestMipmapNearestFilter,
                NearestMipmapLinearFilter: NearestMipmapLinearFilter,
                LinearFilter: LinearFilter,
                LinearMipmapNearestFilter: LinearMipmapNearestFilter,
                LinearMipmapLinearFilter: LinearMipmapLinearFilter
            };
            ImageBitmapLoader.prototype = Object.assign(Object.create(Loader.prototype), {
                constructor: ImageBitmapLoader,
                setOptions: function setOptions(options) {
                    this.options = options;
                    return this;
                },
                load: function (url, onLoad, onProgress, onError) {
                    if (url === undefined)
                        url = '';
                    if (this.path !== undefined)
                        url = this.path + url;
                    url = this.manager.resolveURL(url);
                    var scope = this;
                    var cached = Cache.get(url);
                    if (cached !== undefined) {
                        scope.manager.itemStart(url);
                        setTimeout(function () {
                            if (onLoad)
                                onLoad(cached);
                            scope.manager.itemEnd(url);
                        }, 0);
                        return cached;
                    }
                    fetch(url).then(function (res) {
                        return res.blob();
                    }).then(function (blob) {
                        if (scope.options === undefined) {
                            // Workaround for FireFox. It causes an error if you pass options.
                            return createImageBitmap(blob);
                        }
                        else {
                            return createImageBitmap(blob, scope.options);
                        }
                    }).then(function (imageBitmap) {
                        Cache.add(url, imageBitmap);
                        if (onLoad)
                            onLoad(imageBitmap);
                        scope.manager.itemEnd(url);
                    }).catch(function (e) {
                        if (onError)
                            onError(e);
                        scope.manager.itemError(url);
                        scope.manager.itemEnd(url);
                    });
                    scope.manager.itemStart(url);
                }
            });
            Object.assign(ShapePath.prototype, {
                moveTo: function (x, y) {
                    this.currentPath = new Path();
                    this.subPaths.push(this.currentPath);
                    this.currentPath.moveTo(x, y);
                    return this;
                },
                lineTo: function (x, y) {
                    this.currentPath.lineTo(x, y);
                    return this;
                },
                quadraticCurveTo: function (aCPx, aCPy, aX, aY) {
                    this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
                    return this;
                },
                bezierCurveTo: function (aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
                    this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
                    return this;
                },
                splineThru: function (pts) {
                    this.currentPath.splineThru(pts);
                    return this;
                },
                toShapes: function (isCCW, noHoles) {
                    function toShapesNoHoles(inSubpaths) {
                        var shapes = [];
                        for (var i = 0, l = inSubpaths.length; i < l; i++) {
                            var tmpPath = inSubpaths[i];
                            var tmpShape = new Shape();
                            tmpShape.curves = tmpPath.curves;
                            shapes.push(tmpShape);
                        }
                        return shapes;
                    }
                    function isPointInsidePolygon(inPt, inPolygon) {
                        var polyLen = inPolygon.length;
                        // inPt on polygon contour => immediate success    or
                        // toggling of inside/outside at every single! intersection point of an edge
                        //  with the horizontal line through inPt, left of inPt
                        //  not counting lowerY endpoints of edges and whole edges on that line
                        var inside = false;
                        for (var p = polyLen - 1, q = 0; q < polyLen; p = q++) {
                            var edgeLowPt = inPolygon[p];
                            var edgeHighPt = inPolygon[q];
                            var edgeDx = edgeHighPt.x - edgeLowPt.x;
                            var edgeDy = edgeHighPt.y - edgeLowPt.y;
                            if (Math.abs(edgeDy) > Number.EPSILON) {
                                // not parallel
                                if (edgeDy < 0) {
                                    edgeLowPt = inPolygon[q];
                                    edgeDx = -edgeDx;
                                    edgeHighPt = inPolygon[p];
                                    edgeDy = -edgeDy;
                                }
                                if ((inPt.y < edgeLowPt.y) || (inPt.y > edgeHighPt.y))
                                    continue;
                                if (inPt.y === edgeLowPt.y) {
                                    if (inPt.x === edgeLowPt.x)
                                        return true; // inPt is on contour ?
                                    // continue;				// no intersection or edgeLowPt => doesn't count !!!
                                }
                                else {
                                    var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
                                    if (perpEdge === 0)
                                        return true; // inPt is on contour ?
                                    if (perpEdge < 0)
                                        continue;
                                    inside = !inside; // true intersection left of inPt
                                }
                            }
                            else {
                                // parallel or collinear
                                if (inPt.y !== edgeLowPt.y)
                                    continue; // parallel
                                // edge lies on the same horizontal line as inPt
                                if (((edgeHighPt.x <= inPt.x) && (inPt.x <= edgeLowPt.x)) ||
                                    ((edgeLowPt.x <= inPt.x) && (inPt.x <= edgeHighPt.x)))
                                    return true; // inPt: Point on contour !
                                // continue;
                            }
                        }
                        return inside;
                    }
                    var isClockWise = ShapeUtils.isClockWise;
                    var subPaths = this.subPaths;
                    if (subPaths.length === 0)
                        return [];
                    if (noHoles === true)
                        return toShapesNoHoles(subPaths);
                    var solid, tmpPath, tmpShape, shapes = [];
                    if (subPaths.length === 1) {
                        tmpPath = subPaths[0];
                        tmpShape = new Shape();
                        tmpShape.curves = tmpPath.curves;
                        shapes.push(tmpShape);
                        return shapes;
                    }
                    var holesFirst = !isClockWise(subPaths[0].getPoints());
                    holesFirst = isCCW ? !holesFirst : holesFirst;
                    // console.log("Holes first", holesFirst);
                    var betterShapeHoles = [];
                    var newShapes = [];
                    var newShapeHoles = [];
                    var mainIdx = 0;
                    var tmpPoints;
                    newShapes[mainIdx] = undefined;
                    newShapeHoles[mainIdx] = [];
                    for (var i = 0, l = subPaths.length; i < l; i++) {
                        tmpPath = subPaths[i];
                        tmpPoints = tmpPath.getPoints();
                        solid = isClockWise(tmpPoints);
                        solid = isCCW ? !solid : solid;
                        if (solid) {
                            if ((!holesFirst) && (newShapes[mainIdx]))
                                mainIdx++;
                            newShapes[mainIdx] = { s: new Shape(), p: tmpPoints };
                            newShapes[mainIdx].s.curves = tmpPath.curves;
                            if (holesFirst)
                                mainIdx++;
                            newShapeHoles[mainIdx] = [];
                            //console.log('cw', i);
                        }
                        else {
                            newShapeHoles[mainIdx].push({ h: tmpPath, p: tmpPoints[0] });
                            //console.log('ccw', i);
                        }
                    }
                    // only Holes? -> probably all Shapes with wrong orientation
                    if (!newShapes[0])
                        return toShapesNoHoles(subPaths);
                    if (newShapes.length > 1) {
                        var ambiguous = false;
                        var toChange = [];
                        for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
                            betterShapeHoles[sIdx] = [];
                        }
                        for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
                            var sho = newShapeHoles[sIdx];
                            for (var hIdx = 0; hIdx < sho.length; hIdx++) {
                                var ho = sho[hIdx];
                                var hole_unassigned = true;
                                for (var s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
                                    if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
                                        if (sIdx !== s2Idx)
                                            toChange.push({ froms: sIdx, tos: s2Idx, hole: hIdx });
                                        if (hole_unassigned) {
                                            hole_unassigned = false;
                                            betterShapeHoles[s2Idx].push(ho);
                                        }
                                        else {
                                            ambiguous = true;
                                        }
                                    }
                                }
                                if (hole_unassigned) {
                                    betterShapeHoles[sIdx].push(ho);
                                }
                            }
                        }
                        // console.log("ambiguous: ", ambiguous);
                        if (toChange.length > 0) {
                            // console.log("to change: ", toChange);
                            if (!ambiguous)
                                newShapeHoles = betterShapeHoles;
                        }
                    }
                    var tmpHoles;
                    for (var i = 0, il = newShapes.length; i < il; i++) {
                        tmpShape = newShapes[i].s;
                        shapes.push(tmpShape);
                        tmpHoles = newShapeHoles[i];
                        for (var j = 0, jl = tmpHoles.length; j < jl; j++) {
                            tmpShape.holes.push(tmpHoles[j].h);
                        }
                    }
                    //console.log("shape", shapes);
                    return shapes;
                }
            });
            Object.assign(Font.prototype, {
                isFont: true,
                generateShapes: function (text, size) {
                    if (size === undefined)
                        size = 100;
                    var shapes = [];
                    var paths = createPaths(text, size, this.data);
                    for (var p = 0, pl = paths.length; p < pl; p++) {
                        Array.prototype.push.apply(shapes, paths[p].toShapes());
                    }
                    return shapes;
                }
            });
            FontLoader.prototype = Object.assign(Object.create(Loader.prototype), {
                constructor: FontLoader,
                load: function (url, onLoad, onProgress, onError) {
                    var scope = this;
                    var loader = new FileLoader(this.manager);
                    loader.setPath(this.path);
                    loader.load(url, function (text) {
                        var json;
                        try {
                            json = JSON.parse(text);
                        }
                        catch (e) {
                            console.warn('THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.');
                            json = JSON.parse(text.substring(65, text.length - 2));
                        }
                        var font = scope.parse(json);
                        if (onLoad)
                            onLoad(font);
                    }, onProgress, onError);
                },
                parse: function (json) {
                    return new Font(json);
                }
            });
            AudioContext = {
                getContext: function () {
                    if (_context === undefined) {
                        _context = new (window.AudioContext || window.webkitAudioContext)();
                    }
                    return _context;
                },
                setContext: function (value) {
                    _context = value;
                }
            };
            exports_14("AudioContext", AudioContext);
            AudioLoader.prototype = Object.assign(Object.create(Loader.prototype), {
                constructor: AudioLoader,
                load: function (url, onLoad, onProgress, onError) {
                    var loader = new FileLoader(this.manager);
                    loader.setResponseType('arraybuffer');
                    loader.setPath(this.path);
                    loader.load(url, function (buffer) {
                        // Create a copy of the buffer. The `decodeAudioData` method
                        // detaches the buffer when complete, preventing reuse.
                        var bufferCopy = buffer.slice(0);
                        var context = AudioContext.getContext();
                        context.decodeAudioData(bufferCopy, function (audioBuffer) {
                            onLoad(audioBuffer);
                        });
                    }, onProgress, onError);
                }
            });
            Object.assign(SphericalHarmonics3.prototype, {
                isSphericalHarmonics3: true,
                set: function (coefficients) {
                    for (var i = 0; i < 9; i++) {
                        this.coefficients[i].copy(coefficients[i]);
                    }
                    return this;
                },
                zero: function () {
                    for (var i = 0; i < 9; i++) {
                        this.coefficients[i].set(0, 0, 0);
                    }
                    return this;
                },
                // get the radiance in the direction of the normal
                // target is a Vector3
                getAt: function (normal, target) {
                    // normal is assumed to be unit length
                    var x = normal.x, y = normal.y, z = normal.z;
                    var coeff = this.coefficients;
                    // band 0
                    target.copy(coeff[0]).multiplyScalar(0.282095);
                    // band 1
                    target.addScale(coeff[1], 0.488603 * y);
                    target.addScale(coeff[2], 0.488603 * z);
                    target.addScale(coeff[3], 0.488603 * x);
                    // band 2
                    target.addScale(coeff[4], 1.092548 * (x * y));
                    target.addScale(coeff[5], 1.092548 * (y * z));
                    target.addScale(coeff[6], 0.315392 * (3.0 * z * z - 1.0));
                    target.addScale(coeff[7], 1.092548 * (x * z));
                    target.addScale(coeff[8], 0.546274 * (x * x - y * y));
                    return target;
                },
                // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
                // target is a Vector3
                // https://graphics.stanford.edu/papers/envmap/envmap.pdf
                getIrradianceAt: function (normal, target) {
                    // normal is assumed to be unit length
                    var x = normal.x, y = normal.y, z = normal.z;
                    var coeff = this.coefficients;
                    // band 0
                    target.copy(coeff[0]).multiplyScalar(0.886227); //  * 0.282095
                    // band 1
                    target.addScale(coeff[1], 2.0 * 0.511664 * y); // ( 2 *  / 3 ) * 0.488603
                    target.addScale(coeff[2], 2.0 * 0.511664 * z);
                    target.addScale(coeff[3], 2.0 * 0.511664 * x);
                    // band 2
                    target.addScale(coeff[4], 2.0 * 0.429043 * x * y); // (  / 4 ) * 1.092548
                    target.addScale(coeff[5], 2.0 * 0.429043 * y * z);
                    target.addScale(coeff[6], 0.743125 * z * z - 0.247708); // (  / 4 ) * 0.315392 * 3
                    target.addScale(coeff[7], 2.0 * 0.429043 * x * z);
                    target.addScale(coeff[8], 0.429043 * (x * x - y * y)); // (  / 4 ) * 0.546274
                    return target;
                },
                add: function (sh) {
                    for (var i = 0; i < 9; i++) {
                        this.coefficients[i].add(sh.coefficients[i]);
                    }
                    return this;
                },
                scale: function (s) {
                    for (var i = 0; i < 9; i++) {
                        this.coefficients[i].multiplyScalar(s);
                    }
                    return this;
                },
                lerp: function (sh, alpha) {
                    for (var i = 0; i < 9; i++) {
                        this.coefficients[i].lerp(sh.coefficients[i], alpha);
                    }
                    return this;
                },
                equals: function (sh) {
                    for (var i = 0; i < 9; i++) {
                        if (!this.coefficients[i].equals(sh.coefficients[i])) {
                            return false;
                        }
                    }
                    return true;
                },
                copy: function (sh) {
                    return this.set(sh.coefficients);
                },
                clone: function () {
                    return new this.constructor().copy(this);
                },
                fromArray: function (array, offset) {
                    if (offset === undefined)
                        offset = 0;
                    var coefficients = this.coefficients;
                    for (var i = 0; i < 9; i++) {
                        coefficients[i].fromArray(array, offset + (i * 3));
                    }
                    return this;
                },
                toArray: function (array, offset) {
                    if (array === undefined)
                        array = [];
                    if (offset === undefined)
                        offset = 0;
                    var coefficients = this.coefficients;
                    for (var i = 0; i < 9; i++) {
                        coefficients[i].toArray(array, offset + (i * 3));
                    }
                    return array;
                }
            });
            Object.assign(SphericalHarmonics3, {
                // evaluate the basis functions
                // shBasis is an Array[ 9 ]
                getBasisAt: function (normal, shBasis) {
                    // normal is assumed to be unit length
                    var x = normal.x, y = normal.y, z = normal.z;
                    // band 0
                    shBasis[0] = 0.282095;
                    // band 1
                    shBasis[1] = 0.488603 * y;
                    shBasis[2] = 0.488603 * z;
                    shBasis[3] = 0.488603 * x;
                    // band 2
                    shBasis[4] = 1.092548 * x * y;
                    shBasis[5] = 1.092548 * y * z;
                    shBasis[6] = 0.315392 * (3 * z * z - 1);
                    shBasis[7] = 1.092548 * x * z;
                    shBasis[8] = 0.546274 * (x * x - y * y);
                }
            });
            LightProbe.prototype = Object.assign(Object.create(Light.prototype), {
                constructor: LightProbe,
                isLightProbe: true,
                copy: function (source) {
                    Light.prototype.copy.call(this, source);
                    this.sh.copy(source.sh);
                    this.intensity = source.intensity;
                    return this;
                },
                toJSON: function (meta) {
                    var data = Light.prototype.toJSON.call(this, meta);
                    // data.sh = this.sh.toArray(); // todo
                    return data;
                }
            });
            HemisphereLightProbe.prototype = Object.assign(Object.create(LightProbe.prototype), {
                constructor: HemisphereLightProbe,
                isHemisphereLightProbe: true,
                copy: function (source) {
                    LightProbe.prototype.copy.call(this, source);
                    return this;
                },
                toJSON: function (meta) {
                    var data = LightProbe.prototype.toJSON.call(this, meta);
                    // data.sh = this.sh.toArray(); // todo
                    return data;
                }
            });
            AmbientLightProbe.prototype = Object.assign(Object.create(LightProbe.prototype), {
                constructor: AmbientLightProbe,
                isAmbientLightProbe: true,
                copy: function (source) {
                    LightProbe.prototype.copy.call(this, source);
                    return this;
                },
                toJSON: function (meta) {
                    var data = LightProbe.prototype.toJSON.call(this, meta);
                    // data.sh = this.sh.toArray(); // todo
                    return data;
                }
            });
            _eyeRight = new Matrix4();
            _eyeLeft = new Matrix4();
            Object.assign(StereoCamera.prototype, {
                update: function (camera) {
                    var cache = this._cache;
                    var needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov ||
                        cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near ||
                        cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;
                    if (needsUpdate) {
                        cache.focus = camera.focus;
                        cache.fov = camera.fov;
                        cache.aspect = camera.aspect * this.aspect;
                        cache.near = camera.near;
                        cache.far = camera.far;
                        cache.zoom = camera.zoom;
                        cache.eyeSep = this.eyeSep;
                        // Off-axis stereoscopic effect based on
                        // http://paulbourke.net/stereographics/stereorender/
                        var projectionMatrix = camera.projectionMatrix.clone();
                        var eyeSepHalf = cache.eyeSep / 2;
                        var eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
                        var ymax = (cache.near * Math.tan(MathUtils.DEG2RAD * cache.fov * 0.5)) / cache.zoom;
                        var xmin, xmax;
                        // translate xOffset
                        _eyeLeft.elements[12] = -eyeSepHalf;
                        _eyeRight.elements[12] = eyeSepHalf;
                        // for left eye
                        xmin = -ymax * cache.aspect + eyeSepOnProjection;
                        xmax = ymax * cache.aspect + eyeSepOnProjection;
                        projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
                        projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
                        this.cameraL.projectionMatrix.copy(projectionMatrix);
                        // for right eye
                        xmin = -ymax * cache.aspect - eyeSepOnProjection;
                        xmax = ymax * cache.aspect - eyeSepOnProjection;
                        projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
                        projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
                        this.cameraR.projectionMatrix.copy(projectionMatrix);
                    }
                    this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft);
                    this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight);
                }
            });
            Object.assign(Clock.prototype, {
                start: function () {
                    this.startTime = (typeof performance === 'undefined' ? Date : performance).now(); // see #10732
                    this.oldTime = this.startTime;
                    this.elapsedTime = 0;
                    this.running = true;
                },
                stop: function () {
                    this.getElapsedTime();
                    this.running = false;
                    this.autoStart = false;
                },
                getElapsedTime: function () {
                    this.getDelta();
                    return this.elapsedTime;
                },
                getDelta: function () {
                    var diff = 0;
                    if (this.autoStart && !this.running) {
                        this.start();
                        return 0;
                    }
                    if (this.running) {
                        var newTime = (typeof performance === 'undefined' ? Date : performance).now();
                        diff = (newTime - this.oldTime) / 1000;
                        this.oldTime = newTime;
                        this.elapsedTime += diff;
                    }
                    return diff;
                }
            });
            /**
             * @author mrdoob / http://mrdoob.com/
             */
            _position$2 = new Vector3();
            _quaternion$3 = new Quaternion();
            _scale$1 = new Vector3();
            _orientation = new Vector3();
            AudioListener.prototype = Object.assign(Object.create(Object3D.prototype), {
                constructor: AudioListener,
                getInput: function () {
                    return this.gain;
                },
                removeFilter: function () {
                    if (this.filter !== null) {
                        this.gain.disconnect(this.filter);
                        this.filter.disconnect(this.context.destination);
                        this.gain.connect(this.context.destination);
                        this.filter = null;
                    }
                    return this;
                },
                getFilter: function () {
                    return this.filter;
                },
                setFilter: function (value) {
                    if (this.filter !== null) {
                        this.gain.disconnect(this.filter);
                        this.filter.disconnect(this.context.destination);
                    }
                    else {
                        this.gain.disconnect(this.context.destination);
                    }
                    this.filter = value;
                    this.gain.connect(this.filter);
                    this.filter.connect(this.context.destination);
                    return this;
                },
                getMasterVolume: function () {
                    return this.gain.gain.value;
                },
                setMasterVolume: function (value) {
                    this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
                    return this;
                },
                updateMatrixWorld: function (force) {
                    Object3D.prototype.updateMatrixWorld.call(this, force);
                    var listener = this.context.listener;
                    var up = this.up;
                    this.timeDelta = this._clock.getDelta();
                    this.matrixWorld.decompose(_position$2, _quaternion$3, _scale$1);
                    _orientation.set(0, 0, -1).applyQuaternion(_quaternion$3);
                    if (listener.positionX) {
                        // code path for Chrome (see #14393)
                        var endTime = this.context.currentTime + this.timeDelta;
                        listener.positionX.linearRampToValueAtTime(_position$2.x, endTime);
                        listener.positionY.linearRampToValueAtTime(_position$2.y, endTime);
                        listener.positionZ.linearRampToValueAtTime(_position$2.z, endTime);
                        listener.forwardX.linearRampToValueAtTime(_orientation.x, endTime);
                        listener.forwardY.linearRampToValueAtTime(_orientation.y, endTime);
                        listener.forwardZ.linearRampToValueAtTime(_orientation.z, endTime);
                        listener.upX.linearRampToValueAtTime(up.x, endTime);
                        listener.upY.linearRampToValueAtTime(up.y, endTime);
                        listener.upZ.linearRampToValueAtTime(up.z, endTime);
                    }
                    else {
                        listener.setPosition(_position$2.x, _position$2.y, _position$2.z);
                        listener.setOrientation(_orientation.x, _orientation.y, _orientation.z, up.x, up.y, up.z);
                    }
                }
            });
            Audio.prototype = Object.assign(Object.create(Object3D.prototype), {
                constructor: Audio,
                getOutput: function () {
                    return this.gain;
                },
                setNodeSource: function (audioNode) {
                    this.hasPlaybackControl = false;
                    this.sourceType = 'audioNode';
                    this.source = audioNode;
                    this.connect();
                    return this;
                },
                setMediaElementSource: function (mediaElement) {
                    this.hasPlaybackControl = false;
                    this.sourceType = 'mediaNode';
                    this.source = this.context.createMediaElementSource(mediaElement);
                    this.connect();
                    return this;
                },
                setMediaStreamSource: function (mediaStream) {
                    this.hasPlaybackControl = false;
                    this.sourceType = 'mediaStreamNode';
                    this.source = this.context.createMediaStreamSource(mediaStream);
                    this.connect();
                    return this;
                },
                setBuffer: function (audioBuffer) {
                    this.buffer = audioBuffer;
                    this.sourceType = 'buffer';
                    if (this.autoplay)
                        this.play();
                    return this;
                },
                play: function (delay) {
                    if (delay === undefined)
                        delay = 0;
                    if (this.isPlaying === true) {
                        console.warn('THREE.Audio: Audio is already playing.');
                        return;
                    }
                    if (this.hasPlaybackControl === false) {
                        console.warn('THREE.Audio: this Audio has no playback control.');
                        return;
                    }
                    this._startedAt = this.context.currentTime + delay;
                    var source = this.context.createBufferSource();
                    source.buffer = this.buffer;
                    source.loop = this.loop;
                    source.loopStart = this.loopStart;
                    source.loopEnd = this.loopEnd;
                    source.onended = this.onEnded.bind(this);
                    source.start(this._startedAt, this._pausedAt + this.offset, this.duration);
                    this.isPlaying = true;
                    this.source = source;
                    this.setDetune(this.detune);
                    this.setPlaybackRate(this.playbackRate);
                    return this.connect();
                },
                pause: function () {
                    if (this.hasPlaybackControl === false) {
                        console.warn('THREE.Audio: this Audio has no playback control.');
                        return;
                    }
                    if (this.isPlaying === true) {
                        this._pausedAt = (this.context.currentTime - this._startedAt) * this.playbackRate;
                        this.source.stop();
                        this.source.onended = null;
                        this.isPlaying = false;
                    }
                    return this;
                },
                stop: function () {
                    if (this.hasPlaybackControl === false) {
                        console.warn('THREE.Audio: this Audio has no playback control.');
                        return;
                    }
                    this._pausedAt = 0;
                    this.source.stop();
                    this.source.onended = null;
                    this.isPlaying = false;
                    return this;
                },
                connect: function () {
                    if (this.filters.length > 0) {
                        this.source.connect(this.filters[0]);
                        for (var i = 1, l = this.filters.length; i < l; i++) {
                            this.filters[i - 1].connect(this.filters[i]);
                        }
                        this.filters[this.filters.length - 1].connect(this.getOutput());
                    }
                    else {
                        this.source.connect(this.getOutput());
                    }
                    return this;
                },
                disconnect: function () {
                    if (this.filters.length > 0) {
                        this.source.disconnect(this.filters[0]);
                        for (var i = 1, l = this.filters.length; i < l; i++) {
                            this.filters[i - 1].disconnect(this.filters[i]);
                        }
                        this.filters[this.filters.length - 1].disconnect(this.getOutput());
                    }
                    else {
                        this.source.disconnect(this.getOutput());
                    }
                    return this;
                },
                getFilters: function () {
                    return this.filters;
                },
                setFilters: function (value) {
                    if (!value)
                        value = [];
                    if (this.isPlaying === true) {
                        this.disconnect();
                        this.filters = value;
                        this.connect();
                    }
                    else {
                        this.filters = value;
                    }
                    return this;
                },
                setDetune: function (value) {
                    this.detune = value;
                    if (this.source.detune === undefined)
                        return; // only set detune when available
                    if (this.isPlaying === true) {
                        this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
                    }
                    return this;
                },
                getDetune: function () {
                    return this.detune;
                },
                getFilter: function () {
                    return this.getFilters()[0];
                },
                setFilter: function (filter) {
                    return this.setFilters(filter ? [filter] : []);
                },
                setPlaybackRate: function (value) {
                    if (this.hasPlaybackControl === false) {
                        console.warn('THREE.Audio: this Audio has no playback control.');
                        return;
                    }
                    this.playbackRate = value;
                    if (this.isPlaying === true) {
                        this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
                    }
                    return this;
                },
                getPlaybackRate: function () {
                    return this.playbackRate;
                },
                onEnded: function () {
                    this.isPlaying = false;
                },
                getLoop: function () {
                    if (this.hasPlaybackControl === false) {
                        console.warn('THREE.Audio: this Audio has no playback control.');
                        return false;
                    }
                    return this.loop;
                },
                setLoop: function (value) {
                    if (this.hasPlaybackControl === false) {
                        console.warn('THREE.Audio: this Audio has no playback control.');
                        return;
                    }
                    this.loop = value;
                    if (this.isPlaying === true) {
                        this.source.loop = this.loop;
                    }
                    return this;
                },
                setLoopStart: function (value) {
                    this.loopStart = value;
                    return this;
                },
                setLoopEnd: function (value) {
                    this.loopEnd = value;
                    return this;
                },
                getVolume: function () {
                    return this.gain.gain.value;
                },
                setVolume: function (value) {
                    this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
                    return this;
                }
            });
            /**
             * @author mrdoob / http://mrdoob.com/
             */
            _position$3 = new Vector3();
            _quaternion$4 = new Quaternion();
            _scale$2 = new Vector3();
            _orientation$1 = new Vector3();
            PositionalAudio.prototype = Object.assign(Object.create(Audio.prototype), {
                constructor: PositionalAudio,
                getOutput: function () {
                    return this.panner;
                },
                getRefDistance: function () {
                    return this.panner.refDistance;
                },
                setRefDistance: function (value) {
                    this.panner.refDistance = value;
                    return this;
                },
                getRolloffFactor: function () {
                    return this.panner.rolloffFactor;
                },
                setRolloffFactor: function (value) {
                    this.panner.rolloffFactor = value;
                    return this;
                },
                getDistanceModel: function () {
                    return this.panner.distanceModel;
                },
                setDistanceModel: function (value) {
                    this.panner.distanceModel = value;
                    return this;
                },
                getMaxDistance: function () {
                    return this.panner.maxDistance;
                },
                setMaxDistance: function (value) {
                    this.panner.maxDistance = value;
                    return this;
                },
                setDirectionalCone: function (coneInnerAngle, coneOuterAngle, coneOuterGain) {
                    this.panner.coneInnerAngle = coneInnerAngle;
                    this.panner.coneOuterAngle = coneOuterAngle;
                    this.panner.coneOuterGain = coneOuterGain;
                    return this;
                },
                updateMatrixWorld: function (force) {
                    Object3D.prototype.updateMatrixWorld.call(this, force);
                    if (this.hasPlaybackControl === true && this.isPlaying === false)
                        return;
                    this.matrixWorld.decompose(_position$3, _quaternion$4, _scale$2);
                    _orientation$1.set(0, 0, 1).applyQuaternion(_quaternion$4);
                    var panner = this.panner;
                    if (panner.positionX) {
                        // code path for Chrome and Firefox (see #14393)
                        var endTime = this.context.currentTime + this.listener.timeDelta;
                        panner.positionX.linearRampToValueAtTime(_position$3.x, endTime);
                        panner.positionY.linearRampToValueAtTime(_position$3.y, endTime);
                        panner.positionZ.linearRampToValueAtTime(_position$3.z, endTime);
                        panner.orientationX.linearRampToValueAtTime(_orientation$1.x, endTime);
                        panner.orientationY.linearRampToValueAtTime(_orientation$1.y, endTime);
                        panner.orientationZ.linearRampToValueAtTime(_orientation$1.z, endTime);
                    }
                    else {
                        panner.setPosition(_position$3.x, _position$3.y, _position$3.z);
                        panner.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z);
                    }
                }
            });
            Object.assign(AudioAnalyser.prototype, {
                getFrequencyData: function () {
                    this.analyser.getByteFrequencyData(this.data);
                    return this.data;
                },
                getAverageFrequency: function () {
                    var value = 0, data = this.getFrequencyData();
                    for (var i = 0; i < data.length; i++) {
                        value += data[i];
                    }
                    return value / data.length;
                }
            });
            Object.assign(PropertyMixer.prototype, {
                // accumulate data in the 'incoming' region into 'accu<i>'
                accumulate: function (accuIndex, weight) {
                    // note: happily accumulating nothing when weight = 0, the caller knows
                    // the weight and shouldn't have made the call in the first place
                    var buffer = this.buffer, stride = this.valueSize, offset = accuIndex * stride + stride, currentWeight = this.cumulativeWeight;
                    if (currentWeight === 0) {
                        // accuN := incoming * weight
                        for (var i = 0; i !== stride; ++i) {
                            buffer[offset + i] = buffer[i];
                        }
                        currentWeight = weight;
                    }
                    else {
                        // accuN := accuN + incoming * weight
                        currentWeight += weight;
                        var mix = weight / currentWeight;
                        this._mixBufferRegion(buffer, offset, 0, mix, stride);
                    }
                    this.cumulativeWeight = currentWeight;
                },
                // apply the state of 'accu<i>' to the binding when accus differ
                apply: function (accuIndex) {
                    var stride = this.valueSize, buffer = this.buffer, offset = accuIndex * stride + stride, weight = this.cumulativeWeight, binding = this.binding;
                    this.cumulativeWeight = 0;
                    if (weight < 1) {
                        // accuN := accuN + original * ( 1 - cumulativeWeight )
                        var originalValueOffset = stride * 3;
                        this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
                    }
                    for (var i = stride, e = stride + stride; i !== e; ++i) {
                        if (buffer[i] !== buffer[i + stride]) {
                            // value has changed -> update scene graph
                            binding.setValue(buffer, offset);
                            break;
                        }
                    }
                },
                // remember the state of the bound property and copy it to both accus
                saveOriginalState: function () {
                    var binding = this.binding;
                    var buffer = this.buffer, stride = this.valueSize, originalValueOffset = stride * 3;
                    binding.getValue(buffer, originalValueOffset);
                    // accu[0..1] := orig -- initially detect changes against the original
                    for (var i = stride, e = originalValueOffset; i !== e; ++i) {
                        buffer[i] = buffer[originalValueOffset + (i % stride)];
                    }
                    this.cumulativeWeight = 0;
                },
                // apply the state previously taken via 'saveOriginalState' to the binding
                restoreOriginalState: function () {
                    var originalValueOffset = this.valueSize * 3;
                    this.binding.setValue(this.buffer, originalValueOffset);
                },
                // mix functions
                _select: function (buffer, dstOffset, srcOffset, t, stride) {
                    if (t >= 0.5) {
                        for (var i = 0; i !== stride; ++i) {
                            buffer[dstOffset + i] = buffer[srcOffset + i];
                        }
                    }
                },
                _slerp: function (buffer, dstOffset, srcOffset, t) {
                    Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
                },
                _lerp: function (buffer, dstOffset, srcOffset, t, stride) {
                    var s = 1 - t;
                    for (var i = 0; i !== stride; ++i) {
                        var j = dstOffset + i;
                        buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;
                    }
                }
            });
            /**
             *
             * A reference to a real property in the scene graph.
             *
             *
             * @author Ben Houston / http://clara.io/
             * @author David Sarno / http://lighthaus.us/
             * @author tschw
             */
            // Characters [].:/ are reserved for track binding syntax.
            _RESERVED_CHARS_RE = '\\[\\]\\.:\\/';
            _reservedRe = new RegExp('[' + _RESERVED_CHARS_RE + ']', 'g');
            // Attempts to allow node names from any language. ES5's `\w` regexp matches
            // only latin characters, and the unicode \p{L} is not yet supported. So
            // instead, we exclude reserved characters and match everything else.
            _wordChar = '[^' + _RESERVED_CHARS_RE + ']';
            _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace('\\.', '') + ']';
            // Parent directories, delimited by '/' or ':'. Currently unused, but must
            // be matched to parse the rest of the track name.
            _directoryRe = /((?:WC+[\/:])*)/.source.replace('WC', _wordChar);
            // Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
            _nodeRe = /(WCOD+)?/.source.replace('WCOD', _wordCharOrDot);
            // Object on target node, and accessor. May not contain reserved
            // characters. Accessor may contain any character except closing bracket.
            _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', _wordChar);
            // Property and accessor. May not contain reserved characters. Accessor may
            // contain any non-bracket characters.
            _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', _wordChar);
            _trackRe = new RegExp(''
                + '^'
                + _directoryRe
                + _nodeRe
                + _objectRe
                + _propertyRe
                + '$');
            _supportedObjectNames = ['material', 'materials', 'bones'];
            Object.assign(Composite.prototype, {
                getValue: function (array, offset) {
                    this.bind(); // bind all binding
                    var firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
                    // and only call .getValue on the first
                    if (binding !== undefined)
                        binding.getValue(array, offset);
                },
                setValue: function (array, offset) {
                    var bindings = this._bindings;
                    for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
                        bindings[i].setValue(array, offset);
                    }
                },
                bind: function () {
                    var bindings = this._bindings;
                    for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
                        bindings[i].bind();
                    }
                },
                unbind: function () {
                    var bindings = this._bindings;
                    for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
                        bindings[i].unbind();
                    }
                }
            });
            Object.assign(PropertyBinding, {
                Composite: Composite,
                create: function (root, path, parsedPath) {
                    if (!(root && root.isAnimationObjectGroup)) {
                        return new PropertyBinding(root, path, parsedPath);
                    }
                    else {
                        return new PropertyBinding.Composite(root, path, parsedPath);
                    }
                },
                /**
                 * Replaces spaces with underscores and removes unsupported characters from
                 * node names, to ensure compatibility with parseTrackName().
                 *
                 * @param {string} name Node name to be sanitized.
                 * @return {string}
                 */
                sanitizeNodeName: function (name) {
                    return name.replace(/\s/g, '_').replace(_reservedRe, '');
                },
                parseTrackName: function (trackName) {
                    var matches = _trackRe.exec(trackName);
                    if (!matches) {
                        throw new Error('PropertyBinding: Cannot parse trackName: ' + trackName);
                    }
                    var results = {
                        // directoryName: matches[ 1 ], // (tschw) currently unused
                        nodeName: matches[2],
                        objectName: matches[3],
                        objectIndex: matches[4],
                        propertyName: matches[5],
                        propertyIndex: matches[6]
                    };
                    var lastDot = results.nodeName && results.nodeName.lastIndexOf('.');
                    if (lastDot !== undefined && lastDot !== -1) {
                        var objectName = results.nodeName.substring(lastDot + 1);
                        // Object names must be checked against a whitelist. Otherwise, there
                        // is no way to parse 'foo.bar.baz': 'baz' must be a property, but
                        // 'bar' could be the objectName, or part of a nodeName (which can
                        // include '.' characters).
                        if (_supportedObjectNames.indexOf(objectName) !== -1) {
                            results.nodeName = results.nodeName.substring(0, lastDot);
                            results.objectName = objectName;
                        }
                    }
                    if (results.propertyName === null || results.propertyName.length === 0) {
                        throw new Error('PropertyBinding: can not parse propertyName from trackName: ' + trackName);
                    }
                    return results;
                },
                findNode: function (root, nodeName) {
                    if (!nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
                        return root;
                    }
                    // search into skeleton bones.
                    if (root.skeleton) {
                        var bone = root.skeleton.getBoneByName(nodeName);
                        if (bone !== undefined) {
                            return bone;
                        }
                    }
                    // search into node subtree.
                    if (root.children) {
                        var searchNodeSubtree = function (children) {
                            for (var i = 0; i < children.length; i++) {
                                var childNode = children[i];
                                if (childNode.name === nodeName || childNode.uuid === nodeName) {
                                    return childNode;
                                }
                                var result = searchNodeSubtree(childNode.children);
                                if (result)
                                    return result;
                            }
                            return null;
                        };
                        var subTreeNode = searchNodeSubtree(root.children);
                        if (subTreeNode) {
                            return subTreeNode;
                        }
                    }
                    return null;
                }
            });
            Object.assign(PropertyBinding.prototype, {
                // these are used to "bind" a nonexistent property
                _getValue_unavailable: function () { },
                _setValue_unavailable: function () { },
                BindingType: {
                    Direct: 0,
                    EntireArray: 1,
                    ArrayElement: 2,
                    HasFromToArray: 3
                },
                Versioning: {
                    None: 0,
                    NeedsUpdate: 1,
                    MatrixWorldNeedsUpdate: 2
                },
                GetterByBindingType: [
                    function getValue_direct(buffer, offset) {
                        buffer[offset] = this.node[this.propertyName];
                    },
                    function getValue_array(buffer, offset) {
                        var source = this.resolvedProperty;
                        for (var i = 0, n = source.length; i !== n; ++i) {
                            buffer[offset++] = source[i];
                        }
                    },
                    function getValue_arrayElement(buffer, offset) {
                        buffer[offset] = this.resolvedProperty[this.propertyIndex];
                    },
                    function getValue_toArray(buffer, offset) {
                        this.resolvedProperty.toArray(buffer, offset);
                    }
                ],
                SetterByBindingTypeAndVersioning: [
                    [
                        // Direct
                        function setValue_direct(buffer, offset) {
                            this.targetObject[this.propertyName] = buffer[offset];
                        },
                        function setValue_direct_setNeedsUpdate(buffer, offset) {
                            this.targetObject[this.propertyName] = buffer[offset];
                            this.targetObject.needsUpdate = true;
                        },
                        function setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
                            this.targetObject[this.propertyName] = buffer[offset];
                            this.targetObject.matrixWorldNeedsUpdate = true;
                        }
                    ], [
                        // EntireArray
                        function setValue_array(buffer, offset) {
                            var dest = this.resolvedProperty;
                            for (var i = 0, n = dest.length; i !== n; ++i) {
                                dest[i] = buffer[offset++];
                            }
                        },
                        function setValue_array_setNeedsUpdate(buffer, offset) {
                            var dest = this.resolvedProperty;
                            for (var i = 0, n = dest.length; i !== n; ++i) {
                                dest[i] = buffer[offset++];
                            }
                            this.targetObject.needsUpdate = true;
                        },
                        function setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
                            var dest = this.resolvedProperty;
                            for (var i = 0, n = dest.length; i !== n; ++i) {
                                dest[i] = buffer[offset++];
                            }
                            this.targetObject.matrixWorldNeedsUpdate = true;
                        }
                    ], [
                        // ArrayElement
                        function setValue_arrayElement(buffer, offset) {
                            this.resolvedProperty[this.propertyIndex] = buffer[offset];
                        },
                        function setValue_arrayElement_setNeedsUpdate(buffer, offset) {
                            this.resolvedProperty[this.propertyIndex] = buffer[offset];
                            this.targetObject.needsUpdate = true;
                        },
                        function setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
                            this.resolvedProperty[this.propertyIndex] = buffer[offset];
                            this.targetObject.matrixWorldNeedsUpdate = true;
                        }
                    ], [
                        // HasToFromArray
                        function setValue_fromArray(buffer, offset) {
                            this.resolvedProperty.fromArray(buffer, offset);
                        },
                        function setValue_fromArray_setNeedsUpdate(buffer, offset) {
                            this.resolvedProperty.fromArray(buffer, offset);
                            this.targetObject.needsUpdate = true;
                        },
                        function setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
                            this.resolvedProperty.fromArray(buffer, offset);
                            this.targetObject.matrixWorldNeedsUpdate = true;
                        }
                    ]
                ],
                getValue: function getValue_unbound(targetArray, offset) {
                    this.bind();
                    this.getValue(targetArray, offset);
                    // Note: This class uses a State pattern on a per-method basis:
                    // 'bind' sets 'this.getValue' / 'setValue' and shadows the
                    // prototype version of these methods with one that represents
                    // the bound state. When the property is not found, the methods
                    // become no-ops.
                },
                setValue: function getValue_unbound(sourceArray, offset) {
                    this.bind();
                    this.setValue(sourceArray, offset);
                },
                // create getter / setter pair for a property in the scene graph
                bind: function () {
                    var targetObject = this.node, parsedPath = this.parsedPath, objectName = parsedPath.objectName, propertyName = parsedPath.propertyName, propertyIndex = parsedPath.propertyIndex;
                    if (!targetObject) {
                        targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
                        this.node = targetObject;
                    }
                    // set fail state so we can just 'return' on error
                    this.getValue = this._getValue_unavailable;
                    this.setValue = this._setValue_unavailable;
                    // ensure there is a value node
                    if (!targetObject) {
                        console.error('THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.');
                        return;
                    }
                    if (objectName) {
                        var objectIndex = parsedPath.objectIndex;
                        // special cases were we need to reach deeper into the hierarchy to get the face materials....
                        switch (objectName) {
                            case 'materials':
                                if (!targetObject.material) {
                                    console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this);
                                    return;
                                }
                                if (!targetObject.material.materials) {
                                    console.error('THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this);
                                    return;
                                }
                                targetObject = targetObject.material.materials;
                                break;
                            case 'bones':
                                if (!targetObject.skeleton) {
                                    console.error('THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this);
                                    return;
                                }
                                // potential future optimization: skip this if propertyIndex is already an integer
                                // and convert the integer string to a true integer.
                                targetObject = targetObject.skeleton.bones;
                                // support resolving morphTarget names into indices.
                                for (var i = 0; i < targetObject.length; i++) {
                                    if (targetObject[i].name === objectIndex) {
                                        objectIndex = i;
                                        break;
                                    }
                                }
                                break;
                            default:
                                if (targetObject[objectName] === undefined) {
                                    console.error('THREE.PropertyBinding: Can not bind to objectName of node undefined.', this);
                                    return;
                                }
                                targetObject = targetObject[objectName];
                        }
                        if (objectIndex !== undefined) {
                            if (targetObject[objectIndex] === undefined) {
                                console.error('THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject);
                                return;
                            }
                            targetObject = targetObject[objectIndex];
                        }
                    }
                    // resolve property
                    var nodeProperty = targetObject[propertyName];
                    if (nodeProperty === undefined) {
                        var nodeName = parsedPath.nodeName;
                        console.error('THREE.PropertyBinding: Trying to update property for track: ' + nodeName +
                            '.' + propertyName + ' but it wasn\'t found.', targetObject);
                        return;
                    }
                    // determine versioning scheme
                    var versioning = this.Versioning.None;
                    this.targetObject = targetObject;
                    if (targetObject.needsUpdate !== undefined) { // material
                        versioning = this.Versioning.NeedsUpdate;
                    }
                    else if (targetObject.matrixWorldNeedsUpdate !== undefined) { // node transform
                        versioning = this.Versioning.MatrixWorldNeedsUpdate;
                    }
                    // determine how the property gets bound
                    var bindingType = this.BindingType.Direct;
                    if (propertyIndex !== undefined) {
                        // access a sub element of the property array (only primitives are supported right now)
                        if (propertyName === "morphTargetInfluences") {
                            // potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.
                            // support resolving morphTarget names into indices.
                            if (!targetObject.geometry) {
                                console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this);
                                return;
                            }
                            if (targetObject.geometry.isBufferGeometry) {
                                if (!targetObject.geometry.morphAttributes) {
                                    console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this);
                                    return;
                                }
                                for (var i = 0; i < this.node.geometry.morphAttributes.position.length; i++) {
                                    if (targetObject.geometry.morphAttributes.position[i].name === propertyIndex) {
                                        propertyIndex = i;
                                        break;
                                    }
                                }
                            }
                            else {
                                if (!targetObject.geometry.morphTargets) {
                                    console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.', this);
                                    return;
                                }
                                for (var i = 0; i < this.node.geometry.morphTargets.length; i++) {
                                    if (targetObject.geometry.morphTargets[i].name === propertyIndex) {
                                        propertyIndex = i;
                                        break;
                                    }
                                }
                            }
                        }
                        bindingType = this.BindingType.ArrayElement;
                        this.resolvedProperty = nodeProperty;
                        this.propertyIndex = propertyIndex;
                    }
                    else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {
                        // must use copy for Object3D.Euler/Quaternion
                        bindingType = this.BindingType.HasFromToArray;
                        this.resolvedProperty = nodeProperty;
                    }
                    else if (Array.isArray(nodeProperty)) {
                        bindingType = this.BindingType.EntireArray;
                        this.resolvedProperty = nodeProperty;
                    }
                    else {
                        this.propertyName = propertyName;
                    }
                    // select getter / setter
                    this.getValue = this.GetterByBindingType[bindingType];
                    this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
                },
                unbind: function () {
                    this.node = null;
                    // back to the prototype version of getValue / setValue
                    // note: avoiding to mutate the shape of 'this' via 'delete'
                    this.getValue = this._getValue_unbound;
                    this.setValue = this._setValue_unbound;
                }
            });
            //!\ DECLARE ALIAS AFTER assign prototype !
            Object.assign(PropertyBinding.prototype, {
                // initial state of these methods that calls 'bind'
                _getValue_unbound: PropertyBinding.prototype.getValue,
                _setValue_unbound: PropertyBinding.prototype.setValue,
            });
            Object.assign(AnimationObjectGroup.prototype, {
                isAnimationObjectGroup: true,
                add: function () {
                    var objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, nBindings = bindings.length, knownObject = undefined;
                    for (var i = 0, n = arguments.length; i !== n; ++i) {
                        var object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];
                        if (index === undefined) {
                            // unknown object -> add it to the ACTIVE region
                            index = nObjects++;
                            indicesByUUID[uuid] = index;
                            objects.push(object);
                            // accounting is done, now do the same for all bindings
                            for (var j = 0, m = nBindings; j !== m; ++j) {
                                bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
                            }
                        }
                        else if (index < nCachedObjects) {
                            knownObject = objects[index];
                            // move existing object to the ACTIVE region
                            var firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex];
                            indicesByUUID[lastCachedObject.uuid] = index;
                            objects[index] = lastCachedObject;
                            indicesByUUID[uuid] = firstActiveIndex;
                            objects[firstActiveIndex] = object;
                            // accounting is done, now do the same for all bindings
                            for (var j = 0, m = nBindings; j !== m; ++j) {
                                var bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], binding = bindingsForPath[index];
                                bindingsForPath[index] = lastCached;
                                if (binding === undefined) {
                                    // since we do not bother to create new bindings
                                    // for objects that are cached, the binding may
                                    // or may not exist
                                    binding = new PropertyBinding(object, paths[j], parsedPaths[j]);
                                }
                                bindingsForPath[firstActiveIndex] = binding;
                            }
                        }
                        else if (objects[index] !== knownObject) {
                            console.error('THREE.AnimationObjectGroup: Different objects with the same UUID ' +
                                'detected. Clean the caches or recreate your infrastructure when reloading scenes.');
                        } // else the object is already where we want it to be
                    } // for arguments
                    this.nCachedObjects_ = nCachedObjects;
                },
                remove: function () {
                    var objects = this._objects, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
                    for (var i = 0, n = arguments.length; i !== n; ++i) {
                        var object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];
                        if (index !== undefined && index >= nCachedObjects) {
                            // move existing object into the CACHED region
                            var lastCachedIndex = nCachedObjects++, firstActiveObject = objects[lastCachedIndex];
                            indicesByUUID[firstActiveObject.uuid] = index;
                            objects[index] = firstActiveObject;
                            indicesByUUID[uuid] = lastCachedIndex;
                            objects[lastCachedIndex] = object;
                            // accounting is done, now do the same for all bindings
                            for (var j = 0, m = nBindings; j !== m; ++j) {
                                var bindingsForPath = bindings[j], firstActive = bindingsForPath[lastCachedIndex], binding = bindingsForPath[index];
                                bindingsForPath[index] = firstActive;
                                bindingsForPath[lastCachedIndex] = binding;
                            }
                        }
                    } // for arguments
                    this.nCachedObjects_ = nCachedObjects;
                },
                // remove & forget
                uncache: function () {
                    var objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
                    for (var i = 0, n = arguments.length; i !== n; ++i) {
                        var object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];
                        if (index !== undefined) {
                            delete indicesByUUID[uuid];
                            if (index < nCachedObjects) {
                                // object is cached, shrink the CACHED region
                                var firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex], lastIndex = --nObjects, lastObject = objects[lastIndex];
                                // last cached object takes this object's place
                                indicesByUUID[lastCachedObject.uuid] = index;
                                objects[index] = lastCachedObject;
                                // last object goes to the activated slot and pop
                                indicesByUUID[lastObject.uuid] = firstActiveIndex;
                                objects[firstActiveIndex] = lastObject;
                                objects.pop();
                                // accounting is done, now do the same for all bindings
                                for (var j = 0, m = nBindings; j !== m; ++j) {
                                    var bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], last = bindingsForPath[lastIndex];
                                    bindingsForPath[index] = lastCached;
                                    bindingsForPath[firstActiveIndex] = last;
                                    bindingsForPath.pop();
                                }
                            }
                            else {
                                // object is active, just swap with the last and pop
                                var lastIndex = --nObjects, lastObject = objects[lastIndex];
                                indicesByUUID[lastObject.uuid] = index;
                                objects[index] = lastObject;
                                objects.pop();
                                // accounting is done, now do the same for all bindings
                                for (var j = 0, m = nBindings; j !== m; ++j) {
                                    var bindingsForPath = bindings[j];
                                    bindingsForPath[index] = bindingsForPath[lastIndex];
                                    bindingsForPath.pop();
                                }
                            } // cached or active
                        } // if object is known
                    } // for arguments
                    this.nCachedObjects_ = nCachedObjects;
                },
                // Internal interface used by befriended PropertyBinding.Composite:
                subscribe_: function (path, parsedPath) {
                    // returns an array of bindings for the given path that is changed
                    // according to the contained objects in the group
                    var indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path], bindings = this._bindings;
                    if (index !== undefined)
                        return bindings[index];
                    var paths = this._paths, parsedPaths = this._parsedPaths, objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, bindingsForPath = new Array(nObjects);
                    index = bindings.length;
                    indicesByPath[path] = index;
                    paths.push(path);
                    parsedPaths.push(parsedPath);
                    bindings.push(bindingsForPath);
                    for (var i = nCachedObjects, n = objects.length; i !== n; ++i) {
                        var object = objects[i];
                        bindingsForPath[i] = new PropertyBinding(object, path, parsedPath);
                    }
                    return bindingsForPath;
                },
                unsubscribe_: function (path) {
                    // tells the group to forget about a property path and no longer
                    // update the array previously obtained with 'subscribe_'
                    var indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path];
                    if (index !== undefined) {
                        var paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, lastBindingsIndex = bindings.length - 1, lastBindings = bindings[lastBindingsIndex], lastBindingsPath = path[lastBindingsIndex];
                        indicesByPath[lastBindingsPath] = index;
                        bindings[index] = lastBindings;
                        bindings.pop();
                        parsedPaths[index] = parsedPaths[lastBindingsIndex];
                        parsedPaths.pop();
                        paths[index] = paths[lastBindingsIndex];
                        paths.pop();
                    }
                }
            });
            Object.assign(AnimationAction.prototype, {
                // State & Scheduling
                play: function () {
                    this._mixer._activateAction(this);
                    return this;
                },
                stop: function () {
                    this._mixer._deactivateAction(this);
                    return this.reset();
                },
                reset: function () {
                    this.paused = false;
                    this.enabled = true;
                    this.time = 0; // restart clip
                    this._loopCount = -1; // forget previous loops
                    this._startTime = null; // forget scheduling
                    return this.stopFading().stopWarping();
                },
                isRunning: function () {
                    return this.enabled && !this.paused && this.timeScale !== 0 &&
                        this._startTime === null && this._mixer._isActiveAction(this);
                },
                // return true when play has been called
                isScheduled: function () {
                    return this._mixer._isActiveAction(this);
                },
                startAt: function (time) {
                    this._startTime = time;
                    return this;
                },
                setLoop: function (mode, repetitions) {
                    this.loop = mode;
                    this.repetitions = repetitions;
                    return this;
                },
                // Weight
                // set the weight stopping any scheduled fading
                // although .enabled = false yields an effective weight of zero, this
                // method does *not* change .enabled, because it would be confusing
                setEffectiveWeight: function (weight) {
                    this.weight = weight;
                    // note: same logic as when updated at runtime
                    this._effectiveWeight = this.enabled ? weight : 0;
                    return this.stopFading();
                },
                // return the weight considering fading and .enabled
                getEffectiveWeight: function () {
                    return this._effectiveWeight;
                },
                fadeIn: function (duration) {
                    return this._scheduleFading(duration, 0, 1);
                },
                fadeOut: function (duration) {
                    return this._scheduleFading(duration, 1, 0);
                },
                crossFadeFrom: function (fadeOutAction, duration, warp) {
                    fadeOutAction.fadeOut(duration);
                    this.fadeIn(duration);
                    if (warp) {
                        var fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
                        fadeOutAction.warp(1.0, startEndRatio, duration);
                        this.warp(endStartRatio, 1.0, duration);
                    }
                    return this;
                },
                crossFadeTo: function (fadeInAction, duration, warp) {
                    return fadeInAction.crossFadeFrom(this, duration, warp);
                },
                stopFading: function () {
                    var weightInterpolant = this._weightInterpolant;
                    if (weightInterpolant !== null) {
                        this._weightInterpolant = null;
                        this._mixer._takeBackControlInterpolant(weightInterpolant);
                    }
                    return this;
                },
                // Time Scale Control
                // set the time scale stopping any scheduled warping
                // although .paused = true yields an effective time scale of zero, this
                // method does *not* change .paused, because it would be confusing
                setEffectiveTimeScale: function (timeScale) {
                    this.timeScale = timeScale;
                    this._effectiveTimeScale = this.paused ? 0 : timeScale;
                    return this.stopWarping();
                },
                // return the time scale considering warping and .paused
                getEffectiveTimeScale: function () {
                    return this._effectiveTimeScale;
                },
                setDuration: function (duration) {
                    this.timeScale = this._clip.duration / duration;
                    return this.stopWarping();
                },
                syncWith: function (action) {
                    this.time = action.time;
                    this.timeScale = action.timeScale;
                    return this.stopWarping();
                },
                halt: function (duration) {
                    return this.warp(this._effectiveTimeScale, 0, duration);
                },
                warp: function (startTimeScale, endTimeScale, duration) {
                    var mixer = this._mixer, now = mixer.time, interpolant = this._timeScaleInterpolant, timeScale = this.timeScale;
                    if (interpolant === null) {
                        interpolant = mixer._lendControlInterpolant();
                        this._timeScaleInterpolant = interpolant;
                    }
                    var times = interpolant.parameterPositions, values = interpolant.sampleValues;
                    times[0] = now;
                    times[1] = now + duration;
                    values[0] = startTimeScale / timeScale;
                    values[1] = endTimeScale / timeScale;
                    return this;
                },
                stopWarping: function () {
                    var timeScaleInterpolant = this._timeScaleInterpolant;
                    if (timeScaleInterpolant !== null) {
                        this._timeScaleInterpolant = null;
                        this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
                    }
                    return this;
                },
                // Object Accessors
                getMixer: function () {
                    return this._mixer;
                },
                getClip: function () {
                    return this._clip;
                },
                getRoot: function () {
                    return this._localRoot || this._mixer._root;
                },
                // Interna
                _update: function (time, deltaTime, timeDirection, accuIndex) {
                    // called by the mixer
                    if (!this.enabled) {
                        // call ._updateWeight() to update ._effectiveWeight
                        this._updateWeight(time);
                        return;
                    }
                    var startTime = this._startTime;
                    if (startTime !== null) {
                        // check for scheduled start of action
                        var timeRunning = (time - startTime) * timeDirection;
                        if (timeRunning < 0 || timeDirection === 0) {
                            return; // yet to come / don't decide when delta = 0
                        }
                        // start
                        this._startTime = null; // unschedule
                        deltaTime = timeDirection * timeRunning;
                    }
                    // apply time scale and advance time
                    deltaTime *= this._updateTimeScale(time);
                    var clipTime = this._updateTime(deltaTime);
                    // note: _updateTime may disable the action resulting in
                    // an effective weight of 0
                    var weight = this._updateWeight(time);
                    if (weight > 0) {
                        var interpolants = this._interpolants;
                        var propertyMixers = this._propertyBindings;
                        for (var j = 0, m = interpolants.length; j !== m; ++j) {
                            interpolants[j].evaluate(clipTime);
                            propertyMixers[j].accumulate(accuIndex, weight);
                        }
                    }
                },
                _updateWeight: function (time) {
                    var weight = 0;
                    if (this.enabled) {
                        weight = this.weight;
                        var interpolant = this._weightInterpolant;
                        if (interpolant !== null) {
                            var interpolantValue = interpolant.evaluate(time)[0];
                            weight *= interpolantValue;
                            if (time > interpolant.parameterPositions[1]) {
                                this.stopFading();
                                if (interpolantValue === 0) {
                                    // faded out, disable
                                    this.enabled = false;
                                }
                            }
                        }
                    }
                    this._effectiveWeight = weight;
                    return weight;
                },
                _updateTimeScale: function (time) {
                    var timeScale = 0;
                    if (!this.paused) {
                        timeScale = this.timeScale;
                        var interpolant = this._timeScaleInterpolant;
                        if (interpolant !== null) {
                            var interpolantValue = interpolant.evaluate(time)[0];
                            timeScale *= interpolantValue;
                            if (time > interpolant.parameterPositions[1]) {
                                this.stopWarping();
                                if (timeScale === 0) {
                                    // motion has halted, pause
                                    this.paused = true;
                                }
                                else {
                                    // warp done - apply final time scale
                                    this.timeScale = timeScale;
                                }
                            }
                        }
                    }
                    this._effectiveTimeScale = timeScale;
                    return timeScale;
                },
                _updateTime: function (deltaTime) {
                    var time = this.time + deltaTime;
                    var duration = this._clip.duration;
                    var loop = this.loop;
                    var loopCount = this._loopCount;
                    var pingPong = (loop === LoopPingPong);
                    if (deltaTime === 0) {
                        if (loopCount === -1)
                            return time;
                        return (pingPong && (loopCount & 1) === 1) ? duration - time : time;
                    }
                    if (loop === LoopOnce) {
                        if (loopCount === -1) {
                            // just started
                            this._loopCount = 0;
                            this._setEndings(true, true, false);
                        }
                        handle_stop: {
                            if (time >= duration) {
                                time = duration;
                            }
                            else if (time < 0) {
                                time = 0;
                            }
                            else {
                                this.time = time;
                                break handle_stop;
                            }
                            if (this.clampWhenFinished)
                                this.paused = true;
                            else
                                this.enabled = false;
                            this.time = time;
                            this._mixer.dispatchEvent({
                                type: 'finished', action: this,
                                direction: deltaTime < 0 ? -1 : 1
                            });
                        }
                    }
                    else { // repetitive Repeat or PingPong
                        if (loopCount === -1) {
                            // just started
                            if (deltaTime >= 0) {
                                loopCount = 0;
                                this._setEndings(true, this.repetitions === 0, pingPong);
                            }
                            else {
                                // when looping in reverse direction, the initial
                                // transition through zero counts as a repetition,
                                // so leave loopCount at -1
                                this._setEndings(this.repetitions === 0, true, pingPong);
                            }
                        }
                        if (time >= duration || time < 0) {
                            // wrap around
                            var loopDelta = Math.floor(time / duration); // signed
                            time -= duration * loopDelta;
                            loopCount += Math.abs(loopDelta);
                            var pending = this.repetitions - loopCount;
                            if (pending <= 0) {
                                // have to stop (switch state, clamp time, fire event)
                                if (this.clampWhenFinished)
                                    this.paused = true;
                                else
                                    this.enabled = false;
                                time = deltaTime > 0 ? duration : 0;
                                this.time = time;
                                this._mixer.dispatchEvent({
                                    type: 'finished', action: this,
                                    direction: deltaTime > 0 ? 1 : -1
                                });
                            }
                            else {
                                // keep running
                                if (pending === 1) {
                                    // entering the last round
                                    var atStart = deltaTime < 0;
                                    this._setEndings(atStart, !atStart, pingPong);
                                }
                                else {
                                    this._setEndings(false, false, pingPong);
                                }
                                this._loopCount = loopCount;
                                this.time = time;
                                this._mixer.dispatchEvent({
                                    type: 'loop', action: this, loopDelta: loopDelta
                                });
                            }
                        }
                        else {
                            this.time = time;
                        }
                        if (pingPong && (loopCount & 1) === 1) {
                            // invert time for the "pong round"
                            return duration - time;
                        }
                    }
                    return time;
                },
                _setEndings: function (atStart, atEnd, pingPong) {
                    var settings = this._interpolantSettings;
                    if (pingPong) {
                        settings.endingStart = ZeroSlopeEnding;
                        settings.endingEnd = ZeroSlopeEnding;
                    }
                    else {
                        // assuming for LoopOnce atStart == atEnd == true
                        if (atStart) {
                            settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
                        }
                        else {
                            settings.endingStart = WrapAroundEnding;
                        }
                        if (atEnd) {
                            settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
                        }
                        else {
                            settings.endingEnd = WrapAroundEnding;
                        }
                    }
                },
                _scheduleFading: function (duration, weightNow, weightThen) {
                    var mixer = this._mixer, now = mixer.time, interpolant = this._weightInterpolant;
                    if (interpolant === null) {
                        interpolant = mixer._lendControlInterpolant();
                        this._weightInterpolant = interpolant;
                    }
                    var times = interpolant.parameterPositions, values = interpolant.sampleValues;
                    times[0] = now;
                    values[0] = weightNow;
                    times[1] = now + duration;
                    values[1] = weightThen;
                    return this;
                }
            });
            AnimationMixer.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
                constructor: AnimationMixer,
                _bindAction: function (action, prototypeAction) {
                    var root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName, bindingsByName = bindingsByRoot[rootUuid];
                    if (bindingsByName === undefined) {
                        bindingsByName = {};
                        bindingsByRoot[rootUuid] = bindingsByName;
                    }
                    for (var i = 0; i !== nTracks; ++i) {
                        var track = tracks[i], trackName = track.name, binding = bindingsByName[trackName];
                        if (binding !== undefined) {
                            bindings[i] = binding;
                        }
                        else {
                            binding = bindings[i];
                            if (binding !== undefined) {
                                // existing binding, make sure the cache knows
                                if (binding._cacheIndex === null) {
                                    ++binding.referenceCount;
                                    this._addInactiveBinding(binding, rootUuid, trackName);
                                }
                                continue;
                            }
                            var path = prototypeAction && prototypeAction.
                                _propertyBindings[i].binding.parsedPath;
                            binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
                            ++binding.referenceCount;
                            this._addInactiveBinding(binding, rootUuid, trackName);
                            bindings[i] = binding;
                        }
                        interpolants[i].resultBuffer = binding.buffer;
                    }
                },
                _activateAction: function (action) {
                    if (!this._isActiveAction(action)) {
                        if (action._cacheIndex === null) {
                            // this action has been forgotten by the cache, but the user
                            // appears to be still using it -> rebind
                            var rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
                            this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);
                            this._addInactiveAction(action, clipUuid, rootUuid);
                        }
                        var bindings = action._propertyBindings;
                        // increment reference counts / sort out state
                        for (var i = 0, n = bindings.length; i !== n; ++i) {
                            var binding = bindings[i];
                            if (binding.useCount++ === 0) {
                                this._lendBinding(binding);
                                binding.saveOriginalState();
                            }
                        }
                        this._lendAction(action);
                    }
                },
                _deactivateAction: function (action) {
                    if (this._isActiveAction(action)) {
                        var bindings = action._propertyBindings;
                        // decrement reference counts / sort out state
                        for (var i = 0, n = bindings.length; i !== n; ++i) {
                            var binding = bindings[i];
                            if (--binding.useCount === 0) {
                                binding.restoreOriginalState();
                                this._takeBackBinding(binding);
                            }
                        }
                        this._takeBackAction(action);
                    }
                },
                // Memory manager
                _initMemoryManager: function () {
                    this._actions = []; // 'nActiveActions' followed by inactive ones
                    this._nActiveActions = 0;
                    this._actionsByClip = {};
                    // inside:
                    // {
                    // 	knownActions: Array< AnimationAction > - used as prototypes
                    // 	actionByRoot: AnimationAction - lookup
                    // }
                    this._bindings = []; // 'nActiveBindings' followed by inactive ones
                    this._nActiveBindings = 0;
                    this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >
                    this._controlInterpolants = []; // same game as above
                    this._nActiveControlInterpolants = 0;
                    var scope = this;
                    this.stats = {
                        actions: {
                            get total() {
                                return scope._actions.length;
                            },
                            get inUse() {
                                return scope._nActiveActions;
                            }
                        },
                        bindings: {
                            get total() {
                                return scope._bindings.length;
                            },
                            get inUse() {
                                return scope._nActiveBindings;
                            }
                        },
                        controlInterpolants: {
                            get total() {
                                return scope._controlInterpolants.length;
                            },
                            get inUse() {
                                return scope._nActiveControlInterpolants;
                            }
                        }
                    };
                },
                // Memory management for AnimationAction objects
                _isActiveAction: function (action) {
                    var index = action._cacheIndex;
                    return index !== null && index < this._nActiveActions;
                },
                _addInactiveAction: function (action, clipUuid, rootUuid) {
                    var actions = this._actions, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
                    if (actionsForClip === undefined) {
                        actionsForClip = {
                            knownActions: [action],
                            actionByRoot: {}
                        };
                        action._byClipCacheIndex = 0;
                        actionsByClip[clipUuid] = actionsForClip;
                    }
                    else {
                        var knownActions = actionsForClip.knownActions;
                        action._byClipCacheIndex = knownActions.length;
                        knownActions.push(action);
                    }
                    action._cacheIndex = actions.length;
                    actions.push(action);
                    actionsForClip.actionByRoot[rootUuid] = action;
                },
                _removeInactiveAction: function (action) {
                    var actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;
                    lastInactiveAction._cacheIndex = cacheIndex;
                    actions[cacheIndex] = lastInactiveAction;
                    actions.pop();
                    action._cacheIndex = null;
                    var clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
                    lastKnownAction._byClipCacheIndex = byClipCacheIndex;
                    knownActionsForClip[byClipCacheIndex] = lastKnownAction;
                    knownActionsForClip.pop();
                    action._byClipCacheIndex = null;
                    var actionByRoot = actionsForClip.actionByRoot, rootUuid = (action._localRoot || this._root).uuid;
                    delete actionByRoot[rootUuid];
                    if (knownActionsForClip.length === 0) {
                        delete actionsByClip[clipUuid];
                    }
                    this._removeInactiveBindingsForAction(action);
                },
                _removeInactiveBindingsForAction: function (action) {
                    var bindings = action._propertyBindings;
                    for (var i = 0, n = bindings.length; i !== n; ++i) {
                        var binding = bindings[i];
                        if (--binding.referenceCount === 0) {
                            this._removeInactiveBinding(binding);
                        }
                    }
                },
                _lendAction: function (action) {
                    // [ active actions |  inactive actions  ]
                    // [  active actions >| inactive actions ]
                    //                 s        a
                    //                  <-swap->
                    //                 a        s
                    var actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];
                    action._cacheIndex = lastActiveIndex;
                    actions[lastActiveIndex] = action;
                    firstInactiveAction._cacheIndex = prevIndex;
                    actions[prevIndex] = firstInactiveAction;
                },
                _takeBackAction: function (action) {
                    // [  active actions  | inactive actions ]
                    // [ active actions |< inactive actions  ]
                    //        a        s
                    //         <-swap->
                    //        s        a
                    var actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];
                    action._cacheIndex = firstInactiveIndex;
                    actions[firstInactiveIndex] = action;
                    lastActiveAction._cacheIndex = prevIndex;
                    actions[prevIndex] = lastActiveAction;
                },
                // Memory management for PropertyMixer objects
                _addInactiveBinding: function (binding, rootUuid, trackName) {
                    var bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], bindings = this._bindings;
                    if (bindingByName === undefined) {
                        bindingByName = {};
                        bindingsByRoot[rootUuid] = bindingByName;
                    }
                    bindingByName[trackName] = binding;
                    binding._cacheIndex = bindings.length;
                    bindings.push(binding);
                },
                _removeInactiveBinding: function (binding) {
                    var bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
                    lastInactiveBinding._cacheIndex = cacheIndex;
                    bindings[cacheIndex] = lastInactiveBinding;
                    bindings.pop();
                    delete bindingByName[trackName];
                    if (Object.keys(bindingByName).length === 0) {
                        delete bindingsByRoot[rootUuid];
                    }
                },
                _lendBinding: function (binding) {
                    var bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
                    binding._cacheIndex = lastActiveIndex;
                    bindings[lastActiveIndex] = binding;
                    firstInactiveBinding._cacheIndex = prevIndex;
                    bindings[prevIndex] = firstInactiveBinding;
                },
                _takeBackBinding: function (binding) {
                    var bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
                    binding._cacheIndex = firstInactiveIndex;
                    bindings[firstInactiveIndex] = binding;
                    lastActiveBinding._cacheIndex = prevIndex;
                    bindings[prevIndex] = lastActiveBinding;
                },
                // Memory management of Interpolants for weight and time scale
                _lendControlInterpolant: function () {
                    var interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++, interpolant = interpolants[lastActiveIndex];
                    if (interpolant === undefined) {
                        interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
                        interpolant.__cacheIndex = lastActiveIndex;
                        interpolants[lastActiveIndex] = interpolant;
                    }
                    return interpolant;
                },
                _takeBackControlInterpolant: function (interpolant) {
                    var interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];
                    interpolant.__cacheIndex = firstInactiveIndex;
                    interpolants[firstInactiveIndex] = interpolant;
                    lastActiveInterpolant.__cacheIndex = prevIndex;
                    interpolants[prevIndex] = lastActiveInterpolant;
                },
                _controlInterpolantsResultBuffer: new Float32Array(1),
                // return an action for a clip optionally using a custom root target
                // object (this method allocates a lot of dynamic memory in case a
                // previously unknown clip/root combination is specified)
                clipAction: function (clip, optionalRoot) {
                    var root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === 'string' ?
                        AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject !== null ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid], prototypeAction = null;
                    if (actionsForClip !== undefined) {
                        var existingAction = actionsForClip.actionByRoot[rootUuid];
                        if (existingAction !== undefined) {
                            return existingAction;
                        }
                        // we know the clip, so we don't have to parse all
                        // the bindings again but can just copy
                        prototypeAction = actionsForClip.knownActions[0];
                        // also, take the clip from the prototype action
                        if (clipObject === null)
                            clipObject = prototypeAction._clip;
                    }
                    // clip must be known when specified via string
                    if (clipObject === null)
                        return null;
                    // allocate all resources required to run it
                    var newAction = new AnimationAction(this, clipObject, optionalRoot);
                    this._bindAction(newAction, prototypeAction);
                    // and make the action known to the memory manager
                    this._addInactiveAction(newAction, clipUuid, rootUuid);
                    return newAction;
                },
                // get an existing action
                existingAction: function (clip, optionalRoot) {
                    var root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === 'string' ?
                        AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];
                    if (actionsForClip !== undefined) {
                        return actionsForClip.actionByRoot[rootUuid] || null;
                    }
                    return null;
                },
                // deactivates all previously scheduled actions
                stopAllAction: function () {
                    var actions = this._actions, nActions = this._nActiveActions, bindings = this._bindings, nBindings = this._nActiveBindings;
                    this._nActiveActions = 0;
                    this._nActiveBindings = 0;
                    for (var i = 0; i !== nActions; ++i) {
                        actions[i].reset();
                    }
                    for (var i = 0; i !== nBindings; ++i) {
                        bindings[i].useCount = 0;
                    }
                    return this;
                },
                // advance the time and update apply the animation
                update: function (deltaTime) {
                    deltaTime *= this.timeScale;
                    var actions = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1;
                    // run active actions
                    for (var i = 0; i !== nActions; ++i) {
                        var action = actions[i];
                        action._update(time, deltaTime, timeDirection, accuIndex);
                    }
                    // update scene graph
                    var bindings = this._bindings, nBindings = this._nActiveBindings;
                    for (var i = 0; i !== nBindings; ++i) {
                        bindings[i].apply(accuIndex);
                    }
                    return this;
                },
                // Allows you to seek to a specific time in an animation.
                setTime: function (timeInSeconds) {
                    this.time = 0; // Zero out time attribute for AnimationMixer object;
                    for (var i = 0; i < this._actions.length; i++) {
                        this._actions[i].time = 0; // Zero out time attribute for all associated AnimationAction objects.
                    }
                    return this.update(timeInSeconds); // Update used to set exact time. Returns "this" AnimationMixer object.
                },
                // return this mixer's root target object
                getRoot: function () {
                    return this._root;
                },
                // free all resources specific to a particular clip
                uncacheClip: function (clip) {
                    var actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
                    if (actionsForClip !== undefined) {
                        // note: just calling _removeInactiveAction would mess up the
                        // iteration state and also require updating the state we can
                        // just throw away
                        var actionsToRemove = actionsForClip.knownActions;
                        for (var i = 0, n = actionsToRemove.length; i !== n; ++i) {
                            var action = actionsToRemove[i];
                            this._deactivateAction(action);
                            var cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];
                            action._cacheIndex = null;
                            action._byClipCacheIndex = null;
                            lastInactiveAction._cacheIndex = cacheIndex;
                            actions[cacheIndex] = lastInactiveAction;
                            actions.pop();
                            this._removeInactiveBindingsForAction(action);
                        }
                        delete actionsByClip[clipUuid];
                    }
                },
                // free all resources specific to a particular root target object
                uncacheRoot: function (root) {
                    var rootUuid = root.uuid, actionsByClip = this._actionsByClip;
                    for (var clipUuid in actionsByClip) {
                        var actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
                        if (action !== undefined) {
                            this._deactivateAction(action);
                            this._removeInactiveAction(action);
                        }
                    }
                    var bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
                    if (bindingByName !== undefined) {
                        for (var trackName in bindingByName) {
                            var binding = bindingByName[trackName];
                            binding.restoreOriginalState();
                            this._removeInactiveBinding(binding);
                        }
                    }
                },
                // remove a targeted clip from the cache
                uncacheAction: function (clip, optionalRoot) {
                    var action = this.existingAction(clip, optionalRoot);
                    if (action !== null) {
                        this._deactivateAction(action);
                        this._removeInactiveAction(action);
                    }
                }
            });
            Uniform.prototype.clone = function () {
                return new Uniform(this.value.clone === undefined ? this.value : this.value.clone());
            };
            InstancedInterleavedBuffer.prototype = Object.assign(Object.create(InterleavedBuffer.prototype), {
                constructor: InstancedInterleavedBuffer,
                isInstancedInterleavedBuffer: true,
                copy: function (source) {
                    InterleavedBuffer.prototype.copy.call(this, source);
                    this.meshPerAttribute = source.meshPerAttribute;
                    return this;
                }
            });
            Object.assign(Raycaster.prototype, {
                linePrecision: 1,
                set: function (origin, direction) {
                    // direction is assumed to be normalized (for accurate distance calculations)
                    this.ray.set(origin, direction);
                },
                setFromCamera: function (coords, camera) {
                    if ((camera && camera.isPerspectiveCamera)) {
                        this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
                        this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
                        this.camera = camera;
                    }
                    else if ((camera && camera.isOrthographicCamera)) {
                        this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera); // set origin in plane of camera
                        this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
                        this.camera = camera;
                    }
                    else {
                        console.error('THREE.Raycaster: Unsupported camera type.');
                    }
                },
                intersectObject: function (object, recursive, optionalTarget) {
                    var intersects = optionalTarget || [];
                    intersectObject(object, this, intersects, recursive);
                    intersects.sort(ascSort);
                    return intersects;
                },
                intersectObjects: function (objects, recursive, optionalTarget) {
                    var intersects = optionalTarget || [];
                    if (Array.isArray(objects) === false) {
                        console.warn('THREE.Raycaster.intersectObjects: objects is not an Array.');
                        return intersects;
                    }
                    for (var i = 0, l = objects.length; i < l; i++) {
                        intersectObject(objects[i], this, intersects, recursive);
                    }
                    intersects.sort(ascSort);
                    return intersects;
                }
            });
            Object.assign(Spherical.prototype, {
                set: function (radius, phi, theta) {
                    this.radius = radius;
                    this.phi = phi;
                    this.theta = theta;
                    return this;
                },
                clone: function () {
                    return new this.constructor().copy(this);
                },
                copy: function (other) {
                    this.radius = other.radius;
                    this.phi = other.phi;
                    this.theta = other.theta;
                    return this;
                },
                // restrict phi to be betwee EPS and PI-EPS
                makeSafe: function () {
                    var EPS = 0.000001;
                    this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
                    return this;
                },
                setFromVector3: function (v) {
                    return this.setFromCartesianCoords(v.x, v.y, v.z);
                },
                setFromCartesianCoords: function (x, y, z) {
                    this.radius = Math.sqrt(x * x + y * y + z * z);
                    if (this.radius === 0) {
                        this.theta = 0;
                        this.phi = 0;
                    }
                    else {
                        this.theta = Math.atan2(x, z);
                        this.phi = Math.acos(MathUtils.clamp(y / this.radius, -1, 1));
                    }
                    return this;
                }
            });
            Object.assign(Cylindrical.prototype, {
                set: function (radius, theta, y) {
                    this.radius = radius;
                    this.theta = theta;
                    this.y = y;
                    return this;
                },
                clone: function () {
                    return new this.constructor().copy(this);
                },
                copy: function (other) {
                    this.radius = other.radius;
                    this.theta = other.theta;
                    this.y = other.y;
                    return this;
                },
                setFromVector3: function (v) {
                    return this.setFromCartesianCoords(v.x, v.y, v.z);
                },
                setFromCartesianCoords: function (x, y, z) {
                    this.radius = Math.sqrt(x * x + z * z);
                    this.theta = Math.atan2(x, z);
                    this.y = y;
                    return this;
                }
            });
            /**
             * @author bhouston / http://clara.io
             */
            _vector$7 = new Vector2();
            Object.assign(Box2.prototype, {
                set: function (min, max) {
                    this.min.copy(min);
                    this.max.copy(max);
                    return this;
                },
                setFromPoints: function (points) {
                    this.makeEmpty();
                    for (var i = 0, il = points.length; i < il; i++) {
                        this.expandByPoint(points[i]);
                    }
                    return this;
                },
                setFromCenterAndSize: function (center, size) {
                    var halfSize = _vector$7.copy(size).multiplyScalar(0.5);
                    this.min.copy(center).sub(halfSize);
                    this.max.copy(center).add(halfSize);
                    return this;
                },
                clone: function () {
                    return new this.constructor().copy(this);
                },
                copy: function (box) {
                    this.min.copy(box.min);
                    this.max.copy(box.max);
                    return this;
                },
                makeEmpty: function () {
                    this.min.x = this.min.y = +Infinity;
                    this.max.x = this.max.y = -Infinity;
                    return this;
                },
                isEmpty: function () {
                    // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
                    return (this.max.x < this.min.x) || (this.max.y < this.min.y);
                },
                getCenter: function (target) {
                    if (target === undefined) {
                        console.warn('THREE.Box2: .getCenter() target is now required');
                        target = new Vector2();
                    }
                    return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
                },
                getSize: function (target) {
                    if (target === undefined) {
                        console.warn('THREE.Box2: .getSize() target is now required');
                        target = new Vector2();
                    }
                    return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
                },
                expandByPoint: function (point) {
                    this.min.min(point);
                    this.max.max(point);
                    return this;
                },
                expandByVector: function (vector) {
                    this.min.sub(vector);
                    this.max.add(vector);
                    return this;
                },
                expandByScalar: function (scalar) {
                    this.min.addScalar(-scalar);
                    this.max.addScalar(scalar);
                    return this;
                },
                containsPoint: function (point) {
                    return point.x < this.min.x || point.x > this.max.x ||
                        point.y < this.min.y || point.y > this.max.y ? false : true;
                },
                containsBox: function (box) {
                    return this.min.x <= box.min.x && box.max.x <= this.max.x &&
                        this.min.y <= box.min.y && box.max.y <= this.max.y;
                },
                getParameter: function (point, target) {
                    // This can potentially have a divide by zero if the box
                    // has a size dimension of 0.
                    if (target === undefined) {
                        console.warn('THREE.Box2: .getParameter() target is now required');
                        target = new Vector2();
                    }
                    return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
                },
                intersectsBox: function (box) {
                    // using 4 splitting planes to rule out intersections
                    return box.max.x < this.min.x || box.min.x > this.max.x ||
                        box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
                },
                clampPoint: function (point, target) {
                    if (target === undefined) {
                        console.warn('THREE.Box2: .clampPoint() target is now required');
                        target = new Vector2();
                    }
                    return target.copy(point).clamp(this.min, this.max);
                },
                distanceToPoint: function (point) {
                    var clampedPoint = _vector$7.copy(point).clamp(this.min, this.max);
                    return clampedPoint.sub(point).length();
                },
                intersect: function (box) {
                    this.min.max(box.min);
                    this.max.min(box.max);
                    return this;
                },
                union: function (box) {
                    this.min.min(box.min);
                    this.max.max(box.max);
                    return this;
                },
                translate: function (offset) {
                    this.min.add(offset);
                    this.max.add(offset);
                    return this;
                },
                equals: function (box) {
                    return box.min.equals(this.min) && box.max.equals(this.max);
                }
            });
            /**
             * @author bhouston / http://clara.io
             */
            _startP = new Vector3();
            _startEnd = new Vector3();
            Object.assign(Line3.prototype, {
                set: function (start, end) {
                    this.start.copy(start);
                    this.end.copy(end);
                    return this;
                },
                clone: function () {
                    return new this.constructor().copy(this);
                },
                copy: function (line) {
                    this.start.copy(line.start);
                    this.end.copy(line.end);
                    return this;
                },
                getCenter: function (target) {
                    if (target === undefined) {
                        console.warn('THREE.Line3: .getCenter() target is now required');
                        target = new Vector3();
                    }
                    return target.addVectors(this.start, this.end).multiplyScalar(0.5);
                },
                delta: function (target) {
                    if (target === undefined) {
                        console.warn('THREE.Line3: .delta() target is now required');
                        target = new Vector3();
                    }
                    return target.subVectors(this.end, this.start);
                },
                distanceSq: function () {
                    return this.start.distanceToSquared(this.end);
                },
                distance: function () {
                    return this.start.distanceTo(this.end);
                },
                at: function (t, target) {
                    if (target === undefined) {
                        console.warn('THREE.Line3: .at() target is now required');
                        target = new Vector3();
                    }
                    return this.delta(target).multiplyScalar(t).add(this.start);
                },
                closestPointToPointParameter: function (point, clampToLine) {
                    _startP.subVectors(point, this.start);
                    _startEnd.subVectors(this.end, this.start);
                    var startEnd2 = _startEnd.dot(_startEnd);
                    var startEnd_startP = _startEnd.dot(_startP);
                    var t = startEnd_startP / startEnd2;
                    if (clampToLine) {
                        t = MathUtils.clamp(t, 0, 1);
                    }
                    return t;
                },
                closestPointToPoint: function (point, clampToLine, target) {
                    var t = this.closestPointToPointParameter(point, clampToLine);
                    if (target === undefined) {
                        console.warn('THREE.Line3: .closestPointToPoint() target is now required');
                        target = new Vector3();
                    }
                    return this.delta(target).multiplyScalar(t).add(this.start);
                },
                applyMatrix4: function (matrix) {
                    this.start.applyMatrix4(matrix);
                    this.end.applyMatrix4(matrix);
                    return this;
                },
                equals: function (line) {
                    return line.start.equals(this.start) && line.end.equals(this.end);
                }
            });
            ImmediateRenderObject.prototype = Object.create(Object3D.prototype);
            ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;
            ImmediateRenderObject.prototype.isImmediateRenderObject = true;
            /**
             * @author alteredq / http://alteredqualia.com/
             * @author mrdoob / http://mrdoob.com/
             * @author WestLangley / http://github.com/WestLangley
             */
            _vector$8 = new Vector3();
            SpotLightHelper.prototype = Object.create(Object3D.prototype);
            SpotLightHelper.prototype.constructor = SpotLightHelper;
            SpotLightHelper.prototype.dispose = function () {
                this.cone.geometry.dispose();
                this.cone.material.dispose();
            };
            SpotLightHelper.prototype.update = function () {
                this.light.updateMatrixWorld();
                var coneLength = this.light.distance ? this.light.distance : 1000;
                var coneWidth = coneLength * Math.tan(this.light.angle);
                this.cone.scale.set(coneWidth, coneWidth, coneLength);
                _vector$8.setFromMatrixPosition(this.light.target.matrixWorld);
                this.cone.lookAt(_vector$8);
                if (this.color !== undefined) {
                    this.cone.material.color.set(this.color);
                }
                else {
                    this.cone.material.color.copy(this.light.color);
                }
            };
            /**
             * @author Sean Griffin / http://twitter.com/sgrif
             * @author Michael Guerrero / http://realitymeltdown.com
             * @author mrdoob / http://mrdoob.com/
             * @author ikerr / http://verold.com
             * @author Mugen87 / https://github.com/Mugen87
             */
            _vector$9 = new Vector3();
            _boneMatrix = new Matrix4();
            _matrixWorldInv = new Matrix4();
            SkeletonHelper.prototype = Object.create(LineSegments.prototype);
            SkeletonHelper.prototype.constructor = SkeletonHelper;
            SkeletonHelper.prototype.updateMatrixWorld = function (force) {
                var bones = this.bones;
                var geometry = this.geometry;
                var position = geometry.getAttribute('position');
                _matrixWorldInv.getInverse(this.root.matrixWorld);
                for (var i = 0, j = 0; i < bones.length; i++) {
                    var bone = bones[i];
                    if (bone.parent && bone.parent.isBone) {
                        _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);
                        _vector$9.setFromMatrixPosition(_boneMatrix);
                        position.setXYZ(j, _vector$9.x, _vector$9.y, _vector$9.z);
                        _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);
                        _vector$9.setFromMatrixPosition(_boneMatrix);
                        position.setXYZ(j + 1, _vector$9.x, _vector$9.y, _vector$9.z);
                        j += 2;
                    }
                }
                geometry.getAttribute('position').needsUpdate = true;
                Object3D.prototype.updateMatrixWorld.call(this, force);
            };
            PointLightHelper.prototype = Object.create(Mesh.prototype);
            PointLightHelper.prototype.constructor = PointLightHelper;
            PointLightHelper.prototype.dispose = function () {
                this.geometry.dispose();
                this.material.dispose();
            };
            PointLightHelper.prototype.update = function () {
                if (this.color !== undefined) {
                    this.material.color.set(this.color);
                }
                else {
                    this.material.color.copy(this.light.color);
                }
                /*
                var d = this.light.distance;
            
                if ( d === 0.0 ) {
            
                    this.lightDistance.visible = false;
            
                } else {
            
                    this.lightDistance.visible = true;
                    this.lightDistance.scale.set( d, d, d );
            
                }
                */
            };
            /**
             * @author alteredq / http://alteredqualia.com/
             * @author mrdoob / http://mrdoob.com/
             * @author Mugen87 / https://github.com/Mugen87
             */
            _vector$a = new Vector3();
            _color1 = new Color();
            _color2 = new Color();
            HemisphereLightHelper.prototype = Object.create(Object3D.prototype);
            HemisphereLightHelper.prototype.constructor = HemisphereLightHelper;
            HemisphereLightHelper.prototype.dispose = function () {
                this.children[0].geometry.dispose();
                this.children[0].material.dispose();
            };
            HemisphereLightHelper.prototype.update = function () {
                var mesh = this.children[0];
                if (this.color !== undefined) {
                    this.material.color.set(this.color);
                }
                else {
                    var colors = mesh.geometry.getAttribute('color');
                    _color1.copy(this.light.color);
                    _color2.copy(this.light.groundColor);
                    for (var i = 0, l = colors.count; i < l; i++) {
                        var color = (i < (l / 2)) ? _color1 : _color2;
                        colors.setXYZ(i, color.r, color.g, color.b);
                    }
                    colors.needsUpdate = true;
                }
                mesh.lookAt(_vector$a.setFromMatrixPosition(this.light.matrixWorld).negate());
            };
            GridHelper.prototype = Object.assign(Object.create(LineSegments.prototype), {
                constructor: GridHelper,
                copy: function (source) {
                    LineSegments.prototype.copy.call(this, source);
                    this.geometry.copy(source.geometry);
                    this.material.copy(source.material);
                    return this;
                },
                clone: function () {
                    return new this.constructor().copy(this);
                }
            });
            PolarGridHelper.prototype = Object.create(LineSegments.prototype);
            PolarGridHelper.prototype.constructor = PolarGridHelper;
            /**
             * @author alteredq / http://alteredqualia.com/
             * @author mrdoob / http://mrdoob.com/
             * @author WestLangley / http://github.com/WestLangley
             */
            _v1$5 = new Vector3();
            _v2$3 = new Vector3();
            _v3$1 = new Vector3();
            DirectionalLightHelper.prototype = Object.create(Object3D.prototype);
            DirectionalLightHelper.prototype.constructor = DirectionalLightHelper;
            DirectionalLightHelper.prototype.dispose = function () {
                this.lightPlane.geometry.dispose();
                this.lightPlane.material.dispose();
                this.targetLine.geometry.dispose();
                this.targetLine.material.dispose();
            };
            DirectionalLightHelper.prototype.update = function () {
                _v1$5.setFromMatrixPosition(this.light.matrixWorld);
                _v2$3.setFromMatrixPosition(this.light.target.matrixWorld);
                _v3$1.subVectors(_v2$3, _v1$5);
                this.lightPlane.lookAt(_v2$3);
                if (this.color !== undefined) {
                    this.lightPlane.material.color.set(this.color);
                    this.targetLine.material.color.set(this.color);
                }
                else {
                    this.lightPlane.material.color.copy(this.light.color);
                    this.targetLine.material.color.copy(this.light.color);
                }
                this.targetLine.lookAt(_v2$3);
                this.targetLine.scale.z = _v3$1.length();
            };
            /**
             * @author alteredq / http://alteredqualia.com/
             * @author Mugen87 / https://github.com/Mugen87
             *
             *	- shows frustum, line of sight and up of the camera
             *	- suitable for fast updates
             * 	- based on frustum visualization in lightgl.js shadowmap example
             *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
             */
            _vector$b = new Vector3();
            _camera = new Camera();
            CameraHelper.prototype = Object.create(LineSegments.prototype);
            CameraHelper.prototype.constructor = CameraHelper;
            CameraHelper.prototype.update = function () {
                var geometry = this.geometry;
                var pointMap = this.pointMap;
                var w = 1, h = 1;
                // we need just camera projection matrix inverse
                // world matrix must be identity
                _camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);
                // center / target
                setPoint('c', pointMap, geometry, _camera, 0, 0, -1);
                setPoint('t', pointMap, geometry, _camera, 0, 0, 1);
                // near
                setPoint('n1', pointMap, geometry, _camera, -w, -h, -1);
                setPoint('n2', pointMap, geometry, _camera, w, -h, -1);
                setPoint('n3', pointMap, geometry, _camera, -w, h, -1);
                setPoint('n4', pointMap, geometry, _camera, w, h, -1);
                // far
                setPoint('f1', pointMap, geometry, _camera, -w, -h, 1);
                setPoint('f2', pointMap, geometry, _camera, w, -h, 1);
                setPoint('f3', pointMap, geometry, _camera, -w, h, 1);
                setPoint('f4', pointMap, geometry, _camera, w, h, 1);
                // up
                setPoint('u1', pointMap, geometry, _camera, w * 0.7, h * 1.1, -1);
                setPoint('u2', pointMap, geometry, _camera, -w * 0.7, h * 1.1, -1);
                setPoint('u3', pointMap, geometry, _camera, 0, h * 2, -1);
                // cross
                setPoint('cf1', pointMap, geometry, _camera, -w, 0, 1);
                setPoint('cf2', pointMap, geometry, _camera, w, 0, 1);
                setPoint('cf3', pointMap, geometry, _camera, 0, -h, 1);
                setPoint('cf4', pointMap, geometry, _camera, 0, h, 1);
                setPoint('cn1', pointMap, geometry, _camera, -w, 0, -1);
                setPoint('cn2', pointMap, geometry, _camera, w, 0, -1);
                setPoint('cn3', pointMap, geometry, _camera, 0, -h, -1);
                setPoint('cn4', pointMap, geometry, _camera, 0, h, -1);
                geometry.getAttribute('position').needsUpdate = true;
            };
            /**
             * @author mrdoob / http://mrdoob.com/
             * @author Mugen87 / http://github.com/Mugen87
             */
            _box$3 = new Box3();
            BoxHelper.prototype = Object.create(LineSegments.prototype);
            BoxHelper.prototype.constructor = BoxHelper;
            BoxHelper.prototype.update = function (object) {
                if (object !== undefined) {
                    console.warn('THREE.BoxHelper: .update() has no longer arguments.');
                }
                if (this.object !== undefined) {
                    _box$3.setFromObject(this.object);
                }
                if (_box$3.isEmpty())
                    return;
                var min = _box$3.min;
                var max = _box$3.max;
                /*
                  5____4
                1/___0/|
                | 6__|_7
                2/___3/
            
                0: max.x, max.y, max.z
                1: min.x, max.y, max.z
                2: min.x, min.y, max.z
                3: max.x, min.y, max.z
                4: max.x, max.y, min.z
                5: min.x, max.y, min.z
                6: min.x, min.y, min.z
                7: max.x, min.y, min.z
                */
                var position = this.geometry.attributes.position;
                var array = position.array;
                array[0] = max.x;
                array[1] = max.y;
                array[2] = max.z;
                array[3] = min.x;
                array[4] = max.y;
                array[5] = max.z;
                array[6] = min.x;
                array[7] = min.y;
                array[8] = max.z;
                array[9] = max.x;
                array[10] = min.y;
                array[11] = max.z;
                array[12] = max.x;
                array[13] = max.y;
                array[14] = min.z;
                array[15] = min.x;
                array[16] = max.y;
                array[17] = min.z;
                array[18] = min.x;
                array[19] = min.y;
                array[20] = min.z;
                array[21] = max.x;
                array[22] = min.y;
                array[23] = min.z;
                position.needsUpdate = true;
                this.geometry.computeBoundingSphere();
            };
            BoxHelper.prototype.setFromObject = function (object) {
                this.object = object;
                this.update();
                return this;
            };
            BoxHelper.prototype.copy = function (source) {
                LineSegments.prototype.copy.call(this, source);
                this.object = source.object;
                return this;
            };
            BoxHelper.prototype.clone = function () {
                return new this.constructor().copy(this);
            };
            Box3Helper.prototype = Object.create(LineSegments.prototype);
            Box3Helper.prototype.constructor = Box3Helper;
            Box3Helper.prototype.updateMatrixWorld = function (force) {
                var box = this.box;
                if (box.isEmpty())
                    return;
                box.getCenter(this.position);
                box.getSize(this.scale);
                this.scale.multiplyScalar(0.5);
                Object3D.prototype.updateMatrixWorld.call(this, force);
            };
            PlaneHelper.prototype = Object.create(Line.prototype);
            PlaneHelper.prototype.constructor = PlaneHelper;
            PlaneHelper.prototype.updateMatrixWorld = function (force) {
                var scale = -this.plane.constant;
                if (Math.abs(scale) < 1e-8)
                    scale = 1e-8; // sign does not matter
                this.scale.set(0.5 * this.size, 0.5 * this.size, scale);
                this.children[0].material.side = (scale < 0) ? BackSide : FrontSide; // renderer flips side when determinant < 0; flipping not wanted here
                this.lookAt(this.plane.normal);
                Object3D.prototype.updateMatrixWorld.call(this, force);
            };
            /**
             * @author WestLangley / http://github.com/WestLangley
             * @author zz85 / http://github.com/zz85
             * @author bhouston / http://clara.io
             *
             * Creates an arrow for visualizing directions
             *
             * Parameters:
             *  dir - Vector3
             *  origin - Vector3
             *  length - Number
             *  color - color in hex value
             *  headLength - Number
             *  headWidth - Number
             */
            _axis = new Vector3();
            ArrowHelper.prototype = Object.create(Object3D.prototype);
            ArrowHelper.prototype.constructor = ArrowHelper;
            ArrowHelper.prototype.setDirection = function (dir) {
                // dir is assumed to be normalized
                if (dir.y > 0.99999) {
                    this.quaternion.set(0, 0, 0, 1);
                }
                else if (dir.y < -0.99999) {
                    this.quaternion.set(1, 0, 0, 0);
                }
                else {
                    _axis.set(dir.z, 0, -dir.x).normalize();
                    var radians = Math.acos(dir.y);
                    this.quaternion.setFromAxisAngle(_axis, radians);
                }
            };
            ArrowHelper.prototype.setLength = function (length, headLength, headWidth) {
                if (headLength === undefined)
                    headLength = 0.2 * length;
                if (headWidth === undefined)
                    headWidth = 0.2 * headLength;
                this.line.scale.set(1, Math.max(0.0001, length - headLength), 1); // see #17458
                this.line.updateMatrix();
                this.cone.scale.set(headWidth, headLength, headWidth);
                this.cone.position.y = length;
                this.cone.updateMatrix();
            };
            ArrowHelper.prototype.setColor = function (color) {
                this.line.material.color.set(color);
                this.cone.material.color.set(color);
            };
            ArrowHelper.prototype.copy = function (source) {
                Object3D.prototype.copy.call(this, source, false);
                this.line.copy(source.line);
                this.cone.copy(source.cone);
                return this;
            };
            ArrowHelper.prototype.clone = function () {
                return new this.constructor().copy(this);
            };
            AxesHelper.prototype = Object.create(LineSegments.prototype);
            AxesHelper.prototype.constructor = AxesHelper;
            /**
             * @author Emmett Lalish / elalish
             *
             * This class generates a Prefiltered, Mipmapped Radiance Environment Map
             * (PMREM) from a cubeMap environment texture. This allows different levels of
             * blur to be quickly accessed based on material roughness. It is packed into a
             * special CubeUV format that allows us to perform custom interpolation so that
             * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
             * chain, it only goes down to the LOD_MIN level (above), and then creates extra
             * even more filtered 'mips' at the same LOD_MIN resolution, associated with
             * higher roughness levels. In this way we maintain resolution to smoothly
             * interpolate diffuse lighting while limiting sampling computation.
             */
            LOD_MIN = 4;
            LOD_MAX = 8;
            SIZE_MAX = Math.pow(2, LOD_MAX);
            // The standard deviations (radians) associated with the extra mips. These are
            // chosen to approximate a Trowbridge-Reitz distribution function times the
            // geometric shadowing function. These sigma values squared must match the
            // variance #defines in cube_uv_reflection_fragment.glsl.js.
            EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
            TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
            // The maximum length of the blur for loop. Smaller sigmas will use fewer
            // samples and exit early, but not recompile the shader.
            MAX_SAMPLES = 20;
            ENCODINGS = {
                [LinearEncoding]: 0,
                [sRGBEncoding]: 1,
                [RGBEEncoding]: 2,
                [RGBM7Encoding]: 3,
                [RGBM16Encoding]: 4,
                [RGBDEncoding]: 5,
                [GammaEncoding]: 6
            };
            _flatCamera = new OrthographicCamera();
            _blurMaterial = _getBlurShader(MAX_SAMPLES);
            _equirectShader = null;
            _cubemapShader = null;
            _a = _createPlanes(), _lodPlanes = _a._lodPlanes, _sizeLods = _a._sizeLods, _sigmas = _a._sigmas;
            _pingPongRenderTarget = null;
            _renderer = null;
            _oldTarget = null;
            // Golden Ratio
            PHI = (1 + Math.sqrt(5)) / 2;
            INV_PHI = 1 / PHI;
            // Vertices of a dodecahedron (except the opposites, which represent the
            // same axis), used as axis directions evenly spread on a sphere.
            _axisDirections = [
                new Vector3(1, 1, 1),
                new Vector3(-1, 1, 1),
                new Vector3(1, 1, -1),
                new Vector3(-1, 1, -1),
                new Vector3(0, PHI, INV_PHI),
                new Vector3(0, PHI, -INV_PHI),
                new Vector3(INV_PHI, 0, PHI),
                new Vector3(-INV_PHI, 0, PHI),
                new Vector3(PHI, INV_PHI, 0),
                new Vector3(-PHI, INV_PHI, 0)
            ];
            PMREMGenerator.prototype = {
                constructor: PMREMGenerator,
                /**
                 * Generates a PMREM from a supplied Scene, which can be faster than using an
                 * image if networking bandwidth is low. Optional sigma specifies a blur radius
                 * in radians to be applied to the scene before PMREM generation. Optional near
                 * and far planes ensure the scene is rendered in its entirety (the cubeCamera
                 * is placed at the origin).
                 */
                fromScene: function (scene, sigma = 0, near = 0.1, far = 100) {
                    _oldTarget = _renderer.getRenderTarget();
                    var cubeUVRenderTarget = _allocateTargets();
                    _sceneToCubeUV(scene, near, far, cubeUVRenderTarget);
                    if (sigma > 0) {
                        _blur(cubeUVRenderTarget, 0, 0, sigma);
                    }
                    _applyPMREM(cubeUVRenderTarget);
                    _cleanup(cubeUVRenderTarget);
                    return cubeUVRenderTarget;
                },
                /**
                 * Generates a PMREM from an equirectangular texture, which can be either LDR
                 * (RGBFormat) or HDR (RGBEFormat). The ideal input image size is 1k (1024 x 512),
                 * as this matches best with the 256 x 256 cubemap output.
                 */
                fromEquirectangular: function (equirectangular) {
                    equirectangular.magFilter = NearestFilter;
                    equirectangular.minFilter = NearestFilter;
                    equirectangular.generateMipmaps = false;
                    return this.fromCubemap(equirectangular);
                },
                /**
                 * Generates a PMREM from an cubemap texture, which can be either LDR
                 * (RGBFormat) or HDR (RGBEFormat). The ideal input cube size is 256 x 256,
                 * as this matches best with the 256 x 256 cubemap output.
                 */
                fromCubemap: function (cubemap) {
                    _oldTarget = _renderer.getRenderTarget();
                    var cubeUVRenderTarget = _allocateTargets(cubemap);
                    _textureToCubeUV(cubemap, cubeUVRenderTarget);
                    _applyPMREM(cubeUVRenderTarget);
                    _cleanup(cubeUVRenderTarget);
                    return cubeUVRenderTarget;
                },
                /**
                 * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
                 * your texture's network fetch for increased concurrency.
                 */
                compileCubemapShader: function () {
                    if (_cubemapShader == null) {
                        _cubemapShader = _getCubemapShader();
                        _compileMaterial(_cubemapShader);
                    }
                },
                /**
                 * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
                 * your texture's network fetch for increased concurrency.
                 */
                compileEquirectangularShader: function () {
                    if (_equirectShader == null) {
                        _equirectShader = _getEquirectShader();
                        _compileMaterial(_equirectShader);
                    }
                },
                /**
                 * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
                 * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
                 * one of them will cause any others to also become unusable.
                 */
                dispose: function () {
                    _blurMaterial.dispose();
                    if (_cubemapShader != null)
                        _cubemapShader.dispose();
                    if (_equirectShader != null)
                        _equirectShader.dispose();
                    for (var i = 0; i < _lodPlanes.length; i++) {
                        _lodPlanes[i].dispose();
                    }
                },
            };
            LineStrip = 0;
            exports_14("LineStrip", LineStrip);
            LinePieces = 1;
            exports_14("LinePieces", LinePieces);
            //
            Curve.create = function (construct, getPoint) {
                console.log('THREE.Curve.create() has been deprecated');
                construct.prototype = Object.create(Curve.prototype);
                construct.prototype.constructor = construct;
                construct.prototype.getPoint = getPoint;
                return construct;
            };
            //
            Object.assign(CurvePath.prototype, {
                createPointsGeometry: function (divisions) {
                    console.warn('THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.');
                    // generate geometry from path points (for Line or Points objects)
                    var pts = this.getPoints(divisions);
                    return this.createGeometry(pts);
                },
                createSpacedPointsGeometry: function (divisions) {
                    console.warn('THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.');
                    // generate geometry from equidistant sampling along the path
                    var pts = this.getSpacedPoints(divisions);
                    return this.createGeometry(pts);
                },
                createGeometry: function (points) {
                    console.warn('THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.');
                    var geometry = new Geometry();
                    for (var i = 0, l = points.length; i < l; i++) {
                        var point = points[i];
                        geometry.vertices.push(new Vector3(point.x, point.y, point.z || 0));
                    }
                    return geometry;
                }
            });
            //
            Object.assign(Path.prototype, {
                fromPoints: function (points) {
                    console.warn('THREE.Path: .fromPoints() has been renamed to .setFromPoints().');
                    return this.setFromPoints(points);
                }
            });
            ClosedSplineCurve3.prototype = Object.create(CatmullRomCurve3.prototype);
            SplineCurve3.prototype = Object.create(CatmullRomCurve3.prototype);
            Spline.prototype = Object.create(CatmullRomCurve3.prototype);
            Object.assign(Spline.prototype, {
                initFromArray: function ( /* a */) {
                    console.error('THREE.Spline: .initFromArray() has been removed.');
                },
                getControlPointsArray: function ( /* optionalTarget */) {
                    console.error('THREE.Spline: .getControlPointsArray() has been removed.');
                },
                reparametrizeByArcLength: function ( /* samplingCoef */) {
                    console.error('THREE.Spline: .reparametrizeByArcLength() has been removed.');
                }
            });
            GridHelper.prototype.setColors = function () {
                console.error('THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.');
            };
            SkeletonHelper.prototype.update = function () {
                console.error('THREE.SkeletonHelper: update() no longer needs to be called.');
            };
            //
            Object.assign(Loader.prototype, {
                extractUrlBase: function (url) {
                    console.warn('THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.');
                    return LoaderUtils.extractUrlBase(url);
                }
            });
            Loader.Handlers = {
                add: function ( /* regex, loader */) {
                    console.error('THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.');
                },
                get: function ( /* file */) {
                    console.error('THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.');
                }
            };
            Object.assign(ObjectLoader.prototype, {
                setTexturePath: function (value) {
                    console.warn('THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().');
                    return this.setResourcePath(value);
                }
            });
            //
            Object.assign(Box2.prototype, {
                center: function (optionalTarget) {
                    console.warn('THREE.Box2: .center() has been renamed to .getCenter().');
                    return this.getCenter(optionalTarget);
                },
                empty: function () {
                    console.warn('THREE.Box2: .empty() has been renamed to .isEmpty().');
                    return this.isEmpty();
                },
                isIntersectionBox: function (box) {
                    console.warn('THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().');
                    return this.intersectsBox(box);
                },
                size: function (optionalTarget) {
                    console.warn('THREE.Box2: .size() has been renamed to .getSize().');
                    return this.getSize(optionalTarget);
                }
            });
            Object.assign(Box3.prototype, {
                center: function (optionalTarget) {
                    console.warn('THREE.Box3: .center() has been renamed to .getCenter().');
                    return this.getCenter(optionalTarget);
                },
                empty: function () {
                    console.warn('THREE.Box3: .empty() has been renamed to .isEmpty().');
                    return this.isEmpty();
                },
                isIntersectionBox: function (box) {
                    console.warn('THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().');
                    return this.intersectsBox(box);
                },
                isIntersectionSphere: function (sphere) {
                    console.warn('THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().');
                    return this.intersectsSphere(sphere);
                },
                size: function (optionalTarget) {
                    console.warn('THREE.Box3: .size() has been renamed to .getSize().');
                    return this.getSize(optionalTarget);
                }
            });
            Frustum.prototype.setFromMatrix = function (m) {
                console.warn('THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().');
                return this.setFromProjectionMatrix(m);
            };
            Line3.prototype.center = function (optionalTarget) {
                console.warn('THREE.Line3: .center() has been renamed to .getCenter().');
                return this.getCenter(optionalTarget);
            };
            Object.assign(MathUtils, {
                random16: function () {
                    console.warn('THREE.Math: .random16() has been deprecated. Use Math.random() instead.');
                    return Math.random();
                },
                nearestPowerOfTwo: function (value) {
                    console.warn('THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().');
                    return MathUtils.floorPowerOfTwo(value);
                },
                nextPowerOfTwo: function (value) {
                    console.warn('THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().');
                    return MathUtils.ceilPowerOfTwo(value);
                }
            });
            Object.assign(Matrix3.prototype, {
                flattenToArrayOffset: function (array, offset) {
                    console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
                    return this.toArray(array, offset);
                },
                multiplyVector3: function (vector) {
                    console.warn('THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');
                    return vector.applyMatrix3(this);
                },
                multiplyVector3Array: function ( /* a */) {
                    console.error('THREE.Matrix3: .multiplyVector3Array() has been removed.');
                },
                applyToBufferAttribute: function (attribute) {
                    console.warn('THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.');
                    return attribute.applyMatrix3(this);
                },
                applyToVector3Array: function ( /* array, offset, length */) {
                    console.error('THREE.Matrix3: .applyToVector3Array() has been removed.');
                }
            });
            Object.assign(Matrix4.prototype, {
                extractPosition: function (m) {
                    console.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().');
                    return this.copyPosition(m);
                },
                flattenToArrayOffset: function (array, offset) {
                    console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
                    return this.toArray(array, offset);
                },
                getPosition: function () {
                    console.warn('THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.');
                    return new Vector3().setFromMatrixColumn(this, 3);
                },
                setRotationFromQuaternion: function (q) {
                    console.warn('THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().');
                    return this.makeRotationFromQuaternion(q);
                },
                multiplyToArray: function () {
                    console.warn('THREE.Matrix4: .multiplyToArray() has been removed.');
                },
                multiplyVector3: function (vector) {
                    console.warn('THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.');
                    return vector.applyMatrix4(this);
                },
                multiplyVector4: function (vector) {
                    console.warn('THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');
                    return vector.applyMatrix4(this);
                },
                multiplyVector3Array: function ( /* a */) {
                    console.error('THREE.Matrix4: .multiplyVector3Array() has been removed.');
                },
                rotateAxis: function (v) {
                    console.warn('THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');
                    v.transformDirection(this);
                },
                crossVector: function (vector) {
                    console.warn('THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');
                    return vector.applyMatrix4(this);
                },
                translate: function () {
                    console.error('THREE.Matrix4: .translate() has been removed.');
                },
                rotateX: function () {
                    console.error('THREE.Matrix4: .rotateX() has been removed.');
                },
                rotateY: function () {
                    console.error('THREE.Matrix4: .rotateY() has been removed.');
                },
                rotateZ: function () {
                    console.error('THREE.Matrix4: .rotateZ() has been removed.');
                },
                rotateByAxis: function () {
                    console.error('THREE.Matrix4: .rotateByAxis() has been removed.');
                },
                applyToBufferAttribute: function (attribute) {
                    console.warn('THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.');
                    return attribute.applyMatrix4(this);
                },
                applyToVector3Array: function ( /* array, offset, length */) {
                    console.error('THREE.Matrix4: .applyToVector3Array() has been removed.');
                },
                makeFrustum: function (left, right, bottom, top, near, far) {
                    console.warn('THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.');
                    return this.makePerspective(left, right, top, bottom, near, far);
                }
            });
            Plane.prototype.isIntersectionLine = function (line) {
                console.warn('THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().');
                return this.intersectsLine(line);
            };
            Quaternion.prototype.multiplyVector3 = function (vector) {
                console.warn('THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');
                return vector.applyQuaternion(this);
            };
            Object.assign(Ray.prototype, {
                isIntersectionBox: function (box) {
                    console.warn('THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().');
                    return this.intersectsBox(box);
                },
                isIntersectionPlane: function (plane) {
                    console.warn('THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().');
                    return this.intersectsPlane(plane);
                },
                isIntersectionSphere: function (sphere) {
                    console.warn('THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().');
                    return this.intersectsSphere(sphere);
                }
            });
            Object.assign(Triangle.prototype, {
                area: function () {
                    console.warn('THREE.Triangle: .area() has been renamed to .getArea().');
                    return this.getArea();
                },
                barycoordFromPoint: function (point, target) {
                    console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');
                    return this.getBarycoord(point, target);
                },
                midpoint: function (target) {
                    console.warn('THREE.Triangle: .midpoint() has been renamed to .getMidpoint().');
                    return this.getMidpoint(target);
                },
                normal: function (target) {
                    console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');
                    return this.getNormal(target);
                },
                plane: function (target) {
                    console.warn('THREE.Triangle: .plane() has been renamed to .getPlane().');
                    return this.getPlane(target);
                }
            });
            Object.assign(Triangle, {
                barycoordFromPoint: function (point, a, b, c, target) {
                    console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');
                    return Triangle.getBarycoord(point, a, b, c, target);
                },
                normal: function (a, b, c, target) {
                    console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');
                    return Triangle.getNormal(a, b, c, target);
                }
            });
            Object.assign(Shape.prototype, {
                extractAllPoints: function (divisions) {
                    console.warn('THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.');
                    return this.extractPoints(divisions);
                },
                extrude: function (options) {
                    console.warn('THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.');
                    return new ExtrudeGeometry(this, options);
                },
                makeGeometry: function (options) {
                    console.warn('THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.');
                    return new ShapeGeometry(this, options);
                }
            });
            Object.assign(Vector2.prototype, {
                fromAttribute: function (attribute, index, offset) {
                    console.warn('THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().');
                    return this.fromBufferAttribute(attribute, index, offset);
                },
                distanceToManhattan: function (v) {
                    console.warn('THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');
                    return this.manhattanDistanceTo(v);
                },
                lengthManhattan: function () {
                    console.warn('THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().');
                    return this.manhattanLength();
                }
            });
            Object.assign(Vector3.prototype, {
                setEulerFromRotationMatrix: function () {
                    console.error('THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.');
                },
                setEulerFromQuaternion: function () {
                    console.error('THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.');
                },
                getPositionFromMatrix: function (m) {
                    console.warn('THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().');
                    return this.setFromMatrixPosition(m);
                },
                getScaleFromMatrix: function (m) {
                    console.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().');
                    return this.setFromMatrixScale(m);
                },
                getColumnFromMatrix: function (index, matrix) {
                    console.warn('THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().');
                    return this.setFromMatrixColumn(matrix, index);
                },
                applyProjection: function (m) {
                    console.warn('THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.');
                    return this.applyMatrix4(m);
                },
                fromAttribute: function (attribute, index, offset) {
                    console.warn('THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().');
                    return this.fromBufferAttribute(attribute, index, offset);
                },
                distanceToManhattan: function (v) {
                    console.warn('THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');
                    return this.manhattanDistanceTo(v);
                },
                lengthManhattan: function () {
                    console.warn('THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().');
                    return this.manhattanLength();
                }
            });
            Object.assign(Vector4.prototype, {
                fromAttribute: function (attribute, index, offset) {
                    console.warn('THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().');
                    return this.fromBufferAttribute(attribute, index, offset);
                },
                lengthManhattan: function () {
                    console.warn('THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().');
                    return this.manhattanLength();
                }
            });
            //
            Object.assign(Geometry.prototype, {
                computeTangents: function () {
                    console.error('THREE.Geometry: .computeTangents() has been removed.');
                },
                computeLineDistances: function () {
                    console.error('THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.');
                },
                applyMatrix: function (matrix) {
                    console.warn('THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().');
                    return this.applyMatrix4(matrix);
                }
            });
            Object.assign(Object3D.prototype, {
                getChildByName: function (name) {
                    console.warn('THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().');
                    return this.getObjectByName(name);
                },
                renderDepth: function () {
                    console.warn('THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.');
                },
                translate: function (distance, axis) {
                    console.warn('THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.');
                    return this.translateOnAxis(axis, distance);
                },
                getWorldRotation: function () {
                    console.error('THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.');
                },
                applyMatrix: function (matrix) {
                    console.warn('THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().');
                    return this.applyMatrix4(matrix);
                }
            });
            Object.defineProperties(Object3D.prototype, {
                eulerOrder: {
                    get: function () {
                        console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
                        return this.rotation.order;
                    },
                    set: function (value) {
                        console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
                        this.rotation.order = value;
                    }
                },
                useQuaternion: {
                    get: function () {
                        console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
                    },
                    set: function () {
                        console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
                    }
                }
            });
            Object.assign(Mesh.prototype, {
                setDrawMode: function () {
                    console.error('THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.');
                },
            });
            Object.defineProperties(Mesh.prototype, {
                drawMode: {
                    get: function () {
                        console.error('THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.');
                        return TrianglesDrawMode;
                    },
                    set: function () {
                        console.error('THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.');
                    }
                }
            });
            Object.defineProperties(LOD.prototype, {
                objects: {
                    get: function () {
                        console.warn('THREE.LOD: .objects has been renamed to .levels.');
                        return this.levels;
                    }
                }
            });
            Object.defineProperty(Skeleton.prototype, 'useVertexTexture', {
                get: function () {
                    console.warn('THREE.Skeleton: useVertexTexture has been removed.');
                },
                set: function () {
                    console.warn('THREE.Skeleton: useVertexTexture has been removed.');
                }
            });
            SkinnedMesh.prototype.initBones = function () {
                console.error('THREE.SkinnedMesh: initBones() has been removed.');
            };
            Object.defineProperty(Curve.prototype, '__arcLengthDivisions', {
                get: function () {
                    console.warn('THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.');
                    return this.arcLengthDivisions;
                },
                set: function (value) {
                    console.warn('THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.');
                    this.arcLengthDivisions = value;
                }
            });
            //
            PerspectiveCamera.prototype.setLens = function (focalLength, filmGauge) {
                console.warn("THREE.PerspectiveCamera.setLens is deprecated. " +
                    "Use .setFocalLength and .filmGauge for a photographic setup.");
                if (filmGauge !== undefined)
                    this.filmGauge = filmGauge;
                this.setFocalLength(focalLength);
            };
            //
            Object.defineProperties(Light.prototype, {
                onlyShadow: {
                    set: function () {
                        console.warn('THREE.Light: .onlyShadow has been removed.');
                    }
                },
                shadowCameraFov: {
                    set: function (value) {
                        console.warn('THREE.Light: .shadowCameraFov is now .shadow.camera.fov.');
                        this.shadow.camera.fov = value;
                    }
                },
                shadowCameraLeft: {
                    set: function (value) {
                        console.warn('THREE.Light: .shadowCameraLeft is now .shadow.camera.left.');
                        this.shadow.camera.left = value;
                    }
                },
                shadowCameraRight: {
                    set: function (value) {
                        console.warn('THREE.Light: .shadowCameraRight is now .shadow.camera.right.');
                        this.shadow.camera.right = value;
                    }
                },
                shadowCameraTop: {
                    set: function (value) {
                        console.warn('THREE.Light: .shadowCameraTop is now .shadow.camera.top.');
                        this.shadow.camera.top = value;
                    }
                },
                shadowCameraBottom: {
                    set: function (value) {
                        console.warn('THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.');
                        this.shadow.camera.bottom = value;
                    }
                },
                shadowCameraNear: {
                    set: function (value) {
                        console.warn('THREE.Light: .shadowCameraNear is now .shadow.camera.near.');
                        this.shadow.camera.near = value;
                    }
                },
                shadowCameraFar: {
                    set: function (value) {
                        console.warn('THREE.Light: .shadowCameraFar is now .shadow.camera.far.');
                        this.shadow.camera.far = value;
                    }
                },
                shadowCameraVisible: {
                    set: function () {
                        console.warn('THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.');
                    }
                },
                shadowBias: {
                    set: function (value) {
                        console.warn('THREE.Light: .shadowBias is now .shadow.bias.');
                        this.shadow.bias = value;
                    }
                },
                shadowDarkness: {
                    set: function () {
                        console.warn('THREE.Light: .shadowDarkness has been removed.');
                    }
                },
                shadowMapWidth: {
                    set: function (value) {
                        console.warn('THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.');
                        this.shadow.mapSize.width = value;
                    }
                },
                shadowMapHeight: {
                    set: function (value) {
                        console.warn('THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.');
                        this.shadow.mapSize.height = value;
                    }
                }
            });
            //
            Object.defineProperties(BufferAttribute.prototype, {
                length: {
                    get: function () {
                        console.warn('THREE.BufferAttribute: .length has been deprecated. Use .count instead.');
                        return this.array.length;
                    }
                },
                dynamic: {
                    get: function () {
                        console.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.');
                        return this.usage === DynamicDrawUsage;
                    },
                    set: function ( /* value */) {
                        console.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.');
                        this.setUsage(DynamicDrawUsage);
                    }
                }
            });
            Object.assign(BufferAttribute.prototype, {
                setDynamic: function (value) {
                    console.warn('THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.');
                    this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
                    return this;
                },
                copyIndicesArray: function ( /* indices */) {
                    console.error('THREE.BufferAttribute: .copyIndicesArray() has been removed.');
                },
                setArray: function ( /* array */) {
                    console.error('THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers');
                }
            });
            Object.assign(BufferGeometry.prototype, {
                addIndex: function (index) {
                    console.warn('THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().');
                    this.setIndex(index);
                },
                addAttribute: function (name, attribute) {
                    console.warn('THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().');
                    if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
                        console.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).');
                        return this.setAttribute(name, new BufferAttribute(arguments[1], arguments[2]));
                    }
                    if (name === 'index') {
                        console.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.');
                        this.setIndex(attribute);
                        return this;
                    }
                    return this.setAttribute(name, attribute);
                },
                addDrawCall: function (start, count, indexOffset) {
                    if (indexOffset !== undefined) {
                        console.warn('THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.');
                    }
                    console.warn('THREE.BufferGeometry: .addDrawCall() is now .addGroup().');
                    this.addGroup(start, count);
                },
                clearDrawCalls: function () {
                    console.warn('THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().');
                    this.clearGroups();
                },
                computeTangents: function () {
                    console.warn('THREE.BufferGeometry: .computeTangents() has been removed.');
                },
                computeOffsets: function () {
                    console.warn('THREE.BufferGeometry: .computeOffsets() has been removed.');
                },
                removeAttribute: function (name) {
                    console.warn('THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().');
                    return this.deleteAttribute(name);
                },
                applyMatrix: function (matrix) {
                    console.warn('THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().');
                    return this.applyMatrix4(matrix);
                }
            });
            Object.defineProperties(BufferGeometry.prototype, {
                drawcalls: {
                    get: function () {
                        console.error('THREE.BufferGeometry: .drawcalls has been renamed to .groups.');
                        return this.groups;
                    }
                },
                offsets: {
                    get: function () {
                        console.warn('THREE.BufferGeometry: .offsets has been renamed to .groups.');
                        return this.groups;
                    }
                }
            });
            Object.defineProperties(InterleavedBuffer.prototype, {
                dynamic: {
                    get: function () {
                        console.warn('THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.');
                        return this.usage === DynamicDrawUsage;
                    },
                    set: function (value) {
                        console.warn('THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.');
                        this.setUsage(value);
                    }
                }
            });
            Object.assign(InterleavedBuffer.prototype, {
                setDynamic: function (value) {
                    console.warn('THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.');
                    this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
                    return this;
                },
                setArray: function ( /* array */) {
                    console.error('THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers');
                }
            });
            //
            Object.assign(ExtrudeBufferGeometry.prototype, {
                getArrays: function () {
                    console.error('THREE.ExtrudeBufferGeometry: .getArrays() has been removed.');
                },
                addShapeList: function () {
                    console.error('THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.');
                },
                addShape: function () {
                    console.error('THREE.ExtrudeBufferGeometry: .addShape() has been removed.');
                }
            });
            //
            Object.defineProperties(Uniform.prototype, {
                dynamic: {
                    set: function () {
                        console.warn('THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.');
                    }
                },
                onUpdate: {
                    value: function () {
                        console.warn('THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.');
                        return this;
                    }
                }
            });
            //
            Object.defineProperties(Material.prototype, {
                wrapAround: {
                    get: function () {
                        console.warn('THREE.Material: .wrapAround has been removed.');
                    },
                    set: function () {
                        console.warn('THREE.Material: .wrapAround has been removed.');
                    }
                },
                overdraw: {
                    get: function () {
                        console.warn('THREE.Material: .overdraw has been removed.');
                    },
                    set: function () {
                        console.warn('THREE.Material: .overdraw has been removed.');
                    }
                },
                wrapRGB: {
                    get: function () {
                        console.warn('THREE.Material: .wrapRGB has been removed.');
                        return new Color();
                    }
                },
                shading: {
                    get: function () {
                        console.error('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
                    },
                    set: function (value) {
                        console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
                        this.flatShading = (value === FlatShading);
                    }
                },
                stencilMask: {
                    get: function () {
                        console.warn('THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.');
                        return this.stencilFuncMask;
                    },
                    set: function (value) {
                        console.warn('THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.');
                        this.stencilFuncMask = value;
                    }
                }
            });
            Object.defineProperties(MeshPhongMaterial.prototype, {
                metal: {
                    get: function () {
                        console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.');
                        return false;
                    },
                    set: function () {
                        console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead');
                    }
                }
            });
            Object.defineProperties(ShaderMaterial.prototype, {
                derivatives: {
                    get: function () {
                        console.warn('THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
                        return this.extensions.derivatives;
                    },
                    set: function (value) {
                        console.warn('THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
                        this.extensions.derivatives = value;
                    }
                }
            });
            //
            Object.assign(WebGLRenderer.prototype, {
                clearTarget: function (renderTarget, color, depth, stencil) {
                    console.warn('THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.');
                    this.setRenderTarget(renderTarget);
                    this.clear(color, depth, stencil);
                },
                animate: function (callback) {
                    console.warn('THREE.WebGLRenderer: .animate() is now .setAnimationLoop().');
                    this.setAnimationLoop(callback);
                },
                getCurrentRenderTarget: function () {
                    console.warn('THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().');
                    return this.getRenderTarget();
                },
                getMaxAnisotropy: function () {
                    console.warn('THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().');
                    return this.capabilities.getMaxAnisotropy();
                },
                getPrecision: function () {
                    console.warn('THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.');
                    return this.capabilities.precision;
                },
                resetGLState: function () {
                    console.warn('THREE.WebGLRenderer: .resetGLState() is now .state.reset().');
                    return this.state.reset();
                },
                supportsFloatTextures: function () {
                    console.warn('THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).');
                    return this.extensions.get('OES_texture_float');
                },
                supportsHalfFloatTextures: function () {
                    console.warn('THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).');
                    return this.extensions.get('OES_texture_half_float');
                },
                supportsStandardDerivatives: function () {
                    console.warn('THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).');
                    return this.extensions.get('OES_standard_derivatives');
                },
                supportsCompressedTextureS3TC: function () {
                    console.warn('THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).');
                    return this.extensions.get('WEBGL_compressed_texture_s3tc');
                },
                supportsCompressedTexturePVRTC: function () {
                    console.warn('THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).');
                    return this.extensions.get('WEBGL_compressed_texture_pvrtc');
                },
                supportsBlendMinMax: function () {
                    console.warn('THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).');
                    return this.extensions.get('EXT_blend_minmax');
                },
                supportsVertexTextures: function () {
                    console.warn('THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.');
                    return this.capabilities.vertexTextures;
                },
                supportsInstancedArrays: function () {
                    console.warn('THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).');
                    return this.extensions.get('ANGLE_instanced_arrays');
                },
                enableScissorTest: function (boolean) {
                    console.warn('THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().');
                    this.setScissorTest(boolean);
                },
                initMaterial: function () {
                    console.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');
                },
                addPrePlugin: function () {
                    console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');
                },
                addPostPlugin: function () {
                    console.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');
                },
                updateShadowMap: function () {
                    console.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');
                },
                setFaceCulling: function () {
                    console.warn('THREE.WebGLRenderer: .setFaceCulling() has been removed.');
                },
                allocTextureUnit: function () {
                    console.warn('THREE.WebGLRenderer: .allocTextureUnit() has been removed.');
                },
                setTexture: function () {
                    console.warn('THREE.WebGLRenderer: .setTexture() has been removed.');
                },
                setTexture2D: function () {
                    console.warn('THREE.WebGLRenderer: .setTexture2D() has been removed.');
                },
                setTextureCube: function () {
                    console.warn('THREE.WebGLRenderer: .setTextureCube() has been removed.');
                },
                getActiveMipMapLevel: function () {
                    console.warn('THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().');
                    return this.getActiveMipmapLevel();
                }
            });
            Object.defineProperties(WebGLRenderer.prototype, {
                shadowMapEnabled: {
                    get: function () {
                        return this.shadowMap.enabled;
                    },
                    set: function (value) {
                        console.warn('THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.');
                        this.shadowMap.enabled = value;
                    }
                },
                shadowMapType: {
                    get: function () {
                        return this.shadowMap.type;
                    },
                    set: function (value) {
                        console.warn('THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.');
                        this.shadowMap.type = value;
                    }
                },
                shadowMapCullFace: {
                    get: function () {
                        console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');
                        return undefined;
                    },
                    set: function ( /* value */) {
                        console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');
                    }
                },
                context: {
                    get: function () {
                        console.warn('THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.');
                        return this.getContext();
                    }
                },
                vr: {
                    get: function () {
                        console.warn('THREE.WebGLRenderer: .vr has been renamed to .xr');
                        return this.xr;
                    }
                },
                gammaInput: {
                    get: function () {
                        console.warn('THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.');
                        return false;
                    },
                    set: function () {
                        console.warn('THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.');
                    }
                },
                gammaOutput: {
                    get: function () {
                        console.warn('THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.');
                        return false;
                    },
                    set: function (value) {
                        console.warn('THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.');
                        this.outputEncoding = (value === true) ? sRGBEncoding : LinearEncoding;
                    }
                }
            });
            Object.defineProperties(WebGLShadowMap.prototype, {
                cullFace: {
                    get: function () {
                        console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');
                        return undefined;
                    },
                    set: function ( /* cullFace */) {
                        console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');
                    }
                },
                renderReverseSided: {
                    get: function () {
                        console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');
                        return undefined;
                    },
                    set: function () {
                        console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');
                    }
                },
                renderSingleSided: {
                    get: function () {
                        console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');
                        return undefined;
                    },
                    set: function () {
                        console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');
                    }
                }
            });
            //
            Object.defineProperties(WebGLRenderTarget.prototype, {
                wrapS: {
                    get: function () {
                        console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
                        return this.texture.wrapS;
                    },
                    set: function (value) {
                        console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
                        this.texture.wrapS = value;
                    }
                },
                wrapT: {
                    get: function () {
                        console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
                        return this.texture.wrapT;
                    },
                    set: function (value) {
                        console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
                        this.texture.wrapT = value;
                    }
                },
                magFilter: {
                    get: function () {
                        console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
                        return this.texture.magFilter;
                    },
                    set: function (value) {
                        console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
                        this.texture.magFilter = value;
                    }
                },
                minFilter: {
                    get: function () {
                        console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
                        return this.texture.minFilter;
                    },
                    set: function (value) {
                        console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
                        this.texture.minFilter = value;
                    }
                },
                anisotropy: {
                    get: function () {
                        console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
                        return this.texture.anisotropy;
                    },
                    set: function (value) {
                        console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
                        this.texture.anisotropy = value;
                    }
                },
                offset: {
                    get: function () {
                        console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
                        return this.texture.offset;
                    },
                    set: function (value) {
                        console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
                        this.texture.offset = value;
                    }
                },
                repeat: {
                    get: function () {
                        console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
                        return this.texture.repeat;
                    },
                    set: function (value) {
                        console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
                        this.texture.repeat = value;
                    }
                },
                format: {
                    get: function () {
                        console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
                        return this.texture.format;
                    },
                    set: function (value) {
                        console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
                        this.texture.format = value;
                    }
                },
                type: {
                    get: function () {
                        console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
                        return this.texture.type;
                    },
                    set: function (value) {
                        console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
                        this.texture.type = value;
                    }
                },
                generateMipmaps: {
                    get: function () {
                        console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
                        return this.texture.generateMipmaps;
                    },
                    set: function (value) {
                        console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
                        this.texture.generateMipmaps = value;
                    }
                }
            });
            //
            Object.defineProperties(Audio.prototype, {
                load: {
                    value: function (file) {
                        console.warn('THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.');
                        var scope = this;
                        var audioLoader = new AudioLoader();
                        audioLoader.load(file, function (buffer) {
                            scope.setBuffer(buffer);
                        });
                        return this;
                    }
                },
                startTime: {
                    set: function () {
                        console.warn('THREE.Audio: .startTime is now .play( delay ).');
                    }
                }
            });
            AudioAnalyser.prototype.getData = function () {
                console.warn('THREE.AudioAnalyser: .getData() is now .getFrequencyData().');
                return this.getFrequencyData();
            };
            //
            CubeCamera.prototype.updateCubeMap = function (renderer, scene) {
                console.warn('THREE.CubeCamera: .updateCubeMap() is now .update().');
                return this.update(renderer, scene);
            };
            //
            GeometryUtils = {
                merge: function (geometry1, geometry2, materialIndexOffset) {
                    console.warn('THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.');
                    var matrix;
                    if (geometry2.isMesh) {
                        geometry2.matrixAutoUpdate && geometry2.updateMatrix();
                        matrix = geometry2.matrix;
                        geometry2 = geometry2.geometry;
                    }
                    geometry1.merge(geometry2, matrix, materialIndexOffset);
                },
                center: function (geometry) {
                    console.warn('THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.');
                    return geometry.center();
                }
            };
            exports_14("GeometryUtils", GeometryUtils);
            ImageUtils.crossOrigin = undefined;
            ImageUtils.loadTexture = function (url, mapping, onLoad, onError) {
                console.warn('THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.');
                var loader = new TextureLoader();
                loader.setCrossOrigin(this.crossOrigin);
                var texture = loader.load(url, onLoad, undefined, onError);
                if (mapping)
                    texture.mapping = mapping;
                return texture;
            };
            ImageUtils.loadTextureCube = function (urls, mapping, onLoad, onError) {
                console.warn('THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.');
                var loader = new CubeTextureLoader();
                loader.setCrossOrigin(this.crossOrigin);
                var texture = loader.load(urls, onLoad, undefined, onError);
                if (mapping)
                    texture.mapping = mapping;
                return texture;
            };
            ImageUtils.loadCompressedTexture = function () {
                console.error('THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.');
            };
            ImageUtils.loadCompressedTextureCube = function () {
                console.error('THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.');
            };
            //
            SceneUtils = {
                createMultiMaterialObject: function ( /* geometry, materials */) {
                    console.error('THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js');
                },
                detach: function ( /* child, parent, scene */) {
                    console.error('THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js');
                },
                attach: function ( /* child, scene, parent */) {
                    console.error('THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js');
                }
            };
            exports_14("SceneUtils", SceneUtils);
            if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
                /* eslint-disable no-undef */
                __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('register', { detail: {
                        revision: REVISION,
                    } }));
                /* eslint-enable no-undef */
            }
        }
    };
});
System.register("http://localhost:5501/src/deps/three", ["https://unpkg.com/three@0.113.2/build/three.module"], function (exports_15, context_15) {
    "use strict";
    var __moduleName = context_15 && context_15.id;
    function exportStar_2(m) {
        var exports = {};
        for (var n in m) {
            if (n !== "default") exports[n] = m[n];
        }
        exports_15(exports);
    }
    return {
        setters: [
            function (three_module_js_1_1) {
                exportStar_2(three_module_js_1_1);
            }
        ],
        execute: function () {
        }
    };
});
System.register("http://localhost:5501/src/internals/styling", ["http://localhost:5501/src/deps/vue", "http://localhost:5501/src/deps/three", "http://localhost:5501/src/utils/index"], function (exports_16, context_16) {
    "use strict";
    var vue_js_3, three_js_1, index_js_2, stylingProps, useSvgStyling, stylingCanvas, useThreeFill, useThreeStroke;
    var __moduleName = context_16 && context_16.id;
    return {
        setters: [
            function (vue_js_3_1) {
                vue_js_3 = vue_js_3_1;
            },
            function (three_js_1_1) {
                three_js_1 = three_js_1_1;
            },
            function (index_js_2_1) {
                index_js_2 = index_js_2_1;
            }
        ],
        execute: function () {
            exports_16("stylingProps", stylingProps = {
                stroke: { default: "black", type: [String] },
                strokeWidth: { default: 2, type: [String, Number] },
                fill: { default: "none", type: [String, Number] },
                opacity: { default: 1, type: [String, Number] }
            });
            exports_16("useSvgStyling", useSvgStyling = props => {
                const sceneContext = vue_js_3.inject("sceneContext");
                return vue_js_3.computed(() => {
                    const fill = props.fill;
                    const stroke = props.stroke;
                    const strokeWidth = index_js_2.toNumber(props.strokeWidth, 1) * sceneContext.unit.value;
                    return { fill, stroke, strokeWidth };
                });
            });
            // Canvas
            exports_16("stylingCanvas", stylingCanvas = (props, scene) => {
                scene.fillStyle = props.fill;
                scene.strokeStyle = props.stroke;
                scene.lineWidth = props.strokeWidth;
            });
            // Three
            exports_16("useThreeFill", useThreeFill = props => vue_js_3.computed(() => new three_js_1.MeshPhongMaterial({
                color: props.fill,
                opacity: props.opacity,
                side: three_js_1.DoubleSide
            })));
            exports_16("useThreeStroke", useThreeStroke = props => vue_js_3.computed(() => new three_js_1.LineBasicMaterial({
                color: props.stroke,
                linewidth: props.strokeWidth,
                linecap: "round",
                linejoin: "round",
                opacity: props.opacity,
                side: three_js_1.DoubleSide
            })));
        }
    };
});
System.register("http://localhost:5501/src/internals/transform", ["http://localhost:5501/src/deps/vue", "http://localhost:5501/src/internals/index", "http://localhost:5501/src/utils/index"], function (exports_17, context_17) {
    "use strict";
    var vue_js_4, index_js_3, index_js_4, transformTwoProps, transformThreeProps, getTwoTransform, getThreeTransform, useSvgTransform, test_useSvgTransform_default_props, test_useSvgTransform_custom_props, transformCanvas, transformCanvasReset, useThreeTransform;
    var __moduleName = context_17 && context_17.id;
    return {
        setters: [
            function (vue_js_4_1) {
                vue_js_4 = vue_js_4_1;
            },
            function (index_js_3_1) {
                index_js_3 = index_js_3_1;
            },
            function (index_js_4_1) {
                index_js_4 = index_js_4_1;
            }
        ],
        execute: function () {
            exports_17("transformTwoProps", transformTwoProps = {
                position: { default: [0, 0], type: [String, Number, Array, Object] },
                rotation: { default: 0, type: [String, Number, Array, Object] },
                scale: { default: [1, 1], type: [String, Number, Array, Object] }
            });
            exports_17("transformThreeProps", transformThreeProps = {
                position: { default: [0, 0, 0], type: [String, Number, Array, Object] },
                rotation: { default: [0, 0, 0], type: [String, Number, Array, Object] },
                scale: { default: [1, 1, 1], type: [String, Number, Array, Object] }
            });
            getTwoTransform = props => {
                const position = index_js_3.parseCoords(props.position)[0];
                const rotation = index_js_3.parseCoords(props.rotation)[0];
                const scale = index_js_3.parseCoords(props.scale, index_js_3.normalizeScale)[0];
                return { position, rotation, scale };
            };
            getThreeTransform = props => {
                const position = index_js_3.parseCoords(props.position)[0];
                const rotation = index_js_3.parseCoords(props.rotation, index_js_3.normalizeThreeRotation)[0];
                const scale = index_js_3.parseCoords(props.scale, index_js_3.normalizeScale)[0];
                return { position, rotation, scale };
            };
            // SVG
            exports_17("useSvgTransform", useSvgTransform = props => {
                return vue_js_4.computed(() => {
                    const { position, rotation, scale } = getTwoTransform(props);
                    const positionStr = `translate(${position[0]} ${position[1]})`;
                    const rotationStr = `rotate(${rotation[0]})`;
                    const scaleStr = `scale(${scale[0]} ${scale[1]})`;
                    return [positionStr, rotationStr, scaleStr].join(" ");
                });
            });
            exports_17("test_useSvgTransform_default_props", test_useSvgTransform_default_props = () => {
                return [
                    useSvgTransform(transformTwoProps).value,
                    "translate(0 0) rotate(0) scale(1 1)"
                ];
            });
            exports_17("test_useSvgTransform_custom_props", test_useSvgTransform_custom_props = () => {
                const props = { position: "100 200", rotation: "300", scale: "2" };
                return [
                    useSvgTransform(props).value,
                    "translate(100 200) rotate(300) scale(2 2)"
                ];
            });
            // Canvas
            exports_17("transformCanvas", transformCanvas = (props, ctx) => {
                const { position, rotation, scale } = getTwoTransform(props);
                ctx.translate(position[0], position[1]);
                ctx.rotate(index_js_4.deg2rad(rotation[0]));
                ctx.scale(scale[0], scale[1]);
            });
            exports_17("transformCanvasReset", transformCanvasReset = ctx => {
                ctx.resetTransform();
            });
            // Three
            exports_17("useThreeTransform", useThreeTransform = (props, object) => {
                const { width, height } = vue_js_4.inject("sceneContext");
                vue_js_4.watch(() => props.position, () => {
                    const { position } = getThreeTransform(props);
                    object.position.x = position[0];
                    object.position.y = position[1];
                    object.position.x = index_js_4.fit(position[0], 0, width.value, width.value / -2, width.value / 2);
                    object.position.y = index_js_4.fit(position[1], 0, height.value, height.value / 2, height.value / -2);
                    object.position.z = position[2];
                });
                vue_js_4.watch(() => props.rotation, () => {
                    const { rotation } = getThreeTransform(props);
                    object.rotation.x = index_js_4.deg2rad(360 - rotation[0]);
                    object.rotation.y = index_js_4.deg2rad(360 - rotation[1]);
                    object.rotation.z = index_js_4.deg2rad(360 - rotation[2]);
                });
                vue_js_4.watch(() => props.scale, () => {
                    const { scale } = getThreeTransform(props);
                    object.scale.x = scale[0];
                    object.scale.y = scale[1];
                    object.scale.z = scale[2];
                });
            });
        }
    };
});
System.register("http://localhost:5501/src/internals/index", ["http://localhost:5501/src/internals/content", "http://localhost:5501/src/internals/coordinates", "http://localhost:5501/src/internals/size", "http://localhost:5501/src/internals/styling", "http://localhost:5501/src/internals/transform"], function (exports_18, context_18) {
    "use strict";
    var __moduleName = context_18 && context_18.id;
    function exportStar_3(m) {
        var exports = {};
        for (var n in m) {
            if (n !== "default") exports[n] = m[n];
        }
        exports_18(exports);
    }
    return {
        setters: [
            function (content_js_1_1) {
                exportStar_3(content_js_1_1);
            },
            function (coordinates_js_1_1) {
                exportStar_3(coordinates_js_1_1);
            },
            function (size_js_1_1) {
                exportStar_3(size_js_1_1);
            },
            function (styling_js_1_1) {
                exportStar_3(styling_js_1_1);
            },
            function (transform_js_1_1) {
                exportStar_3(transform_js_1_1);
            }
        ],
        execute: function () {
        }
    };
});
System.register("http://localhost:5501/src/components/FSquareSvg", ["http://localhost:5501/src/internals/index"], function (exports_19, context_19) {
    "use strict";
    var index_js_5, FSquareSvg;
    var __moduleName = context_19 && context_19.id;
    return {
        setters: [
            function (index_js_5_1) {
                index_js_5 = index_js_5_1;
            }
        ],
        execute: function () {
            exports_19("FSquareSvg", FSquareSvg = {
                props: { r: { default: 1 }, ...index_js_5.transformTwoProps, ...index_js_5.stylingProps },
                setup(props) {
                    const styling = index_js_5.useSvgStyling(props);
                    const transform = index_js_5.useSvgTransform(props);
                    return { styling, transform };
                },
                template: `
    <rect 
      :x="-r"
      :y="-r"
      :width="r * 2"
      :height="r * 2"
      :fill="styling.fill"
      :stroke="styling.stroke"
      :stroke-width="styling.strokeWidth"
      :transform="transform"
    />`
            });
        }
    };
});
System.register("http://localhost:5501/src/components/FSquareCanvas", ["http://localhost:5501/src/deps/vue", "http://localhost:5501/src/internals/index"], function (exports_20, context_20) {
    "use strict";
    var vue_js_5, index_js_6, FSquareCanvas;
    var __moduleName = context_20 && context_20.id;
    return {
        setters: [
            function (vue_js_5_1) {
                vue_js_5 = vue_js_5_1;
            },
            function (index_js_6_1) {
                index_js_6 = index_js_6_1;
            }
        ],
        execute: function () {
            exports_20("FSquareCanvas", FSquareCanvas = {
                props: {
                    r: { default: 1 },
                    ...index_js_6.stylingProps,
                    ...index_js_6.transformTwoProps
                },
                setup(props) {
                    const sceneContext = vue_js_5.inject("sceneContext");
                    vue_js_5.watch(() => {
                        if (sceneContext.ctx.value) {
                            index_js_6.transformCanvas(props, sceneContext.ctx.value);
                            index_js_6.stylingCanvas(props, sceneContext.ctx.value);
                            if (props.fill !== "none") {
                                sceneContext.ctx.value.fillRect(-props.r, -props.r, props.r * 2, props.r * 2);
                            }
                            if (props.stroke !== "none") {
                                sceneContext.ctx.value.strokeRect(-props.r, -props.r, props.r * 2, props.r * 2);
                            }
                            index_js_6.transformCanvasReset(sceneContext.ctx.value);
                        }
                    });
                    return () => null;
                }
            });
        }
    };
});
System.register("http://localhost:5501/src/components/FSquareThree", ["http://localhost:5501/src/deps/vue", "http://localhost:5501/src/deps/three", "http://localhost:5501/src/internals/index"], function (exports_21, context_21) {
    "use strict";
    var vue_js_6, three_js_2, index_js_7, FSquareThree;
    var __moduleName = context_21 && context_21.id;
    return {
        setters: [
            function (vue_js_6_1) {
                vue_js_6 = vue_js_6_1;
            },
            function (three_js_2_1) {
                three_js_2 = three_js_2_1;
            },
            function (index_js_7_1) {
                index_js_7 = index_js_7_1;
            }
        ],
        execute: function () {
            exports_21("FSquareThree", FSquareThree = {
                props: { r: { default: 1 }, ...index_js_7.transformThreeProps, ...index_js_7.stylingProps },
                setup(props) {
                    const sceneContext = vue_js_6.inject("sceneContext");
                    var group = new three_js_2.Group();
                    const geometry = new three_js_2.PlaneGeometry(props.r * 2, props.r * 2);
                    if (props.fill !== "none") {
                        const fill = index_js_7.useThreeFill(props);
                        const fillObject = new three_js_2.Mesh(geometry, fill.value);
                        group.add(fillObject);
                    }
                    if (props.stroke !== "none") {
                        const edges = new three_js_2.EdgesGeometry(geometry);
                        const stroke = index_js_7.useThreeStroke(props);
                        const strokeObject = new three_js_2.LineSegments(edges, stroke.value);
                        group.add(strokeObject);
                    }
                    sceneContext.scene.add(group);
                    index_js_7.useThreeTransform(props, group);
                    return () => null;
                }
            });
        }
    };
});
System.register("http://localhost:5501/src/components/FSquare", ["http://localhost:5501/src/deps/vue", "http://localhost:5501/src/components/FSquareSvg", "http://localhost:5501/src/components/FSquareCanvas", "http://localhost:5501/src/components/FSquareThree"], function (exports_22, context_22) {
    "use strict";
    var vue_js_7, FSquareSvg_js_1, FSquareCanvas_js_1, FSquareThree_js_1, FSquare;
    var __moduleName = context_22 && context_22.id;
    return {
        setters: [
            function (vue_js_7_1) {
                vue_js_7 = vue_js_7_1;
            },
            function (FSquareSvg_js_1_1) {
                FSquareSvg_js_1 = FSquareSvg_js_1_1;
            },
            function (FSquareCanvas_js_1_1) {
                FSquareCanvas_js_1 = FSquareCanvas_js_1_1;
            },
            function (FSquareThree_js_1_1) {
                FSquareThree_js_1 = FSquareThree_js_1_1;
            }
        ],
        execute: function () {
            exports_22("FSquare", FSquare = {
                setup(props, { slots }) {
                    const types = {
                        svg: FSquareSvg_js_1.FSquareSvg,
                        canvas: FSquareCanvas_js_1.FSquareCanvas,
                        three: FSquareThree_js_1.FSquareThree,
                        webgl: FSquareThree_js_1.FSquareThree
                    };
                    const sceneContext = vue_js_7.inject("sceneContext");
                    return () => vue_js_7.h(types[sceneContext.type.value], { ...props }, slots);
                }
            });
        }
    };
});
System.register("http://localhost:5501/src/components/FCircleSvg", ["http://localhost:5501/src/internals/index"], function (exports_23, context_23) {
    "use strict";
    var index_js_8, FCircleSvg;
    var __moduleName = context_23 && context_23.id;
    return {
        setters: [
            function (index_js_8_1) {
                index_js_8 = index_js_8_1;
            }
        ],
        execute: function () {
            exports_23("FCircleSvg", FCircleSvg = {
                props: { r: { default: 1 }, ...index_js_8.transformTwoProps, ...index_js_8.stylingProps },
                setup(props) {
                    const styling = index_js_8.useSvgStyling(props);
                    const transform = index_js_8.useSvgTransform(props);
                    return { transform, styling };
                },
                template: `
    <circle 
      cx="0"
      cy="0"
      :r="r"
      :transform="transform"
      :fill="styling.fill"
      :stroke="styling.stroke"
      :stroke-width="styling.strokeWidth"
    />`
            });
        }
    };
});
System.register("http://localhost:5501/src/components/FCircleCanvas", ["http://localhost:5501/src/deps/vue", "http://localhost:5501/src/internals/index"], function (exports_24, context_24) {
    "use strict";
    var vue_js_8, index_js_9, FCircleCanvas;
    var __moduleName = context_24 && context_24.id;
    return {
        setters: [
            function (vue_js_8_1) {
                vue_js_8 = vue_js_8_1;
            },
            function (index_js_9_1) {
                index_js_9 = index_js_9_1;
            }
        ],
        execute: function () {
            exports_24("FCircleCanvas", FCircleCanvas = {
                props: {
                    ...index_js_9.transformTwoProps,
                    ...index_js_9.stylingProps,
                    r: { default: 1 }
                },
                setup(props) {
                    const sceneContext = vue_js_8.inject("sceneContext");
                    vue_js_8.watch(() => {
                        if (sceneContext.ctx.value) {
                            index_js_9.transformCanvas(props, sceneContext.ctx.value);
                            index_js_9.stylingCanvas(props, sceneContext.ctx.value);
                            sceneContext.ctx.value.beginPath();
                            sceneContext.ctx.value.arc(0, 0, props.r, 0, 2 * Math.PI);
                            if (props.fill !== "none") {
                                sceneContext.ctx.value.fill();
                            }
                            if (props.stroke !== "none") {
                                sceneContext.ctx.value.stroke();
                            }
                            index_js_9.transformCanvasReset(sceneContext.ctx.value);
                        }
                    });
                    return () => null;
                }
            });
        }
    };
});
System.register("http://localhost:5501/src/components/FCircleThree", ["http://localhost:5501/src/deps/vue", "http://localhost:5501/src/deps/three", "http://localhost:5501/src/internals/index"], function (exports_25, context_25) {
    "use strict";
    var vue_js_9, three_js_3, index_js_10, FCircleThree;
    var __moduleName = context_25 && context_25.id;
    return {
        setters: [
            function (vue_js_9_1) {
                vue_js_9 = vue_js_9_1;
            },
            function (three_js_3_1) {
                three_js_3 = three_js_3_1;
            },
            function (index_js_10_1) {
                index_js_10 = index_js_10_1;
            }
        ],
        execute: function () {
            exports_25("FCircleThree", FCircleThree = {
                props: { r: { default: 1 }, ...index_js_10.stylingProps, ...index_js_10.transformThreeProps },
                setup(props) {
                    const sceneContext = vue_js_9.inject("sceneContext");
                    var group = new three_js_3.Group();
                    const geometry = new three_js_3.CircleGeometry(props.r, 64);
                    if (props.fill !== "none") {
                        const fill = index_js_10.useThreeFill(props);
                        const fillObject = new three_js_3.Mesh(geometry, fill.value);
                        group.add(fillObject);
                    }
                    if (props.stroke !== "none") {
                        const edges = new three_js_3.EdgesGeometry(geometry);
                        const stroke = index_js_10.useThreeStroke(props);
                        const strokeObject = new three_js_3.LineSegments(edges, stroke.value);
                        group.add(strokeObject);
                    }
                    sceneContext.scene.add(group);
                    index_js_10.useThreeTransform(props, group);
                    return () => null;
                }
            });
        }
    };
});
System.register("http://localhost:5501/src/components/FCircle", ["http://localhost:5501/src/deps/vue", "http://localhost:5501/src/components/FCircleSvg", "http://localhost:5501/src/components/FCircleCanvas", "http://localhost:5501/src/components/FCircleThree"], function (exports_26, context_26) {
    "use strict";
    var vue_js_10, FCircleSvg_js_1, FCircleCanvas_js_1, FCircleThree_js_1, FCircle;
    var __moduleName = context_26 && context_26.id;
    return {
        setters: [
            function (vue_js_10_1) {
                vue_js_10 = vue_js_10_1;
            },
            function (FCircleSvg_js_1_1) {
                FCircleSvg_js_1 = FCircleSvg_js_1_1;
            },
            function (FCircleCanvas_js_1_1) {
                FCircleCanvas_js_1 = FCircleCanvas_js_1_1;
            },
            function (FCircleThree_js_1_1) {
                FCircleThree_js_1 = FCircleThree_js_1_1;
            }
        ],
        execute: function () {
            exports_26("FCircle", FCircle = {
                setup(props, { slots }) {
                    const types = {
                        svg: FCircleSvg_js_1.FCircleSvg,
                        canvas: FCircleCanvas_js_1.FCircleCanvas,
                        three: FCircleThree_js_1.FCircleThree,
                        webgl: FCircleThree_js_1.FCircleThree
                    };
                    const sceneContext = vue_js_10.inject("sceneContext");
                    return () => types[sceneContext.type.value]
                        ? vue_js_10.h(types[sceneContext.type.value], { ...props }, slots)
                        : null;
                }
            });
        }
    };
});
/**
 * marked - a markdown parser
 * Copyright (c) 2011-2019, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/markedjs/marked
 */
System.register("https://unpkg.com/marked@0.8.0/lib/marked.esm", [], function (exports_27, context_27) {
    "use strict";
    var defaults, defaults_1, defaults_2, defaults_3, escapeTest, escapeReplace, escapeTestNoEncode, escapeReplaceNoEncode, escapeReplacements, getEscapeReplacement, unescapeTest, caret, nonWordAndColonTest, originIndependentUrl, baseUrls, justDomain, protocol, domain, noopTest, helpers, noopTest$1, edit$1, merge$1, block, inline, rules, defaults$1, block$1, rtrim$1, splitCells$1, escape$1, Lexer_1, defaults$2, cleanUrl$1, escape$2, Renderer_1, Slugger_1, defaults$3, inline$1, findClosingBracket$1, escape$3, InlineLexer_1, TextRenderer_1, defaults$4, merge$2, unescape$1, Parser_1, merge$3, checkSanitizeDeprecation$1, escape$4, getDefaults, changeDefaults, defaults$5, marked_1;
    var __moduleName = context_27 && context_27.id;
    /**
     * DO NOT EDIT THIS FILE
     * The code in this file is generated from files in ./src/
     */
    function createCommonjsModule(fn, module) {
        return module = { exports: {} }, fn(module, module.exports), module.exports;
    }
    function escape(html, encode) {
        if (encode) {
            if (escapeTest.test(html)) {
                return html.replace(escapeReplace, getEscapeReplacement);
            }
        }
        else {
            if (escapeTestNoEncode.test(html)) {
                return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
            }
        }
        return html;
    }
    function unescape(html) {
        // explicitly match decimal, hex, and named HTML entities
        return html.replace(unescapeTest, (_, n) => {
            n = n.toLowerCase();
            if (n === 'colon')
                return ':';
            if (n.charAt(0) === '#') {
                return n.charAt(1) === 'x'
                    ? String.fromCharCode(parseInt(n.substring(2), 16))
                    : String.fromCharCode(+n.substring(1));
            }
            return '';
        });
    }
    function edit(regex, opt) {
        regex = regex.source || regex;
        opt = opt || '';
        const obj = {
            replace: (name, val) => {
                val = val.source || val;
                val = val.replace(caret, '$1');
                regex = regex.replace(name, val);
                return obj;
            },
            getRegex: () => {
                return new RegExp(regex, opt);
            }
        };
        return obj;
    }
    function cleanUrl(sanitize, base, href) {
        if (sanitize) {
            let prot;
            try {
                prot = decodeURIComponent(unescape(href))
                    .replace(nonWordAndColonTest, '')
                    .toLowerCase();
            }
            catch (e) {
                return null;
            }
            if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {
                return null;
            }
        }
        if (base && !originIndependentUrl.test(href)) {
            href = resolveUrl(base, href);
        }
        try {
            href = encodeURI(href).replace(/%25/g, '%');
        }
        catch (e) {
            return null;
        }
        return href;
    }
    function resolveUrl(base, href) {
        if (!baseUrls[' ' + base]) {
            // we can ignore everything in base after the last slash of its path component,
            // but we might need to add _that_
            // https://tools.ietf.org/html/rfc3986#section-3
            if (justDomain.test(base)) {
                baseUrls[' ' + base] = base + '/';
            }
            else {
                baseUrls[' ' + base] = rtrim(base, '/', true);
            }
        }
        base = baseUrls[' ' + base];
        const relativeBase = base.indexOf(':') === -1;
        if (href.substring(0, 2) === '//') {
            if (relativeBase) {
                return href;
            }
            return base.replace(protocol, '$1') + href;
        }
        else if (href.charAt(0) === '/') {
            if (relativeBase) {
                return href;
            }
            return base.replace(domain, '$1') + href;
        }
        else {
            return base + href;
        }
    }
    function merge(obj) {
        let i = 1, target, key;
        for (; i < arguments.length; i++) {
            target = arguments[i];
            for (key in target) {
                if (Object.prototype.hasOwnProperty.call(target, key)) {
                    obj[key] = target[key];
                }
            }
        }
        return obj;
    }
    function splitCells(tableRow, count) {
        // ensure that every cell-delimiting pipe has a space
        // before it to distinguish it from an escaped pipe
        const row = tableRow.replace(/\|/g, (match, offset, str) => {
            let escaped = false, curr = offset;
            while (--curr >= 0 && str[curr] === '\\')
                escaped = !escaped;
            if (escaped) {
                // odd number of slashes means | is escaped
                // so we leave it alone
                return '|';
            }
            else {
                // add space before unescaped |
                return ' |';
            }
        }), cells = row.split(/ \|/);
        let i = 0;
        if (cells.length > count) {
            cells.splice(count);
        }
        else {
            while (cells.length < count)
                cells.push('');
        }
        for (; i < cells.length; i++) {
            // leading or trailing whitespace is ignored per the gfm spec
            cells[i] = cells[i].trim().replace(/\\\|/g, '|');
        }
        return cells;
    }
    // Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').
    // /c*$/ is vulnerable to REDOS.
    // invert: Remove suffix of non-c chars instead. Default falsey.
    function rtrim(str, c, invert) {
        const l = str.length;
        if (l === 0) {
            return '';
        }
        // Length of suffix matching the invert condition.
        let suffLen = 0;
        // Step left until we fail to match the invert condition.
        while (suffLen < l) {
            const currChar = str.charAt(l - suffLen - 1);
            if (currChar === c && !invert) {
                suffLen++;
            }
            else if (currChar !== c && invert) {
                suffLen++;
            }
            else {
                break;
            }
        }
        return str.substr(0, l - suffLen);
    }
    function findClosingBracket(str, b) {
        if (str.indexOf(b[1]) === -1) {
            return -1;
        }
        const l = str.length;
        let level = 0, i = 0;
        for (; i < l; i++) {
            if (str[i] === '\\') {
                i++;
            }
            else if (str[i] === b[0]) {
                level++;
            }
            else if (str[i] === b[1]) {
                level--;
                if (level < 0) {
                    return i;
                }
            }
        }
        return -1;
    }
    function checkSanitizeDeprecation(opt) {
        if (opt && opt.sanitize && !opt.silent) {
            console.warn('marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options');
        }
    }
    /**
     * Marked
     */
    function marked(src, opt, callback) {
        // throw error in case of non string input
        if (typeof src === 'undefined' || src === null) {
            throw new Error('marked(): input parameter is undefined or null');
        }
        if (typeof src !== 'string') {
            throw new Error('marked(): input parameter is of type '
                + Object.prototype.toString.call(src) + ', string expected');
        }
        if (callback || typeof opt === 'function') {
            if (!callback) {
                callback = opt;
                opt = null;
            }
            opt = merge$3({}, marked.defaults, opt || {});
            checkSanitizeDeprecation$1(opt);
            const highlight = opt.highlight;
            let tokens, pending, i = 0;
            try {
                tokens = Lexer_1.lex(src, opt);
            }
            catch (e) {
                return callback(e);
            }
            pending = tokens.length;
            const done = function (err) {
                if (err) {
                    opt.highlight = highlight;
                    return callback(err);
                }
                let out;
                try {
                    out = Parser_1.parse(tokens, opt);
                }
                catch (e) {
                    err = e;
                }
                opt.highlight = highlight;
                return err
                    ? callback(err)
                    : callback(null, out);
            };
            if (!highlight || highlight.length < 3) {
                return done();
            }
            delete opt.highlight;
            if (!pending)
                return done();
            for (; i < tokens.length; i++) {
                (function (token) {
                    if (token.type !== 'code') {
                        return --pending || done();
                    }
                    return highlight(token.text, token.lang, function (err, code) {
                        if (err)
                            return done(err);
                        if (code == null || code === token.text) {
                            return --pending || done();
                        }
                        token.text = code;
                        token.escaped = true;
                        --pending || done();
                    });
                })(tokens[i]);
            }
            return;
        }
        try {
            opt = merge$3({}, marked.defaults, opt || {});
            checkSanitizeDeprecation$1(opt);
            return Parser_1.parse(Lexer_1.lex(src, opt), opt);
        }
        catch (e) {
            e.message += '\nPlease report this to https://github.com/markedjs/marked.';
            if ((opt || marked.defaults).silent) {
                return '<p>An error occurred:</p><pre>'
                    + escape$4(e.message + '', true)
                    + '</pre>';
            }
            throw e;
        }
    }
    return {
        setters: [],
        execute: function () {
            defaults = createCommonjsModule(function (module) {
                function getDefaults() {
                    return {
                        baseUrl: null,
                        breaks: false,
                        gfm: true,
                        headerIds: true,
                        headerPrefix: '',
                        highlight: null,
                        langPrefix: 'language-',
                        mangle: true,
                        pedantic: false,
                        renderer: null,
                        sanitize: false,
                        sanitizer: null,
                        silent: false,
                        smartLists: false,
                        smartypants: false,
                        xhtml: false
                    };
                }
                function changeDefaults(newDefaults) {
                    module.exports.defaults = newDefaults;
                }
                module.exports = {
                    defaults: getDefaults(),
                    getDefaults,
                    changeDefaults
                };
            });
            defaults_1 = defaults.defaults;
            defaults_2 = defaults.getDefaults;
            defaults_3 = defaults.changeDefaults;
            /**
             * Helpers
             */
            escapeTest = /[&<>"']/;
            escapeReplace = /[&<>"']/g;
            escapeTestNoEncode = /[<>"']|&(?!#?\w+;)/;
            escapeReplaceNoEncode = /[<>"']|&(?!#?\w+;)/g;
            escapeReplacements = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#39;'
            };
            getEscapeReplacement = (ch) => escapeReplacements[ch];
            unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
            caret = /(^|[^\[])\^/g;
            nonWordAndColonTest = /[^\w:]/g;
            originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
            baseUrls = {};
            justDomain = /^[^:]+:\/*[^/]*$/;
            protocol = /^([^:]+:)[\s\S]*$/;
            domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;
            noopTest = { exec: function noopTest() { } };
            helpers = {
                escape,
                unescape,
                edit,
                cleanUrl,
                resolveUrl,
                noopTest,
                merge,
                splitCells,
                rtrim,
                findClosingBracket,
                checkSanitizeDeprecation
            };
            noopTest$1 = helpers.noopTest, edit$1 = helpers.edit, merge$1 = helpers.merge;
            /**
             * Block-Level Grammar
             */
            block = {
                newline: /^\n+/,
                code: /^( {4}[^\n]+\n*)+/,
                fences: /^ {0,3}(`{3,}|~{3,})([^`~\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?:\n+|$)|$)/,
                hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/,
                heading: /^ {0,3}(#{1,6}) +([^\n]*?)(?: +#+)? *(?:\n+|$)/,
                blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
                list: /^( {0,3})(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
                html: '^ {0,3}(?:' // optional indentation
                    + '<(script|pre|style)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)' // (1)
                    + '|comment[^\\n]*(\\n+|$)' // (2)
                    + '|<\\?[\\s\\S]*?\\?>\\n*' // (3)
                    + '|<![A-Z][\\s\\S]*?>\\n*' // (4)
                    + '|<!\\[CDATA\\[[\\s\\S]*?\\]\\]>\\n*' // (5)
                    + '|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:\\n{2,}|$)' // (6)
                    + '|<(?!script|pre|style)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:\\n{2,}|$)' // (7) open tag
                    + '|</(?!script|pre|style)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:\\n{2,}|$)' // (7) closing tag
                    + ')',
                def: /^ {0,3}\[(label)\]: *\n? *<?([^\s>]+)>?(?:(?: +\n? *| *\n *)(title))? *(?:\n+|$)/,
                nptable: noopTest$1,
                table: noopTest$1,
                lheading: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/,
                // regex template, placeholders will be replaced according to different paragraph
                // interruption rules of commonmark and the original markdown spec:
                _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html)[^\n]+)*)/,
                text: /^[^\n]+/
            };
            block._label = /(?!\s*\])(?:\\[\[\]]|[^\[\]])+/;
            block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
            block.def = edit$1(block.def)
                .replace('label', block._label)
                .replace('title', block._title)
                .getRegex();
            block.bullet = /(?:[*+-]|\d{1,9}\.)/;
            block.item = /^( *)(bull) ?[^\n]*(?:\n(?!\1bull ?)[^\n]*)*/;
            block.item = edit$1(block.item, 'gm')
                .replace(/bull/g, block.bullet)
                .getRegex();
            block.list = edit$1(block.list)
                .replace(/bull/g, block.bullet)
                .replace('hr', '\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))')
                .replace('def', '\\n+(?=' + block.def.source + ')')
                .getRegex();
            block._tag = 'address|article|aside|base|basefont|blockquote|body|caption'
                + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption'
                + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe'
                + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option'
                + '|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr'
                + '|track|ul';
            block._comment = /<!--(?!-?>)[\s\S]*?-->/;
            block.html = edit$1(block.html, 'i')
                .replace('comment', block._comment)
                .replace('tag', block._tag)
                .replace('attribute', / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/)
                .getRegex();
            block.paragraph = edit$1(block._paragraph)
                .replace('hr', block.hr)
                .replace('heading', ' {0,3}#{1,6} +')
                .replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs
                .replace('blockquote', ' {0,3}>')
                .replace('fences', ' {0,3}(?:`{3,}|~{3,})[^`\\n]*\\n')
                .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
                .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|!--)')
                .replace('tag', block._tag) // pars can be interrupted by type (6) html blocks
                .getRegex();
            block.blockquote = edit$1(block.blockquote)
                .replace('paragraph', block.paragraph)
                .getRegex();
            /**
             * Normal Block Grammar
             */
            block.normal = merge$1({}, block);
            /**
             * GFM Block Grammar
             */
            block.gfm = merge$1({}, block.normal, {
                nptable: /^ *([^|\n ].*\|.*)\n *([-:]+ *\|[-| :]*)(?:\n((?:.*[^>\n ].*(?:\n|$))*)\n*|$)/,
                table: /^ *\|(.+)\n *\|?( *[-:]+[-| :]*)(?:\n((?: *[^>\n ].*(?:\n|$))*)\n*|$)/
            });
            /**
             * Pedantic grammar (original John Gruber's loose markdown specification)
             */
            block.pedantic = merge$1({}, block.normal, {
                html: edit$1('^ *(?:comment *(?:\\n|\\s*$)'
                    + '|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)' // closed tag
                    + '|<tag(?:"[^"]*"|\'[^\']*\'|\\s[^\'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))')
                    .replace('comment', block._comment)
                    .replace(/tag/g, '(?!(?:'
                    + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub'
                    + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)'
                    + '\\b)\\w+(?!:|[^\\w\\s@]*@)\\b')
                    .getRegex(),
                def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
                heading: /^ *(#{1,6}) *([^\n]+?) *(?:#+ *)?(?:\n+|$)/,
                fences: noopTest$1,
                paragraph: edit$1(block.normal._paragraph)
                    .replace('hr', block.hr)
                    .replace('heading', ' *#{1,6} *[^\n]')
                    .replace('lheading', block.lheading)
                    .replace('blockquote', ' {0,3}>')
                    .replace('|fences', '')
                    .replace('|list', '')
                    .replace('|html', '')
                    .getRegex()
            });
            /**
             * Inline-Level Grammar
             */
            inline = {
                escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
                autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
                url: noopTest$1,
                tag: '^comment'
                    + '|^</[a-zA-Z][\\w:-]*\\s*>' // self-closing tag
                    + '|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>' // open tag
                    + '|^<\\?[\\s\\S]*?\\?>' // processing instruction, e.g. <?php ?>
                    + '|^<![a-zA-Z]+\\s[\\s\\S]*?>' // declaration, e.g. <!DOCTYPE html>
                    + '|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>',
                link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
                reflink: /^!?\[(label)\]\[(?!\s*\])((?:\\[\[\]]?|[^\[\]\\])+)\]/,
                nolink: /^!?\[(?!\s*\])((?:\[[^\[\]]*\]|\\[\[\]]|[^\[\]])*)\](?:\[\])?/,
                strong: /^__([^\s_])__(?!_)|^\*\*([^\s*])\*\*(?!\*)|^__([^\s][\s\S]*?[^\s])__(?!_)|^\*\*([^\s][\s\S]*?[^\s])\*\*(?!\*)/,
                em: /^_([^\s_])_(?!_)|^\*([^\s*<\[])\*(?!\*)|^_([^\s<][\s\S]*?[^\s_])_(?!_|[^\spunctuation])|^_([^\s_<][\s\S]*?[^\s])_(?!_|[^\spunctuation])|^\*([^\s<"][\s\S]*?[^\s\*])\*(?!\*|[^\spunctuation])|^\*([^\s*"<\[][\s\S]*?[^\s])\*(?!\*)/,
                code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
                br: /^( {2,}|\\)\n(?!\s*$)/,
                del: noopTest$1,
                text: /^(`+|[^`])(?:[\s\S]*?(?:(?=[\\<!\[`*]|\b_|$)|[^ ](?= {2,}\n))|(?= {2,}\n))/
            };
            // list of punctuation marks from common mark spec
            // without ` and ] to workaround Rule 17 (inline code blocks/links)
            inline._punctuation = '!"#$%&\'()*+,\\-./:;<=>?@\\[^_{|}~';
            inline.em = edit$1(inline.em).replace(/punctuation/g, inline._punctuation).getRegex();
            inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
            inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
            inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
            inline.autolink = edit$1(inline.autolink)
                .replace('scheme', inline._scheme)
                .replace('email', inline._email)
                .getRegex();
            inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
            inline.tag = edit$1(inline.tag)
                .replace('comment', block._comment)
                .replace('attribute', inline._attribute)
                .getRegex();
            inline._label = /(?:\[[^\[\]]*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
            inline._href = /<(?:\\[<>]?|[^\s<>\\])*>|[^\s\x00-\x1f]*/;
            inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
            inline.link = edit$1(inline.link)
                .replace('label', inline._label)
                .replace('href', inline._href)
                .replace('title', inline._title)
                .getRegex();
            inline.reflink = edit$1(inline.reflink)
                .replace('label', inline._label)
                .getRegex();
            /**
             * Normal Inline Grammar
             */
            inline.normal = merge$1({}, inline);
            /**
             * Pedantic Inline Grammar
             */
            inline.pedantic = merge$1({}, inline.normal, {
                strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
                em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/,
                link: edit$1(/^!?\[(label)\]\((.*?)\)/)
                    .replace('label', inline._label)
                    .getRegex(),
                reflink: edit$1(/^!?\[(label)\]\s*\[([^\]]*)\]/)
                    .replace('label', inline._label)
                    .getRegex()
            });
            /**
             * GFM Inline Grammar
             */
            inline.gfm = merge$1({}, inline.normal, {
                escape: edit$1(inline.escape).replace('])', '~|])').getRegex(),
                _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
                url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
                _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
                del: /^~+(?=\S)([\s\S]*?\S)~+/,
                text: /^(`+|[^`])(?:[\s\S]*?(?:(?=[\\<!\[`*~]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@))|(?= {2,}\n|[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@))/
            });
            inline.gfm.url = edit$1(inline.gfm.url, 'i')
                .replace('email', inline.gfm._extended_email)
                .getRegex();
            /**
             * GFM + Line Breaks Inline Grammar
             */
            inline.breaks = merge$1({}, inline.gfm, {
                br: edit$1(inline.br).replace('{2,}', '*').getRegex(),
                text: edit$1(inline.gfm.text)
                    .replace('\\b_', '\\b_| {2,}\\n')
                    .replace(/\{2,\}/g, '*')
                    .getRegex()
            });
            rules = {
                block,
                inline
            };
            defaults$1 = defaults.defaults;
            block$1 = rules.block;
            rtrim$1 = helpers.rtrim, splitCells$1 = helpers.splitCells, escape$1 = helpers.escape;
            /**
             * Block Lexer
             */
            Lexer_1 = class Lexer {
                constructor(options) {
                    this.tokens = [];
                    this.tokens.links = Object.create(null);
                    this.options = options || defaults$1;
                    this.rules = block$1.normal;
                    if (this.options.pedantic) {
                        this.rules = block$1.pedantic;
                    }
                    else if (this.options.gfm) {
                        this.rules = block$1.gfm;
                    }
                }
                /**
                 * Expose Block Rules
                 */
                static get rules() {
                    return block$1;
                }
                /**
                 * Static Lex Method
                 */
                static lex(src, options) {
                    const lexer = new Lexer(options);
                    return lexer.lex(src);
                }
                ;
                /**
                 * Preprocessing
                 */
                lex(src) {
                    src = src
                        .replace(/\r\n|\r/g, '\n')
                        .replace(/\t/g, '    ');
                    return this.token(src, true);
                }
                ;
                /**
                 * Lexing
                 */
                token(src, top) {
                    src = src.replace(/^ +$/gm, '');
                    let next, loose, cap, bull, b, item, listStart, listItems, t, space, i, tag, l, isordered, istask, ischecked;
                    while (src) {
                        // newline
                        if (cap = this.rules.newline.exec(src)) {
                            src = src.substring(cap[0].length);
                            if (cap[0].length > 1) {
                                this.tokens.push({
                                    type: 'space'
                                });
                            }
                        }
                        // code
                        if (cap = this.rules.code.exec(src)) {
                            const lastToken = this.tokens[this.tokens.length - 1];
                            src = src.substring(cap[0].length);
                            // An indented code block cannot interrupt a paragraph.
                            if (lastToken && lastToken.type === 'paragraph') {
                                lastToken.text += '\n' + cap[0].trimRight();
                            }
                            else {
                                cap = cap[0].replace(/^ {4}/gm, '');
                                this.tokens.push({
                                    type: 'code',
                                    codeBlockStyle: 'indented',
                                    text: !this.options.pedantic
                                        ? rtrim$1(cap, '\n')
                                        : cap
                                });
                            }
                            continue;
                        }
                        // fences
                        if (cap = this.rules.fences.exec(src)) {
                            src = src.substring(cap[0].length);
                            this.tokens.push({
                                type: 'code',
                                lang: cap[2] ? cap[2].trim() : cap[2],
                                text: cap[3] || ''
                            });
                            continue;
                        }
                        // heading
                        if (cap = this.rules.heading.exec(src)) {
                            src = src.substring(cap[0].length);
                            this.tokens.push({
                                type: 'heading',
                                depth: cap[1].length,
                                text: cap[2]
                            });
                            continue;
                        }
                        // table no leading pipe (gfm)
                        if (cap = this.rules.nptable.exec(src)) {
                            item = {
                                type: 'table',
                                header: splitCells$1(cap[1].replace(/^ *| *\| *$/g, '')),
                                align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
                                cells: cap[3] ? cap[3].replace(/\n$/, '').split('\n') : []
                            };
                            if (item.header.length === item.align.length) {
                                src = src.substring(cap[0].length);
                                for (i = 0; i < item.align.length; i++) {
                                    if (/^ *-+: *$/.test(item.align[i])) {
                                        item.align[i] = 'right';
                                    }
                                    else if (/^ *:-+: *$/.test(item.align[i])) {
                                        item.align[i] = 'center';
                                    }
                                    else if (/^ *:-+ *$/.test(item.align[i])) {
                                        item.align[i] = 'left';
                                    }
                                    else {
                                        item.align[i] = null;
                                    }
                                }
                                for (i = 0; i < item.cells.length; i++) {
                                    item.cells[i] = splitCells$1(item.cells[i], item.header.length);
                                }
                                this.tokens.push(item);
                                continue;
                            }
                        }
                        // hr
                        if (cap = this.rules.hr.exec(src)) {
                            src = src.substring(cap[0].length);
                            this.tokens.push({
                                type: 'hr'
                            });
                            continue;
                        }
                        // blockquote
                        if (cap = this.rules.blockquote.exec(src)) {
                            src = src.substring(cap[0].length);
                            this.tokens.push({
                                type: 'blockquote_start'
                            });
                            cap = cap[0].replace(/^ *> ?/gm, '');
                            // Pass `top` to keep the current
                            // "toplevel" state. This is exactly
                            // how markdown.pl works.
                            this.token(cap, top);
                            this.tokens.push({
                                type: 'blockquote_end'
                            });
                            continue;
                        }
                        // list
                        if (cap = this.rules.list.exec(src)) {
                            src = src.substring(cap[0].length);
                            bull = cap[2];
                            isordered = bull.length > 1;
                            listStart = {
                                type: 'list_start',
                                ordered: isordered,
                                start: isordered ? +bull : '',
                                loose: false
                            };
                            this.tokens.push(listStart);
                            // Get each top-level item.
                            cap = cap[0].match(this.rules.item);
                            listItems = [];
                            next = false;
                            l = cap.length;
                            i = 0;
                            for (; i < l; i++) {
                                item = cap[i];
                                // Remove the list item's bullet
                                // so it is seen as the next token.
                                space = item.length;
                                item = item.replace(/^ *([*+-]|\d+\.) */, '');
                                // Outdent whatever the
                                // list item contains. Hacky.
                                if (~item.indexOf('\n ')) {
                                    space -= item.length;
                                    item = !this.options.pedantic
                                        ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')
                                        : item.replace(/^ {1,4}/gm, '');
                                }
                                // Determine whether the next list item belongs here.
                                // Backpedal if it does not belong in this list.
                                if (i !== l - 1) {
                                    b = block$1.bullet.exec(cap[i + 1])[0];
                                    if (bull.length > 1 ? b.length === 1
                                        : (b.length > 1 || (this.options.smartLists && b !== bull))) {
                                        src = cap.slice(i + 1).join('\n') + src;
                                        i = l - 1;
                                    }
                                }
                                // Determine whether item is loose or not.
                                // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
                                // for discount behavior.
                                loose = next || /\n\n(?!\s*$)/.test(item);
                                if (i !== l - 1) {
                                    next = item.charAt(item.length - 1) === '\n';
                                    if (!loose)
                                        loose = next;
                                }
                                if (loose) {
                                    listStart.loose = true;
                                }
                                // Check for task list items
                                istask = /^\[[ xX]\] /.test(item);
                                ischecked = undefined;
                                if (istask) {
                                    ischecked = item[1] !== ' ';
                                    item = item.replace(/^\[[ xX]\] +/, '');
                                }
                                t = {
                                    type: 'list_item_start',
                                    task: istask,
                                    checked: ischecked,
                                    loose: loose
                                };
                                listItems.push(t);
                                this.tokens.push(t);
                                // Recurse.
                                this.token(item, false);
                                this.tokens.push({
                                    type: 'list_item_end'
                                });
                            }
                            if (listStart.loose) {
                                l = listItems.length;
                                i = 0;
                                for (; i < l; i++) {
                                    listItems[i].loose = true;
                                }
                            }
                            this.tokens.push({
                                type: 'list_end'
                            });
                            continue;
                        }
                        // html
                        if (cap = this.rules.html.exec(src)) {
                            src = src.substring(cap[0].length);
                            this.tokens.push({
                                type: this.options.sanitize
                                    ? 'paragraph'
                                    : 'html',
                                pre: !this.options.sanitizer
                                    && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),
                                text: this.options.sanitize ? (this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape$1(cap[0])) : cap[0]
                            });
                            continue;
                        }
                        // def
                        if (top && (cap = this.rules.def.exec(src))) {
                            src = src.substring(cap[0].length);
                            if (cap[3])
                                cap[3] = cap[3].substring(1, cap[3].length - 1);
                            tag = cap[1].toLowerCase().replace(/\s+/g, ' ');
                            if (!this.tokens.links[tag]) {
                                this.tokens.links[tag] = {
                                    href: cap[2],
                                    title: cap[3]
                                };
                            }
                            continue;
                        }
                        // table (gfm)
                        if (cap = this.rules.table.exec(src)) {
                            item = {
                                type: 'table',
                                header: splitCells$1(cap[1].replace(/^ *| *\| *$/g, '')),
                                align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
                                cells: cap[3] ? cap[3].replace(/\n$/, '').split('\n') : []
                            };
                            if (item.header.length === item.align.length) {
                                src = src.substring(cap[0].length);
                                for (i = 0; i < item.align.length; i++) {
                                    if (/^ *-+: *$/.test(item.align[i])) {
                                        item.align[i] = 'right';
                                    }
                                    else if (/^ *:-+: *$/.test(item.align[i])) {
                                        item.align[i] = 'center';
                                    }
                                    else if (/^ *:-+ *$/.test(item.align[i])) {
                                        item.align[i] = 'left';
                                    }
                                    else {
                                        item.align[i] = null;
                                    }
                                }
                                for (i = 0; i < item.cells.length; i++) {
                                    item.cells[i] = splitCells$1(item.cells[i].replace(/^ *\| *| *\| *$/g, ''), item.header.length);
                                }
                                this.tokens.push(item);
                                continue;
                            }
                        }
                        // lheading
                        if (cap = this.rules.lheading.exec(src)) {
                            src = src.substring(cap[0].length);
                            this.tokens.push({
                                type: 'heading',
                                depth: cap[2].charAt(0) === '=' ? 1 : 2,
                                text: cap[1]
                            });
                            continue;
                        }
                        // top-level paragraph
                        if (top && (cap = this.rules.paragraph.exec(src))) {
                            src = src.substring(cap[0].length);
                            this.tokens.push({
                                type: 'paragraph',
                                text: cap[1].charAt(cap[1].length - 1) === '\n'
                                    ? cap[1].slice(0, -1)
                                    : cap[1]
                            });
                            continue;
                        }
                        // text
                        if (cap = this.rules.text.exec(src)) {
                            // Top-level should never reach here.
                            src = src.substring(cap[0].length);
                            this.tokens.push({
                                type: 'text',
                                text: cap[0]
                            });
                            continue;
                        }
                        if (src) {
                            throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));
                        }
                    }
                    return this.tokens;
                }
                ;
            };
            defaults$2 = defaults.defaults;
            cleanUrl$1 = helpers.cleanUrl, escape$2 = helpers.escape;
            /**
             * Renderer
             */
            Renderer_1 = class Renderer {
                constructor(options) {
                    this.options = options || defaults$2;
                }
                code(code, infostring, escaped) {
                    const lang = (infostring || '').match(/\S*/)[0];
                    if (this.options.highlight) {
                        const out = this.options.highlight(code, lang);
                        if (out != null && out !== code) {
                            escaped = true;
                            code = out;
                        }
                    }
                    if (!lang) {
                        return '<pre><code>'
                            + (escaped ? code : escape$2(code, true))
                            + '</code></pre>';
                    }
                    return '<pre><code class="'
                        + this.options.langPrefix
                        + escape$2(lang, true)
                        + '">'
                        + (escaped ? code : escape$2(code, true))
                        + '</code></pre>\n';
                }
                ;
                blockquote(quote) {
                    return '<blockquote>\n' + quote + '</blockquote>\n';
                }
                ;
                html(html) {
                    return html;
                }
                ;
                heading(text, level, raw, slugger) {
                    if (this.options.headerIds) {
                        return '<h'
                            + level
                            + ' id="'
                            + this.options.headerPrefix
                            + slugger.slug(raw)
                            + '">'
                            + text
                            + '</h'
                            + level
                            + '>\n';
                    }
                    // ignore IDs
                    return '<h' + level + '>' + text + '</h' + level + '>\n';
                }
                ;
                hr() {
                    return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
                }
                ;
                list(body, ordered, start) {
                    const type = ordered ? 'ol' : 'ul', startatt = (ordered && start !== 1) ? (' start="' + start + '"') : '';
                    return '<' + type + startatt + '>\n' + body + '</' + type + '>\n';
                }
                ;
                listitem(text) {
                    return '<li>' + text + '</li>\n';
                }
                ;
                checkbox(checked) {
                    return '<input '
                        + (checked ? 'checked="" ' : '')
                        + 'disabled="" type="checkbox"'
                        + (this.options.xhtml ? ' /' : '')
                        + '> ';
                }
                ;
                paragraph(text) {
                    return '<p>' + text + '</p>\n';
                }
                ;
                table(header, body) {
                    if (body)
                        body = '<tbody>' + body + '</tbody>';
                    return '<table>\n'
                        + '<thead>\n'
                        + header
                        + '</thead>\n'
                        + body
                        + '</table>\n';
                }
                ;
                tablerow(content) {
                    return '<tr>\n' + content + '</tr>\n';
                }
                ;
                tablecell(content, flags) {
                    const type = flags.header ? 'th' : 'td';
                    const tag = flags.align
                        ? '<' + type + ' align="' + flags.align + '">'
                        : '<' + type + '>';
                    return tag + content + '</' + type + '>\n';
                }
                ;
                // span level renderer
                strong(text) {
                    return '<strong>' + text + '</strong>';
                }
                ;
                em(text) {
                    return '<em>' + text + '</em>';
                }
                ;
                codespan(text) {
                    return '<code>' + text + '</code>';
                }
                ;
                br() {
                    return this.options.xhtml ? '<br/>' : '<br>';
                }
                ;
                del(text) {
                    return '<del>' + text + '</del>';
                }
                ;
                link(href, title, text) {
                    href = cleanUrl$1(this.options.sanitize, this.options.baseUrl, href);
                    if (href === null) {
                        return text;
                    }
                    let out = '<a href="' + escape$2(href) + '"';
                    if (title) {
                        out += ' title="' + title + '"';
                    }
                    out += '>' + text + '</a>';
                    return out;
                }
                ;
                image(href, title, text) {
                    href = cleanUrl$1(this.options.sanitize, this.options.baseUrl, href);
                    if (href === null) {
                        return text;
                    }
                    let out = '<img src="' + href + '" alt="' + text + '"';
                    if (title) {
                        out += ' title="' + title + '"';
                    }
                    out += this.options.xhtml ? '/>' : '>';
                    return out;
                }
                ;
                text(text) {
                    return text;
                }
                ;
            };
            /**
             * Slugger generates header id
             */
            Slugger_1 = class Slugger {
                constructor() {
                    this.seen = {};
                }
                /**
                 * Convert string to unique id
                 */
                slug(value) {
                    let slug = value
                        .toLowerCase()
                        .trim()
                        .replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, '')
                        .replace(/\s/g, '-');
                    if (this.seen.hasOwnProperty(slug)) {
                        const originalSlug = slug;
                        do {
                            this.seen[originalSlug]++;
                            slug = originalSlug + '-' + this.seen[originalSlug];
                        } while (this.seen.hasOwnProperty(slug));
                    }
                    this.seen[slug] = 0;
                    return slug;
                }
                ;
            };
            defaults$3 = defaults.defaults;
            inline$1 = rules.inline;
            findClosingBracket$1 = helpers.findClosingBracket, escape$3 = helpers.escape;
            /**
             * Inline Lexer & Compiler
             */
            InlineLexer_1 = class InlineLexer {
                constructor(links, options) {
                    this.options = options || defaults$3;
                    this.links = links;
                    this.rules = inline$1.normal;
                    this.options.renderer = this.options.renderer || new Renderer_1();
                    this.renderer = this.options.renderer;
                    this.renderer.options = this.options;
                    if (!this.links) {
                        throw new Error('Tokens array requires a `links` property.');
                    }
                    if (this.options.pedantic) {
                        this.rules = inline$1.pedantic;
                    }
                    else if (this.options.gfm) {
                        if (this.options.breaks) {
                            this.rules = inline$1.breaks;
                        }
                        else {
                            this.rules = inline$1.gfm;
                        }
                    }
                }
                /**
                 * Expose Inline Rules
                 */
                static get rules() {
                    return inline$1;
                }
                /**
                 * Static Lexing/Compiling Method
                 */
                static output(src, links, options) {
                    const inline = new InlineLexer(links, options);
                    return inline.output(src);
                }
                /**
                 * Lexing/Compiling
                 */
                output(src) {
                    let out = '', link, text, href, title, cap, prevCapZero;
                    while (src) {
                        // escape
                        if (cap = this.rules.escape.exec(src)) {
                            src = src.substring(cap[0].length);
                            out += escape$3(cap[1]);
                            continue;
                        }
                        // tag
                        if (cap = this.rules.tag.exec(src)) {
                            if (!this.inLink && /^<a /i.test(cap[0])) {
                                this.inLink = true;
                            }
                            else if (this.inLink && /^<\/a>/i.test(cap[0])) {
                                this.inLink = false;
                            }
                            if (!this.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
                                this.inRawBlock = true;
                            }
                            else if (this.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
                                this.inRawBlock = false;
                            }
                            src = src.substring(cap[0].length);
                            out += this.options.sanitize
                                ? this.options.sanitizer
                                    ? this.options.sanitizer(cap[0])
                                    : escape$3(cap[0])
                                : cap[0];
                            continue;
                        }
                        // link
                        if (cap = this.rules.link.exec(src)) {
                            const lastParenIndex = findClosingBracket$1(cap[2], '()');
                            if (lastParenIndex > -1) {
                                const start = cap[0].indexOf('!') === 0 ? 5 : 4;
                                const linkLen = start + cap[1].length + lastParenIndex;
                                cap[2] = cap[2].substring(0, lastParenIndex);
                                cap[0] = cap[0].substring(0, linkLen).trim();
                                cap[3] = '';
                            }
                            src = src.substring(cap[0].length);
                            this.inLink = true;
                            href = cap[2];
                            if (this.options.pedantic) {
                                link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
                                if (link) {
                                    href = link[1];
                                    title = link[3];
                                }
                                else {
                                    title = '';
                                }
                            }
                            else {
                                title = cap[3] ? cap[3].slice(1, -1) : '';
                            }
                            href = href.trim().replace(/^<([\s\S]*)>$/, '$1');
                            out += this.outputLink(cap, {
                                href: InlineLexer.escapes(href),
                                title: InlineLexer.escapes(title)
                            });
                            this.inLink = false;
                            continue;
                        }
                        // reflink, nolink
                        if ((cap = this.rules.reflink.exec(src))
                            || (cap = this.rules.nolink.exec(src))) {
                            src = src.substring(cap[0].length);
                            link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
                            link = this.links[link.toLowerCase()];
                            if (!link || !link.href) {
                                out += cap[0].charAt(0);
                                src = cap[0].substring(1) + src;
                                continue;
                            }
                            this.inLink = true;
                            out += this.outputLink(cap, link);
                            this.inLink = false;
                            continue;
                        }
                        // strong
                        if (cap = this.rules.strong.exec(src)) {
                            src = src.substring(cap[0].length);
                            out += this.renderer.strong(this.output(cap[4] || cap[3] || cap[2] || cap[1]));
                            continue;
                        }
                        // em
                        if (cap = this.rules.em.exec(src)) {
                            src = src.substring(cap[0].length);
                            out += this.renderer.em(this.output(cap[6] || cap[5] || cap[4] || cap[3] || cap[2] || cap[1]));
                            continue;
                        }
                        // code
                        if (cap = this.rules.code.exec(src)) {
                            src = src.substring(cap[0].length);
                            out += this.renderer.codespan(escape$3(cap[2].trim(), true));
                            continue;
                        }
                        // br
                        if (cap = this.rules.br.exec(src)) {
                            src = src.substring(cap[0].length);
                            out += this.renderer.br();
                            continue;
                        }
                        // del (gfm)
                        if (cap = this.rules.del.exec(src)) {
                            src = src.substring(cap[0].length);
                            out += this.renderer.del(this.output(cap[1]));
                            continue;
                        }
                        // autolink
                        if (cap = this.rules.autolink.exec(src)) {
                            src = src.substring(cap[0].length);
                            if (cap[2] === '@') {
                                text = escape$3(this.mangle(cap[1]));
                                href = 'mailto:' + text;
                            }
                            else {
                                text = escape$3(cap[1]);
                                href = text;
                            }
                            out += this.renderer.link(href, null, text);
                            continue;
                        }
                        // url (gfm)
                        if (!this.inLink && (cap = this.rules.url.exec(src))) {
                            if (cap[2] === '@') {
                                text = escape$3(cap[0]);
                                href = 'mailto:' + text;
                            }
                            else {
                                // do extended autolink path validation
                                do {
                                    prevCapZero = cap[0];
                                    cap[0] = this.rules._backpedal.exec(cap[0])[0];
                                } while (prevCapZero !== cap[0]);
                                text = escape$3(cap[0]);
                                if (cap[1] === 'www.') {
                                    href = 'http://' + text;
                                }
                                else {
                                    href = text;
                                }
                            }
                            src = src.substring(cap[0].length);
                            out += this.renderer.link(href, null, text);
                            continue;
                        }
                        // text
                        if (cap = this.rules.text.exec(src)) {
                            src = src.substring(cap[0].length);
                            if (this.inRawBlock) {
                                out += this.renderer.text(this.options.sanitize ? (this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape$3(cap[0])) : cap[0]);
                            }
                            else {
                                out += this.renderer.text(escape$3(this.smartypants(cap[0])));
                            }
                            continue;
                        }
                        if (src) {
                            throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));
                        }
                    }
                    return out;
                }
                static escapes(text) {
                    return text ? text.replace(InlineLexer.rules._escapes, '$1') : text;
                }
                /**
                 * Compile Link
                 */
                outputLink(cap, link) {
                    const href = link.href, title = link.title ? escape$3(link.title) : null;
                    return cap[0].charAt(0) !== '!'
                        ? this.renderer.link(href, title, this.output(cap[1]))
                        : this.renderer.image(href, title, escape$3(cap[1]));
                }
                /**
                 * Smartypants Transformations
                 */
                smartypants(text) {
                    if (!this.options.smartypants)
                        return text;
                    return text
                        // em-dashes
                        .replace(/---/g, '\u2014')
                        // en-dashes
                        .replace(/--/g, '\u2013')
                        // opening singles
                        .replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018')
                        // closing singles & apostrophes
                        .replace(/'/g, '\u2019')
                        // opening doubles
                        .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201c')
                        // closing doubles
                        .replace(/"/g, '\u201d')
                        // ellipses
                        .replace(/\.{3}/g, '\u2026');
                }
                /**
                 * Mangle Links
                 */
                mangle(text) {
                    if (!this.options.mangle)
                        return text;
                    const l = text.length;
                    let out = '', i = 0, ch;
                    for (; i < l; i++) {
                        ch = text.charCodeAt(i);
                        if (Math.random() > 0.5) {
                            ch = 'x' + ch.toString(16);
                        }
                        out += '&#' + ch + ';';
                    }
                    return out;
                }
            };
            /**
             * TextRenderer
             * returns only the textual part of the token
             */
            TextRenderer_1 = class TextRenderer {
                // no need for block level renderers
                strong(text) {
                    return text;
                }
                em(text) {
                    return text;
                }
                codespan(text) {
                    return text;
                }
                del(text) {
                    return text;
                }
                text(text) {
                    return text;
                }
                link(href, title, text) {
                    return '' + text;
                }
                image(href, title, text) {
                    return '' + text;
                }
                br() {
                    return '';
                }
            };
            defaults$4 = defaults.defaults;
            merge$2 = helpers.merge, unescape$1 = helpers.unescape;
            /**
             * Parsing & Compiling
             */
            Parser_1 = class Parser {
                constructor(options) {
                    this.tokens = [];
                    this.token = null;
                    this.options = options || defaults$4;
                    this.options.renderer = this.options.renderer || new Renderer_1();
                    this.renderer = this.options.renderer;
                    this.renderer.options = this.options;
                    this.slugger = new Slugger_1();
                }
                /**
                 * Static Parse Method
                 */
                static parse(tokens, options) {
                    const parser = new Parser(options);
                    return parser.parse(tokens);
                }
                ;
                /**
                 * Parse Loop
                 */
                parse(tokens) {
                    this.inline = new InlineLexer_1(tokens.links, this.options);
                    // use an InlineLexer with a TextRenderer to extract pure text
                    this.inlineText = new InlineLexer_1(tokens.links, merge$2({}, this.options, { renderer: new TextRenderer_1() }));
                    this.tokens = tokens.reverse();
                    let out = '';
                    while (this.next()) {
                        out += this.tok();
                    }
                    return out;
                }
                ;
                /**
                 * Next Token
                 */
                next() {
                    this.token = this.tokens.pop();
                    return this.token;
                }
                ;
                /**
                 * Preview Next Token
                 */
                peek() {
                    return this.tokens[this.tokens.length - 1] || 0;
                }
                ;
                /**
                 * Parse Text Tokens
                 */
                parseText() {
                    let body = this.token.text;
                    while (this.peek().type === 'text') {
                        body += '\n' + this.next().text;
                    }
                    return this.inline.output(body);
                }
                ;
                /**
                 * Parse Current Token
                 */
                tok() {
                    let body = '';
                    switch (this.token.type) {
                        case 'space': {
                            return '';
                        }
                        case 'hr': {
                            return this.renderer.hr();
                        }
                        case 'heading': {
                            return this.renderer.heading(this.inline.output(this.token.text), this.token.depth, unescape$1(this.inlineText.output(this.token.text)), this.slugger);
                        }
                        case 'code': {
                            return this.renderer.code(this.token.text, this.token.lang, this.token.escaped);
                        }
                        case 'table': {
                            let header = '', i, row, cell, j;
                            // header
                            cell = '';
                            for (i = 0; i < this.token.header.length; i++) {
                                cell += this.renderer.tablecell(this.inline.output(this.token.header[i]), { header: true, align: this.token.align[i] });
                            }
                            header += this.renderer.tablerow(cell);
                            for (i = 0; i < this.token.cells.length; i++) {
                                row = this.token.cells[i];
                                cell = '';
                                for (j = 0; j < row.length; j++) {
                                    cell += this.renderer.tablecell(this.inline.output(row[j]), { header: false, align: this.token.align[j] });
                                }
                                body += this.renderer.tablerow(cell);
                            }
                            return this.renderer.table(header, body);
                        }
                        case 'blockquote_start': {
                            body = '';
                            while (this.next().type !== 'blockquote_end') {
                                body += this.tok();
                            }
                            return this.renderer.blockquote(body);
                        }
                        case 'list_start': {
                            body = '';
                            const ordered = this.token.ordered, start = this.token.start;
                            while (this.next().type !== 'list_end') {
                                body += this.tok();
                            }
                            return this.renderer.list(body, ordered, start);
                        }
                        case 'list_item_start': {
                            body = '';
                            const loose = this.token.loose;
                            const checked = this.token.checked;
                            const task = this.token.task;
                            if (this.token.task) {
                                if (loose) {
                                    if (this.peek().type === 'text') {
                                        const nextToken = this.peek();
                                        nextToken.text = this.renderer.checkbox(checked) + ' ' + nextToken.text;
                                    }
                                    else {
                                        this.tokens.push({
                                            type: 'text',
                                            text: this.renderer.checkbox(checked)
                                        });
                                    }
                                }
                                else {
                                    body += this.renderer.checkbox(checked);
                                }
                            }
                            while (this.next().type !== 'list_item_end') {
                                body += !loose && this.token.type === 'text'
                                    ? this.parseText()
                                    : this.tok();
                            }
                            return this.renderer.listitem(body, task, checked);
                        }
                        case 'html': {
                            // TODO parse inline content if parameter markdown=1
                            return this.renderer.html(this.token.text);
                        }
                        case 'paragraph': {
                            return this.renderer.paragraph(this.inline.output(this.token.text));
                        }
                        case 'text': {
                            return this.renderer.paragraph(this.parseText());
                        }
                        default: {
                            const errMsg = 'Token with "' + this.token.type + '" type was not found.';
                            if (this.options.silent) {
                                console.log(errMsg);
                            }
                            else {
                                throw new Error(errMsg);
                            }
                        }
                    }
                }
                ;
            };
            merge$3 = helpers.merge, checkSanitizeDeprecation$1 = helpers.checkSanitizeDeprecation, escape$4 = helpers.escape;
            getDefaults = defaults.getDefaults, changeDefaults = defaults.changeDefaults, defaults$5 = defaults.defaults;
            /**
             * Options
             */
            marked.options =
                marked.setOptions = function (opt) {
                    merge$3(marked.defaults, opt);
                    changeDefaults(marked.defaults);
                    return marked;
                };
            marked.getDefaults = getDefaults;
            marked.defaults = defaults$5;
            /**
             * Expose
             */
            marked.Parser = Parser_1;
            marked.parser = Parser_1.parse;
            marked.Renderer = Renderer_1;
            marked.TextRenderer = TextRenderer_1;
            marked.Lexer = Lexer_1;
            marked.lexer = Lexer_1.lex;
            marked.InlineLexer = InlineLexer_1;
            marked.inlineLexer = InlineLexer_1.output;
            marked.Slugger = Slugger_1;
            marked.parse = marked;
            marked_1 = marked;
            exports_27("default", marked_1);
        }
    };
});
System.register("http://localhost:5501/src/deps/marked", ["https://unpkg.com/marked@0.8.0/lib/marked.esm"], function (exports_28, context_28) {
    "use strict";
    var marked_esm_js_1;
    var __moduleName = context_28 && context_28.id;
    return {
        setters: [
            function (marked_esm_js_1_1) {
                marked_esm_js_1 = marked_esm_js_1_1;
            }
        ],
        execute: function () {
            exports_28("default", marked_esm_js_1.default);
        }
    };
});
System.register("http://localhost:5501/src/components/FCompiler", ["http://localhost:5501/src/deps/vue", "http://localhost:5501/src/deps/marked", "http://localhost:5501/fachwerk"], function (exports_29, context_29) {
    "use strict";
    var vue_js_11, marked_js_1, fachwerk_js_3, renderer, compileContent, FCompiler;
    var __moduleName = context_29 && context_29.id;
    return {
        setters: [
            function (vue_js_11_1) {
                vue_js_11 = vue_js_11_1;
            },
            function (marked_js_1_1) {
                marked_js_1 = marked_js_1_1;
            },
            function (fachwerk_js_3_1) {
                fachwerk_js_3 = fachwerk_js_3_1;
            }
        ],
        execute: function () {
            renderer = new marked_js_1.default.Renderer();
            renderer.code = (code, info) => {
                const escapedCode = code
                    .replace(/&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;")
                    .replace(/"/g, "&quot;")
                    .replace(/'/g, "&#39;");
                if (info === "vue") {
                    return `<pre v-pre>${escapedCode}</pre>

${code}`;
                }
                return `<pre v-pre>${escapedCode}</pre>`;
            };
            compileContent = content => {
                let c = () => null;
                try {
                    c = vue_js_11.compile(marked_js_1.default(content, { renderer, breaks: true }), {
                        onError: fachwerk_js_3.onCompilerError
                    });
                }
                catch (error) {
                    fachwerk_js_3.onCompilerError(error);
                }
                return c;
            };
            exports_29("FCompiler", FCompiler = {
                props: {
                    content: {
                        default: ""
                    }
                },
                setup(props) {
                    vue_js_11.onErrorCaptured(fachwerk_js_3.onCompilerError);
                    const customUtils = vue_js_11.inject("customUtils");
                    const compiledContent = vue_js_11.computed(() => ({
                        setup() {
                            return { ...fachwerk_js_3.utils, ...customUtils };
                        },
                        render: compileContent(props.content)
                    }));
                    return () => (compiledContent.value ? vue_js_11.h(compiledContent.value) : null);
                }
            });
        }
    };
});
System.register("http://localhost:5501/src/components/FEditor", ["http://localhost:5501/src/deps/vue"], function (exports_30, context_30) {
    "use strict";
    var vue_js_12, FEditor;
    var __moduleName = context_30 && context_30.id;
    return {
        setters: [
            function (vue_js_12_1) {
                vue_js_12 = vue_js_12_1;
            }
        ],
        execute: function () {
            exports_30("FEditor", FEditor = {
                props: { content: { default: "", type: String } },
                setup(props, { emit }) {
                    const editor = vue_js_12.ref(null);
                    const currentContent = vue_js_12.ref("");
                    vue_js_12.watch(() => props.content, content => {
                        currentContent.value = content;
                    });
                    vue_js_12.watch(currentContent, currentContent => {
                        emit("input:content", currentContent);
                    });
                    vue_js_12.onMounted(() => {
                        editor.value.onkeydown = function (e) {
                            if (e.keyCode === 9) {
                                const val = this.value;
                                const start = this.selectionStart;
                                const end = this.selectionEnd;
                                this.value = val.substring(0, start) + "  " + val.substring(end);
                                this.selectionStart = this.selectionEnd = start + 2;
                                emit("input:content", currentContent);
                                return false;
                            }
                        };
                    });
                    return { currentContent, editor };
                },
                template: `
  <textarea
    ref="editor"
    v-model="currentContent"
    style="
      color: var(--lightergray);
      background: var(--paleblue);
      font-family: var(--font-mono);
      font-size: var(--font-mono-size);
      line-height: var(--font-mono-lineheight);
      border: none;
      outline: none;
      resize: none;
      width: 100%;
      padding: var(--base2);
    "
  />
  `
            });
        }
    };
});
System.register("http://localhost:5501/src/components/FContent", ["http://localhost:5501/src/deps/vue", "http://localhost:5501/src/internals/content"], function (exports_31, context_31) {
    "use strict";
    var vue_js_13, content_js_2, FContent;
    var __moduleName = context_31 && context_31.id;
    return {
        setters: [
            function (vue_js_13_1) {
                vue_js_13 = vue_js_13_1;
            },
            function (content_js_2_1) {
                content_js_2 = content_js_2_1;
            }
        ],
        execute: function () {
            exports_31("FContent", FContent = {
                props: {
                    content: {
                        default: "",
                        type: String
                    }
                },
                setup(props) {
                    const parsedContent = vue_js_13.computed(() => content_js_2.parseContent(props.content));
                    return { parsedContent, slideGridStyle: content_js_2.slideGridStyle };
                },
                template: `
  <div style="display: flex; justify-content: center;">
    <div style="max-width: 800px; width: 100%;">
      <div
        v-for="(slide,i) in parsedContent"
        :style="{
          padding: 'var(--base4)',
          display: 'grid',
          ...slideGridStyle(slide)
        }"
      >
        <div v-for="cell in slide.content">
          <f-compiler :content="cell" />
        </div>
      </div>
    </div>
  </div>
  `
            });
        }
    };
});
System.register("https://unpkg.com/katex@0.11.1/dist/katex.mjs", [], function (exports_32, context_32) {
    "use strict";
    var SourceLocation, Token, ParseError, contains, deflt, uppercase, hyphenate, ESCAPE_LOOKUP, ESCAPE_REGEX, getBaseElem, isCharacterBox, assert, protocolFromUrl, utils, Settings, Style, D, Dc, T, Tc, S, Sc, SS, SSc, styles, sup, sub, fracNum, fracDen, cramp, text, Style$1, scriptData, allBlocks, hLinePad, sqrtMain, sqrtSize1, sqrtSize2, sqrtSize3, sqrtSize4, sqrtTall, sqrtPath, path, DocumentFragment, createClass, initNode, toNode, toMarkup, Span, Anchor, Img, iCombinations, SymbolNode, SvgNode, PathNode, LineNode, metricMap, sigmasAndXis, extraCharacterMap, fontMetricsBySizeIndex, ATOMS, NON_ATOMS, symbols, math, text$1, main, ams, accent, bin, close, inner, mathord, op, open, punct, rel, spacing, textord, ligatures, mathTextSymbols, textSymbols, letters, wideChar, extraLatin, wideLatinLetterData, wideNumeralData, wideCharacterFont, sizeStyleMap, sizeMultipliers, sizeAtStyle, Options, ptPerUnit, relativeUnit, validUnit, calculateSize, mathitLetters, lookupSymbol, makeSymbol, mathsym, mathdefault, mathnormal, boldsymbol, makeOrd, canCombine, tryCombineChars, sizeElementFromChildren, makeSpan, makeSvgSpan, makeLineSpan, makeAnchor, makeFragment, wrapFragment, getVListChildrenAndDepth, makeVList, makeGlue, retrieveTextFontName, fontMap, svgData, staticSvg, buildCommon, thinspace, mediumspace, thickspace, spacings, tightSpacings, _functions, _htmlGroupBuilders, _mathmlGroupBuilders, ordargument, makeSpan$1, binLeftCanceller, binRightCanceller, styleMap, DomEnum, buildExpression, traverseNonSpaceNodes, checkPartialGroup, getOutermostNode, getTypeOfDomTree, makeNullDelimiter, buildGroup, MathNode, TextNode, SpaceNode, mathMLTree, makeText, makeRow, getVariant, buildExpression$1, buildExpressionRow, buildGroup$1, optionsFromSettings, displayWrap, buildTree, buildHTMLTree, stretchyCodePoint, mathMLnode, katexImagesData, groupLength, svgSpan, encloseSpan, stretchy, htmlBuilder, mathmlBuilder, NON_STRETCHY_ACCENT_REGEX, paddedNode, htmlBuilder$1, mathmlBuilder$1, getMetrics, styleWrap, centerSpan, makeSmallDelim, mathrmSize, makeLargeDelim, makeInner, lap, makeStackedDelim, vbPad, emPad, sqrtSvg, makeSqrtImage, stackLargeDelimiters, stackAlwaysDelimiters, stackNeverDelimiters, sizeToMaxHeight, makeSizedDelim, stackNeverDelimiterSequence, stackAlwaysDelimiterSequence, stackLargeDelimiterSequence, delimTypeToFont, traverseSequence, makeCustomSizedDelim, makeLeftRightDelim, delimiter, delimiterSizes, delimiters, htmlBuilder$2, mathmlBuilder$2, _environments, htmlBuilder$3, alignMap, mathmlBuilder$3, alignedHandler, environments, makeSpan$2, binrelClass, htmlBuilder$5, mathmlBuilder$5, fontAliases, adjustStyle, htmlBuilder$6, mathmlBuilder$6, stylArray, delimFromValue, htmlBuilder$7, mathmlBuilder$7, sizeData, chooseMathStyle, assembleSupSub, noSuccessor, htmlBuilder$8, mathmlBuilder$8, singleCharBigOps, singleCharIntegrals, htmlBuilder$9, mathmlBuilder$9, sizeFuncs, htmlBuilder$a, styleMap$1, htmlBuilderDelegate, defaultVariant, cssSpace, regularSpace, pad, textFontFamilies, textFontWeights, textFontShapes, optionsWithFont, makeVerb, functions, spaceRegexString, controlWordRegexString, controlSymbolRegexString, controlWordWhitespaceRegexString, controlWordWhitespaceRegex, combiningDiacriticalMarkString, combiningDiacriticalMarksEndRegex, tokenRegexString, Lexer, Namespace, builtinMacros, digitToNumber, def, newcommand, dotsByToken, spaceAfterDots, latexRaiseA, implicitCommands, MacroExpander, unicodeAccents, unicodeSymbols, Parser, parseTree, render, renderToString, generateParseTree, renderError, renderToDomTree, renderToHTMLTree, katex;
    var __moduleName = context_32 && context_32.id;
    /**
     * Escapes text to prevent scripting attacks.
     */
    function escape(text) {
        return String(text).replace(ESCAPE_REGEX, match => ESCAPE_LOOKUP[match]);
    }
    /**
     * Given a codepoint, return the name of the script or script family
     * it is from, or null if it is not part of a known block
     */
    function scriptFromCodepoint(codepoint) {
        for (let i = 0; i < scriptData.length; i++) {
            const script = scriptData[i];
            for (let i = 0; i < script.blocks.length; i++) {
                const block = script.blocks[i];
                if (codepoint >= block[0] && codepoint <= block[1]) {
                    return script.name;
                }
            }
        }
        return null;
    }
    /**
     * Given a codepoint, return true if it falls within one of the
     * scripts or script families defined above and false otherwise.
     *
     * Micro benchmarks shows that this is faster than
     * /[\u3000-\u30FF\u4E00-\u9FAF\uFF00-\uFF60\uAC00-\uD7AF\u0900-\u109F]/.test()
     * in Firefox, Chrome and Node.
     */
    function supportedCodepoint(codepoint) {
        for (let i = 0; i < allBlocks.length; i += 2) {
            if (codepoint >= allBlocks[i] && codepoint <= allBlocks[i + 1]) {
                return true;
            }
        }
        return false;
    }
    function assertSymbolDomNode(group) {
        if (group instanceof SymbolNode) {
            return group;
        }
        else {
            throw new Error(`Expected symbolNode but got ${String(group)}.`);
        }
    }
    function assertSpan(group) {
        if (group instanceof Span) {
            return group;
        }
        else {
            throw new Error(`Expected span<HtmlDomNode> but got ${String(group)}.`);
        }
    }
    /**
     * This function adds new font metrics to default metricMap
     * It can also override existing metrics
     */
    function setFontMetrics(fontName, metrics) {
        metricMap[fontName] = metrics;
    }
    /**
     * This function is a convenience function for looking up information in the
     * metricMap table. It takes a character as a string, and a font.
     *
     * Note: the `width` property may be undefined if fontMetricsData.js wasn't
     * built using `Make extended_metrics`.
     */
    function getCharacterMetrics(character, font, mode) {
        if (!metricMap[font]) {
            throw new Error(`Font metrics not found for font: ${font}.`);
        }
        let ch = character.charCodeAt(0);
        let metrics = metricMap[font][ch];
        if (!metrics && character[0] in extraCharacterMap) {
            ch = extraCharacterMap[character[0]].charCodeAt(0);
            metrics = metricMap[font][ch];
        }
        if (!metrics && mode === 'text') {
            // We don't typically have font metrics for Asian scripts.
            // But since we support them in text mode, we need to return
            // some sort of metrics.
            // So if the character is in a script we support but we
            // don't have metrics for it, just use the metrics for
            // the Latin capital letter M. This is close enough because
            // we (currently) only care about the height of the glpyh
            // not its width.
            if (supportedCodepoint(ch)) {
                metrics = metricMap[font][77]; // 77 is the charcode for 'M'
            }
        }
        if (metrics) {
            return {
                depth: metrics[0],
                height: metrics[1],
                italic: metrics[2],
                skew: metrics[3],
                width: metrics[4]
            };
        }
    }
    /**
     * Get the font metrics for a given size.
     */
    function getGlobalMetrics(size) {
        let sizeIndex;
        if (size >= 5) {
            sizeIndex = 0;
        }
        else if (size >= 3) {
            sizeIndex = 1;
        }
        else {
            sizeIndex = 2;
        }
        if (!fontMetricsBySizeIndex[sizeIndex]) {
            const metrics = fontMetricsBySizeIndex[sizeIndex] = {
                cssEmPerMu: sigmasAndXis.quad[sizeIndex] / 18
            };
            for (const key in sigmasAndXis) {
                if (sigmasAndXis.hasOwnProperty(key)) {
                    metrics[key] = sigmasAndXis[key][sizeIndex];
                }
            }
        }
        return fontMetricsBySizeIndex[sizeIndex];
    }
    /** `acceptUnicodeChar = true` is only applicable if `replace` is set. */
    function defineSymbol(mode, font, group, replace, name, acceptUnicodeChar) {
        symbols[mode][name] = {
            font,
            group,
            replace
        };
        if (acceptUnicodeChar && replace) {
            symbols[mode][replace] = symbols[mode][name];
        }
    } // Some abbreviations for commonly used strings.
    /**
     * Asserts that the node is of the given type and returns it with stricter
     * typing. Throws if the node's type does not match.
     */
    function assertNodeType(node, type) {
        const typedNode = checkNodeType(node, type);
        if (!typedNode) {
            throw new Error(`Expected node of type ${type}, but got ` + (node ? `node of type ${node.type}` : String(node)));
        } // $FlowFixMe: Unsure why.
        return typedNode;
    }
    /**
     * Returns the node more strictly typed iff it is of the given type. Otherwise,
     * returns null.
     */
    function checkNodeType(node, type) {
        if (node && node.type === type) {
            // The definition of ParseNode<TYPE> doesn't communicate to flow that
            // `type: TYPE` (as that's not explicitly mentioned anywhere), though that
            // happens to be true for all our value types.
            // $FlowFixMe
            return node;
        }
        return null;
    }
    /**
     * Asserts that the node is of the given type and returns it with stricter
     * typing. Throws if the node's type does not match.
     */
    function assertAtomFamily(node, family) {
        const typedNode = checkAtomFamily(node, family);
        if (!typedNode) {
            throw new Error(`Expected node of type "atom" and family "${family}", but got ` + (node ? node.type === "atom" ? `atom of family ${node.family}` : `node of type ${node.type}` : String(node)));
        }
        return typedNode;
    }
    /**
     * Returns the node more strictly typed iff it is of the given type. Otherwise,
     * returns null.
     */
    function checkAtomFamily(node, family) {
        return node && node.type === "atom" && node.family === family ? node : null;
    }
    /**
     * Returns the node more strictly typed iff it is of the given type. Otherwise,
     * returns null.
     */
    function assertSymbolNodeType(node) {
        const typedNode = checkSymbolNodeType(node);
        if (!typedNode) {
            throw new Error(`Expected node of symbol group type, but got ` + (node ? `node of type ${node.type}` : String(node)));
        }
        return typedNode;
    }
    /**
     * Returns the node more strictly typed iff it is of the given type. Otherwise,
     * returns null.
     */
    function checkSymbolNodeType(node) {
        if (node && (node.type === "atom" || NON_ATOMS.hasOwnProperty(node.type))) {
            // $FlowFixMe
            return node;
        }
        return null;
    }
    function defineFunction(_ref) {
        let type = _ref.type, names = _ref.names, props = _ref.props, handler = _ref.handler, htmlBuilder = _ref.htmlBuilder, mathmlBuilder = _ref.mathmlBuilder;
        // Set default values of functions
        const data = {
            type,
            numArgs: props.numArgs,
            argTypes: props.argTypes,
            greediness: props.greediness === undefined ? 1 : props.greediness,
            allowedInText: !!props.allowedInText,
            allowedInMath: props.allowedInMath === undefined ? true : props.allowedInMath,
            numOptionalArgs: props.numOptionalArgs || 0,
            infix: !!props.infix,
            handler: handler
        };
        for (let i = 0; i < names.length; ++i) {
            _functions[names[i]] = data;
        }
        if (type) {
            if (htmlBuilder) {
                _htmlGroupBuilders[type] = htmlBuilder;
            }
            if (mathmlBuilder) {
                _mathmlGroupBuilders[type] = mathmlBuilder;
            }
        }
    }
    /**
     * Use this to register only the HTML and MathML builders for a function (e.g.
     * if the function's ParseNode is generated in Parser.js rather than via a
     * stand-alone handler provided to `defineFunction`).
     */
    function defineFunctionBuilders(_ref2) {
        let type = _ref2.type, htmlBuilder = _ref2.htmlBuilder, mathmlBuilder = _ref2.mathmlBuilder;
        defineFunction({
            type,
            names: [],
            props: {
                numArgs: 0
            },
            handler() {
                throw new Error('Should never be called.');
            },
            htmlBuilder,
            mathmlBuilder
        });
    } // Since the corresponding buildHTML/buildMathML function expects a
    /**
     * Combine an array of HTML DOM nodes (e.g., the output of `buildExpression`)
     * into an unbreakable HTML node of class .base, with proper struts to
     * guarantee correct vertical extent.  `buildHTML` calls this repeatedly to
     * make up the entire expression as a sequence of unbreakable units.
     */
    function buildHTMLUnbreakable(children, options) {
        // Compute height and depth of this chunk.
        const body = makeSpan$1(["base"], children, options); // Add strut, which ensures that the top of the HTML element falls at
        // the height of the expression, and the bottom of the HTML element
        // falls at the depth of the expression.
        // We used to have separate top and bottom struts, where the bottom strut
        // would like to use `vertical-align: top`, but in IE 9 this lowers the
        // baseline of the box to the bottom of this strut (instead of staying in
        // the normal place) so we use an absolute value for vertical-align instead.
        const strut = makeSpan$1(["strut"]);
        strut.style.height = body.height + body.depth + "em";
        strut.style.verticalAlign = -body.depth + "em";
        body.children.unshift(strut);
        return body;
    }
    /**
     * Take an entire parse tree, and build it into an appropriate set of HTML
     * nodes.
     */
    function buildHTML(tree, options) {
        // Strip off outer tag wrapper for processing below.
        let tag = null;
        if (tree.length === 1 && tree[0].type === "tag") {
            tag = tree[0].tag;
            tree = tree[0].body;
        } // Build the expression contained in the tree
        const expression = buildExpression(tree, options, true);
        const children = []; // Create one base node for each chunk between potential line breaks.
        // The TeXBook [p.173] says "A formula will be broken only after a
        // relation symbol like $=$ or $<$ or $\rightarrow$, or after a binary
        // operation symbol like $+$ or $-$ or $\times$, where the relation or
        // binary operation is on the ``outer level'' of the formula (i.e., not
        // enclosed in {...} and not part of an \over construction)."
        let parts = [];
        for (let i = 0; i < expression.length; i++) {
            parts.push(expression[i]);
            if (expression[i].hasClass("mbin") || expression[i].hasClass("mrel") || expression[i].hasClass("allowbreak")) {
                // Put any post-operator glue on same line as operator.
                // Watch for \nobreak along the way, and stop at \newline.
                let nobreak = false;
                while (i < expression.length - 1 && expression[i + 1].hasClass("mspace") && !expression[i + 1].hasClass("newline")) {
                    i++;
                    parts.push(expression[i]);
                    if (expression[i].hasClass("nobreak")) {
                        nobreak = true;
                    }
                } // Don't allow break if \nobreak among the post-operator glue.
                if (!nobreak) {
                    children.push(buildHTMLUnbreakable(parts, options));
                    parts = [];
                }
            }
            else if (expression[i].hasClass("newline")) {
                // Write the line except the newline
                parts.pop();
                if (parts.length > 0) {
                    children.push(buildHTMLUnbreakable(parts, options));
                    parts = [];
                } // Put the newline at the top level
                children.push(expression[i]);
            }
        }
        if (parts.length > 0) {
            children.push(buildHTMLUnbreakable(parts, options));
        } // Now, if there was a tag, build it too and append it as a final child.
        let tagChild;
        if (tag) {
            tagChild = buildHTMLUnbreakable(buildExpression(tag, options, true));
            tagChild.classes = ["tag"];
            children.push(tagChild);
        }
        const htmlNode = makeSpan$1(["katex-html"], children);
        htmlNode.setAttribute("aria-hidden", "true"); // Adjust the strut of the tag to be the maximum height of all children
        // (the height of the enclosing htmlNode) for proper vertical alignment.
        if (tagChild) {
            const strut = tagChild.children[0];
            strut.style.height = htmlNode.height + htmlNode.depth + "em";
            strut.style.verticalAlign = -htmlNode.depth + "em";
        }
        return htmlNode;
    }
    /**
     * These objects store data about MathML nodes. This is the MathML equivalent
     * of the types in domTree.js. Since MathML handles its own rendering, and
     * since we're mainly using MathML to improve accessibility, we don't manage
     * any of the styling state that the plain DOM nodes do.
     *
     * The `toNode` and `toMarkup` functions work simlarly to how they do in
     * domTree.js, creating namespaced DOM nodes and HTML text markup respectively.
     */
    function newDocumentFragment(children) {
        return new DocumentFragment(children);
    }
    /**
     * Takes a full parse tree and settings and builds a MathML representation of
     * it. In particular, we put the elements from building the parse tree into a
     * <semantics> tag so we can also include that TeX source as an annotation.
     *
     * Note that we actually return a domTree element with a `<math>` inside it so
     * we can do appropriate styling.
     */
    function buildMathML(tree, texExpression, options, forMathmlOnly) {
        const expression = buildExpression$1(tree, options); // Wrap up the expression in an mrow so it is presented in the semantics
        // tag correctly, unless it's a single <mrow> or <mtable>.
        let wrapper;
        if (expression.length === 1 && expression[0] instanceof MathNode && utils.contains(["mrow", "mtable"], expression[0].type)) {
            wrapper = expression[0];
        }
        else {
            wrapper = new mathMLTree.MathNode("mrow", expression);
        } // Build a TeX annotation of the source
        const annotation = new mathMLTree.MathNode("annotation", [new mathMLTree.TextNode(texExpression)]);
        annotation.setAttribute("encoding", "application/x-tex");
        const semantics = new mathMLTree.MathNode("semantics", [wrapper, annotation]);
        const math = new mathMLTree.MathNode("math", [semantics]);
        math.setAttribute("xmlns", "http://www.w3.org/1998/Math/MathML"); // You can't style <math> nodes, so we wrap the node in a span.
        // NOTE: The span class is not typed to have <math> nodes as children, and
        // we don't want to make the children type more generic since the children
        // of span are expected to have more fields in `buildHtml` contexts.
        const wrapperClass = forMathmlOnly ? "katex" : "katex-mathml"; // $FlowFixMe
        return buildCommon.makeSpan([wrapperClass], [math]);
    }
    // Delimiter functions
    function checkDelimiter(delim, context) {
        const symDelim = checkSymbolNodeType(delim);
        if (symDelim && utils.contains(delimiters, symDelim.text)) {
            return symDelim;
        }
        else {
            throw new ParseError("Invalid delimiter: '" + (symDelim ? symDelim.text : JSON.stringify(delim)) + "' after '" + context.funcName + "'", delim);
        }
    }
    function assertParsed(group) {
        if (!group.body) {
            throw new Error("Bug: The leftright ParseNode wasn't fully parsed.");
        }
    }
    function defineEnvironment(_ref) {
        let type = _ref.type, names = _ref.names, props = _ref.props, handler = _ref.handler, htmlBuilder = _ref.htmlBuilder, mathmlBuilder = _ref.mathmlBuilder;
        // Set default values of environments.
        const data = {
            type,
            numArgs: props.numArgs || 0,
            greediness: 1,
            allowedInText: false,
            numOptionalArgs: 0,
            handler
        };
        for (let i = 0; i < names.length; ++i) {
            // TODO: The value type of _environments should be a type union of all
            // possible `EnvSpec<>` possibilities instead of `EnvSpec<*>`, which is
            // an existential type.
            // $FlowFixMe
            _environments[names[i]] = data;
        }
        if (htmlBuilder) {
            _htmlGroupBuilders[type] = htmlBuilder;
        }
        if (mathmlBuilder) {
            _mathmlGroupBuilders[type] = mathmlBuilder;
        }
    }
    function getHLines(parser) {
        // Return an array. The array length = number of hlines.
        // Each element in the array tells if the line is dashed.
        const hlineInfo = [];
        parser.consumeSpaces();
        let nxt = parser.fetch().text;
        while (nxt === "\\hline" || nxt === "\\hdashline") {
            parser.consume();
            hlineInfo.push(nxt === "\\hdashline");
            parser.consumeSpaces();
            nxt = parser.fetch().text;
        }
        return hlineInfo;
    }
    /**
     * Parse the body of the environment, with rows delimited by \\ and
     * columns delimited by &, and create a nested list in row-major order
     * with one group per cell.  If given an optional argument style
     * ("text", "display", etc.), then each cell is cast into that style.
     */
    function parseArray(parser, _ref, style) {
        let hskipBeforeAndAfter = _ref.hskipBeforeAndAfter, addJot = _ref.addJot, cols = _ref.cols, arraystretch = _ref.arraystretch, colSeparationType = _ref.colSeparationType;
        // Parse body of array with \\ temporarily mapped to \cr
        parser.gullet.beginGroup();
        parser.gullet.macros.set("\\\\", "\\cr"); // Get current arraystretch if it's not set by the environment
        if (!arraystretch) {
            const stretch = parser.gullet.expandMacroAsText("\\arraystretch");
            if (stretch == null) {
                // Default \arraystretch from lttab.dtx
                arraystretch = 1;
            }
            else {
                arraystretch = parseFloat(stretch);
                if (!arraystretch || arraystretch < 0) {
                    throw new ParseError(`Invalid \\arraystretch: ${stretch}`);
                }
            }
        } // Start group for first cell
        parser.gullet.beginGroup();
        let row = [];
        const body = [row];
        const rowGaps = [];
        const hLinesBeforeRow = []; // Test for \hline at the top of the array.
        hLinesBeforeRow.push(getHLines(parser));
        while (true) {
            // eslint-disable-line no-constant-condition
            // Parse each cell in its own group (namespace)
            let cell = parser.parseExpression(false, "\\cr");
            parser.gullet.endGroup();
            parser.gullet.beginGroup();
            cell = {
                type: "ordgroup",
                mode: parser.mode,
                body: cell
            };
            if (style) {
                cell = {
                    type: "styling",
                    mode: parser.mode,
                    style,
                    body: [cell]
                };
            }
            row.push(cell);
            const next = parser.fetch().text;
            if (next === "&") {
                parser.consume();
            }
            else if (next === "\\end") {
                // Arrays terminate newlines with `\crcr` which consumes a `\cr` if
                // the last line is empty.
                // NOTE: Currently, `cell` is the last item added into `row`.
                if (row.length === 1 && cell.type === "styling" && cell.body[0].body.length === 0) {
                    body.pop();
                }
                if (hLinesBeforeRow.length < body.length + 1) {
                    hLinesBeforeRow.push([]);
                }
                break;
            }
            else if (next === "\\cr") {
                const cr = assertNodeType(parser.parseFunction(), "cr");
                rowGaps.push(cr.size); // check for \hline(s) following the row separator
                hLinesBeforeRow.push(getHLines(parser));
                row = [];
                body.push(row);
            }
            else {
                throw new ParseError("Expected & or \\\\ or \\cr or \\end", parser.nextToken);
            }
        } // End cell group
        parser.gullet.endGroup(); // End array group defining \\
        parser.gullet.endGroup();
        return {
            type: "array",
            mode: parser.mode,
            addJot,
            arraystretch,
            body,
            cols,
            rowGaps,
            hskipBeforeAndAfter,
            hLinesBeforeRow,
            colSeparationType
        };
    } // Decides on a style for cells in an array according to whether the given
    // environment name starts with the letter 'd'.
    function dCellStyle(envName) {
        if (envName.substr(0, 1) === "d") {
            return "display";
        }
        else {
            return "text";
        }
    }
    function htmlBuilder$4(group, options) {
        const elements = buildExpression(group.body, options, true);
        return makeSpan$2([group.mclass], elements, options);
    }
    function mathmlBuilder$4(group, options) {
        let node;
        const inner = buildExpression$1(group.body, options);
        if (group.mclass === "minner") {
            return mathMLTree.newDocumentFragment(inner);
        }
        else if (group.mclass === "mord") {
            if (group.isCharacterBox) {
                node = inner[0];
                node.type = "mi";
            }
            else {
                node = new mathMLTree.MathNode("mi", inner);
            }
        }
        else {
            if (group.isCharacterBox) {
                node = inner[0];
                node.type = "mo";
            }
            else {
                node = new mathMLTree.MathNode("mo", inner);
            } // Set spacing based on what is the most likely adjacent atom type.
            // See TeXbook p170.
            if (group.mclass === "mbin") {
                node.attributes.lspace = "0.22em"; // medium space
                node.attributes.rspace = "0.22em";
            }
            else if (group.mclass === "mpunct") {
                node.attributes.lspace = "0em";
                node.attributes.rspace = "0.17em"; // thinspace
            }
            else if (group.mclass === "mopen" || group.mclass === "mclose") {
                node.attributes.lspace = "0em";
                node.attributes.rspace = "0em";
            } // MathML <mo> default space is 5/18 em, so <mrel> needs no action.
            // Ref: https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mo
        }
        return node;
    } // Math class commands except \mathop
    function sizingGroup(value, options, baseOptions) {
        const inner = buildExpression(value, options, false);
        const multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier; // Add size-resetting classes to the inner list and set maxFontSize
        // manually. Handle nested size changes.
        for (let i = 0; i < inner.length; i++) {
            const pos = inner[i].classes.indexOf("sizing");
            if (pos < 0) {
                Array.prototype.push.apply(inner[i].classes, options.sizingClasses(baseOptions));
            }
            else if (inner[i].classes[pos + 1] === "reset-size" + options.size) {
                // This is a nested size change: e.g., inner[i] is the "b" in
                // `\Huge a \small b`. Override the old size (the `reset-` class)
                // but not the new size.
                inner[i].classes[pos + 1] = "reset-size" + baseOptions.size;
            }
            inner[i].height *= multiplier;
            inner[i].depth *= multiplier;
        }
        return buildCommon.makeFragment(inner);
    }
    function defineMacro(name, body) {
        builtinMacros[name] = body;
    } //////////////////////////////////////////////////////////////////////
    return {
        setters: [],
        execute: function () {
            /**
             * Lexing or parsing positional information for error reporting.
             * This object is immutable.
             */
            SourceLocation = class SourceLocation {
                // The + prefix indicates that these fields aren't writeable
                // Lexer holding the input string.
                // Start offset, zero-based inclusive.
                // End offset, zero-based exclusive.
                constructor(lexer, start, end) {
                    this.lexer = void 0;
                    this.start = void 0;
                    this.end = void 0;
                    this.lexer = lexer;
                    this.start = start;
                    this.end = end;
                }
                /**
                 * Merges two `SourceLocation`s from location providers, given they are
                 * provided in order of appearance.
                 * - Returns the first one's location if only the first is provided.
                 * - Returns a merged range of the first and the last if both are provided
                 *   and their lexers match.
                 * - Otherwise, returns null.
                 */
                static range(first, second) {
                    if (!second) {
                        return first && first.loc;
                    }
                    else if (!first || !first.loc || !second.loc || first.loc.lexer !== second.loc.lexer) {
                        return null;
                    }
                    else {
                        return new SourceLocation(first.loc.lexer, first.loc.start, second.loc.end);
                    }
                }
            };
            /**
             * Interface required to break circular dependency between Token, Lexer, and
             * ParseError.
             */
            /**
             * The resulting token returned from `lex`.
             *
             * It consists of the token text plus some position information.
             * The position information is essentially a range in an input string,
             * but instead of referencing the bare input string, we refer to the lexer.
             * That way it is possible to attach extra metadata to the input string,
             * like for example a file name or similar.
             *
             * The position information is optional, so it is OK to construct synthetic
             * tokens if appropriate. Not providing available position information may
             * lead to degraded error reporting, though.
             */
            Token = class Token {
                constructor(text, // the text of this token
                loc) {
                    this.text = void 0;
                    this.loc = void 0;
                    this.text = text;
                    this.loc = loc;
                }
                /**
                 * Given a pair of tokens (this and endToken), compute a `Token` encompassing
                 * the whole input range enclosed by these two.
                 */
                range(endToken, // last token of the range, inclusive
                text) {
                    return new Token(text, SourceLocation.range(this, endToken));
                }
            };
            /**
             * This is the ParseError class, which is the main error thrown by KaTeX
             * functions when something has gone wrong. This is used to distinguish internal
             * errors from errors in the expression that the user provided.
             *
             * If possible, a caller should provide a Token or ParseNode with information
             * about where in the source string the problem occurred.
             */
            ParseError = class ParseError {
                // Error position based on passed-in Token or ParseNode.
                constructor(message, // The error message
                token) {
                    this.position = void 0;
                    let error = "KaTeX parse error: " + message;
                    let start;
                    const loc = token && token.loc;
                    if (loc && loc.start <= loc.end) {
                        // If we have the input and a position, make the error a bit fancier
                        // Get the input
                        const input = loc.lexer.input; // Prepend some information
                        start = loc.start;
                        const end = loc.end;
                        if (start === input.length) {
                            error += " at end of input: ";
                        }
                        else {
                            error += " at position " + (start + 1) + ": ";
                        } // Underline token in question using combining underscores
                        const underlined = input.slice(start, end).replace(/[^]/g, "$&\u0332"); // Extract some context from the input and add it to the error
                        let left;
                        if (start > 15) {
                            left = "" + input.slice(start - 15, start);
                        }
                        else {
                            left = input.slice(0, start);
                        }
                        let right;
                        if (end + 15 < input.length) {
                            right = input.slice(end, end + 15) + "";
                        }
                        else {
                            right = input.slice(end);
                        }
                        error += left + underlined + right;
                    } // Some hackery to make ParseError a prototype of Error
                    // See http://stackoverflow.com/a/8460753
                    const self = new Error(error);
                    self.name = "ParseError"; // $FlowFixMe
                    self.__proto__ = ParseError.prototype; // $FlowFixMe
                    self.position = start;
                    return self;
                }
            }; // $FlowFixMe More hackery
            ParseError.prototype.__proto__ = Error.prototype;
            /**
             * This file contains a list of utility functions which are useful in other
             * files.
             */
            /**
             * Return whether an element is contained in a list
             */
            contains = function contains(list, elem) {
                return list.indexOf(elem) !== -1;
            };
            /**
             * Provide a default value if a setting is undefined
             * NOTE: Couldn't use `T` as the output type due to facebook/flow#5022.
             */
            deflt = function deflt(setting, defaultIfUndefined) {
                return setting === undefined ? defaultIfUndefined : setting;
            }; // hyphenate and escape adapted from Facebook's React under Apache 2 license
            uppercase = /([A-Z])/g;
            hyphenate = function hyphenate(str) {
                return str.replace(uppercase, "-$1").toLowerCase();
            };
            ESCAPE_LOOKUP = {
                "&": "&amp;",
                ">": "&gt;",
                "<": "&lt;",
                "\"": "&quot;",
                "'": "&#x27;"
            };
            ESCAPE_REGEX = /[&><"']/g;
            /**
             * Sometimes we want to pull out the innermost element of a group. In most
             * cases, this will just be the group itself, but when ordgroups and colors have
             * a single element, we want to pull that out.
             */
            getBaseElem = function getBaseElem(group) {
                if (group.type === "ordgroup") {
                    if (group.body.length === 1) {
                        return getBaseElem(group.body[0]);
                    }
                    else {
                        return group;
                    }
                }
                else if (group.type === "color") {
                    if (group.body.length === 1) {
                        return getBaseElem(group.body[0]);
                    }
                    else {
                        return group;
                    }
                }
                else if (group.type === "font") {
                    return getBaseElem(group.body);
                }
                else {
                    return group;
                }
            };
            /**
             * TeXbook algorithms often reference "character boxes", which are simply groups
             * with a single character in them. To decide if something is a character box,
             * we find its innermost group, and see if it is a single character.
             */
            isCharacterBox = function isCharacterBox(group) {
                const baseElem = getBaseElem(group); // These are all they types of groups which hold single characters
                return baseElem.type === "mathord" || baseElem.type === "textord" || baseElem.type === "atom";
            };
            assert = function assert(value) {
                if (!value) {
                    throw new Error('Expected non-null, but got ' + String(value));
                }
                return value;
            };
            /**
             * Return the protocol of a URL, or "_relative" if the URL does not specify a
             * protocol (and thus is relative).
             */
            protocolFromUrl = function protocolFromUrl(url) {
                const protocol = /^\s*([^\\/#]*?)(?::|&#0*58|&#x0*3a)/i.exec(url);
                return protocol != null ? protocol[1] : "_relative";
            };
            utils = {
                contains,
                deflt,
                escape,
                hyphenate,
                getBaseElem,
                isCharacterBox,
                protocolFromUrl
            };
            /* eslint no-console:0 */
            /**
             * The main Settings object
             *
             * The current options stored are:
             *  - displayMode: Whether the expression should be typeset as inline math
             *                 (false, the default), meaning that the math starts in
             *                 \textstyle and is placed in an inline-block); or as display
             *                 math (true), meaning that the math starts in \displaystyle
             *                 and is placed in a block with vertical margin.
             */
            Settings = class Settings {
                constructor(options) {
                    this.displayMode = void 0;
                    this.output = void 0;
                    this.leqno = void 0;
                    this.fleqn = void 0;
                    this.throwOnError = void 0;
                    this.errorColor = void 0;
                    this.macros = void 0;
                    this.minRuleThickness = void 0;
                    this.colorIsTextColor = void 0;
                    this.strict = void 0;
                    this.trust = void 0;
                    this.maxSize = void 0;
                    this.maxExpand = void 0;
                    // allow null options
                    options = options || {};
                    this.displayMode = utils.deflt(options.displayMode, false);
                    this.output = utils.deflt(options.output, "htmlAndMathml");
                    this.leqno = utils.deflt(options.leqno, false);
                    this.fleqn = utils.deflt(options.fleqn, false);
                    this.throwOnError = utils.deflt(options.throwOnError, true);
                    this.errorColor = utils.deflt(options.errorColor, "#cc0000");
                    this.macros = options.macros || {};
                    this.minRuleThickness = Math.max(0, utils.deflt(options.minRuleThickness, 0));
                    this.colorIsTextColor = utils.deflt(options.colorIsTextColor, false);
                    this.strict = utils.deflt(options.strict, "warn");
                    this.trust = utils.deflt(options.trust, false);
                    this.maxSize = Math.max(0, utils.deflt(options.maxSize, Infinity));
                    this.maxExpand = Math.max(0, utils.deflt(options.maxExpand, 1000));
                }
                /**
                 * Report nonstrict (non-LaTeX-compatible) input.
                 * Can safely not be called if `this.strict` is false in JavaScript.
                 */
                reportNonstrict(errorCode, errorMsg, token) {
                    let strict = this.strict;
                    if (typeof strict === "function") {
                        // Allow return value of strict function to be boolean or string
                        // (or null/undefined, meaning no further processing).
                        strict = strict(errorCode, errorMsg, token);
                    }
                    if (!strict || strict === "ignore") {
                        return;
                    }
                    else if (strict === true || strict === "error") {
                        throw new ParseError("LaTeX-incompatible input and strict mode is set to 'error': " + `${errorMsg} [${errorCode}]`, token);
                    }
                    else if (strict === "warn") {
                        typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + `${errorMsg} [${errorCode}]`);
                    }
                    else {
                        // won't happen in type-safe code
                        typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + `unrecognized '${strict}': ${errorMsg} [${errorCode}]`);
                    }
                }
                /**
                 * Check whether to apply strict (LaTeX-adhering) behavior for unusual
                 * input (like `\\`).  Unlike `nonstrict`, will not throw an error;
                 * instead, "error" translates to a return value of `true`, while "ignore"
                 * translates to a return value of `false`.  May still print a warning:
                 * "warn" prints a warning and returns `false`.
                 * This is for the second category of `errorCode`s listed in the README.
                 */
                useStrictBehavior(errorCode, errorMsg, token) {
                    let strict = this.strict;
                    if (typeof strict === "function") {
                        // Allow return value of strict function to be boolean or string
                        // (or null/undefined, meaning no further processing).
                        // But catch any exceptions thrown by function, treating them
                        // like "error".
                        try {
                            strict = strict(errorCode, errorMsg, token);
                        }
                        catch (error) {
                            strict = "error";
                        }
                    }
                    if (!strict || strict === "ignore") {
                        return false;
                    }
                    else if (strict === true || strict === "error") {
                        return true;
                    }
                    else if (strict === "warn") {
                        typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + `${errorMsg} [${errorCode}]`);
                        return false;
                    }
                    else {
                        // won't happen in type-safe code
                        typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + `unrecognized '${strict}': ${errorMsg} [${errorCode}]`);
                        return false;
                    }
                }
                /**
                 * Check whether to test potentially dangerous input, and return
                 * `true` (trusted) or `false` (untrusted).  The sole argument `context`
                 * should be an object with `command` field specifying the relevant LaTeX
                 * command (as a string starting with `\`), and any other arguments, etc.
                 * If `context` has a `url` field, a `protocol` field will automatically
                 * get added by this function (changing the specified object).
                 */
                isTrusted(context) {
                    if (context.url && !context.protocol) {
                        context.protocol = utils.protocolFromUrl(context.url);
                    }
                    const trust = typeof this.trust === "function" ? this.trust(context) : this.trust;
                    return Boolean(trust);
                }
            };
            /**
             * This file contains information and classes for the various kinds of styles
             * used in TeX. It provides a generic `Style` class, which holds information
             * about a specific style. It then provides instances of all the different kinds
             * of styles possible, and provides functions to move between them and get
             * information about them.
             */
            /**
             * The main style class. Contains a unique id for the style, a size (which is
             * the same for cramped and uncramped version of a style), and a cramped flag.
             */
            Style = class Style {
                constructor(id, size, cramped) {
                    this.id = void 0;
                    this.size = void 0;
                    this.cramped = void 0;
                    this.id = id;
                    this.size = size;
                    this.cramped = cramped;
                }
                /**
                 * Get the style of a superscript given a base in the current style.
                 */
                sup() {
                    return styles[sup[this.id]];
                }
                /**
                 * Get the style of a subscript given a base in the current style.
                 */
                sub() {
                    return styles[sub[this.id]];
                }
                /**
                 * Get the style of a fraction numerator given the fraction in the current
                 * style.
                 */
                fracNum() {
                    return styles[fracNum[this.id]];
                }
                /**
                 * Get the style of a fraction denominator given the fraction in the current
                 * style.
                 */
                fracDen() {
                    return styles[fracDen[this.id]];
                }
                /**
                 * Get the cramped version of a style (in particular, cramping a cramped style
                 * doesn't change the style).
                 */
                cramp() {
                    return styles[cramp[this.id]];
                }
                /**
                 * Get a text or display version of this style.
                 */
                text() {
                    return styles[text[this.id]];
                }
                /**
                 * Return true if this style is tightly spaced (scriptstyle/scriptscriptstyle)
                 */
                isTight() {
                    return this.size >= 2;
                }
            }; // Export an interface for type checking, but don't expose the implementation.
            // This way, no more styles can be generated.
            // IDs of the different styles
            D = 0;
            Dc = 1;
            T = 2;
            Tc = 3;
            S = 4;
            Sc = 5;
            SS = 6;
            SSc = 7; // Instances of the different styles
            styles = [new Style(D, 0, false), new Style(Dc, 0, true), new Style(T, 1, false), new Style(Tc, 1, true), new Style(S, 2, false), new Style(Sc, 2, true), new Style(SS, 3, false), new Style(SSc, 3, true)]; // Lookup tables for switching from one style to another
            sup = [S, Sc, S, Sc, SS, SSc, SS, SSc];
            sub = [Sc, Sc, Sc, Sc, SSc, SSc, SSc, SSc];
            fracNum = [T, Tc, S, Sc, SS, SSc, SS, SSc];
            fracDen = [Tc, Tc, Sc, Sc, SSc, SSc, SSc, SSc];
            cramp = [Dc, Dc, Tc, Tc, Sc, Sc, SSc, SSc];
            text = [D, Dc, T, Tc, T, Tc, T, Tc]; // We only export some of the styles.
            Style$1 = {
                DISPLAY: styles[D],
                TEXT: styles[T],
                SCRIPT: styles[S],
                SCRIPTSCRIPT: styles[SS]
            };
            /*
             * This file defines the Unicode scripts and script families that we
             * support. To add new scripts or families, just add a new entry to the
             * scriptData array below. Adding scripts to the scriptData array allows
             * characters from that script to appear in \text{} environments.
             */
            /**
             * Each script or script family has a name and an array of blocks.
             * Each block is an array of two numbers which specify the start and
             * end points (inclusive) of a block of Unicode codepoints.
             */
            /**
             * Unicode block data for the families of scripts we support in \text{}.
             * Scripts only need to appear here if they do not have font metrics.
             */
            scriptData = [{
                    // Latin characters beyond the Latin-1 characters we have metrics for.
                    // Needed for Czech, Hungarian and Turkish text, for example.
                    name: 'latin',
                    blocks: [[0x0100, 0x024f],
                        [0x0300, 0x036f]]
                }, {
                    // The Cyrillic script used by Russian and related languages.
                    // A Cyrillic subset used to be supported as explicitly defined
                    // symbols in symbols.js
                    name: 'cyrillic',
                    blocks: [[0x0400, 0x04ff]]
                }, {
                    // The Brahmic scripts of South and Southeast Asia
                    // Devanagari (0900097F)
                    // Bengali (098009FF)
                    // Gurmukhi (0A000A7F)
                    // Gujarati (0A800AFF)
                    // Oriya (0B000B7F)
                    // Tamil (0B800BFF)
                    // Telugu (0C000C7F)
                    // Kannada (0C800CFF)
                    // Malayalam (0D000D7F)
                    // Sinhala (0D800DFF)
                    // Thai (0E000E7F)
                    // Lao (0E800EFF)
                    // Tibetan (0F000FFF)
                    // Myanmar (1000109F)
                    name: 'brahmic',
                    blocks: [[0x0900, 0x109F]]
                }, {
                    name: 'georgian',
                    blocks: [[0x10A0, 0x10ff]]
                }, {
                    // Chinese and Japanese.
                    // The "k" in cjk is for Korean, but we've separated Korean out
                    name: "cjk",
                    blocks: [[0x3000, 0x30FF],
                        [0x4E00, 0x9FAF],
                        [0xFF00, 0xFF60]]
                }, {
                    // Korean
                    name: 'hangul',
                    blocks: [[0xAC00, 0xD7AF]]
                }];
            /**
             * A flattened version of all the supported blocks in a single array.
             * This is an optimization to make supportedCodepoint() fast.
             */
            allBlocks = [];
            scriptData.forEach(s => s.blocks.forEach(b => allBlocks.push(...b)));
            /**
             * This file provides support to domTree.js and delimiter.js.
             * It's a storehouse of path geometry for SVG images.
             */
            // In all paths below, the viewBox-to-em scale is 1000:1.
            hLinePad = 80; // padding above a sqrt viniculum. Prevents image cropping.
            // The viniculum of a \sqrt can be made thicker by a KaTeX rendering option.
            // Think of variable extraViniculum as two detours in the SVG path.
            // The detour begins at the lower left of the area labeled extraViniculum below.
            // The detour proceeds one extraViniculum distance up and slightly to the right,
            // displacing the radiused corner between surd and viniculum. The radius is
            // traversed as usual, then the detour resumes. It goes right, to the end of
            // the very long viniculumn, then down one extraViniculum distance,
            // after which it resumes regular path geometry for the radical.
            /*                                                  viniculum
                                                               /
                     /extraViniculum
                    / 0.04em (40 unit) std viniculum thickness
                   / /
                  / /
                 / /\
                / / surd
            */
            sqrtMain = function sqrtMain(extraViniculum, hLinePad) {
                // sqrtMain path geometry is from glyph U221A in the font KaTeX Main
                return `M95,${622 + extraViniculum + hLinePad}
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l${extraViniculum / 2.075} -${extraViniculum}
c5.3,-9.3,12,-14,20,-14
H400000v${40 + extraViniculum}H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M${834 + extraViniculum} ${hLinePad}h400000v${40 + extraViniculum}h-400000z`;
            };
            sqrtSize1 = function sqrtSize1(extraViniculum, hLinePad) {
                // size1 is from glyph U221A in the font KaTeX_Size1-Regular
                return `M263,${601 + extraViniculum + hLinePad}c0.7,0,18,39.7,52,119
c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120
c340,-704.7,510.7,-1060.3,512,-1067
l${extraViniculum / 2.084} -${extraViniculum}
c4.7,-7.3,11,-11,19,-11
H40000v${40 + extraViniculum}H1012.3
s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232
c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1
s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26
c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z
M${1001 + extraViniculum} ${hLinePad}h400000v${40 + extraViniculum}h-400000z`;
            };
            sqrtSize2 = function sqrtSize2(extraViniculum, hLinePad) {
                // size2 is from glyph U221A in the font KaTeX_Size2-Regular
                return `M983 ${10 + extraViniculum + hLinePad}
l${extraViniculum / 3.13} -${extraViniculum}
c4,-6.7,10,-10,18,-10 H400000v${40 + extraViniculum}
H1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7
s-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744
c-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30
c26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722
c56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5
c53.7,-170.3,84.5,-266.8,92.5,-289.5z
M${1001 + extraViniculum} ${hLinePad}h400000v${40 + extraViniculum}h-400000z`;
            };
            sqrtSize3 = function sqrtSize3(extraViniculum, hLinePad) {
                // size3 is from glyph U221A in the font KaTeX_Size3-Regular
                return `M424,${2398 + extraViniculum + hLinePad}
c-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514
c0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20
s-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121
s209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081
l${extraViniculum / 4.223} -${extraViniculum}c4,-6.7,10,-10,18,-10 H400000
v${40 + extraViniculum}H1014.6
s-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185
c-2,6,-10,9,-24,9
c-8,0,-12,-0.7,-12,-2z M${1001 + extraViniculum} ${hLinePad}
h400000v${40 + extraViniculum}h-400000z`;
            };
            sqrtSize4 = function sqrtSize4(extraViniculum, hLinePad) {
                // size4 is from glyph U221A in the font KaTeX_Size4-Regular
                return `M473,${2713 + extraViniculum + hLinePad}
c339.3,-1799.3,509.3,-2700,510,-2702 l${extraViniculum / 5.298} -${extraViniculum}
c3.3,-7.3,9.3,-11,18,-11 H400000v${40 + extraViniculum}H1017.7
s-90.5,478,-276.2,1466c-185.7,988,-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9
c-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200
c0,-1.3,-5.3,8.7,-16,30c-10.7,21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26
s76,-153,76,-153s77,-151,77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,
606zM${1001 + extraViniculum} ${hLinePad}h400000v${40 + extraViniculum}H1017.7z`;
            };
            sqrtTall = function sqrtTall(extraViniculum, hLinePad, viewBoxHeight) {
                // sqrtTall is from glyph U23B7 in the font KaTeX_Size4-Regular
                // One path edge has a variable length. It runs vertically from the viniculumn
                // to a point near (14 units) the bottom of the surd. The viniculum
                // is normally 40 units thick. So the length of the line in question is:
                const vertSegment = viewBoxHeight - 54 - hLinePad - extraViniculum;
                return `M702 ${extraViniculum + hLinePad}H400000${40 + extraViniculum}
H742v${vertSegment}l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1
h-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170
c-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667
219 661 l218 661zM702 ${hLinePad}H400000v${40 + extraViniculum}H742z`;
            };
            sqrtPath = function sqrtPath(size, extraViniculum, viewBoxHeight) {
                extraViniculum = 1000 * extraViniculum; // Convert from document ems to viewBox.
                let path = "";
                switch (size) {
                    case "sqrtMain":
                        path = sqrtMain(extraViniculum, hLinePad);
                        break;
                    case "sqrtSize1":
                        path = sqrtSize1(extraViniculum, hLinePad);
                        break;
                    case "sqrtSize2":
                        path = sqrtSize2(extraViniculum, hLinePad);
                        break;
                    case "sqrtSize3":
                        path = sqrtSize3(extraViniculum, hLinePad);
                        break;
                    case "sqrtSize4":
                        path = sqrtSize4(extraViniculum, hLinePad);
                        break;
                    case "sqrtTall":
                        path = sqrtTall(extraViniculum, hLinePad, viewBoxHeight);
                }
                return path;
            };
            path = {
                // The doubleleftarrow geometry is from glyph U+21D0 in the font KaTeX Main
                doubleleftarrow: `M262 157
l10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3
 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28
 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5
c2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5
 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87
-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7
-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z
m8 0v40h399730v-40zm0 194v40h399730v-40z`,
                // doublerightarrow is from glyph U+21D2 in font KaTeX Main
                doublerightarrow: `M399738 392l
-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5
 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88
-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68
-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18
-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782
c-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3
-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z`,
                // leftarrow is from glyph U+2190 in font KaTeX Main
                leftarrow: `M400000 241H110l3-3c68.7-52.7 113.7-120
 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8
-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247
c-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208
 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3
 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202
 l-3-3h399890zM100 241v40h399900v-40z`,
                // overbrace is from glyphs U+23A9/23A8/23A7 in font KaTeX_Size4-Regular
                leftbrace: `M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117
-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7
 5-6 9-10 13-.7 1-7.3 1-20 1H6z`,
                leftbraceunder: `M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13
 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688
 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7
-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z`,
                // overgroup is from the MnSymbol package (public domain)
                leftgroup: `M400000 80
H435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0
 435 0h399565z`,
                leftgroupunder: `M400000 262
H435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219
 435 219h399565z`,
                // Harpoons are from glyph U+21BD in font KaTeX Main
                leftharpoon: `M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3
-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5
-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7
-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z`,
                leftharpoonplus: `M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5
 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3
-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7
-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z
m0 0v40h400000v-40z`,
                leftharpoondown: `M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333
 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5
 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667
-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z`,
                leftharpoondownplus: `M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12
 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7
-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0
v40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z`,
                // hook is from glyph U+21A9 in font KaTeX Main
                lefthook: `M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5
-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3
-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21
 71.5 23h399859zM103 281v-40h399897v40z`,
                leftlinesegment: `M40 281 V428 H0 V94 H40 V241 H400000 v40z
M40 281 V428 H0 V94 H40 V241 H400000 v40z`,
                leftmapsto: `M40 281 V448H0V74H40V241H400000v40z
M40 281 V448H0V74H40V241H400000v40z`,
                // tofrom is from glyph U+21C4 in font KaTeX AMS Regular
                leftToFrom: `M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23
-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8
c28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3
 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z`,
                longequal: `M0 50 h400000 v40H0z m0 194h40000v40H0z
M0 50 h400000 v40H0z m0 194h40000v40H0z`,
                midbrace: `M200428 334
c-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14
-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7
 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11
 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z`,
                midbraceunder: `M199572 214
c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14
 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3
 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0
-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z`,
                oiintSize1: `M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6
-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z
m368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8
60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z`,
                oiintSize2: `M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8
-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z
m502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2
c0 110 84 276 504 276s502.4-166 502.4-276z`,
                oiiintSize1: `M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6
-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z
m525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0
85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z`,
                oiiintSize2: `M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8
-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z
m770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1
c0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z`,
                rightarrow: `M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z`,
                rightbrace: `M400000 542l
-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5
s-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1
c124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z`,
                rightbraceunder: `M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3
 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237
-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z`,
                rightgroup: `M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0
 3-1 3-3v-38c-76-158-257-219-435-219H0z`,
                rightgroupunder: `M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18
 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z`,
                rightharpoon: `M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3
-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2
-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58
 69.2 92 94.5zm0 0v40h399900v-40z`,
                rightharpoonplus: `M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11
-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7
 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z
m0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z`,
                rightharpoondown: `M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8
 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5
-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95
-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z`,
                rightharpoondownplus: `M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8
 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3
 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3
-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z
m0-194v40h400000v-40zm0 0v40h400000v-40z`,
                righthook: `M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3
 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0
-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21
 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z`,
                rightlinesegment: `M399960 241 V94 h40 V428 h-40 V281 H0 v-40z
M399960 241 V94 h40 V428 h-40 V281 H0 v-40z`,
                rightToFrom: `M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23
 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32
-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142
-167z M100 147v40h399900v-40zM0 341v40h399900v-40z`,
                // twoheadleftarrow is from glyph U+219E in font KaTeX AMS Regular
                twoheadleftarrow: `M0 167c68 40
 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69
-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3
-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19
-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101
 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z`,
                twoheadrightarrow: `M400000 167
c-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3
 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42
 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333
-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70
 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z`,
                // tilde1 is a modified version of a glyph from the MnSymbol package
                tilde1: `M200 55.538c-77 0-168 73.953-177 73.953-3 0-7
-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0
 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0
 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128
-68.267.847-113-73.952-191-73.952z`,
                // ditto tilde2, tilde3, & tilde4
                tilde2: `M344 55.266c-142 0-300.638 81.316-311.5 86.418
-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9
 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114
c1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751
 181.476 676 181.476c-149 0-189-126.21-332-126.21z`,
                tilde3: `M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457
-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0
 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697
 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696
 -338 0-409-156.573-744-156.573z`,
                tilde4: `M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345
-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409
 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9
 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409
 -175.236-744-175.236z`,
                // vec is from glyph U+20D7 in font KaTeX Main
                vec: `M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z`,
                // widehat1 is a modified version of a glyph from the MnSymbol package
                widehat1: `M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22
c-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z`,
                // ditto widehat2, widehat3, & widehat4
                widehat2: `M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
                widehat3: `M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
                widehat4: `M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
                // widecheck paths are all inverted versions of widehat
                widecheck1: `M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,
-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z`,
                widecheck2: `M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
                widecheck3: `M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
                widecheck4: `M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
                // The next ten paths support reaction arrows from the mhchem package.
                // Arrows for \ce{<-->} are offset from xAxis by 0.22ex, per mhchem in LaTeX
                // baraboveleftarrow is mostly from from glyph U+2190 in font KaTeX Main
                baraboveleftarrow: `M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202
c4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5
c-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130
s-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47
121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6
s2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11
c0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z
M100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z`,
                // rightarrowabovebar is mostly from glyph U+2192, KaTeX Main
                rightarrowabovebar: `M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32
-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0
13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39
-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5
-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z`,
                // The short left harpoon has 0.5em (i.e. 500 units) kern on the left end.
                // Ref from mhchem.sty: \rlap{\raisebox{-.22ex}{$\kern0.5em
                baraboveshortleftharpoon: `M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11
c1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17
c2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21
c-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40
c-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z
M0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z`,
                rightharpoonaboveshortbar: `M0,241 l0,40c399126,0,399993,0,399993,0
c4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,
-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6
c-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z
M0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z`,
                shortbaraboveleftharpoon: `M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11
c1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,
1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,
-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z
M93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z`,
                shortrightharpoonabovebar: `M53,241l0,40c398570,0,399437,0,399437,0
c4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,
-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6
c-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z
M500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z`
            };
            /**
             * This node represents a document fragment, which contains elements, but when
             * placed into the DOM doesn't have any representation itself. It only contains
             * children and doesn't have any DOM node properties.
             */
            DocumentFragment = class DocumentFragment {
                // HtmlDomNode
                // Never used; needed for satisfying interface.
                constructor(children) {
                    this.children = void 0;
                    this.classes = void 0;
                    this.height = void 0;
                    this.depth = void 0;
                    this.maxFontSize = void 0;
                    this.style = void 0;
                    this.children = children;
                    this.classes = [];
                    this.height = 0;
                    this.depth = 0;
                    this.maxFontSize = 0;
                    this.style = {};
                }
                hasClass(className) {
                    return utils.contains(this.classes, className);
                }
                /** Convert the fragment into a node. */
                toNode() {
                    const frag = document.createDocumentFragment();
                    for (let i = 0; i < this.children.length; i++) {
                        frag.appendChild(this.children[i].toNode());
                    }
                    return frag;
                }
                /** Convert the fragment into HTML markup. */
                toMarkup() {
                    let markup = ""; // Simply concatenate the markup for the children together.
                    for (let i = 0; i < this.children.length; i++) {
                        markup += this.children[i].toMarkup();
                    }
                    return markup;
                }
                /**
                 * Converts the math node into a string, similar to innerText. Applies to
                 * MathDomNode's only.
                 */
                toText() {
                    // To avoid this, we would subclass documentFragment separately for
                    // MathML, but polyfills for subclassing is expensive per PR 1469.
                    // $FlowFixMe: Only works for ChildType = MathDomNode.
                    const toText = child => child.toText();
                    return this.children.map(toText).join("");
                }
            };
            /**
             * These objects store the data about the DOM nodes we create, as well as some
             * extra data. They can then be transformed into real DOM nodes with the
             * `toNode` function or HTML markup using `toMarkup`. They are useful for both
             * storing extra properties on the nodes, as well as providing a way to easily
             * work with the DOM.
             *
             * Similar functions for working with MathML nodes exist in mathMLTree.js.
             *
             * TODO: refactor `span` and `anchor` into common superclass when
             * target environments support class inheritance
             */
            /**
             * Create an HTML className based on a list of classes. In addition to joining
             * with spaces, we also remove empty classes.
             */
            createClass = function createClass(classes) {
                return classes.filter(cls => cls).join(" ");
            };
            initNode = function initNode(classes, options, style) {
                this.classes = classes || [];
                this.attributes = {};
                this.height = 0;
                this.depth = 0;
                this.maxFontSize = 0;
                this.style = style || {};
                if (options) {
                    if (options.style.isTight()) {
                        this.classes.push("mtight");
                    }
                    const color = options.getColor();
                    if (color) {
                        this.style.color = color;
                    }
                }
            };
            /**
             * Convert into an HTML node
             */
            toNode = function toNode(tagName) {
                const node = document.createElement(tagName); // Apply the class
                node.className = createClass(this.classes); // Apply inline styles
                for (const style in this.style) {
                    if (this.style.hasOwnProperty(style)) {
                        // $FlowFixMe Flow doesn't seem to understand span.style's type.
                        node.style[style] = this.style[style];
                    }
                } // Apply attributes
                for (const attr in this.attributes) {
                    if (this.attributes.hasOwnProperty(attr)) {
                        node.setAttribute(attr, this.attributes[attr]);
                    }
                } // Append the children, also as HTML nodes
                for (let i = 0; i < this.children.length; i++) {
                    node.appendChild(this.children[i].toNode());
                }
                return node;
            };
            /**
             * Convert into an HTML markup string
             */
            toMarkup = function toMarkup(tagName) {
                let markup = `<${tagName}`; // Add the class
                if (this.classes.length) {
                    markup += ` class="${utils.escape(createClass(this.classes))}"`;
                }
                let styles = ""; // Add the styles, after hyphenation
                for (const style in this.style) {
                    if (this.style.hasOwnProperty(style)) {
                        styles += `${utils.hyphenate(style)}:${this.style[style]};`;
                    }
                }
                if (styles) {
                    markup += ` style="${utils.escape(styles)}"`;
                } // Add the attributes
                for (const attr in this.attributes) {
                    if (this.attributes.hasOwnProperty(attr)) {
                        markup += ` ${attr}="${utils.escape(this.attributes[attr])}"`;
                    }
                }
                markup += ">"; // Add the markup of the children, also as markup
                for (let i = 0; i < this.children.length; i++) {
                    markup += this.children[i].toMarkup();
                }
                markup += `</${tagName}>`;
                return markup;
            }; // Making the type below exact with all optional fields doesn't work due to
            // - https://github.com/facebook/flow/issues/4582
            // - https://github.com/facebook/flow/issues/5688
            // However, since *all* fields are optional, $Shape<> works as suggested in 5688
            // above.
            // This type does not include all CSS properties. Additional properties should
            // be added as needed.
            /**
             * This node represents a span node, with a className, a list of children, and
             * an inline style. It also contains information about its height, depth, and
             * maxFontSize.
             *
             * Represents two types with different uses: SvgSpan to wrap an SVG and DomSpan
             * otherwise. This typesafety is important when HTML builders access a span's
             * children.
             */
            Span = class Span {
                constructor(classes, children, options, style) {
                    this.children = void 0;
                    this.attributes = void 0;
                    this.classes = void 0;
                    this.height = void 0;
                    this.depth = void 0;
                    this.width = void 0;
                    this.maxFontSize = void 0;
                    this.style = void 0;
                    initNode.call(this, classes, options, style);
                    this.children = children || [];
                }
                /**
                 * Sets an arbitrary attribute on the span. Warning: use this wisely. Not
                 * all browsers support attributes the same, and having too many custom
                 * attributes is probably bad.
                 */
                setAttribute(attribute, value) {
                    this.attributes[attribute] = value;
                }
                hasClass(className) {
                    return utils.contains(this.classes, className);
                }
                toNode() {
                    return toNode.call(this, "span");
                }
                toMarkup() {
                    return toMarkup.call(this, "span");
                }
            };
            /**
             * This node represents an anchor (<a>) element with a hyperlink.  See `span`
             * for further details.
             */
            Anchor = class Anchor {
                constructor(href, classes, children, options) {
                    this.children = void 0;
                    this.attributes = void 0;
                    this.classes = void 0;
                    this.height = void 0;
                    this.depth = void 0;
                    this.maxFontSize = void 0;
                    this.style = void 0;
                    initNode.call(this, classes, options);
                    this.children = children || [];
                    this.setAttribute('href', href);
                }
                setAttribute(attribute, value) {
                    this.attributes[attribute] = value;
                }
                hasClass(className) {
                    return utils.contains(this.classes, className);
                }
                toNode() {
                    return toNode.call(this, "a");
                }
                toMarkup() {
                    return toMarkup.call(this, "a");
                }
            };
            /**
             * This node represents an image embed (<img>) element.
             */
            Img = class Img {
                constructor(src, alt, style) {
                    this.src = void 0;
                    this.alt = void 0;
                    this.classes = void 0;
                    this.height = void 0;
                    this.depth = void 0;
                    this.maxFontSize = void 0;
                    this.style = void 0;
                    this.alt = alt;
                    this.src = src;
                    this.classes = ["mord"];
                    this.style = style;
                }
                hasClass(className) {
                    return utils.contains(this.classes, className);
                }
                toNode() {
                    const node = document.createElement("img");
                    node.src = this.src;
                    node.alt = this.alt;
                    node.className = "mord"; // Apply inline styles
                    for (const style in this.style) {
                        if (this.style.hasOwnProperty(style)) {
                            // $FlowFixMe
                            node.style[style] = this.style[style];
                        }
                    }
                    return node;
                }
                toMarkup() {
                    let markup = `<img  src='${this.src} 'alt='${this.alt}' `; // Add the styles, after hyphenation
                    let styles = "";
                    for (const style in this.style) {
                        if (this.style.hasOwnProperty(style)) {
                            styles += `${utils.hyphenate(style)}:${this.style[style]};`;
                        }
                    }
                    if (styles) {
                        markup += ` style="${utils.escape(styles)}"`;
                    }
                    markup += "'/>";
                    return markup;
                }
            };
            iCombinations = {
                '': '\u0131\u0302',
                '': '\u0131\u0308',
                '': '\u0131\u0301',
                // '': '\u0131\u0304', // enable when we add Extended Latin
                '': '\u0131\u0300'
            };
            /**
             * A symbol node contains information about a single symbol. It either renders
             * to a single text node, or a span with a single text node in it, depending on
             * whether it has CSS classes, styles, or needs italic correction.
             */
            SymbolNode = class SymbolNode {
                constructor(text, height, depth, italic, skew, width, classes, style) {
                    this.text = void 0;
                    this.height = void 0;
                    this.depth = void 0;
                    this.italic = void 0;
                    this.skew = void 0;
                    this.width = void 0;
                    this.maxFontSize = void 0;
                    this.classes = void 0;
                    this.style = void 0;
                    this.text = text;
                    this.height = height || 0;
                    this.depth = depth || 0;
                    this.italic = italic || 0;
                    this.skew = skew || 0;
                    this.width = width || 0;
                    this.classes = classes || [];
                    this.style = style || {};
                    this.maxFontSize = 0; // Mark text from non-Latin scripts with specific classes so that we
                    // can specify which fonts to use.  This allows us to render these
                    // characters with a serif font in situations where the browser would
                    // either default to a sans serif or render a placeholder character.
                    // We use CSS class names like cjk_fallback, hangul_fallback and
                    // brahmic_fallback. See ./unicodeScripts.js for the set of possible
                    // script names
                    const script = scriptFromCodepoint(this.text.charCodeAt(0));
                    if (script) {
                        this.classes.push(script + "_fallback");
                    }
                    if (/[]/.test(this.text)) {
                        // add  when we add Extended Latin
                        this.text = iCombinations[this.text];
                    }
                }
                hasClass(className) {
                    return utils.contains(this.classes, className);
                }
                /**
                 * Creates a text node or span from a symbol node. Note that a span is only
                 * created if it is needed.
                 */
                toNode() {
                    const node = document.createTextNode(this.text);
                    let span = null;
                    if (this.italic > 0) {
                        span = document.createElement("span");
                        span.style.marginRight = this.italic + "em";
                    }
                    if (this.classes.length > 0) {
                        span = span || document.createElement("span");
                        span.className = createClass(this.classes);
                    }
                    for (const style in this.style) {
                        if (this.style.hasOwnProperty(style)) {
                            span = span || document.createElement("span"); // $FlowFixMe Flow doesn't seem to understand span.style's type.
                            span.style[style] = this.style[style];
                        }
                    }
                    if (span) {
                        span.appendChild(node);
                        return span;
                    }
                    else {
                        return node;
                    }
                }
                /**
                 * Creates markup for a symbol node.
                 */
                toMarkup() {
                    // TODO(alpert): More duplication than I'd like from
                    // span.prototype.toMarkup and symbolNode.prototype.toNode...
                    let needsSpan = false;
                    let markup = "<span";
                    if (this.classes.length) {
                        needsSpan = true;
                        markup += " class=\"";
                        markup += utils.escape(createClass(this.classes));
                        markup += "\"";
                    }
                    let styles = "";
                    if (this.italic > 0) {
                        styles += "margin-right:" + this.italic + "em;";
                    }
                    for (const style in this.style) {
                        if (this.style.hasOwnProperty(style)) {
                            styles += utils.hyphenate(style) + ":" + this.style[style] + ";";
                        }
                    }
                    if (styles) {
                        needsSpan = true;
                        markup += " style=\"" + utils.escape(styles) + "\"";
                    }
                    const escaped = utils.escape(this.text);
                    if (needsSpan) {
                        markup += ">";
                        markup += escaped;
                        markup += "</span>";
                        return markup;
                    }
                    else {
                        return escaped;
                    }
                }
            };
            /**
             * SVG nodes are used to render stretchy wide elements.
             */
            SvgNode = class SvgNode {
                constructor(children, attributes) {
                    this.children = void 0;
                    this.attributes = void 0;
                    this.children = children || [];
                    this.attributes = attributes || {};
                }
                toNode() {
                    const svgNS = "http://www.w3.org/2000/svg";
                    const node = document.createElementNS(svgNS, "svg"); // Apply attributes
                    for (const attr in this.attributes) {
                        if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
                            node.setAttribute(attr, this.attributes[attr]);
                        }
                    }
                    for (let i = 0; i < this.children.length; i++) {
                        node.appendChild(this.children[i].toNode());
                    }
                    return node;
                }
                toMarkup() {
                    let markup = "<svg"; // Apply attributes
                    for (const attr in this.attributes) {
                        if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
                            markup += ` ${attr}='${this.attributes[attr]}'`;
                        }
                    }
                    markup += ">";
                    for (let i = 0; i < this.children.length; i++) {
                        markup += this.children[i].toMarkup();
                    }
                    markup += "</svg>";
                    return markup;
                }
            };
            PathNode = class PathNode {
                constructor(pathName, alternate) {
                    this.pathName = void 0;
                    this.alternate = void 0;
                    this.pathName = pathName;
                    this.alternate = alternate; // Used only for \sqrt
                }
                toNode() {
                    const svgNS = "http://www.w3.org/2000/svg";
                    const node = document.createElementNS(svgNS, "path");
                    if (this.alternate) {
                        node.setAttribute("d", this.alternate);
                    }
                    else {
                        node.setAttribute("d", path[this.pathName]);
                    }
                    return node;
                }
                toMarkup() {
                    if (this.alternate) {
                        return `<path d='${this.alternate}'/>`;
                    }
                    else {
                        return `<path d='${path[this.pathName]}'/>`;
                    }
                }
            };
            LineNode = class LineNode {
                constructor(attributes) {
                    this.attributes = void 0;
                    this.attributes = attributes || {};
                }
                toNode() {
                    const svgNS = "http://www.w3.org/2000/svg";
                    const node = document.createElementNS(svgNS, "line"); // Apply attributes
                    for (const attr in this.attributes) {
                        if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
                            node.setAttribute(attr, this.attributes[attr]);
                        }
                    }
                    return node;
                }
                toMarkup() {
                    let markup = "<line";
                    for (const attr in this.attributes) {
                        if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
                            markup += ` ${attr}='${this.attributes[attr]}'`;
                        }
                    }
                    markup += "/>";
                    return markup;
                }
            };
            // This file is GENERATED by buildMetrics.sh. DO NOT MODIFY.
            metricMap = {
                "AMS-Regular": {
                    "65": [0, 0.68889, 0, 0, 0.72222],
                    "66": [0, 0.68889, 0, 0, 0.66667],
                    "67": [0, 0.68889, 0, 0, 0.72222],
                    "68": [0, 0.68889, 0, 0, 0.72222],
                    "69": [0, 0.68889, 0, 0, 0.66667],
                    "70": [0, 0.68889, 0, 0, 0.61111],
                    "71": [0, 0.68889, 0, 0, 0.77778],
                    "72": [0, 0.68889, 0, 0, 0.77778],
                    "73": [0, 0.68889, 0, 0, 0.38889],
                    "74": [0.16667, 0.68889, 0, 0, 0.5],
                    "75": [0, 0.68889, 0, 0, 0.77778],
                    "76": [0, 0.68889, 0, 0, 0.66667],
                    "77": [0, 0.68889, 0, 0, 0.94445],
                    "78": [0, 0.68889, 0, 0, 0.72222],
                    "79": [0.16667, 0.68889, 0, 0, 0.77778],
                    "80": [0, 0.68889, 0, 0, 0.61111],
                    "81": [0.16667, 0.68889, 0, 0, 0.77778],
                    "82": [0, 0.68889, 0, 0, 0.72222],
                    "83": [0, 0.68889, 0, 0, 0.55556],
                    "84": [0, 0.68889, 0, 0, 0.66667],
                    "85": [0, 0.68889, 0, 0, 0.72222],
                    "86": [0, 0.68889, 0, 0, 0.72222],
                    "87": [0, 0.68889, 0, 0, 1.0],
                    "88": [0, 0.68889, 0, 0, 0.72222],
                    "89": [0, 0.68889, 0, 0, 0.72222],
                    "90": [0, 0.68889, 0, 0, 0.66667],
                    "107": [0, 0.68889, 0, 0, 0.55556],
                    "165": [0, 0.675, 0.025, 0, 0.75],
                    "174": [0.15559, 0.69224, 0, 0, 0.94666],
                    "240": [0, 0.68889, 0, 0, 0.55556],
                    "295": [0, 0.68889, 0, 0, 0.54028],
                    "710": [0, 0.825, 0, 0, 2.33334],
                    "732": [0, 0.9, 0, 0, 2.33334],
                    "770": [0, 0.825, 0, 0, 2.33334],
                    "771": [0, 0.9, 0, 0, 2.33334],
                    "989": [0.08167, 0.58167, 0, 0, 0.77778],
                    "1008": [0, 0.43056, 0.04028, 0, 0.66667],
                    "8245": [0, 0.54986, 0, 0, 0.275],
                    "8463": [0, 0.68889, 0, 0, 0.54028],
                    "8487": [0, 0.68889, 0, 0, 0.72222],
                    "8498": [0, 0.68889, 0, 0, 0.55556],
                    "8502": [0, 0.68889, 0, 0, 0.66667],
                    "8503": [0, 0.68889, 0, 0, 0.44445],
                    "8504": [0, 0.68889, 0, 0, 0.66667],
                    "8513": [0, 0.68889, 0, 0, 0.63889],
                    "8592": [-0.03598, 0.46402, 0, 0, 0.5],
                    "8594": [-0.03598, 0.46402, 0, 0, 0.5],
                    "8602": [-0.13313, 0.36687, 0, 0, 1.0],
                    "8603": [-0.13313, 0.36687, 0, 0, 1.0],
                    "8606": [0.01354, 0.52239, 0, 0, 1.0],
                    "8608": [0.01354, 0.52239, 0, 0, 1.0],
                    "8610": [0.01354, 0.52239, 0, 0, 1.11111],
                    "8611": [0.01354, 0.52239, 0, 0, 1.11111],
                    "8619": [0, 0.54986, 0, 0, 1.0],
                    "8620": [0, 0.54986, 0, 0, 1.0],
                    "8621": [-0.13313, 0.37788, 0, 0, 1.38889],
                    "8622": [-0.13313, 0.36687, 0, 0, 1.0],
                    "8624": [0, 0.69224, 0, 0, 0.5],
                    "8625": [0, 0.69224, 0, 0, 0.5],
                    "8630": [0, 0.43056, 0, 0, 1.0],
                    "8631": [0, 0.43056, 0, 0, 1.0],
                    "8634": [0.08198, 0.58198, 0, 0, 0.77778],
                    "8635": [0.08198, 0.58198, 0, 0, 0.77778],
                    "8638": [0.19444, 0.69224, 0, 0, 0.41667],
                    "8639": [0.19444, 0.69224, 0, 0, 0.41667],
                    "8642": [0.19444, 0.69224, 0, 0, 0.41667],
                    "8643": [0.19444, 0.69224, 0, 0, 0.41667],
                    "8644": [0.1808, 0.675, 0, 0, 1.0],
                    "8646": [0.1808, 0.675, 0, 0, 1.0],
                    "8647": [0.1808, 0.675, 0, 0, 1.0],
                    "8648": [0.19444, 0.69224, 0, 0, 0.83334],
                    "8649": [0.1808, 0.675, 0, 0, 1.0],
                    "8650": [0.19444, 0.69224, 0, 0, 0.83334],
                    "8651": [0.01354, 0.52239, 0, 0, 1.0],
                    "8652": [0.01354, 0.52239, 0, 0, 1.0],
                    "8653": [-0.13313, 0.36687, 0, 0, 1.0],
                    "8654": [-0.13313, 0.36687, 0, 0, 1.0],
                    "8655": [-0.13313, 0.36687, 0, 0, 1.0],
                    "8666": [0.13667, 0.63667, 0, 0, 1.0],
                    "8667": [0.13667, 0.63667, 0, 0, 1.0],
                    "8669": [-0.13313, 0.37788, 0, 0, 1.0],
                    "8672": [-0.064, 0.437, 0, 0, 1.334],
                    "8674": [-0.064, 0.437, 0, 0, 1.334],
                    "8705": [0, 0.825, 0, 0, 0.5],
                    "8708": [0, 0.68889, 0, 0, 0.55556],
                    "8709": [0.08167, 0.58167, 0, 0, 0.77778],
                    "8717": [0, 0.43056, 0, 0, 0.42917],
                    "8722": [-0.03598, 0.46402, 0, 0, 0.5],
                    "8724": [0.08198, 0.69224, 0, 0, 0.77778],
                    "8726": [0.08167, 0.58167, 0, 0, 0.77778],
                    "8733": [0, 0.69224, 0, 0, 0.77778],
                    "8736": [0, 0.69224, 0, 0, 0.72222],
                    "8737": [0, 0.69224, 0, 0, 0.72222],
                    "8738": [0.03517, 0.52239, 0, 0, 0.72222],
                    "8739": [0.08167, 0.58167, 0, 0, 0.22222],
                    "8740": [0.25142, 0.74111, 0, 0, 0.27778],
                    "8741": [0.08167, 0.58167, 0, 0, 0.38889],
                    "8742": [0.25142, 0.74111, 0, 0, 0.5],
                    "8756": [0, 0.69224, 0, 0, 0.66667],
                    "8757": [0, 0.69224, 0, 0, 0.66667],
                    "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
                    "8765": [-0.13313, 0.37788, 0, 0, 0.77778],
                    "8769": [-0.13313, 0.36687, 0, 0, 0.77778],
                    "8770": [-0.03625, 0.46375, 0, 0, 0.77778],
                    "8774": [0.30274, 0.79383, 0, 0, 0.77778],
                    "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
                    "8778": [0.08167, 0.58167, 0, 0, 0.77778],
                    "8782": [0.06062, 0.54986, 0, 0, 0.77778],
                    "8783": [0.06062, 0.54986, 0, 0, 0.77778],
                    "8785": [0.08198, 0.58198, 0, 0, 0.77778],
                    "8786": [0.08198, 0.58198, 0, 0, 0.77778],
                    "8787": [0.08198, 0.58198, 0, 0, 0.77778],
                    "8790": [0, 0.69224, 0, 0, 0.77778],
                    "8791": [0.22958, 0.72958, 0, 0, 0.77778],
                    "8796": [0.08198, 0.91667, 0, 0, 0.77778],
                    "8806": [0.25583, 0.75583, 0, 0, 0.77778],
                    "8807": [0.25583, 0.75583, 0, 0, 0.77778],
                    "8808": [0.25142, 0.75726, 0, 0, 0.77778],
                    "8809": [0.25142, 0.75726, 0, 0, 0.77778],
                    "8812": [0.25583, 0.75583, 0, 0, 0.5],
                    "8814": [0.20576, 0.70576, 0, 0, 0.77778],
                    "8815": [0.20576, 0.70576, 0, 0, 0.77778],
                    "8816": [0.30274, 0.79383, 0, 0, 0.77778],
                    "8817": [0.30274, 0.79383, 0, 0, 0.77778],
                    "8818": [0.22958, 0.72958, 0, 0, 0.77778],
                    "8819": [0.22958, 0.72958, 0, 0, 0.77778],
                    "8822": [0.1808, 0.675, 0, 0, 0.77778],
                    "8823": [0.1808, 0.675, 0, 0, 0.77778],
                    "8828": [0.13667, 0.63667, 0, 0, 0.77778],
                    "8829": [0.13667, 0.63667, 0, 0, 0.77778],
                    "8830": [0.22958, 0.72958, 0, 0, 0.77778],
                    "8831": [0.22958, 0.72958, 0, 0, 0.77778],
                    "8832": [0.20576, 0.70576, 0, 0, 0.77778],
                    "8833": [0.20576, 0.70576, 0, 0, 0.77778],
                    "8840": [0.30274, 0.79383, 0, 0, 0.77778],
                    "8841": [0.30274, 0.79383, 0, 0, 0.77778],
                    "8842": [0.13597, 0.63597, 0, 0, 0.77778],
                    "8843": [0.13597, 0.63597, 0, 0, 0.77778],
                    "8847": [0.03517, 0.54986, 0, 0, 0.77778],
                    "8848": [0.03517, 0.54986, 0, 0, 0.77778],
                    "8858": [0.08198, 0.58198, 0, 0, 0.77778],
                    "8859": [0.08198, 0.58198, 0, 0, 0.77778],
                    "8861": [0.08198, 0.58198, 0, 0, 0.77778],
                    "8862": [0, 0.675, 0, 0, 0.77778],
                    "8863": [0, 0.675, 0, 0, 0.77778],
                    "8864": [0, 0.675, 0, 0, 0.77778],
                    "8865": [0, 0.675, 0, 0, 0.77778],
                    "8872": [0, 0.69224, 0, 0, 0.61111],
                    "8873": [0, 0.69224, 0, 0, 0.72222],
                    "8874": [0, 0.69224, 0, 0, 0.88889],
                    "8876": [0, 0.68889, 0, 0, 0.61111],
                    "8877": [0, 0.68889, 0, 0, 0.61111],
                    "8878": [0, 0.68889, 0, 0, 0.72222],
                    "8879": [0, 0.68889, 0, 0, 0.72222],
                    "8882": [0.03517, 0.54986, 0, 0, 0.77778],
                    "8883": [0.03517, 0.54986, 0, 0, 0.77778],
                    "8884": [0.13667, 0.63667, 0, 0, 0.77778],
                    "8885": [0.13667, 0.63667, 0, 0, 0.77778],
                    "8888": [0, 0.54986, 0, 0, 1.11111],
                    "8890": [0.19444, 0.43056, 0, 0, 0.55556],
                    "8891": [0.19444, 0.69224, 0, 0, 0.61111],
                    "8892": [0.19444, 0.69224, 0, 0, 0.61111],
                    "8901": [0, 0.54986, 0, 0, 0.27778],
                    "8903": [0.08167, 0.58167, 0, 0, 0.77778],
                    "8905": [0.08167, 0.58167, 0, 0, 0.77778],
                    "8906": [0.08167, 0.58167, 0, 0, 0.77778],
                    "8907": [0, 0.69224, 0, 0, 0.77778],
                    "8908": [0, 0.69224, 0, 0, 0.77778],
                    "8909": [-0.03598, 0.46402, 0, 0, 0.77778],
                    "8910": [0, 0.54986, 0, 0, 0.76042],
                    "8911": [0, 0.54986, 0, 0, 0.76042],
                    "8912": [0.03517, 0.54986, 0, 0, 0.77778],
                    "8913": [0.03517, 0.54986, 0, 0, 0.77778],
                    "8914": [0, 0.54986, 0, 0, 0.66667],
                    "8915": [0, 0.54986, 0, 0, 0.66667],
                    "8916": [0, 0.69224, 0, 0, 0.66667],
                    "8918": [0.0391, 0.5391, 0, 0, 0.77778],
                    "8919": [0.0391, 0.5391, 0, 0, 0.77778],
                    "8920": [0.03517, 0.54986, 0, 0, 1.33334],
                    "8921": [0.03517, 0.54986, 0, 0, 1.33334],
                    "8922": [0.38569, 0.88569, 0, 0, 0.77778],
                    "8923": [0.38569, 0.88569, 0, 0, 0.77778],
                    "8926": [0.13667, 0.63667, 0, 0, 0.77778],
                    "8927": [0.13667, 0.63667, 0, 0, 0.77778],
                    "8928": [0.30274, 0.79383, 0, 0, 0.77778],
                    "8929": [0.30274, 0.79383, 0, 0, 0.77778],
                    "8934": [0.23222, 0.74111, 0, 0, 0.77778],
                    "8935": [0.23222, 0.74111, 0, 0, 0.77778],
                    "8936": [0.23222, 0.74111, 0, 0, 0.77778],
                    "8937": [0.23222, 0.74111, 0, 0, 0.77778],
                    "8938": [0.20576, 0.70576, 0, 0, 0.77778],
                    "8939": [0.20576, 0.70576, 0, 0, 0.77778],
                    "8940": [0.30274, 0.79383, 0, 0, 0.77778],
                    "8941": [0.30274, 0.79383, 0, 0, 0.77778],
                    "8994": [0.19444, 0.69224, 0, 0, 0.77778],
                    "8995": [0.19444, 0.69224, 0, 0, 0.77778],
                    "9416": [0.15559, 0.69224, 0, 0, 0.90222],
                    "9484": [0, 0.69224, 0, 0, 0.5],
                    "9488": [0, 0.69224, 0, 0, 0.5],
                    "9492": [0, 0.37788, 0, 0, 0.5],
                    "9496": [0, 0.37788, 0, 0, 0.5],
                    "9585": [0.19444, 0.68889, 0, 0, 0.88889],
                    "9586": [0.19444, 0.74111, 0, 0, 0.88889],
                    "9632": [0, 0.675, 0, 0, 0.77778],
                    "9633": [0, 0.675, 0, 0, 0.77778],
                    "9650": [0, 0.54986, 0, 0, 0.72222],
                    "9651": [0, 0.54986, 0, 0, 0.72222],
                    "9654": [0.03517, 0.54986, 0, 0, 0.77778],
                    "9660": [0, 0.54986, 0, 0, 0.72222],
                    "9661": [0, 0.54986, 0, 0, 0.72222],
                    "9664": [0.03517, 0.54986, 0, 0, 0.77778],
                    "9674": [0.11111, 0.69224, 0, 0, 0.66667],
                    "9733": [0.19444, 0.69224, 0, 0, 0.94445],
                    "10003": [0, 0.69224, 0, 0, 0.83334],
                    "10016": [0, 0.69224, 0, 0, 0.83334],
                    "10731": [0.11111, 0.69224, 0, 0, 0.66667],
                    "10846": [0.19444, 0.75583, 0, 0, 0.61111],
                    "10877": [0.13667, 0.63667, 0, 0, 0.77778],
                    "10878": [0.13667, 0.63667, 0, 0, 0.77778],
                    "10885": [0.25583, 0.75583, 0, 0, 0.77778],
                    "10886": [0.25583, 0.75583, 0, 0, 0.77778],
                    "10887": [0.13597, 0.63597, 0, 0, 0.77778],
                    "10888": [0.13597, 0.63597, 0, 0, 0.77778],
                    "10889": [0.26167, 0.75726, 0, 0, 0.77778],
                    "10890": [0.26167, 0.75726, 0, 0, 0.77778],
                    "10891": [0.48256, 0.98256, 0, 0, 0.77778],
                    "10892": [0.48256, 0.98256, 0, 0, 0.77778],
                    "10901": [0.13667, 0.63667, 0, 0, 0.77778],
                    "10902": [0.13667, 0.63667, 0, 0, 0.77778],
                    "10933": [0.25142, 0.75726, 0, 0, 0.77778],
                    "10934": [0.25142, 0.75726, 0, 0, 0.77778],
                    "10935": [0.26167, 0.75726, 0, 0, 0.77778],
                    "10936": [0.26167, 0.75726, 0, 0, 0.77778],
                    "10937": [0.26167, 0.75726, 0, 0, 0.77778],
                    "10938": [0.26167, 0.75726, 0, 0, 0.77778],
                    "10949": [0.25583, 0.75583, 0, 0, 0.77778],
                    "10950": [0.25583, 0.75583, 0, 0, 0.77778],
                    "10955": [0.28481, 0.79383, 0, 0, 0.77778],
                    "10956": [0.28481, 0.79383, 0, 0, 0.77778],
                    "57350": [0.08167, 0.58167, 0, 0, 0.22222],
                    "57351": [0.08167, 0.58167, 0, 0, 0.38889],
                    "57352": [0.08167, 0.58167, 0, 0, 0.77778],
                    "57353": [0, 0.43056, 0.04028, 0, 0.66667],
                    "57356": [0.25142, 0.75726, 0, 0, 0.77778],
                    "57357": [0.25142, 0.75726, 0, 0, 0.77778],
                    "57358": [0.41951, 0.91951, 0, 0, 0.77778],
                    "57359": [0.30274, 0.79383, 0, 0, 0.77778],
                    "57360": [0.30274, 0.79383, 0, 0, 0.77778],
                    "57361": [0.41951, 0.91951, 0, 0, 0.77778],
                    "57366": [0.25142, 0.75726, 0, 0, 0.77778],
                    "57367": [0.25142, 0.75726, 0, 0, 0.77778],
                    "57368": [0.25142, 0.75726, 0, 0, 0.77778],
                    "57369": [0.25142, 0.75726, 0, 0, 0.77778],
                    "57370": [0.13597, 0.63597, 0, 0, 0.77778],
                    "57371": [0.13597, 0.63597, 0, 0, 0.77778]
                },
                "Caligraphic-Regular": {
                    "48": [0, 0.43056, 0, 0, 0.5],
                    "49": [0, 0.43056, 0, 0, 0.5],
                    "50": [0, 0.43056, 0, 0, 0.5],
                    "51": [0.19444, 0.43056, 0, 0, 0.5],
                    "52": [0.19444, 0.43056, 0, 0, 0.5],
                    "53": [0.19444, 0.43056, 0, 0, 0.5],
                    "54": [0, 0.64444, 0, 0, 0.5],
                    "55": [0.19444, 0.43056, 0, 0, 0.5],
                    "56": [0, 0.64444, 0, 0, 0.5],
                    "57": [0.19444, 0.43056, 0, 0, 0.5],
                    "65": [0, 0.68333, 0, 0.19445, 0.79847],
                    "66": [0, 0.68333, 0.03041, 0.13889, 0.65681],
                    "67": [0, 0.68333, 0.05834, 0.13889, 0.52653],
                    "68": [0, 0.68333, 0.02778, 0.08334, 0.77139],
                    "69": [0, 0.68333, 0.08944, 0.11111, 0.52778],
                    "70": [0, 0.68333, 0.09931, 0.11111, 0.71875],
                    "71": [0.09722, 0.68333, 0.0593, 0.11111, 0.59487],
                    "72": [0, 0.68333, 0.00965, 0.11111, 0.84452],
                    "73": [0, 0.68333, 0.07382, 0, 0.54452],
                    "74": [0.09722, 0.68333, 0.18472, 0.16667, 0.67778],
                    "75": [0, 0.68333, 0.01445, 0.05556, 0.76195],
                    "76": [0, 0.68333, 0, 0.13889, 0.68972],
                    "77": [0, 0.68333, 0, 0.13889, 1.2009],
                    "78": [0, 0.68333, 0.14736, 0.08334, 0.82049],
                    "79": [0, 0.68333, 0.02778, 0.11111, 0.79611],
                    "80": [0, 0.68333, 0.08222, 0.08334, 0.69556],
                    "81": [0.09722, 0.68333, 0, 0.11111, 0.81667],
                    "82": [0, 0.68333, 0, 0.08334, 0.8475],
                    "83": [0, 0.68333, 0.075, 0.13889, 0.60556],
                    "84": [0, 0.68333, 0.25417, 0, 0.54464],
                    "85": [0, 0.68333, 0.09931, 0.08334, 0.62583],
                    "86": [0, 0.68333, 0.08222, 0, 0.61278],
                    "87": [0, 0.68333, 0.08222, 0.08334, 0.98778],
                    "88": [0, 0.68333, 0.14643, 0.13889, 0.7133],
                    "89": [0.09722, 0.68333, 0.08222, 0.08334, 0.66834],
                    "90": [0, 0.68333, 0.07944, 0.13889, 0.72473]
                },
                "Fraktur-Regular": {
                    "33": [0, 0.69141, 0, 0, 0.29574],
                    "34": [0, 0.69141, 0, 0, 0.21471],
                    "38": [0, 0.69141, 0, 0, 0.73786],
                    "39": [0, 0.69141, 0, 0, 0.21201],
                    "40": [0.24982, 0.74947, 0, 0, 0.38865],
                    "41": [0.24982, 0.74947, 0, 0, 0.38865],
                    "42": [0, 0.62119, 0, 0, 0.27764],
                    "43": [0.08319, 0.58283, 0, 0, 0.75623],
                    "44": [0, 0.10803, 0, 0, 0.27764],
                    "45": [0.08319, 0.58283, 0, 0, 0.75623],
                    "46": [0, 0.10803, 0, 0, 0.27764],
                    "47": [0.24982, 0.74947, 0, 0, 0.50181],
                    "48": [0, 0.47534, 0, 0, 0.50181],
                    "49": [0, 0.47534, 0, 0, 0.50181],
                    "50": [0, 0.47534, 0, 0, 0.50181],
                    "51": [0.18906, 0.47534, 0, 0, 0.50181],
                    "52": [0.18906, 0.47534, 0, 0, 0.50181],
                    "53": [0.18906, 0.47534, 0, 0, 0.50181],
                    "54": [0, 0.69141, 0, 0, 0.50181],
                    "55": [0.18906, 0.47534, 0, 0, 0.50181],
                    "56": [0, 0.69141, 0, 0, 0.50181],
                    "57": [0.18906, 0.47534, 0, 0, 0.50181],
                    "58": [0, 0.47534, 0, 0, 0.21606],
                    "59": [0.12604, 0.47534, 0, 0, 0.21606],
                    "61": [-0.13099, 0.36866, 0, 0, 0.75623],
                    "63": [0, 0.69141, 0, 0, 0.36245],
                    "65": [0, 0.69141, 0, 0, 0.7176],
                    "66": [0, 0.69141, 0, 0, 0.88397],
                    "67": [0, 0.69141, 0, 0, 0.61254],
                    "68": [0, 0.69141, 0, 0, 0.83158],
                    "69": [0, 0.69141, 0, 0, 0.66278],
                    "70": [0.12604, 0.69141, 0, 0, 0.61119],
                    "71": [0, 0.69141, 0, 0, 0.78539],
                    "72": [0.06302, 0.69141, 0, 0, 0.7203],
                    "73": [0, 0.69141, 0, 0, 0.55448],
                    "74": [0.12604, 0.69141, 0, 0, 0.55231],
                    "75": [0, 0.69141, 0, 0, 0.66845],
                    "76": [0, 0.69141, 0, 0, 0.66602],
                    "77": [0, 0.69141, 0, 0, 1.04953],
                    "78": [0, 0.69141, 0, 0, 0.83212],
                    "79": [0, 0.69141, 0, 0, 0.82699],
                    "80": [0.18906, 0.69141, 0, 0, 0.82753],
                    "81": [0.03781, 0.69141, 0, 0, 0.82699],
                    "82": [0, 0.69141, 0, 0, 0.82807],
                    "83": [0, 0.69141, 0, 0, 0.82861],
                    "84": [0, 0.69141, 0, 0, 0.66899],
                    "85": [0, 0.69141, 0, 0, 0.64576],
                    "86": [0, 0.69141, 0, 0, 0.83131],
                    "87": [0, 0.69141, 0, 0, 1.04602],
                    "88": [0, 0.69141, 0, 0, 0.71922],
                    "89": [0.18906, 0.69141, 0, 0, 0.83293],
                    "90": [0.12604, 0.69141, 0, 0, 0.60201],
                    "91": [0.24982, 0.74947, 0, 0, 0.27764],
                    "93": [0.24982, 0.74947, 0, 0, 0.27764],
                    "94": [0, 0.69141, 0, 0, 0.49965],
                    "97": [0, 0.47534, 0, 0, 0.50046],
                    "98": [0, 0.69141, 0, 0, 0.51315],
                    "99": [0, 0.47534, 0, 0, 0.38946],
                    "100": [0, 0.62119, 0, 0, 0.49857],
                    "101": [0, 0.47534, 0, 0, 0.40053],
                    "102": [0.18906, 0.69141, 0, 0, 0.32626],
                    "103": [0.18906, 0.47534, 0, 0, 0.5037],
                    "104": [0.18906, 0.69141, 0, 0, 0.52126],
                    "105": [0, 0.69141, 0, 0, 0.27899],
                    "106": [0, 0.69141, 0, 0, 0.28088],
                    "107": [0, 0.69141, 0, 0, 0.38946],
                    "108": [0, 0.69141, 0, 0, 0.27953],
                    "109": [0, 0.47534, 0, 0, 0.76676],
                    "110": [0, 0.47534, 0, 0, 0.52666],
                    "111": [0, 0.47534, 0, 0, 0.48885],
                    "112": [0.18906, 0.52396, 0, 0, 0.50046],
                    "113": [0.18906, 0.47534, 0, 0, 0.48912],
                    "114": [0, 0.47534, 0, 0, 0.38919],
                    "115": [0, 0.47534, 0, 0, 0.44266],
                    "116": [0, 0.62119, 0, 0, 0.33301],
                    "117": [0, 0.47534, 0, 0, 0.5172],
                    "118": [0, 0.52396, 0, 0, 0.5118],
                    "119": [0, 0.52396, 0, 0, 0.77351],
                    "120": [0.18906, 0.47534, 0, 0, 0.38865],
                    "121": [0.18906, 0.47534, 0, 0, 0.49884],
                    "122": [0.18906, 0.47534, 0, 0, 0.39054],
                    "8216": [0, 0.69141, 0, 0, 0.21471],
                    "8217": [0, 0.69141, 0, 0, 0.21471],
                    "58112": [0, 0.62119, 0, 0, 0.49749],
                    "58113": [0, 0.62119, 0, 0, 0.4983],
                    "58114": [0.18906, 0.69141, 0, 0, 0.33328],
                    "58115": [0.18906, 0.69141, 0, 0, 0.32923],
                    "58116": [0.18906, 0.47534, 0, 0, 0.50343],
                    "58117": [0, 0.69141, 0, 0, 0.33301],
                    "58118": [0, 0.62119, 0, 0, 0.33409],
                    "58119": [0, 0.47534, 0, 0, 0.50073]
                },
                "Main-Bold": {
                    "33": [0, 0.69444, 0, 0, 0.35],
                    "34": [0, 0.69444, 0, 0, 0.60278],
                    "35": [0.19444, 0.69444, 0, 0, 0.95833],
                    "36": [0.05556, 0.75, 0, 0, 0.575],
                    "37": [0.05556, 0.75, 0, 0, 0.95833],
                    "38": [0, 0.69444, 0, 0, 0.89444],
                    "39": [0, 0.69444, 0, 0, 0.31944],
                    "40": [0.25, 0.75, 0, 0, 0.44722],
                    "41": [0.25, 0.75, 0, 0, 0.44722],
                    "42": [0, 0.75, 0, 0, 0.575],
                    "43": [0.13333, 0.63333, 0, 0, 0.89444],
                    "44": [0.19444, 0.15556, 0, 0, 0.31944],
                    "45": [0, 0.44444, 0, 0, 0.38333],
                    "46": [0, 0.15556, 0, 0, 0.31944],
                    "47": [0.25, 0.75, 0, 0, 0.575],
                    "48": [0, 0.64444, 0, 0, 0.575],
                    "49": [0, 0.64444, 0, 0, 0.575],
                    "50": [0, 0.64444, 0, 0, 0.575],
                    "51": [0, 0.64444, 0, 0, 0.575],
                    "52": [0, 0.64444, 0, 0, 0.575],
                    "53": [0, 0.64444, 0, 0, 0.575],
                    "54": [0, 0.64444, 0, 0, 0.575],
                    "55": [0, 0.64444, 0, 0, 0.575],
                    "56": [0, 0.64444, 0, 0, 0.575],
                    "57": [0, 0.64444, 0, 0, 0.575],
                    "58": [0, 0.44444, 0, 0, 0.31944],
                    "59": [0.19444, 0.44444, 0, 0, 0.31944],
                    "60": [0.08556, 0.58556, 0, 0, 0.89444],
                    "61": [-0.10889, 0.39111, 0, 0, 0.89444],
                    "62": [0.08556, 0.58556, 0, 0, 0.89444],
                    "63": [0, 0.69444, 0, 0, 0.54305],
                    "64": [0, 0.69444, 0, 0, 0.89444],
                    "65": [0, 0.68611, 0, 0, 0.86944],
                    "66": [0, 0.68611, 0, 0, 0.81805],
                    "67": [0, 0.68611, 0, 0, 0.83055],
                    "68": [0, 0.68611, 0, 0, 0.88194],
                    "69": [0, 0.68611, 0, 0, 0.75555],
                    "70": [0, 0.68611, 0, 0, 0.72361],
                    "71": [0, 0.68611, 0, 0, 0.90416],
                    "72": [0, 0.68611, 0, 0, 0.9],
                    "73": [0, 0.68611, 0, 0, 0.43611],
                    "74": [0, 0.68611, 0, 0, 0.59444],
                    "75": [0, 0.68611, 0, 0, 0.90138],
                    "76": [0, 0.68611, 0, 0, 0.69166],
                    "77": [0, 0.68611, 0, 0, 1.09166],
                    "78": [0, 0.68611, 0, 0, 0.9],
                    "79": [0, 0.68611, 0, 0, 0.86388],
                    "80": [0, 0.68611, 0, 0, 0.78611],
                    "81": [0.19444, 0.68611, 0, 0, 0.86388],
                    "82": [0, 0.68611, 0, 0, 0.8625],
                    "83": [0, 0.68611, 0, 0, 0.63889],
                    "84": [0, 0.68611, 0, 0, 0.8],
                    "85": [0, 0.68611, 0, 0, 0.88472],
                    "86": [0, 0.68611, 0.01597, 0, 0.86944],
                    "87": [0, 0.68611, 0.01597, 0, 1.18888],
                    "88": [0, 0.68611, 0, 0, 0.86944],
                    "89": [0, 0.68611, 0.02875, 0, 0.86944],
                    "90": [0, 0.68611, 0, 0, 0.70277],
                    "91": [0.25, 0.75, 0, 0, 0.31944],
                    "92": [0.25, 0.75, 0, 0, 0.575],
                    "93": [0.25, 0.75, 0, 0, 0.31944],
                    "94": [0, 0.69444, 0, 0, 0.575],
                    "95": [0.31, 0.13444, 0.03194, 0, 0.575],
                    "97": [0, 0.44444, 0, 0, 0.55902],
                    "98": [0, 0.69444, 0, 0, 0.63889],
                    "99": [0, 0.44444, 0, 0, 0.51111],
                    "100": [0, 0.69444, 0, 0, 0.63889],
                    "101": [0, 0.44444, 0, 0, 0.52708],
                    "102": [0, 0.69444, 0.10903, 0, 0.35139],
                    "103": [0.19444, 0.44444, 0.01597, 0, 0.575],
                    "104": [0, 0.69444, 0, 0, 0.63889],
                    "105": [0, 0.69444, 0, 0, 0.31944],
                    "106": [0.19444, 0.69444, 0, 0, 0.35139],
                    "107": [0, 0.69444, 0, 0, 0.60694],
                    "108": [0, 0.69444, 0, 0, 0.31944],
                    "109": [0, 0.44444, 0, 0, 0.95833],
                    "110": [0, 0.44444, 0, 0, 0.63889],
                    "111": [0, 0.44444, 0, 0, 0.575],
                    "112": [0.19444, 0.44444, 0, 0, 0.63889],
                    "113": [0.19444, 0.44444, 0, 0, 0.60694],
                    "114": [0, 0.44444, 0, 0, 0.47361],
                    "115": [0, 0.44444, 0, 0, 0.45361],
                    "116": [0, 0.63492, 0, 0, 0.44722],
                    "117": [0, 0.44444, 0, 0, 0.63889],
                    "118": [0, 0.44444, 0.01597, 0, 0.60694],
                    "119": [0, 0.44444, 0.01597, 0, 0.83055],
                    "120": [0, 0.44444, 0, 0, 0.60694],
                    "121": [0.19444, 0.44444, 0.01597, 0, 0.60694],
                    "122": [0, 0.44444, 0, 0, 0.51111],
                    "123": [0.25, 0.75, 0, 0, 0.575],
                    "124": [0.25, 0.75, 0, 0, 0.31944],
                    "125": [0.25, 0.75, 0, 0, 0.575],
                    "126": [0.35, 0.34444, 0, 0, 0.575],
                    "168": [0, 0.69444, 0, 0, 0.575],
                    "172": [0, 0.44444, 0, 0, 0.76666],
                    "176": [0, 0.69444, 0, 0, 0.86944],
                    "177": [0.13333, 0.63333, 0, 0, 0.89444],
                    "184": [0.17014, 0, 0, 0, 0.51111],
                    "198": [0, 0.68611, 0, 0, 1.04166],
                    "215": [0.13333, 0.63333, 0, 0, 0.89444],
                    "216": [0.04861, 0.73472, 0, 0, 0.89444],
                    "223": [0, 0.69444, 0, 0, 0.59722],
                    "230": [0, 0.44444, 0, 0, 0.83055],
                    "247": [0.13333, 0.63333, 0, 0, 0.89444],
                    "248": [0.09722, 0.54167, 0, 0, 0.575],
                    "305": [0, 0.44444, 0, 0, 0.31944],
                    "338": [0, 0.68611, 0, 0, 1.16944],
                    "339": [0, 0.44444, 0, 0, 0.89444],
                    "567": [0.19444, 0.44444, 0, 0, 0.35139],
                    "710": [0, 0.69444, 0, 0, 0.575],
                    "711": [0, 0.63194, 0, 0, 0.575],
                    "713": [0, 0.59611, 0, 0, 0.575],
                    "714": [0, 0.69444, 0, 0, 0.575],
                    "715": [0, 0.69444, 0, 0, 0.575],
                    "728": [0, 0.69444, 0, 0, 0.575],
                    "729": [0, 0.69444, 0, 0, 0.31944],
                    "730": [0, 0.69444, 0, 0, 0.86944],
                    "732": [0, 0.69444, 0, 0, 0.575],
                    "733": [0, 0.69444, 0, 0, 0.575],
                    "915": [0, 0.68611, 0, 0, 0.69166],
                    "916": [0, 0.68611, 0, 0, 0.95833],
                    "920": [0, 0.68611, 0, 0, 0.89444],
                    "923": [0, 0.68611, 0, 0, 0.80555],
                    "926": [0, 0.68611, 0, 0, 0.76666],
                    "928": [0, 0.68611, 0, 0, 0.9],
                    "931": [0, 0.68611, 0, 0, 0.83055],
                    "933": [0, 0.68611, 0, 0, 0.89444],
                    "934": [0, 0.68611, 0, 0, 0.83055],
                    "936": [0, 0.68611, 0, 0, 0.89444],
                    "937": [0, 0.68611, 0, 0, 0.83055],
                    "8211": [0, 0.44444, 0.03194, 0, 0.575],
                    "8212": [0, 0.44444, 0.03194, 0, 1.14999],
                    "8216": [0, 0.69444, 0, 0, 0.31944],
                    "8217": [0, 0.69444, 0, 0, 0.31944],
                    "8220": [0, 0.69444, 0, 0, 0.60278],
                    "8221": [0, 0.69444, 0, 0, 0.60278],
                    "8224": [0.19444, 0.69444, 0, 0, 0.51111],
                    "8225": [0.19444, 0.69444, 0, 0, 0.51111],
                    "8242": [0, 0.55556, 0, 0, 0.34444],
                    "8407": [0, 0.72444, 0.15486, 0, 0.575],
                    "8463": [0, 0.69444, 0, 0, 0.66759],
                    "8465": [0, 0.69444, 0, 0, 0.83055],
                    "8467": [0, 0.69444, 0, 0, 0.47361],
                    "8472": [0.19444, 0.44444, 0, 0, 0.74027],
                    "8476": [0, 0.69444, 0, 0, 0.83055],
                    "8501": [0, 0.69444, 0, 0, 0.70277],
                    "8592": [-0.10889, 0.39111, 0, 0, 1.14999],
                    "8593": [0.19444, 0.69444, 0, 0, 0.575],
                    "8594": [-0.10889, 0.39111, 0, 0, 1.14999],
                    "8595": [0.19444, 0.69444, 0, 0, 0.575],
                    "8596": [-0.10889, 0.39111, 0, 0, 1.14999],
                    "8597": [0.25, 0.75, 0, 0, 0.575],
                    "8598": [0.19444, 0.69444, 0, 0, 1.14999],
                    "8599": [0.19444, 0.69444, 0, 0, 1.14999],
                    "8600": [0.19444, 0.69444, 0, 0, 1.14999],
                    "8601": [0.19444, 0.69444, 0, 0, 1.14999],
                    "8636": [-0.10889, 0.39111, 0, 0, 1.14999],
                    "8637": [-0.10889, 0.39111, 0, 0, 1.14999],
                    "8640": [-0.10889, 0.39111, 0, 0, 1.14999],
                    "8641": [-0.10889, 0.39111, 0, 0, 1.14999],
                    "8656": [-0.10889, 0.39111, 0, 0, 1.14999],
                    "8657": [0.19444, 0.69444, 0, 0, 0.70277],
                    "8658": [-0.10889, 0.39111, 0, 0, 1.14999],
                    "8659": [0.19444, 0.69444, 0, 0, 0.70277],
                    "8660": [-0.10889, 0.39111, 0, 0, 1.14999],
                    "8661": [0.25, 0.75, 0, 0, 0.70277],
                    "8704": [0, 0.69444, 0, 0, 0.63889],
                    "8706": [0, 0.69444, 0.06389, 0, 0.62847],
                    "8707": [0, 0.69444, 0, 0, 0.63889],
                    "8709": [0.05556, 0.75, 0, 0, 0.575],
                    "8711": [0, 0.68611, 0, 0, 0.95833],
                    "8712": [0.08556, 0.58556, 0, 0, 0.76666],
                    "8715": [0.08556, 0.58556, 0, 0, 0.76666],
                    "8722": [0.13333, 0.63333, 0, 0, 0.89444],
                    "8723": [0.13333, 0.63333, 0, 0, 0.89444],
                    "8725": [0.25, 0.75, 0, 0, 0.575],
                    "8726": [0.25, 0.75, 0, 0, 0.575],
                    "8727": [-0.02778, 0.47222, 0, 0, 0.575],
                    "8728": [-0.02639, 0.47361, 0, 0, 0.575],
                    "8729": [-0.02639, 0.47361, 0, 0, 0.575],
                    "8730": [0.18, 0.82, 0, 0, 0.95833],
                    "8733": [0, 0.44444, 0, 0, 0.89444],
                    "8734": [0, 0.44444, 0, 0, 1.14999],
                    "8736": [0, 0.69224, 0, 0, 0.72222],
                    "8739": [0.25, 0.75, 0, 0, 0.31944],
                    "8741": [0.25, 0.75, 0, 0, 0.575],
                    "8743": [0, 0.55556, 0, 0, 0.76666],
                    "8744": [0, 0.55556, 0, 0, 0.76666],
                    "8745": [0, 0.55556, 0, 0, 0.76666],
                    "8746": [0, 0.55556, 0, 0, 0.76666],
                    "8747": [0.19444, 0.69444, 0.12778, 0, 0.56875],
                    "8764": [-0.10889, 0.39111, 0, 0, 0.89444],
                    "8768": [0.19444, 0.69444, 0, 0, 0.31944],
                    "8771": [0.00222, 0.50222, 0, 0, 0.89444],
                    "8776": [0.02444, 0.52444, 0, 0, 0.89444],
                    "8781": [0.00222, 0.50222, 0, 0, 0.89444],
                    "8801": [0.00222, 0.50222, 0, 0, 0.89444],
                    "8804": [0.19667, 0.69667, 0, 0, 0.89444],
                    "8805": [0.19667, 0.69667, 0, 0, 0.89444],
                    "8810": [0.08556, 0.58556, 0, 0, 1.14999],
                    "8811": [0.08556, 0.58556, 0, 0, 1.14999],
                    "8826": [0.08556, 0.58556, 0, 0, 0.89444],
                    "8827": [0.08556, 0.58556, 0, 0, 0.89444],
                    "8834": [0.08556, 0.58556, 0, 0, 0.89444],
                    "8835": [0.08556, 0.58556, 0, 0, 0.89444],
                    "8838": [0.19667, 0.69667, 0, 0, 0.89444],
                    "8839": [0.19667, 0.69667, 0, 0, 0.89444],
                    "8846": [0, 0.55556, 0, 0, 0.76666],
                    "8849": [0.19667, 0.69667, 0, 0, 0.89444],
                    "8850": [0.19667, 0.69667, 0, 0, 0.89444],
                    "8851": [0, 0.55556, 0, 0, 0.76666],
                    "8852": [0, 0.55556, 0, 0, 0.76666],
                    "8853": [0.13333, 0.63333, 0, 0, 0.89444],
                    "8854": [0.13333, 0.63333, 0, 0, 0.89444],
                    "8855": [0.13333, 0.63333, 0, 0, 0.89444],
                    "8856": [0.13333, 0.63333, 0, 0, 0.89444],
                    "8857": [0.13333, 0.63333, 0, 0, 0.89444],
                    "8866": [0, 0.69444, 0, 0, 0.70277],
                    "8867": [0, 0.69444, 0, 0, 0.70277],
                    "8868": [0, 0.69444, 0, 0, 0.89444],
                    "8869": [0, 0.69444, 0, 0, 0.89444],
                    "8900": [-0.02639, 0.47361, 0, 0, 0.575],
                    "8901": [-0.02639, 0.47361, 0, 0, 0.31944],
                    "8902": [-0.02778, 0.47222, 0, 0, 0.575],
                    "8968": [0.25, 0.75, 0, 0, 0.51111],
                    "8969": [0.25, 0.75, 0, 0, 0.51111],
                    "8970": [0.25, 0.75, 0, 0, 0.51111],
                    "8971": [0.25, 0.75, 0, 0, 0.51111],
                    "8994": [-0.13889, 0.36111, 0, 0, 1.14999],
                    "8995": [-0.13889, 0.36111, 0, 0, 1.14999],
                    "9651": [0.19444, 0.69444, 0, 0, 1.02222],
                    "9657": [-0.02778, 0.47222, 0, 0, 0.575],
                    "9661": [0.19444, 0.69444, 0, 0, 1.02222],
                    "9667": [-0.02778, 0.47222, 0, 0, 0.575],
                    "9711": [0.19444, 0.69444, 0, 0, 1.14999],
                    "9824": [0.12963, 0.69444, 0, 0, 0.89444],
                    "9825": [0.12963, 0.69444, 0, 0, 0.89444],
                    "9826": [0.12963, 0.69444, 0, 0, 0.89444],
                    "9827": [0.12963, 0.69444, 0, 0, 0.89444],
                    "9837": [0, 0.75, 0, 0, 0.44722],
                    "9838": [0.19444, 0.69444, 0, 0, 0.44722],
                    "9839": [0.19444, 0.69444, 0, 0, 0.44722],
                    "10216": [0.25, 0.75, 0, 0, 0.44722],
                    "10217": [0.25, 0.75, 0, 0, 0.44722],
                    "10815": [0, 0.68611, 0, 0, 0.9],
                    "10927": [0.19667, 0.69667, 0, 0, 0.89444],
                    "10928": [0.19667, 0.69667, 0, 0, 0.89444],
                    "57376": [0.19444, 0.69444, 0, 0, 0]
                },
                "Main-BoldItalic": {
                    "33": [0, 0.69444, 0.11417, 0, 0.38611],
                    "34": [0, 0.69444, 0.07939, 0, 0.62055],
                    "35": [0.19444, 0.69444, 0.06833, 0, 0.94444],
                    "37": [0.05556, 0.75, 0.12861, 0, 0.94444],
                    "38": [0, 0.69444, 0.08528, 0, 0.88555],
                    "39": [0, 0.69444, 0.12945, 0, 0.35555],
                    "40": [0.25, 0.75, 0.15806, 0, 0.47333],
                    "41": [0.25, 0.75, 0.03306, 0, 0.47333],
                    "42": [0, 0.75, 0.14333, 0, 0.59111],
                    "43": [0.10333, 0.60333, 0.03306, 0, 0.88555],
                    "44": [0.19444, 0.14722, 0, 0, 0.35555],
                    "45": [0, 0.44444, 0.02611, 0, 0.41444],
                    "46": [0, 0.14722, 0, 0, 0.35555],
                    "47": [0.25, 0.75, 0.15806, 0, 0.59111],
                    "48": [0, 0.64444, 0.13167, 0, 0.59111],
                    "49": [0, 0.64444, 0.13167, 0, 0.59111],
                    "50": [0, 0.64444, 0.13167, 0, 0.59111],
                    "51": [0, 0.64444, 0.13167, 0, 0.59111],
                    "52": [0.19444, 0.64444, 0.13167, 0, 0.59111],
                    "53": [0, 0.64444, 0.13167, 0, 0.59111],
                    "54": [0, 0.64444, 0.13167, 0, 0.59111],
                    "55": [0.19444, 0.64444, 0.13167, 0, 0.59111],
                    "56": [0, 0.64444, 0.13167, 0, 0.59111],
                    "57": [0, 0.64444, 0.13167, 0, 0.59111],
                    "58": [0, 0.44444, 0.06695, 0, 0.35555],
                    "59": [0.19444, 0.44444, 0.06695, 0, 0.35555],
                    "61": [-0.10889, 0.39111, 0.06833, 0, 0.88555],
                    "63": [0, 0.69444, 0.11472, 0, 0.59111],
                    "64": [0, 0.69444, 0.09208, 0, 0.88555],
                    "65": [0, 0.68611, 0, 0, 0.86555],
                    "66": [0, 0.68611, 0.0992, 0, 0.81666],
                    "67": [0, 0.68611, 0.14208, 0, 0.82666],
                    "68": [0, 0.68611, 0.09062, 0, 0.87555],
                    "69": [0, 0.68611, 0.11431, 0, 0.75666],
                    "70": [0, 0.68611, 0.12903, 0, 0.72722],
                    "71": [0, 0.68611, 0.07347, 0, 0.89527],
                    "72": [0, 0.68611, 0.17208, 0, 0.8961],
                    "73": [0, 0.68611, 0.15681, 0, 0.47166],
                    "74": [0, 0.68611, 0.145, 0, 0.61055],
                    "75": [0, 0.68611, 0.14208, 0, 0.89499],
                    "76": [0, 0.68611, 0, 0, 0.69777],
                    "77": [0, 0.68611, 0.17208, 0, 1.07277],
                    "78": [0, 0.68611, 0.17208, 0, 0.8961],
                    "79": [0, 0.68611, 0.09062, 0, 0.85499],
                    "80": [0, 0.68611, 0.0992, 0, 0.78721],
                    "81": [0.19444, 0.68611, 0.09062, 0, 0.85499],
                    "82": [0, 0.68611, 0.02559, 0, 0.85944],
                    "83": [0, 0.68611, 0.11264, 0, 0.64999],
                    "84": [0, 0.68611, 0.12903, 0, 0.7961],
                    "85": [0, 0.68611, 0.17208, 0, 0.88083],
                    "86": [0, 0.68611, 0.18625, 0, 0.86555],
                    "87": [0, 0.68611, 0.18625, 0, 1.15999],
                    "88": [0, 0.68611, 0.15681, 0, 0.86555],
                    "89": [0, 0.68611, 0.19803, 0, 0.86555],
                    "90": [0, 0.68611, 0.14208, 0, 0.70888],
                    "91": [0.25, 0.75, 0.1875, 0, 0.35611],
                    "93": [0.25, 0.75, 0.09972, 0, 0.35611],
                    "94": [0, 0.69444, 0.06709, 0, 0.59111],
                    "95": [0.31, 0.13444, 0.09811, 0, 0.59111],
                    "97": [0, 0.44444, 0.09426, 0, 0.59111],
                    "98": [0, 0.69444, 0.07861, 0, 0.53222],
                    "99": [0, 0.44444, 0.05222, 0, 0.53222],
                    "100": [0, 0.69444, 0.10861, 0, 0.59111],
                    "101": [0, 0.44444, 0.085, 0, 0.53222],
                    "102": [0.19444, 0.69444, 0.21778, 0, 0.4],
                    "103": [0.19444, 0.44444, 0.105, 0, 0.53222],
                    "104": [0, 0.69444, 0.09426, 0, 0.59111],
                    "105": [0, 0.69326, 0.11387, 0, 0.35555],
                    "106": [0.19444, 0.69326, 0.1672, 0, 0.35555],
                    "107": [0, 0.69444, 0.11111, 0, 0.53222],
                    "108": [0, 0.69444, 0.10861, 0, 0.29666],
                    "109": [0, 0.44444, 0.09426, 0, 0.94444],
                    "110": [0, 0.44444, 0.09426, 0, 0.64999],
                    "111": [0, 0.44444, 0.07861, 0, 0.59111],
                    "112": [0.19444, 0.44444, 0.07861, 0, 0.59111],
                    "113": [0.19444, 0.44444, 0.105, 0, 0.53222],
                    "114": [0, 0.44444, 0.11111, 0, 0.50167],
                    "115": [0, 0.44444, 0.08167, 0, 0.48694],
                    "116": [0, 0.63492, 0.09639, 0, 0.385],
                    "117": [0, 0.44444, 0.09426, 0, 0.62055],
                    "118": [0, 0.44444, 0.11111, 0, 0.53222],
                    "119": [0, 0.44444, 0.11111, 0, 0.76777],
                    "120": [0, 0.44444, 0.12583, 0, 0.56055],
                    "121": [0.19444, 0.44444, 0.105, 0, 0.56166],
                    "122": [0, 0.44444, 0.13889, 0, 0.49055],
                    "126": [0.35, 0.34444, 0.11472, 0, 0.59111],
                    "163": [0, 0.69444, 0, 0, 0.86853],
                    "168": [0, 0.69444, 0.11473, 0, 0.59111],
                    "176": [0, 0.69444, 0, 0, 0.94888],
                    "184": [0.17014, 0, 0, 0, 0.53222],
                    "198": [0, 0.68611, 0.11431, 0, 1.02277],
                    "216": [0.04861, 0.73472, 0.09062, 0, 0.88555],
                    "223": [0.19444, 0.69444, 0.09736, 0, 0.665],
                    "230": [0, 0.44444, 0.085, 0, 0.82666],
                    "248": [0.09722, 0.54167, 0.09458, 0, 0.59111],
                    "305": [0, 0.44444, 0.09426, 0, 0.35555],
                    "338": [0, 0.68611, 0.11431, 0, 1.14054],
                    "339": [0, 0.44444, 0.085, 0, 0.82666],
                    "567": [0.19444, 0.44444, 0.04611, 0, 0.385],
                    "710": [0, 0.69444, 0.06709, 0, 0.59111],
                    "711": [0, 0.63194, 0.08271, 0, 0.59111],
                    "713": [0, 0.59444, 0.10444, 0, 0.59111],
                    "714": [0, 0.69444, 0.08528, 0, 0.59111],
                    "715": [0, 0.69444, 0, 0, 0.59111],
                    "728": [0, 0.69444, 0.10333, 0, 0.59111],
                    "729": [0, 0.69444, 0.12945, 0, 0.35555],
                    "730": [0, 0.69444, 0, 0, 0.94888],
                    "732": [0, 0.69444, 0.11472, 0, 0.59111],
                    "733": [0, 0.69444, 0.11472, 0, 0.59111],
                    "915": [0, 0.68611, 0.12903, 0, 0.69777],
                    "916": [0, 0.68611, 0, 0, 0.94444],
                    "920": [0, 0.68611, 0.09062, 0, 0.88555],
                    "923": [0, 0.68611, 0, 0, 0.80666],
                    "926": [0, 0.68611, 0.15092, 0, 0.76777],
                    "928": [0, 0.68611, 0.17208, 0, 0.8961],
                    "931": [0, 0.68611, 0.11431, 0, 0.82666],
                    "933": [0, 0.68611, 0.10778, 0, 0.88555],
                    "934": [0, 0.68611, 0.05632, 0, 0.82666],
                    "936": [0, 0.68611, 0.10778, 0, 0.88555],
                    "937": [0, 0.68611, 0.0992, 0, 0.82666],
                    "8211": [0, 0.44444, 0.09811, 0, 0.59111],
                    "8212": [0, 0.44444, 0.09811, 0, 1.18221],
                    "8216": [0, 0.69444, 0.12945, 0, 0.35555],
                    "8217": [0, 0.69444, 0.12945, 0, 0.35555],
                    "8220": [0, 0.69444, 0.16772, 0, 0.62055],
                    "8221": [0, 0.69444, 0.07939, 0, 0.62055]
                },
                "Main-Italic": {
                    "33": [0, 0.69444, 0.12417, 0, 0.30667],
                    "34": [0, 0.69444, 0.06961, 0, 0.51444],
                    "35": [0.19444, 0.69444, 0.06616, 0, 0.81777],
                    "37": [0.05556, 0.75, 0.13639, 0, 0.81777],
                    "38": [0, 0.69444, 0.09694, 0, 0.76666],
                    "39": [0, 0.69444, 0.12417, 0, 0.30667],
                    "40": [0.25, 0.75, 0.16194, 0, 0.40889],
                    "41": [0.25, 0.75, 0.03694, 0, 0.40889],
                    "42": [0, 0.75, 0.14917, 0, 0.51111],
                    "43": [0.05667, 0.56167, 0.03694, 0, 0.76666],
                    "44": [0.19444, 0.10556, 0, 0, 0.30667],
                    "45": [0, 0.43056, 0.02826, 0, 0.35778],
                    "46": [0, 0.10556, 0, 0, 0.30667],
                    "47": [0.25, 0.75, 0.16194, 0, 0.51111],
                    "48": [0, 0.64444, 0.13556, 0, 0.51111],
                    "49": [0, 0.64444, 0.13556, 0, 0.51111],
                    "50": [0, 0.64444, 0.13556, 0, 0.51111],
                    "51": [0, 0.64444, 0.13556, 0, 0.51111],
                    "52": [0.19444, 0.64444, 0.13556, 0, 0.51111],
                    "53": [0, 0.64444, 0.13556, 0, 0.51111],
                    "54": [0, 0.64444, 0.13556, 0, 0.51111],
                    "55": [0.19444, 0.64444, 0.13556, 0, 0.51111],
                    "56": [0, 0.64444, 0.13556, 0, 0.51111],
                    "57": [0, 0.64444, 0.13556, 0, 0.51111],
                    "58": [0, 0.43056, 0.0582, 0, 0.30667],
                    "59": [0.19444, 0.43056, 0.0582, 0, 0.30667],
                    "61": [-0.13313, 0.36687, 0.06616, 0, 0.76666],
                    "63": [0, 0.69444, 0.1225, 0, 0.51111],
                    "64": [0, 0.69444, 0.09597, 0, 0.76666],
                    "65": [0, 0.68333, 0, 0, 0.74333],
                    "66": [0, 0.68333, 0.10257, 0, 0.70389],
                    "67": [0, 0.68333, 0.14528, 0, 0.71555],
                    "68": [0, 0.68333, 0.09403, 0, 0.755],
                    "69": [0, 0.68333, 0.12028, 0, 0.67833],
                    "70": [0, 0.68333, 0.13305, 0, 0.65277],
                    "71": [0, 0.68333, 0.08722, 0, 0.77361],
                    "72": [0, 0.68333, 0.16389, 0, 0.74333],
                    "73": [0, 0.68333, 0.15806, 0, 0.38555],
                    "74": [0, 0.68333, 0.14028, 0, 0.525],
                    "75": [0, 0.68333, 0.14528, 0, 0.76888],
                    "76": [0, 0.68333, 0, 0, 0.62722],
                    "77": [0, 0.68333, 0.16389, 0, 0.89666],
                    "78": [0, 0.68333, 0.16389, 0, 0.74333],
                    "79": [0, 0.68333, 0.09403, 0, 0.76666],
                    "80": [0, 0.68333, 0.10257, 0, 0.67833],
                    "81": [0.19444, 0.68333, 0.09403, 0, 0.76666],
                    "82": [0, 0.68333, 0.03868, 0, 0.72944],
                    "83": [0, 0.68333, 0.11972, 0, 0.56222],
                    "84": [0, 0.68333, 0.13305, 0, 0.71555],
                    "85": [0, 0.68333, 0.16389, 0, 0.74333],
                    "86": [0, 0.68333, 0.18361, 0, 0.74333],
                    "87": [0, 0.68333, 0.18361, 0, 0.99888],
                    "88": [0, 0.68333, 0.15806, 0, 0.74333],
                    "89": [0, 0.68333, 0.19383, 0, 0.74333],
                    "90": [0, 0.68333, 0.14528, 0, 0.61333],
                    "91": [0.25, 0.75, 0.1875, 0, 0.30667],
                    "93": [0.25, 0.75, 0.10528, 0, 0.30667],
                    "94": [0, 0.69444, 0.06646, 0, 0.51111],
                    "95": [0.31, 0.12056, 0.09208, 0, 0.51111],
                    "97": [0, 0.43056, 0.07671, 0, 0.51111],
                    "98": [0, 0.69444, 0.06312, 0, 0.46],
                    "99": [0, 0.43056, 0.05653, 0, 0.46],
                    "100": [0, 0.69444, 0.10333, 0, 0.51111],
                    "101": [0, 0.43056, 0.07514, 0, 0.46],
                    "102": [0.19444, 0.69444, 0.21194, 0, 0.30667],
                    "103": [0.19444, 0.43056, 0.08847, 0, 0.46],
                    "104": [0, 0.69444, 0.07671, 0, 0.51111],
                    "105": [0, 0.65536, 0.1019, 0, 0.30667],
                    "106": [0.19444, 0.65536, 0.14467, 0, 0.30667],
                    "107": [0, 0.69444, 0.10764, 0, 0.46],
                    "108": [0, 0.69444, 0.10333, 0, 0.25555],
                    "109": [0, 0.43056, 0.07671, 0, 0.81777],
                    "110": [0, 0.43056, 0.07671, 0, 0.56222],
                    "111": [0, 0.43056, 0.06312, 0, 0.51111],
                    "112": [0.19444, 0.43056, 0.06312, 0, 0.51111],
                    "113": [0.19444, 0.43056, 0.08847, 0, 0.46],
                    "114": [0, 0.43056, 0.10764, 0, 0.42166],
                    "115": [0, 0.43056, 0.08208, 0, 0.40889],
                    "116": [0, 0.61508, 0.09486, 0, 0.33222],
                    "117": [0, 0.43056, 0.07671, 0, 0.53666],
                    "118": [0, 0.43056, 0.10764, 0, 0.46],
                    "119": [0, 0.43056, 0.10764, 0, 0.66444],
                    "120": [0, 0.43056, 0.12042, 0, 0.46389],
                    "121": [0.19444, 0.43056, 0.08847, 0, 0.48555],
                    "122": [0, 0.43056, 0.12292, 0, 0.40889],
                    "126": [0.35, 0.31786, 0.11585, 0, 0.51111],
                    "163": [0, 0.69444, 0, 0, 0.76909],
                    "168": [0, 0.66786, 0.10474, 0, 0.51111],
                    "176": [0, 0.69444, 0, 0, 0.83129],
                    "184": [0.17014, 0, 0, 0, 0.46],
                    "198": [0, 0.68333, 0.12028, 0, 0.88277],
                    "216": [0.04861, 0.73194, 0.09403, 0, 0.76666],
                    "223": [0.19444, 0.69444, 0.10514, 0, 0.53666],
                    "230": [0, 0.43056, 0.07514, 0, 0.71555],
                    "248": [0.09722, 0.52778, 0.09194, 0, 0.51111],
                    "305": [0, 0.43056, 0, 0.02778, 0.32246],
                    "338": [0, 0.68333, 0.12028, 0, 0.98499],
                    "339": [0, 0.43056, 0.07514, 0, 0.71555],
                    "567": [0.19444, 0.43056, 0, 0.08334, 0.38403],
                    "710": [0, 0.69444, 0.06646, 0, 0.51111],
                    "711": [0, 0.62847, 0.08295, 0, 0.51111],
                    "713": [0, 0.56167, 0.10333, 0, 0.51111],
                    "714": [0, 0.69444, 0.09694, 0, 0.51111],
                    "715": [0, 0.69444, 0, 0, 0.51111],
                    "728": [0, 0.69444, 0.10806, 0, 0.51111],
                    "729": [0, 0.66786, 0.11752, 0, 0.30667],
                    "730": [0, 0.69444, 0, 0, 0.83129],
                    "732": [0, 0.66786, 0.11585, 0, 0.51111],
                    "733": [0, 0.69444, 0.1225, 0, 0.51111],
                    "915": [0, 0.68333, 0.13305, 0, 0.62722],
                    "916": [0, 0.68333, 0, 0, 0.81777],
                    "920": [0, 0.68333, 0.09403, 0, 0.76666],
                    "923": [0, 0.68333, 0, 0, 0.69222],
                    "926": [0, 0.68333, 0.15294, 0, 0.66444],
                    "928": [0, 0.68333, 0.16389, 0, 0.74333],
                    "931": [0, 0.68333, 0.12028, 0, 0.71555],
                    "933": [0, 0.68333, 0.11111, 0, 0.76666],
                    "934": [0, 0.68333, 0.05986, 0, 0.71555],
                    "936": [0, 0.68333, 0.11111, 0, 0.76666],
                    "937": [0, 0.68333, 0.10257, 0, 0.71555],
                    "8211": [0, 0.43056, 0.09208, 0, 0.51111],
                    "8212": [0, 0.43056, 0.09208, 0, 1.02222],
                    "8216": [0, 0.69444, 0.12417, 0, 0.30667],
                    "8217": [0, 0.69444, 0.12417, 0, 0.30667],
                    "8220": [0, 0.69444, 0.1685, 0, 0.51444],
                    "8221": [0, 0.69444, 0.06961, 0, 0.51444],
                    "8463": [0, 0.68889, 0, 0, 0.54028]
                },
                "Main-Regular": {
                    "32": [0, 0, 0, 0, 0.25],
                    "33": [0, 0.69444, 0, 0, 0.27778],
                    "34": [0, 0.69444, 0, 0, 0.5],
                    "35": [0.19444, 0.69444, 0, 0, 0.83334],
                    "36": [0.05556, 0.75, 0, 0, 0.5],
                    "37": [0.05556, 0.75, 0, 0, 0.83334],
                    "38": [0, 0.69444, 0, 0, 0.77778],
                    "39": [0, 0.69444, 0, 0, 0.27778],
                    "40": [0.25, 0.75, 0, 0, 0.38889],
                    "41": [0.25, 0.75, 0, 0, 0.38889],
                    "42": [0, 0.75, 0, 0, 0.5],
                    "43": [0.08333, 0.58333, 0, 0, 0.77778],
                    "44": [0.19444, 0.10556, 0, 0, 0.27778],
                    "45": [0, 0.43056, 0, 0, 0.33333],
                    "46": [0, 0.10556, 0, 0, 0.27778],
                    "47": [0.25, 0.75, 0, 0, 0.5],
                    "48": [0, 0.64444, 0, 0, 0.5],
                    "49": [0, 0.64444, 0, 0, 0.5],
                    "50": [0, 0.64444, 0, 0, 0.5],
                    "51": [0, 0.64444, 0, 0, 0.5],
                    "52": [0, 0.64444, 0, 0, 0.5],
                    "53": [0, 0.64444, 0, 0, 0.5],
                    "54": [0, 0.64444, 0, 0, 0.5],
                    "55": [0, 0.64444, 0, 0, 0.5],
                    "56": [0, 0.64444, 0, 0, 0.5],
                    "57": [0, 0.64444, 0, 0, 0.5],
                    "58": [0, 0.43056, 0, 0, 0.27778],
                    "59": [0.19444, 0.43056, 0, 0, 0.27778],
                    "60": [0.0391, 0.5391, 0, 0, 0.77778],
                    "61": [-0.13313, 0.36687, 0, 0, 0.77778],
                    "62": [0.0391, 0.5391, 0, 0, 0.77778],
                    "63": [0, 0.69444, 0, 0, 0.47222],
                    "64": [0, 0.69444, 0, 0, 0.77778],
                    "65": [0, 0.68333, 0, 0, 0.75],
                    "66": [0, 0.68333, 0, 0, 0.70834],
                    "67": [0, 0.68333, 0, 0, 0.72222],
                    "68": [0, 0.68333, 0, 0, 0.76389],
                    "69": [0, 0.68333, 0, 0, 0.68056],
                    "70": [0, 0.68333, 0, 0, 0.65278],
                    "71": [0, 0.68333, 0, 0, 0.78472],
                    "72": [0, 0.68333, 0, 0, 0.75],
                    "73": [0, 0.68333, 0, 0, 0.36111],
                    "74": [0, 0.68333, 0, 0, 0.51389],
                    "75": [0, 0.68333, 0, 0, 0.77778],
                    "76": [0, 0.68333, 0, 0, 0.625],
                    "77": [0, 0.68333, 0, 0, 0.91667],
                    "78": [0, 0.68333, 0, 0, 0.75],
                    "79": [0, 0.68333, 0, 0, 0.77778],
                    "80": [0, 0.68333, 0, 0, 0.68056],
                    "81": [0.19444, 0.68333, 0, 0, 0.77778],
                    "82": [0, 0.68333, 0, 0, 0.73611],
                    "83": [0, 0.68333, 0, 0, 0.55556],
                    "84": [0, 0.68333, 0, 0, 0.72222],
                    "85": [0, 0.68333, 0, 0, 0.75],
                    "86": [0, 0.68333, 0.01389, 0, 0.75],
                    "87": [0, 0.68333, 0.01389, 0, 1.02778],
                    "88": [0, 0.68333, 0, 0, 0.75],
                    "89": [0, 0.68333, 0.025, 0, 0.75],
                    "90": [0, 0.68333, 0, 0, 0.61111],
                    "91": [0.25, 0.75, 0, 0, 0.27778],
                    "92": [0.25, 0.75, 0, 0, 0.5],
                    "93": [0.25, 0.75, 0, 0, 0.27778],
                    "94": [0, 0.69444, 0, 0, 0.5],
                    "95": [0.31, 0.12056, 0.02778, 0, 0.5],
                    "97": [0, 0.43056, 0, 0, 0.5],
                    "98": [0, 0.69444, 0, 0, 0.55556],
                    "99": [0, 0.43056, 0, 0, 0.44445],
                    "100": [0, 0.69444, 0, 0, 0.55556],
                    "101": [0, 0.43056, 0, 0, 0.44445],
                    "102": [0, 0.69444, 0.07778, 0, 0.30556],
                    "103": [0.19444, 0.43056, 0.01389, 0, 0.5],
                    "104": [0, 0.69444, 0, 0, 0.55556],
                    "105": [0, 0.66786, 0, 0, 0.27778],
                    "106": [0.19444, 0.66786, 0, 0, 0.30556],
                    "107": [0, 0.69444, 0, 0, 0.52778],
                    "108": [0, 0.69444, 0, 0, 0.27778],
                    "109": [0, 0.43056, 0, 0, 0.83334],
                    "110": [0, 0.43056, 0, 0, 0.55556],
                    "111": [0, 0.43056, 0, 0, 0.5],
                    "112": [0.19444, 0.43056, 0, 0, 0.55556],
                    "113": [0.19444, 0.43056, 0, 0, 0.52778],
                    "114": [0, 0.43056, 0, 0, 0.39167],
                    "115": [0, 0.43056, 0, 0, 0.39445],
                    "116": [0, 0.61508, 0, 0, 0.38889],
                    "117": [0, 0.43056, 0, 0, 0.55556],
                    "118": [0, 0.43056, 0.01389, 0, 0.52778],
                    "119": [0, 0.43056, 0.01389, 0, 0.72222],
                    "120": [0, 0.43056, 0, 0, 0.52778],
                    "121": [0.19444, 0.43056, 0.01389, 0, 0.52778],
                    "122": [0, 0.43056, 0, 0, 0.44445],
                    "123": [0.25, 0.75, 0, 0, 0.5],
                    "124": [0.25, 0.75, 0, 0, 0.27778],
                    "125": [0.25, 0.75, 0, 0, 0.5],
                    "126": [0.35, 0.31786, 0, 0, 0.5],
                    "160": [0, 0, 0, 0, 0.25],
                    "167": [0.19444, 0.69444, 0, 0, 0.44445],
                    "168": [0, 0.66786, 0, 0, 0.5],
                    "172": [0, 0.43056, 0, 0, 0.66667],
                    "176": [0, 0.69444, 0, 0, 0.75],
                    "177": [0.08333, 0.58333, 0, 0, 0.77778],
                    "182": [0.19444, 0.69444, 0, 0, 0.61111],
                    "184": [0.17014, 0, 0, 0, 0.44445],
                    "198": [0, 0.68333, 0, 0, 0.90278],
                    "215": [0.08333, 0.58333, 0, 0, 0.77778],
                    "216": [0.04861, 0.73194, 0, 0, 0.77778],
                    "223": [0, 0.69444, 0, 0, 0.5],
                    "230": [0, 0.43056, 0, 0, 0.72222],
                    "247": [0.08333, 0.58333, 0, 0, 0.77778],
                    "248": [0.09722, 0.52778, 0, 0, 0.5],
                    "305": [0, 0.43056, 0, 0, 0.27778],
                    "338": [0, 0.68333, 0, 0, 1.01389],
                    "339": [0, 0.43056, 0, 0, 0.77778],
                    "567": [0.19444, 0.43056, 0, 0, 0.30556],
                    "710": [0, 0.69444, 0, 0, 0.5],
                    "711": [0, 0.62847, 0, 0, 0.5],
                    "713": [0, 0.56778, 0, 0, 0.5],
                    "714": [0, 0.69444, 0, 0, 0.5],
                    "715": [0, 0.69444, 0, 0, 0.5],
                    "728": [0, 0.69444, 0, 0, 0.5],
                    "729": [0, 0.66786, 0, 0, 0.27778],
                    "730": [0, 0.69444, 0, 0, 0.75],
                    "732": [0, 0.66786, 0, 0, 0.5],
                    "733": [0, 0.69444, 0, 0, 0.5],
                    "915": [0, 0.68333, 0, 0, 0.625],
                    "916": [0, 0.68333, 0, 0, 0.83334],
                    "920": [0, 0.68333, 0, 0, 0.77778],
                    "923": [0, 0.68333, 0, 0, 0.69445],
                    "926": [0, 0.68333, 0, 0, 0.66667],
                    "928": [0, 0.68333, 0, 0, 0.75],
                    "931": [0, 0.68333, 0, 0, 0.72222],
                    "933": [0, 0.68333, 0, 0, 0.77778],
                    "934": [0, 0.68333, 0, 0, 0.72222],
                    "936": [0, 0.68333, 0, 0, 0.77778],
                    "937": [0, 0.68333, 0, 0, 0.72222],
                    "8211": [0, 0.43056, 0.02778, 0, 0.5],
                    "8212": [0, 0.43056, 0.02778, 0, 1.0],
                    "8216": [0, 0.69444, 0, 0, 0.27778],
                    "8217": [0, 0.69444, 0, 0, 0.27778],
                    "8220": [0, 0.69444, 0, 0, 0.5],
                    "8221": [0, 0.69444, 0, 0, 0.5],
                    "8224": [0.19444, 0.69444, 0, 0, 0.44445],
                    "8225": [0.19444, 0.69444, 0, 0, 0.44445],
                    "8230": [0, 0.12, 0, 0, 1.172],
                    "8242": [0, 0.55556, 0, 0, 0.275],
                    "8407": [0, 0.71444, 0.15382, 0, 0.5],
                    "8463": [0, 0.68889, 0, 0, 0.54028],
                    "8465": [0, 0.69444, 0, 0, 0.72222],
                    "8467": [0, 0.69444, 0, 0.11111, 0.41667],
                    "8472": [0.19444, 0.43056, 0, 0.11111, 0.63646],
                    "8476": [0, 0.69444, 0, 0, 0.72222],
                    "8501": [0, 0.69444, 0, 0, 0.61111],
                    "8592": [-0.13313, 0.36687, 0, 0, 1.0],
                    "8593": [0.19444, 0.69444, 0, 0, 0.5],
                    "8594": [-0.13313, 0.36687, 0, 0, 1.0],
                    "8595": [0.19444, 0.69444, 0, 0, 0.5],
                    "8596": [-0.13313, 0.36687, 0, 0, 1.0],
                    "8597": [0.25, 0.75, 0, 0, 0.5],
                    "8598": [0.19444, 0.69444, 0, 0, 1.0],
                    "8599": [0.19444, 0.69444, 0, 0, 1.0],
                    "8600": [0.19444, 0.69444, 0, 0, 1.0],
                    "8601": [0.19444, 0.69444, 0, 0, 1.0],
                    "8614": [0.011, 0.511, 0, 0, 1.0],
                    "8617": [0.011, 0.511, 0, 0, 1.126],
                    "8618": [0.011, 0.511, 0, 0, 1.126],
                    "8636": [-0.13313, 0.36687, 0, 0, 1.0],
                    "8637": [-0.13313, 0.36687, 0, 0, 1.0],
                    "8640": [-0.13313, 0.36687, 0, 0, 1.0],
                    "8641": [-0.13313, 0.36687, 0, 0, 1.0],
                    "8652": [0.011, 0.671, 0, 0, 1.0],
                    "8656": [-0.13313, 0.36687, 0, 0, 1.0],
                    "8657": [0.19444, 0.69444, 0, 0, 0.61111],
                    "8658": [-0.13313, 0.36687, 0, 0, 1.0],
                    "8659": [0.19444, 0.69444, 0, 0, 0.61111],
                    "8660": [-0.13313, 0.36687, 0, 0, 1.0],
                    "8661": [0.25, 0.75, 0, 0, 0.61111],
                    "8704": [0, 0.69444, 0, 0, 0.55556],
                    "8706": [0, 0.69444, 0.05556, 0.08334, 0.5309],
                    "8707": [0, 0.69444, 0, 0, 0.55556],
                    "8709": [0.05556, 0.75, 0, 0, 0.5],
                    "8711": [0, 0.68333, 0, 0, 0.83334],
                    "8712": [0.0391, 0.5391, 0, 0, 0.66667],
                    "8715": [0.0391, 0.5391, 0, 0, 0.66667],
                    "8722": [0.08333, 0.58333, 0, 0, 0.77778],
                    "8723": [0.08333, 0.58333, 0, 0, 0.77778],
                    "8725": [0.25, 0.75, 0, 0, 0.5],
                    "8726": [0.25, 0.75, 0, 0, 0.5],
                    "8727": [-0.03472, 0.46528, 0, 0, 0.5],
                    "8728": [-0.05555, 0.44445, 0, 0, 0.5],
                    "8729": [-0.05555, 0.44445, 0, 0, 0.5],
                    "8730": [0.2, 0.8, 0, 0, 0.83334],
                    "8733": [0, 0.43056, 0, 0, 0.77778],
                    "8734": [0, 0.43056, 0, 0, 1.0],
                    "8736": [0, 0.69224, 0, 0, 0.72222],
                    "8739": [0.25, 0.75, 0, 0, 0.27778],
                    "8741": [0.25, 0.75, 0, 0, 0.5],
                    "8743": [0, 0.55556, 0, 0, 0.66667],
                    "8744": [0, 0.55556, 0, 0, 0.66667],
                    "8745": [0, 0.55556, 0, 0, 0.66667],
                    "8746": [0, 0.55556, 0, 0, 0.66667],
                    "8747": [0.19444, 0.69444, 0.11111, 0, 0.41667],
                    "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
                    "8768": [0.19444, 0.69444, 0, 0, 0.27778],
                    "8771": [-0.03625, 0.46375, 0, 0, 0.77778],
                    "8773": [-0.022, 0.589, 0, 0, 1.0],
                    "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
                    "8781": [-0.03625, 0.46375, 0, 0, 0.77778],
                    "8784": [-0.133, 0.67, 0, 0, 0.778],
                    "8801": [-0.03625, 0.46375, 0, 0, 0.77778],
                    "8804": [0.13597, 0.63597, 0, 0, 0.77778],
                    "8805": [0.13597, 0.63597, 0, 0, 0.77778],
                    "8810": [0.0391, 0.5391, 0, 0, 1.0],
                    "8811": [0.0391, 0.5391, 0, 0, 1.0],
                    "8826": [0.0391, 0.5391, 0, 0, 0.77778],
                    "8827": [0.0391, 0.5391, 0, 0, 0.77778],
                    "8834": [0.0391, 0.5391, 0, 0, 0.77778],
                    "8835": [0.0391, 0.5391, 0, 0, 0.77778],
                    "8838": [0.13597, 0.63597, 0, 0, 0.77778],
                    "8839": [0.13597, 0.63597, 0, 0, 0.77778],
                    "8846": [0, 0.55556, 0, 0, 0.66667],
                    "8849": [0.13597, 0.63597, 0, 0, 0.77778],
                    "8850": [0.13597, 0.63597, 0, 0, 0.77778],
                    "8851": [0, 0.55556, 0, 0, 0.66667],
                    "8852": [0, 0.55556, 0, 0, 0.66667],
                    "8853": [0.08333, 0.58333, 0, 0, 0.77778],
                    "8854": [0.08333, 0.58333, 0, 0, 0.77778],
                    "8855": [0.08333, 0.58333, 0, 0, 0.77778],
                    "8856": [0.08333, 0.58333, 0, 0, 0.77778],
                    "8857": [0.08333, 0.58333, 0, 0, 0.77778],
                    "8866": [0, 0.69444, 0, 0, 0.61111],
                    "8867": [0, 0.69444, 0, 0, 0.61111],
                    "8868": [0, 0.69444, 0, 0, 0.77778],
                    "8869": [0, 0.69444, 0, 0, 0.77778],
                    "8872": [0.249, 0.75, 0, 0, 0.867],
                    "8900": [-0.05555, 0.44445, 0, 0, 0.5],
                    "8901": [-0.05555, 0.44445, 0, 0, 0.27778],
                    "8902": [-0.03472, 0.46528, 0, 0, 0.5],
                    "8904": [0.005, 0.505, 0, 0, 0.9],
                    "8942": [0.03, 0.9, 0, 0, 0.278],
                    "8943": [-0.19, 0.31, 0, 0, 1.172],
                    "8945": [-0.1, 0.82, 0, 0, 1.282],
                    "8968": [0.25, 0.75, 0, 0, 0.44445],
                    "8969": [0.25, 0.75, 0, 0, 0.44445],
                    "8970": [0.25, 0.75, 0, 0, 0.44445],
                    "8971": [0.25, 0.75, 0, 0, 0.44445],
                    "8994": [-0.14236, 0.35764, 0, 0, 1.0],
                    "8995": [-0.14236, 0.35764, 0, 0, 1.0],
                    "9136": [0.244, 0.744, 0, 0, 0.412],
                    "9137": [0.244, 0.744, 0, 0, 0.412],
                    "9651": [0.19444, 0.69444, 0, 0, 0.88889],
                    "9657": [-0.03472, 0.46528, 0, 0, 0.5],
                    "9661": [0.19444, 0.69444, 0, 0, 0.88889],
                    "9667": [-0.03472, 0.46528, 0, 0, 0.5],
                    "9711": [0.19444, 0.69444, 0, 0, 1.0],
                    "9824": [0.12963, 0.69444, 0, 0, 0.77778],
                    "9825": [0.12963, 0.69444, 0, 0, 0.77778],
                    "9826": [0.12963, 0.69444, 0, 0, 0.77778],
                    "9827": [0.12963, 0.69444, 0, 0, 0.77778],
                    "9837": [0, 0.75, 0, 0, 0.38889],
                    "9838": [0.19444, 0.69444, 0, 0, 0.38889],
                    "9839": [0.19444, 0.69444, 0, 0, 0.38889],
                    "10216": [0.25, 0.75, 0, 0, 0.38889],
                    "10217": [0.25, 0.75, 0, 0, 0.38889],
                    "10222": [0.244, 0.744, 0, 0, 0.412],
                    "10223": [0.244, 0.744, 0, 0, 0.412],
                    "10229": [0.011, 0.511, 0, 0, 1.609],
                    "10230": [0.011, 0.511, 0, 0, 1.638],
                    "10231": [0.011, 0.511, 0, 0, 1.859],
                    "10232": [0.024, 0.525, 0, 0, 1.609],
                    "10233": [0.024, 0.525, 0, 0, 1.638],
                    "10234": [0.024, 0.525, 0, 0, 1.858],
                    "10236": [0.011, 0.511, 0, 0, 1.638],
                    "10815": [0, 0.68333, 0, 0, 0.75],
                    "10927": [0.13597, 0.63597, 0, 0, 0.77778],
                    "10928": [0.13597, 0.63597, 0, 0, 0.77778],
                    "57376": [0.19444, 0.69444, 0, 0, 0]
                },
                "Math-BoldItalic": {
                    "65": [0, 0.68611, 0, 0, 0.86944],
                    "66": [0, 0.68611, 0.04835, 0, 0.8664],
                    "67": [0, 0.68611, 0.06979, 0, 0.81694],
                    "68": [0, 0.68611, 0.03194, 0, 0.93812],
                    "69": [0, 0.68611, 0.05451, 0, 0.81007],
                    "70": [0, 0.68611, 0.15972, 0, 0.68889],
                    "71": [0, 0.68611, 0, 0, 0.88673],
                    "72": [0, 0.68611, 0.08229, 0, 0.98229],
                    "73": [0, 0.68611, 0.07778, 0, 0.51111],
                    "74": [0, 0.68611, 0.10069, 0, 0.63125],
                    "75": [0, 0.68611, 0.06979, 0, 0.97118],
                    "76": [0, 0.68611, 0, 0, 0.75555],
                    "77": [0, 0.68611, 0.11424, 0, 1.14201],
                    "78": [0, 0.68611, 0.11424, 0, 0.95034],
                    "79": [0, 0.68611, 0.03194, 0, 0.83666],
                    "80": [0, 0.68611, 0.15972, 0, 0.72309],
                    "81": [0.19444, 0.68611, 0, 0, 0.86861],
                    "82": [0, 0.68611, 0.00421, 0, 0.87235],
                    "83": [0, 0.68611, 0.05382, 0, 0.69271],
                    "84": [0, 0.68611, 0.15972, 0, 0.63663],
                    "85": [0, 0.68611, 0.11424, 0, 0.80027],
                    "86": [0, 0.68611, 0.25555, 0, 0.67778],
                    "87": [0, 0.68611, 0.15972, 0, 1.09305],
                    "88": [0, 0.68611, 0.07778, 0, 0.94722],
                    "89": [0, 0.68611, 0.25555, 0, 0.67458],
                    "90": [0, 0.68611, 0.06979, 0, 0.77257],
                    "97": [0, 0.44444, 0, 0, 0.63287],
                    "98": [0, 0.69444, 0, 0, 0.52083],
                    "99": [0, 0.44444, 0, 0, 0.51342],
                    "100": [0, 0.69444, 0, 0, 0.60972],
                    "101": [0, 0.44444, 0, 0, 0.55361],
                    "102": [0.19444, 0.69444, 0.11042, 0, 0.56806],
                    "103": [0.19444, 0.44444, 0.03704, 0, 0.5449],
                    "104": [0, 0.69444, 0, 0, 0.66759],
                    "105": [0, 0.69326, 0, 0, 0.4048],
                    "106": [0.19444, 0.69326, 0.0622, 0, 0.47083],
                    "107": [0, 0.69444, 0.01852, 0, 0.6037],
                    "108": [0, 0.69444, 0.0088, 0, 0.34815],
                    "109": [0, 0.44444, 0, 0, 1.0324],
                    "110": [0, 0.44444, 0, 0, 0.71296],
                    "111": [0, 0.44444, 0, 0, 0.58472],
                    "112": [0.19444, 0.44444, 0, 0, 0.60092],
                    "113": [0.19444, 0.44444, 0.03704, 0, 0.54213],
                    "114": [0, 0.44444, 0.03194, 0, 0.5287],
                    "115": [0, 0.44444, 0, 0, 0.53125],
                    "116": [0, 0.63492, 0, 0, 0.41528],
                    "117": [0, 0.44444, 0, 0, 0.68102],
                    "118": [0, 0.44444, 0.03704, 0, 0.56666],
                    "119": [0, 0.44444, 0.02778, 0, 0.83148],
                    "120": [0, 0.44444, 0, 0, 0.65903],
                    "121": [0.19444, 0.44444, 0.03704, 0, 0.59028],
                    "122": [0, 0.44444, 0.04213, 0, 0.55509],
                    "915": [0, 0.68611, 0.15972, 0, 0.65694],
                    "916": [0, 0.68611, 0, 0, 0.95833],
                    "920": [0, 0.68611, 0.03194, 0, 0.86722],
                    "923": [0, 0.68611, 0, 0, 0.80555],
                    "926": [0, 0.68611, 0.07458, 0, 0.84125],
                    "928": [0, 0.68611, 0.08229, 0, 0.98229],
                    "931": [0, 0.68611, 0.05451, 0, 0.88507],
                    "933": [0, 0.68611, 0.15972, 0, 0.67083],
                    "934": [0, 0.68611, 0, 0, 0.76666],
                    "936": [0, 0.68611, 0.11653, 0, 0.71402],
                    "937": [0, 0.68611, 0.04835, 0, 0.8789],
                    "945": [0, 0.44444, 0, 0, 0.76064],
                    "946": [0.19444, 0.69444, 0.03403, 0, 0.65972],
                    "947": [0.19444, 0.44444, 0.06389, 0, 0.59003],
                    "948": [0, 0.69444, 0.03819, 0, 0.52222],
                    "949": [0, 0.44444, 0, 0, 0.52882],
                    "950": [0.19444, 0.69444, 0.06215, 0, 0.50833],
                    "951": [0.19444, 0.44444, 0.03704, 0, 0.6],
                    "952": [0, 0.69444, 0.03194, 0, 0.5618],
                    "953": [0, 0.44444, 0, 0, 0.41204],
                    "954": [0, 0.44444, 0, 0, 0.66759],
                    "955": [0, 0.69444, 0, 0, 0.67083],
                    "956": [0.19444, 0.44444, 0, 0, 0.70787],
                    "957": [0, 0.44444, 0.06898, 0, 0.57685],
                    "958": [0.19444, 0.69444, 0.03021, 0, 0.50833],
                    "959": [0, 0.44444, 0, 0, 0.58472],
                    "960": [0, 0.44444, 0.03704, 0, 0.68241],
                    "961": [0.19444, 0.44444, 0, 0, 0.6118],
                    "962": [0.09722, 0.44444, 0.07917, 0, 0.42361],
                    "963": [0, 0.44444, 0.03704, 0, 0.68588],
                    "964": [0, 0.44444, 0.13472, 0, 0.52083],
                    "965": [0, 0.44444, 0.03704, 0, 0.63055],
                    "966": [0.19444, 0.44444, 0, 0, 0.74722],
                    "967": [0.19444, 0.44444, 0, 0, 0.71805],
                    "968": [0.19444, 0.69444, 0.03704, 0, 0.75833],
                    "969": [0, 0.44444, 0.03704, 0, 0.71782],
                    "977": [0, 0.69444, 0, 0, 0.69155],
                    "981": [0.19444, 0.69444, 0, 0, 0.7125],
                    "982": [0, 0.44444, 0.03194, 0, 0.975],
                    "1009": [0.19444, 0.44444, 0, 0, 0.6118],
                    "1013": [0, 0.44444, 0, 0, 0.48333]
                },
                "Math-Italic": {
                    "65": [0, 0.68333, 0, 0.13889, 0.75],
                    "66": [0, 0.68333, 0.05017, 0.08334, 0.75851],
                    "67": [0, 0.68333, 0.07153, 0.08334, 0.71472],
                    "68": [0, 0.68333, 0.02778, 0.05556, 0.82792],
                    "69": [0, 0.68333, 0.05764, 0.08334, 0.7382],
                    "70": [0, 0.68333, 0.13889, 0.08334, 0.64306],
                    "71": [0, 0.68333, 0, 0.08334, 0.78625],
                    "72": [0, 0.68333, 0.08125, 0.05556, 0.83125],
                    "73": [0, 0.68333, 0.07847, 0.11111, 0.43958],
                    "74": [0, 0.68333, 0.09618, 0.16667, 0.55451],
                    "75": [0, 0.68333, 0.07153, 0.05556, 0.84931],
                    "76": [0, 0.68333, 0, 0.02778, 0.68056],
                    "77": [0, 0.68333, 0.10903, 0.08334, 0.97014],
                    "78": [0, 0.68333, 0.10903, 0.08334, 0.80347],
                    "79": [0, 0.68333, 0.02778, 0.08334, 0.76278],
                    "80": [0, 0.68333, 0.13889, 0.08334, 0.64201],
                    "81": [0.19444, 0.68333, 0, 0.08334, 0.79056],
                    "82": [0, 0.68333, 0.00773, 0.08334, 0.75929],
                    "83": [0, 0.68333, 0.05764, 0.08334, 0.6132],
                    "84": [0, 0.68333, 0.13889, 0.08334, 0.58438],
                    "85": [0, 0.68333, 0.10903, 0.02778, 0.68278],
                    "86": [0, 0.68333, 0.22222, 0, 0.58333],
                    "87": [0, 0.68333, 0.13889, 0, 0.94445],
                    "88": [0, 0.68333, 0.07847, 0.08334, 0.82847],
                    "89": [0, 0.68333, 0.22222, 0, 0.58056],
                    "90": [0, 0.68333, 0.07153, 0.08334, 0.68264],
                    "97": [0, 0.43056, 0, 0, 0.52859],
                    "98": [0, 0.69444, 0, 0, 0.42917],
                    "99": [0, 0.43056, 0, 0.05556, 0.43276],
                    "100": [0, 0.69444, 0, 0.16667, 0.52049],
                    "101": [0, 0.43056, 0, 0.05556, 0.46563],
                    "102": [0.19444, 0.69444, 0.10764, 0.16667, 0.48959],
                    "103": [0.19444, 0.43056, 0.03588, 0.02778, 0.47697],
                    "104": [0, 0.69444, 0, 0, 0.57616],
                    "105": [0, 0.65952, 0, 0, 0.34451],
                    "106": [0.19444, 0.65952, 0.05724, 0, 0.41181],
                    "107": [0, 0.69444, 0.03148, 0, 0.5206],
                    "108": [0, 0.69444, 0.01968, 0.08334, 0.29838],
                    "109": [0, 0.43056, 0, 0, 0.87801],
                    "110": [0, 0.43056, 0, 0, 0.60023],
                    "111": [0, 0.43056, 0, 0.05556, 0.48472],
                    "112": [0.19444, 0.43056, 0, 0.08334, 0.50313],
                    "113": [0.19444, 0.43056, 0.03588, 0.08334, 0.44641],
                    "114": [0, 0.43056, 0.02778, 0.05556, 0.45116],
                    "115": [0, 0.43056, 0, 0.05556, 0.46875],
                    "116": [0, 0.61508, 0, 0.08334, 0.36111],
                    "117": [0, 0.43056, 0, 0.02778, 0.57246],
                    "118": [0, 0.43056, 0.03588, 0.02778, 0.48472],
                    "119": [0, 0.43056, 0.02691, 0.08334, 0.71592],
                    "120": [0, 0.43056, 0, 0.02778, 0.57153],
                    "121": [0.19444, 0.43056, 0.03588, 0.05556, 0.49028],
                    "122": [0, 0.43056, 0.04398, 0.05556, 0.46505],
                    "915": [0, 0.68333, 0.13889, 0.08334, 0.61528],
                    "916": [0, 0.68333, 0, 0.16667, 0.83334],
                    "920": [0, 0.68333, 0.02778, 0.08334, 0.76278],
                    "923": [0, 0.68333, 0, 0.16667, 0.69445],
                    "926": [0, 0.68333, 0.07569, 0.08334, 0.74236],
                    "928": [0, 0.68333, 0.08125, 0.05556, 0.83125],
                    "931": [0, 0.68333, 0.05764, 0.08334, 0.77986],
                    "933": [0, 0.68333, 0.13889, 0.05556, 0.58333],
                    "934": [0, 0.68333, 0, 0.08334, 0.66667],
                    "936": [0, 0.68333, 0.11, 0.05556, 0.61222],
                    "937": [0, 0.68333, 0.05017, 0.08334, 0.7724],
                    "945": [0, 0.43056, 0.0037, 0.02778, 0.6397],
                    "946": [0.19444, 0.69444, 0.05278, 0.08334, 0.56563],
                    "947": [0.19444, 0.43056, 0.05556, 0, 0.51773],
                    "948": [0, 0.69444, 0.03785, 0.05556, 0.44444],
                    "949": [0, 0.43056, 0, 0.08334, 0.46632],
                    "950": [0.19444, 0.69444, 0.07378, 0.08334, 0.4375],
                    "951": [0.19444, 0.43056, 0.03588, 0.05556, 0.49653],
                    "952": [0, 0.69444, 0.02778, 0.08334, 0.46944],
                    "953": [0, 0.43056, 0, 0.05556, 0.35394],
                    "954": [0, 0.43056, 0, 0, 0.57616],
                    "955": [0, 0.69444, 0, 0, 0.58334],
                    "956": [0.19444, 0.43056, 0, 0.02778, 0.60255],
                    "957": [0, 0.43056, 0.06366, 0.02778, 0.49398],
                    "958": [0.19444, 0.69444, 0.04601, 0.11111, 0.4375],
                    "959": [0, 0.43056, 0, 0.05556, 0.48472],
                    "960": [0, 0.43056, 0.03588, 0, 0.57003],
                    "961": [0.19444, 0.43056, 0, 0.08334, 0.51702],
                    "962": [0.09722, 0.43056, 0.07986, 0.08334, 0.36285],
                    "963": [0, 0.43056, 0.03588, 0, 0.57141],
                    "964": [0, 0.43056, 0.1132, 0.02778, 0.43715],
                    "965": [0, 0.43056, 0.03588, 0.02778, 0.54028],
                    "966": [0.19444, 0.43056, 0, 0.08334, 0.65417],
                    "967": [0.19444, 0.43056, 0, 0.05556, 0.62569],
                    "968": [0.19444, 0.69444, 0.03588, 0.11111, 0.65139],
                    "969": [0, 0.43056, 0.03588, 0, 0.62245],
                    "977": [0, 0.69444, 0, 0.08334, 0.59144],
                    "981": [0.19444, 0.69444, 0, 0.08334, 0.59583],
                    "982": [0, 0.43056, 0.02778, 0, 0.82813],
                    "1009": [0.19444, 0.43056, 0, 0.08334, 0.51702],
                    "1013": [0, 0.43056, 0, 0.05556, 0.4059]
                },
                "Math-Regular": {
                    "65": [0, 0.68333, 0, 0.13889, 0.75],
                    "66": [0, 0.68333, 0.05017, 0.08334, 0.75851],
                    "67": [0, 0.68333, 0.07153, 0.08334, 0.71472],
                    "68": [0, 0.68333, 0.02778, 0.05556, 0.82792],
                    "69": [0, 0.68333, 0.05764, 0.08334, 0.7382],
                    "70": [0, 0.68333, 0.13889, 0.08334, 0.64306],
                    "71": [0, 0.68333, 0, 0.08334, 0.78625],
                    "72": [0, 0.68333, 0.08125, 0.05556, 0.83125],
                    "73": [0, 0.68333, 0.07847, 0.11111, 0.43958],
                    "74": [0, 0.68333, 0.09618, 0.16667, 0.55451],
                    "75": [0, 0.68333, 0.07153, 0.05556, 0.84931],
                    "76": [0, 0.68333, 0, 0.02778, 0.68056],
                    "77": [0, 0.68333, 0.10903, 0.08334, 0.97014],
                    "78": [0, 0.68333, 0.10903, 0.08334, 0.80347],
                    "79": [0, 0.68333, 0.02778, 0.08334, 0.76278],
                    "80": [0, 0.68333, 0.13889, 0.08334, 0.64201],
                    "81": [0.19444, 0.68333, 0, 0.08334, 0.79056],
                    "82": [0, 0.68333, 0.00773, 0.08334, 0.75929],
                    "83": [0, 0.68333, 0.05764, 0.08334, 0.6132],
                    "84": [0, 0.68333, 0.13889, 0.08334, 0.58438],
                    "85": [0, 0.68333, 0.10903, 0.02778, 0.68278],
                    "86": [0, 0.68333, 0.22222, 0, 0.58333],
                    "87": [0, 0.68333, 0.13889, 0, 0.94445],
                    "88": [0, 0.68333, 0.07847, 0.08334, 0.82847],
                    "89": [0, 0.68333, 0.22222, 0, 0.58056],
                    "90": [0, 0.68333, 0.07153, 0.08334, 0.68264],
                    "97": [0, 0.43056, 0, 0, 0.52859],
                    "98": [0, 0.69444, 0, 0, 0.42917],
                    "99": [0, 0.43056, 0, 0.05556, 0.43276],
                    "100": [0, 0.69444, 0, 0.16667, 0.52049],
                    "101": [0, 0.43056, 0, 0.05556, 0.46563],
                    "102": [0.19444, 0.69444, 0.10764, 0.16667, 0.48959],
                    "103": [0.19444, 0.43056, 0.03588, 0.02778, 0.47697],
                    "104": [0, 0.69444, 0, 0, 0.57616],
                    "105": [0, 0.65952, 0, 0, 0.34451],
                    "106": [0.19444, 0.65952, 0.05724, 0, 0.41181],
                    "107": [0, 0.69444, 0.03148, 0, 0.5206],
                    "108": [0, 0.69444, 0.01968, 0.08334, 0.29838],
                    "109": [0, 0.43056, 0, 0, 0.87801],
                    "110": [0, 0.43056, 0, 0, 0.60023],
                    "111": [0, 0.43056, 0, 0.05556, 0.48472],
                    "112": [0.19444, 0.43056, 0, 0.08334, 0.50313],
                    "113": [0.19444, 0.43056, 0.03588, 0.08334, 0.44641],
                    "114": [0, 0.43056, 0.02778, 0.05556, 0.45116],
                    "115": [0, 0.43056, 0, 0.05556, 0.46875],
                    "116": [0, 0.61508, 0, 0.08334, 0.36111],
                    "117": [0, 0.43056, 0, 0.02778, 0.57246],
                    "118": [0, 0.43056, 0.03588, 0.02778, 0.48472],
                    "119": [0, 0.43056, 0.02691, 0.08334, 0.71592],
                    "120": [0, 0.43056, 0, 0.02778, 0.57153],
                    "121": [0.19444, 0.43056, 0.03588, 0.05556, 0.49028],
                    "122": [0, 0.43056, 0.04398, 0.05556, 0.46505],
                    "915": [0, 0.68333, 0.13889, 0.08334, 0.61528],
                    "916": [0, 0.68333, 0, 0.16667, 0.83334],
                    "920": [0, 0.68333, 0.02778, 0.08334, 0.76278],
                    "923": [0, 0.68333, 0, 0.16667, 0.69445],
                    "926": [0, 0.68333, 0.07569, 0.08334, 0.74236],
                    "928": [0, 0.68333, 0.08125, 0.05556, 0.83125],
                    "931": [0, 0.68333, 0.05764, 0.08334, 0.77986],
                    "933": [0, 0.68333, 0.13889, 0.05556, 0.58333],
                    "934": [0, 0.68333, 0, 0.08334, 0.66667],
                    "936": [0, 0.68333, 0.11, 0.05556, 0.61222],
                    "937": [0, 0.68333, 0.05017, 0.08334, 0.7724],
                    "945": [0, 0.43056, 0.0037, 0.02778, 0.6397],
                    "946": [0.19444, 0.69444, 0.05278, 0.08334, 0.56563],
                    "947": [0.19444, 0.43056, 0.05556, 0, 0.51773],
                    "948": [0, 0.69444, 0.03785, 0.05556, 0.44444],
                    "949": [0, 0.43056, 0, 0.08334, 0.46632],
                    "950": [0.19444, 0.69444, 0.07378, 0.08334, 0.4375],
                    "951": [0.19444, 0.43056, 0.03588, 0.05556, 0.49653],
                    "952": [0, 0.69444, 0.02778, 0.08334, 0.46944],
                    "953": [0, 0.43056, 0, 0.05556, 0.35394],
                    "954": [0, 0.43056, 0, 0, 0.57616],
                    "955": [0, 0.69444, 0, 0, 0.58334],
                    "956": [0.19444, 0.43056, 0, 0.02778, 0.60255],
                    "957": [0, 0.43056, 0.06366, 0.02778, 0.49398],
                    "958": [0.19444, 0.69444, 0.04601, 0.11111, 0.4375],
                    "959": [0, 0.43056, 0, 0.05556, 0.48472],
                    "960": [0, 0.43056, 0.03588, 0, 0.57003],
                    "961": [0.19444, 0.43056, 0, 0.08334, 0.51702],
                    "962": [0.09722, 0.43056, 0.07986, 0.08334, 0.36285],
                    "963": [0, 0.43056, 0.03588, 0, 0.57141],
                    "964": [0, 0.43056, 0.1132, 0.02778, 0.43715],
                    "965": [0, 0.43056, 0.03588, 0.02778, 0.54028],
                    "966": [0.19444, 0.43056, 0, 0.08334, 0.65417],
                    "967": [0.19444, 0.43056, 0, 0.05556, 0.62569],
                    "968": [0.19444, 0.69444, 0.03588, 0.11111, 0.65139],
                    "969": [0, 0.43056, 0.03588, 0, 0.62245],
                    "977": [0, 0.69444, 0, 0.08334, 0.59144],
                    "981": [0.19444, 0.69444, 0, 0.08334, 0.59583],
                    "982": [0, 0.43056, 0.02778, 0, 0.82813],
                    "1009": [0.19444, 0.43056, 0, 0.08334, 0.51702],
                    "1013": [0, 0.43056, 0, 0.05556, 0.4059]
                },
                "SansSerif-Bold": {
                    "33": [0, 0.69444, 0, 0, 0.36667],
                    "34": [0, 0.69444, 0, 0, 0.55834],
                    "35": [0.19444, 0.69444, 0, 0, 0.91667],
                    "36": [0.05556, 0.75, 0, 0, 0.55],
                    "37": [0.05556, 0.75, 0, 0, 1.02912],
                    "38": [0, 0.69444, 0, 0, 0.83056],
                    "39": [0, 0.69444, 0, 0, 0.30556],
                    "40": [0.25, 0.75, 0, 0, 0.42778],
                    "41": [0.25, 0.75, 0, 0, 0.42778],
                    "42": [0, 0.75, 0, 0, 0.55],
                    "43": [0.11667, 0.61667, 0, 0, 0.85556],
                    "44": [0.10556, 0.13056, 0, 0, 0.30556],
                    "45": [0, 0.45833, 0, 0, 0.36667],
                    "46": [0, 0.13056, 0, 0, 0.30556],
                    "47": [0.25, 0.75, 0, 0, 0.55],
                    "48": [0, 0.69444, 0, 0, 0.55],
                    "49": [0, 0.69444, 0, 0, 0.55],
                    "50": [0, 0.69444, 0, 0, 0.55],
                    "51": [0, 0.69444, 0, 0, 0.55],
                    "52": [0, 0.69444, 0, 0, 0.55],
                    "53": [0, 0.69444, 0, 0, 0.55],
                    "54": [0, 0.69444, 0, 0, 0.55],
                    "55": [0, 0.69444, 0, 0, 0.55],
                    "56": [0, 0.69444, 0, 0, 0.55],
                    "57": [0, 0.69444, 0, 0, 0.55],
                    "58": [0, 0.45833, 0, 0, 0.30556],
                    "59": [0.10556, 0.45833, 0, 0, 0.30556],
                    "61": [-0.09375, 0.40625, 0, 0, 0.85556],
                    "63": [0, 0.69444, 0, 0, 0.51945],
                    "64": [0, 0.69444, 0, 0, 0.73334],
                    "65": [0, 0.69444, 0, 0, 0.73334],
                    "66": [0, 0.69444, 0, 0, 0.73334],
                    "67": [0, 0.69444, 0, 0, 0.70278],
                    "68": [0, 0.69444, 0, 0, 0.79445],
                    "69": [0, 0.69444, 0, 0, 0.64167],
                    "70": [0, 0.69444, 0, 0, 0.61111],
                    "71": [0, 0.69444, 0, 0, 0.73334],
                    "72": [0, 0.69444, 0, 0, 0.79445],
                    "73": [0, 0.69444, 0, 0, 0.33056],
                    "74": [0, 0.69444, 0, 0, 0.51945],
                    "75": [0, 0.69444, 0, 0, 0.76389],
                    "76": [0, 0.69444, 0, 0, 0.58056],
                    "77": [0, 0.69444, 0, 0, 0.97778],
                    "78": [0, 0.69444, 0, 0, 0.79445],
                    "79": [0, 0.69444, 0, 0, 0.79445],
                    "80": [0, 0.69444, 0, 0, 0.70278],
                    "81": [0.10556, 0.69444, 0, 0, 0.79445],
                    "82": [0, 0.69444, 0, 0, 0.70278],
                    "83": [0, 0.69444, 0, 0, 0.61111],
                    "84": [0, 0.69444, 0, 0, 0.73334],
                    "85": [0, 0.69444, 0, 0, 0.76389],
                    "86": [0, 0.69444, 0.01528, 0, 0.73334],
                    "87": [0, 0.69444, 0.01528, 0, 1.03889],
                    "88": [0, 0.69444, 0, 0, 0.73334],
                    "89": [0, 0.69444, 0.0275, 0, 0.73334],
                    "90": [0, 0.69444, 0, 0, 0.67223],
                    "91": [0.25, 0.75, 0, 0, 0.34306],
                    "93": [0.25, 0.75, 0, 0, 0.34306],
                    "94": [0, 0.69444, 0, 0, 0.55],
                    "95": [0.35, 0.10833, 0.03056, 0, 0.55],
                    "97": [0, 0.45833, 0, 0, 0.525],
                    "98": [0, 0.69444, 0, 0, 0.56111],
                    "99": [0, 0.45833, 0, 0, 0.48889],
                    "100": [0, 0.69444, 0, 0, 0.56111],
                    "101": [0, 0.45833, 0, 0, 0.51111],
                    "102": [0, 0.69444, 0.07639, 0, 0.33611],
                    "103": [0.19444, 0.45833, 0.01528, 0, 0.55],
                    "104": [0, 0.69444, 0, 0, 0.56111],
                    "105": [0, 0.69444, 0, 0, 0.25556],
                    "106": [0.19444, 0.69444, 0, 0, 0.28611],
                    "107": [0, 0.69444, 0, 0, 0.53056],
                    "108": [0, 0.69444, 0, 0, 0.25556],
                    "109": [0, 0.45833, 0, 0, 0.86667],
                    "110": [0, 0.45833, 0, 0, 0.56111],
                    "111": [0, 0.45833, 0, 0, 0.55],
                    "112": [0.19444, 0.45833, 0, 0, 0.56111],
                    "113": [0.19444, 0.45833, 0, 0, 0.56111],
                    "114": [0, 0.45833, 0.01528, 0, 0.37222],
                    "115": [0, 0.45833, 0, 0, 0.42167],
                    "116": [0, 0.58929, 0, 0, 0.40417],
                    "117": [0, 0.45833, 0, 0, 0.56111],
                    "118": [0, 0.45833, 0.01528, 0, 0.5],
                    "119": [0, 0.45833, 0.01528, 0, 0.74445],
                    "120": [0, 0.45833, 0, 0, 0.5],
                    "121": [0.19444, 0.45833, 0.01528, 0, 0.5],
                    "122": [0, 0.45833, 0, 0, 0.47639],
                    "126": [0.35, 0.34444, 0, 0, 0.55],
                    "168": [0, 0.69444, 0, 0, 0.55],
                    "176": [0, 0.69444, 0, 0, 0.73334],
                    "180": [0, 0.69444, 0, 0, 0.55],
                    "184": [0.17014, 0, 0, 0, 0.48889],
                    "305": [0, 0.45833, 0, 0, 0.25556],
                    "567": [0.19444, 0.45833, 0, 0, 0.28611],
                    "710": [0, 0.69444, 0, 0, 0.55],
                    "711": [0, 0.63542, 0, 0, 0.55],
                    "713": [0, 0.63778, 0, 0, 0.55],
                    "728": [0, 0.69444, 0, 0, 0.55],
                    "729": [0, 0.69444, 0, 0, 0.30556],
                    "730": [0, 0.69444, 0, 0, 0.73334],
                    "732": [0, 0.69444, 0, 0, 0.55],
                    "733": [0, 0.69444, 0, 0, 0.55],
                    "915": [0, 0.69444, 0, 0, 0.58056],
                    "916": [0, 0.69444, 0, 0, 0.91667],
                    "920": [0, 0.69444, 0, 0, 0.85556],
                    "923": [0, 0.69444, 0, 0, 0.67223],
                    "926": [0, 0.69444, 0, 0, 0.73334],
                    "928": [0, 0.69444, 0, 0, 0.79445],
                    "931": [0, 0.69444, 0, 0, 0.79445],
                    "933": [0, 0.69444, 0, 0, 0.85556],
                    "934": [0, 0.69444, 0, 0, 0.79445],
                    "936": [0, 0.69444, 0, 0, 0.85556],
                    "937": [0, 0.69444, 0, 0, 0.79445],
                    "8211": [0, 0.45833, 0.03056, 0, 0.55],
                    "8212": [0, 0.45833, 0.03056, 0, 1.10001],
                    "8216": [0, 0.69444, 0, 0, 0.30556],
                    "8217": [0, 0.69444, 0, 0, 0.30556],
                    "8220": [0, 0.69444, 0, 0, 0.55834],
                    "8221": [0, 0.69444, 0, 0, 0.55834]
                },
                "SansSerif-Italic": {
                    "33": [0, 0.69444, 0.05733, 0, 0.31945],
                    "34": [0, 0.69444, 0.00316, 0, 0.5],
                    "35": [0.19444, 0.69444, 0.05087, 0, 0.83334],
                    "36": [0.05556, 0.75, 0.11156, 0, 0.5],
                    "37": [0.05556, 0.75, 0.03126, 0, 0.83334],
                    "38": [0, 0.69444, 0.03058, 0, 0.75834],
                    "39": [0, 0.69444, 0.07816, 0, 0.27778],
                    "40": [0.25, 0.75, 0.13164, 0, 0.38889],
                    "41": [0.25, 0.75, 0.02536, 0, 0.38889],
                    "42": [0, 0.75, 0.11775, 0, 0.5],
                    "43": [0.08333, 0.58333, 0.02536, 0, 0.77778],
                    "44": [0.125, 0.08333, 0, 0, 0.27778],
                    "45": [0, 0.44444, 0.01946, 0, 0.33333],
                    "46": [0, 0.08333, 0, 0, 0.27778],
                    "47": [0.25, 0.75, 0.13164, 0, 0.5],
                    "48": [0, 0.65556, 0.11156, 0, 0.5],
                    "49": [0, 0.65556, 0.11156, 0, 0.5],
                    "50": [0, 0.65556, 0.11156, 0, 0.5],
                    "51": [0, 0.65556, 0.11156, 0, 0.5],
                    "52": [0, 0.65556, 0.11156, 0, 0.5],
                    "53": [0, 0.65556, 0.11156, 0, 0.5],
                    "54": [0, 0.65556, 0.11156, 0, 0.5],
                    "55": [0, 0.65556, 0.11156, 0, 0.5],
                    "56": [0, 0.65556, 0.11156, 0, 0.5],
                    "57": [0, 0.65556, 0.11156, 0, 0.5],
                    "58": [0, 0.44444, 0.02502, 0, 0.27778],
                    "59": [0.125, 0.44444, 0.02502, 0, 0.27778],
                    "61": [-0.13, 0.37, 0.05087, 0, 0.77778],
                    "63": [0, 0.69444, 0.11809, 0, 0.47222],
                    "64": [0, 0.69444, 0.07555, 0, 0.66667],
                    "65": [0, 0.69444, 0, 0, 0.66667],
                    "66": [0, 0.69444, 0.08293, 0, 0.66667],
                    "67": [0, 0.69444, 0.11983, 0, 0.63889],
                    "68": [0, 0.69444, 0.07555, 0, 0.72223],
                    "69": [0, 0.69444, 0.11983, 0, 0.59722],
                    "70": [0, 0.69444, 0.13372, 0, 0.56945],
                    "71": [0, 0.69444, 0.11983, 0, 0.66667],
                    "72": [0, 0.69444, 0.08094, 0, 0.70834],
                    "73": [0, 0.69444, 0.13372, 0, 0.27778],
                    "74": [0, 0.69444, 0.08094, 0, 0.47222],
                    "75": [0, 0.69444, 0.11983, 0, 0.69445],
                    "76": [0, 0.69444, 0, 0, 0.54167],
                    "77": [0, 0.69444, 0.08094, 0, 0.875],
                    "78": [0, 0.69444, 0.08094, 0, 0.70834],
                    "79": [0, 0.69444, 0.07555, 0, 0.73611],
                    "80": [0, 0.69444, 0.08293, 0, 0.63889],
                    "81": [0.125, 0.69444, 0.07555, 0, 0.73611],
                    "82": [0, 0.69444, 0.08293, 0, 0.64584],
                    "83": [0, 0.69444, 0.09205, 0, 0.55556],
                    "84": [0, 0.69444, 0.13372, 0, 0.68056],
                    "85": [0, 0.69444, 0.08094, 0, 0.6875],
                    "86": [0, 0.69444, 0.1615, 0, 0.66667],
                    "87": [0, 0.69444, 0.1615, 0, 0.94445],
                    "88": [0, 0.69444, 0.13372, 0, 0.66667],
                    "89": [0, 0.69444, 0.17261, 0, 0.66667],
                    "90": [0, 0.69444, 0.11983, 0, 0.61111],
                    "91": [0.25, 0.75, 0.15942, 0, 0.28889],
                    "93": [0.25, 0.75, 0.08719, 0, 0.28889],
                    "94": [0, 0.69444, 0.0799, 0, 0.5],
                    "95": [0.35, 0.09444, 0.08616, 0, 0.5],
                    "97": [0, 0.44444, 0.00981, 0, 0.48056],
                    "98": [0, 0.69444, 0.03057, 0, 0.51667],
                    "99": [0, 0.44444, 0.08336, 0, 0.44445],
                    "100": [0, 0.69444, 0.09483, 0, 0.51667],
                    "101": [0, 0.44444, 0.06778, 0, 0.44445],
                    "102": [0, 0.69444, 0.21705, 0, 0.30556],
                    "103": [0.19444, 0.44444, 0.10836, 0, 0.5],
                    "104": [0, 0.69444, 0.01778, 0, 0.51667],
                    "105": [0, 0.67937, 0.09718, 0, 0.23889],
                    "106": [0.19444, 0.67937, 0.09162, 0, 0.26667],
                    "107": [0, 0.69444, 0.08336, 0, 0.48889],
                    "108": [0, 0.69444, 0.09483, 0, 0.23889],
                    "109": [0, 0.44444, 0.01778, 0, 0.79445],
                    "110": [0, 0.44444, 0.01778, 0, 0.51667],
                    "111": [0, 0.44444, 0.06613, 0, 0.5],
                    "112": [0.19444, 0.44444, 0.0389, 0, 0.51667],
                    "113": [0.19444, 0.44444, 0.04169, 0, 0.51667],
                    "114": [0, 0.44444, 0.10836, 0, 0.34167],
                    "115": [0, 0.44444, 0.0778, 0, 0.38333],
                    "116": [0, 0.57143, 0.07225, 0, 0.36111],
                    "117": [0, 0.44444, 0.04169, 0, 0.51667],
                    "118": [0, 0.44444, 0.10836, 0, 0.46111],
                    "119": [0, 0.44444, 0.10836, 0, 0.68334],
                    "120": [0, 0.44444, 0.09169, 0, 0.46111],
                    "121": [0.19444, 0.44444, 0.10836, 0, 0.46111],
                    "122": [0, 0.44444, 0.08752, 0, 0.43472],
                    "126": [0.35, 0.32659, 0.08826, 0, 0.5],
                    "168": [0, 0.67937, 0.06385, 0, 0.5],
                    "176": [0, 0.69444, 0, 0, 0.73752],
                    "184": [0.17014, 0, 0, 0, 0.44445],
                    "305": [0, 0.44444, 0.04169, 0, 0.23889],
                    "567": [0.19444, 0.44444, 0.04169, 0, 0.26667],
                    "710": [0, 0.69444, 0.0799, 0, 0.5],
                    "711": [0, 0.63194, 0.08432, 0, 0.5],
                    "713": [0, 0.60889, 0.08776, 0, 0.5],
                    "714": [0, 0.69444, 0.09205, 0, 0.5],
                    "715": [0, 0.69444, 0, 0, 0.5],
                    "728": [0, 0.69444, 0.09483, 0, 0.5],
                    "729": [0, 0.67937, 0.07774, 0, 0.27778],
                    "730": [0, 0.69444, 0, 0, 0.73752],
                    "732": [0, 0.67659, 0.08826, 0, 0.5],
                    "733": [0, 0.69444, 0.09205, 0, 0.5],
                    "915": [0, 0.69444, 0.13372, 0, 0.54167],
                    "916": [0, 0.69444, 0, 0, 0.83334],
                    "920": [0, 0.69444, 0.07555, 0, 0.77778],
                    "923": [0, 0.69444, 0, 0, 0.61111],
                    "926": [0, 0.69444, 0.12816, 0, 0.66667],
                    "928": [0, 0.69444, 0.08094, 0, 0.70834],
                    "931": [0, 0.69444, 0.11983, 0, 0.72222],
                    "933": [0, 0.69444, 0.09031, 0, 0.77778],
                    "934": [0, 0.69444, 0.04603, 0, 0.72222],
                    "936": [0, 0.69444, 0.09031, 0, 0.77778],
                    "937": [0, 0.69444, 0.08293, 0, 0.72222],
                    "8211": [0, 0.44444, 0.08616, 0, 0.5],
                    "8212": [0, 0.44444, 0.08616, 0, 1.0],
                    "8216": [0, 0.69444, 0.07816, 0, 0.27778],
                    "8217": [0, 0.69444, 0.07816, 0, 0.27778],
                    "8220": [0, 0.69444, 0.14205, 0, 0.5],
                    "8221": [0, 0.69444, 0.00316, 0, 0.5]
                },
                "SansSerif-Regular": {
                    "33": [0, 0.69444, 0, 0, 0.31945],
                    "34": [0, 0.69444, 0, 0, 0.5],
                    "35": [0.19444, 0.69444, 0, 0, 0.83334],
                    "36": [0.05556, 0.75, 0, 0, 0.5],
                    "37": [0.05556, 0.75, 0, 0, 0.83334],
                    "38": [0, 0.69444, 0, 0, 0.75834],
                    "39": [0, 0.69444, 0, 0, 0.27778],
                    "40": [0.25, 0.75, 0, 0, 0.38889],
                    "41": [0.25, 0.75, 0, 0, 0.38889],
                    "42": [0, 0.75, 0, 0, 0.5],
                    "43": [0.08333, 0.58333, 0, 0, 0.77778],
                    "44": [0.125, 0.08333, 0, 0, 0.27778],
                    "45": [0, 0.44444, 0, 0, 0.33333],
                    "46": [0, 0.08333, 0, 0, 0.27778],
                    "47": [0.25, 0.75, 0, 0, 0.5],
                    "48": [0, 0.65556, 0, 0, 0.5],
                    "49": [0, 0.65556, 0, 0, 0.5],
                    "50": [0, 0.65556, 0, 0, 0.5],
                    "51": [0, 0.65556, 0, 0, 0.5],
                    "52": [0, 0.65556, 0, 0, 0.5],
                    "53": [0, 0.65556, 0, 0, 0.5],
                    "54": [0, 0.65556, 0, 0, 0.5],
                    "55": [0, 0.65556, 0, 0, 0.5],
                    "56": [0, 0.65556, 0, 0, 0.5],
                    "57": [0, 0.65556, 0, 0, 0.5],
                    "58": [0, 0.44444, 0, 0, 0.27778],
                    "59": [0.125, 0.44444, 0, 0, 0.27778],
                    "61": [-0.13, 0.37, 0, 0, 0.77778],
                    "63": [0, 0.69444, 0, 0, 0.47222],
                    "64": [0, 0.69444, 0, 0, 0.66667],
                    "65": [0, 0.69444, 0, 0, 0.66667],
                    "66": [0, 0.69444, 0, 0, 0.66667],
                    "67": [0, 0.69444, 0, 0, 0.63889],
                    "68": [0, 0.69444, 0, 0, 0.72223],
                    "69": [0, 0.69444, 0, 0, 0.59722],
                    "70": [0, 0.69444, 0, 0, 0.56945],
                    "71": [0, 0.69444, 0, 0, 0.66667],
                    "72": [0, 0.69444, 0, 0, 0.70834],
                    "73": [0, 0.69444, 0, 0, 0.27778],
                    "74": [0, 0.69444, 0, 0, 0.47222],
                    "75": [0, 0.69444, 0, 0, 0.69445],
                    "76": [0, 0.69444, 0, 0, 0.54167],
                    "77": [0, 0.69444, 0, 0, 0.875],
                    "78": [0, 0.69444, 0, 0, 0.70834],
                    "79": [0, 0.69444, 0, 0, 0.73611],
                    "80": [0, 0.69444, 0, 0, 0.63889],
                    "81": [0.125, 0.69444, 0, 0, 0.73611],
                    "82": [0, 0.69444, 0, 0, 0.64584],
                    "83": [0, 0.69444, 0, 0, 0.55556],
                    "84": [0, 0.69444, 0, 0, 0.68056],
                    "85": [0, 0.69444, 0, 0, 0.6875],
                    "86": [0, 0.69444, 0.01389, 0, 0.66667],
                    "87": [0, 0.69444, 0.01389, 0, 0.94445],
                    "88": [0, 0.69444, 0, 0, 0.66667],
                    "89": [0, 0.69444, 0.025, 0, 0.66667],
                    "90": [0, 0.69444, 0, 0, 0.61111],
                    "91": [0.25, 0.75, 0, 0, 0.28889],
                    "93": [0.25, 0.75, 0, 0, 0.28889],
                    "94": [0, 0.69444, 0, 0, 0.5],
                    "95": [0.35, 0.09444, 0.02778, 0, 0.5],
                    "97": [0, 0.44444, 0, 0, 0.48056],
                    "98": [0, 0.69444, 0, 0, 0.51667],
                    "99": [0, 0.44444, 0, 0, 0.44445],
                    "100": [0, 0.69444, 0, 0, 0.51667],
                    "101": [0, 0.44444, 0, 0, 0.44445],
                    "102": [0, 0.69444, 0.06944, 0, 0.30556],
                    "103": [0.19444, 0.44444, 0.01389, 0, 0.5],
                    "104": [0, 0.69444, 0, 0, 0.51667],
                    "105": [0, 0.67937, 0, 0, 0.23889],
                    "106": [0.19444, 0.67937, 0, 0, 0.26667],
                    "107": [0, 0.69444, 0, 0, 0.48889],
                    "108": [0, 0.69444, 0, 0, 0.23889],
                    "109": [0, 0.44444, 0, 0, 0.79445],
                    "110": [0, 0.44444, 0, 0, 0.51667],
                    "111": [0, 0.44444, 0, 0, 0.5],
                    "112": [0.19444, 0.44444, 0, 0, 0.51667],
                    "113": [0.19444, 0.44444, 0, 0, 0.51667],
                    "114": [0, 0.44444, 0.01389, 0, 0.34167],
                    "115": [0, 0.44444, 0, 0, 0.38333],
                    "116": [0, 0.57143, 0, 0, 0.36111],
                    "117": [0, 0.44444, 0, 0, 0.51667],
                    "118": [0, 0.44444, 0.01389, 0, 0.46111],
                    "119": [0, 0.44444, 0.01389, 0, 0.68334],
                    "120": [0, 0.44444, 0, 0, 0.46111],
                    "121": [0.19444, 0.44444, 0.01389, 0, 0.46111],
                    "122": [0, 0.44444, 0, 0, 0.43472],
                    "126": [0.35, 0.32659, 0, 0, 0.5],
                    "168": [0, 0.67937, 0, 0, 0.5],
                    "176": [0, 0.69444, 0, 0, 0.66667],
                    "184": [0.17014, 0, 0, 0, 0.44445],
                    "305": [0, 0.44444, 0, 0, 0.23889],
                    "567": [0.19444, 0.44444, 0, 0, 0.26667],
                    "710": [0, 0.69444, 0, 0, 0.5],
                    "711": [0, 0.63194, 0, 0, 0.5],
                    "713": [0, 0.60889, 0, 0, 0.5],
                    "714": [0, 0.69444, 0, 0, 0.5],
                    "715": [0, 0.69444, 0, 0, 0.5],
                    "728": [0, 0.69444, 0, 0, 0.5],
                    "729": [0, 0.67937, 0, 0, 0.27778],
                    "730": [0, 0.69444, 0, 0, 0.66667],
                    "732": [0, 0.67659, 0, 0, 0.5],
                    "733": [0, 0.69444, 0, 0, 0.5],
                    "915": [0, 0.69444, 0, 0, 0.54167],
                    "916": [0, 0.69444, 0, 0, 0.83334],
                    "920": [0, 0.69444, 0, 0, 0.77778],
                    "923": [0, 0.69444, 0, 0, 0.61111],
                    "926": [0, 0.69444, 0, 0, 0.66667],
                    "928": [0, 0.69444, 0, 0, 0.70834],
                    "931": [0, 0.69444, 0, 0, 0.72222],
                    "933": [0, 0.69444, 0, 0, 0.77778],
                    "934": [0, 0.69444, 0, 0, 0.72222],
                    "936": [0, 0.69444, 0, 0, 0.77778],
                    "937": [0, 0.69444, 0, 0, 0.72222],
                    "8211": [0, 0.44444, 0.02778, 0, 0.5],
                    "8212": [0, 0.44444, 0.02778, 0, 1.0],
                    "8216": [0, 0.69444, 0, 0, 0.27778],
                    "8217": [0, 0.69444, 0, 0, 0.27778],
                    "8220": [0, 0.69444, 0, 0, 0.5],
                    "8221": [0, 0.69444, 0, 0, 0.5]
                },
                "Script-Regular": {
                    "65": [0, 0.7, 0.22925, 0, 0.80253],
                    "66": [0, 0.7, 0.04087, 0, 0.90757],
                    "67": [0, 0.7, 0.1689, 0, 0.66619],
                    "68": [0, 0.7, 0.09371, 0, 0.77443],
                    "69": [0, 0.7, 0.18583, 0, 0.56162],
                    "70": [0, 0.7, 0.13634, 0, 0.89544],
                    "71": [0, 0.7, 0.17322, 0, 0.60961],
                    "72": [0, 0.7, 0.29694, 0, 0.96919],
                    "73": [0, 0.7, 0.19189, 0, 0.80907],
                    "74": [0.27778, 0.7, 0.19189, 0, 1.05159],
                    "75": [0, 0.7, 0.31259, 0, 0.91364],
                    "76": [0, 0.7, 0.19189, 0, 0.87373],
                    "77": [0, 0.7, 0.15981, 0, 1.08031],
                    "78": [0, 0.7, 0.3525, 0, 0.9015],
                    "79": [0, 0.7, 0.08078, 0, 0.73787],
                    "80": [0, 0.7, 0.08078, 0, 1.01262],
                    "81": [0, 0.7, 0.03305, 0, 0.88282],
                    "82": [0, 0.7, 0.06259, 0, 0.85],
                    "83": [0, 0.7, 0.19189, 0, 0.86767],
                    "84": [0, 0.7, 0.29087, 0, 0.74697],
                    "85": [0, 0.7, 0.25815, 0, 0.79996],
                    "86": [0, 0.7, 0.27523, 0, 0.62204],
                    "87": [0, 0.7, 0.27523, 0, 0.80532],
                    "88": [0, 0.7, 0.26006, 0, 0.94445],
                    "89": [0, 0.7, 0.2939, 0, 0.70961],
                    "90": [0, 0.7, 0.24037, 0, 0.8212]
                },
                "Size1-Regular": {
                    "40": [0.35001, 0.85, 0, 0, 0.45834],
                    "41": [0.35001, 0.85, 0, 0, 0.45834],
                    "47": [0.35001, 0.85, 0, 0, 0.57778],
                    "91": [0.35001, 0.85, 0, 0, 0.41667],
                    "92": [0.35001, 0.85, 0, 0, 0.57778],
                    "93": [0.35001, 0.85, 0, 0, 0.41667],
                    "123": [0.35001, 0.85, 0, 0, 0.58334],
                    "125": [0.35001, 0.85, 0, 0, 0.58334],
                    "710": [0, 0.72222, 0, 0, 0.55556],
                    "732": [0, 0.72222, 0, 0, 0.55556],
                    "770": [0, 0.72222, 0, 0, 0.55556],
                    "771": [0, 0.72222, 0, 0, 0.55556],
                    "8214": [-0.00099, 0.601, 0, 0, 0.77778],
                    "8593": [1e-05, 0.6, 0, 0, 0.66667],
                    "8595": [1e-05, 0.6, 0, 0, 0.66667],
                    "8657": [1e-05, 0.6, 0, 0, 0.77778],
                    "8659": [1e-05, 0.6, 0, 0, 0.77778],
                    "8719": [0.25001, 0.75, 0, 0, 0.94445],
                    "8720": [0.25001, 0.75, 0, 0, 0.94445],
                    "8721": [0.25001, 0.75, 0, 0, 1.05556],
                    "8730": [0.35001, 0.85, 0, 0, 1.0],
                    "8739": [-0.00599, 0.606, 0, 0, 0.33333],
                    "8741": [-0.00599, 0.606, 0, 0, 0.55556],
                    "8747": [0.30612, 0.805, 0.19445, 0, 0.47222],
                    "8748": [0.306, 0.805, 0.19445, 0, 0.47222],
                    "8749": [0.306, 0.805, 0.19445, 0, 0.47222],
                    "8750": [0.30612, 0.805, 0.19445, 0, 0.47222],
                    "8896": [0.25001, 0.75, 0, 0, 0.83334],
                    "8897": [0.25001, 0.75, 0, 0, 0.83334],
                    "8898": [0.25001, 0.75, 0, 0, 0.83334],
                    "8899": [0.25001, 0.75, 0, 0, 0.83334],
                    "8968": [0.35001, 0.85, 0, 0, 0.47222],
                    "8969": [0.35001, 0.85, 0, 0, 0.47222],
                    "8970": [0.35001, 0.85, 0, 0, 0.47222],
                    "8971": [0.35001, 0.85, 0, 0, 0.47222],
                    "9168": [-0.00099, 0.601, 0, 0, 0.66667],
                    "10216": [0.35001, 0.85, 0, 0, 0.47222],
                    "10217": [0.35001, 0.85, 0, 0, 0.47222],
                    "10752": [0.25001, 0.75, 0, 0, 1.11111],
                    "10753": [0.25001, 0.75, 0, 0, 1.11111],
                    "10754": [0.25001, 0.75, 0, 0, 1.11111],
                    "10756": [0.25001, 0.75, 0, 0, 0.83334],
                    "10758": [0.25001, 0.75, 0, 0, 0.83334]
                },
                "Size2-Regular": {
                    "40": [0.65002, 1.15, 0, 0, 0.59722],
                    "41": [0.65002, 1.15, 0, 0, 0.59722],
                    "47": [0.65002, 1.15, 0, 0, 0.81111],
                    "91": [0.65002, 1.15, 0, 0, 0.47222],
                    "92": [0.65002, 1.15, 0, 0, 0.81111],
                    "93": [0.65002, 1.15, 0, 0, 0.47222],
                    "123": [0.65002, 1.15, 0, 0, 0.66667],
                    "125": [0.65002, 1.15, 0, 0, 0.66667],
                    "710": [0, 0.75, 0, 0, 1.0],
                    "732": [0, 0.75, 0, 0, 1.0],
                    "770": [0, 0.75, 0, 0, 1.0],
                    "771": [0, 0.75, 0, 0, 1.0],
                    "8719": [0.55001, 1.05, 0, 0, 1.27778],
                    "8720": [0.55001, 1.05, 0, 0, 1.27778],
                    "8721": [0.55001, 1.05, 0, 0, 1.44445],
                    "8730": [0.65002, 1.15, 0, 0, 1.0],
                    "8747": [0.86225, 1.36, 0.44445, 0, 0.55556],
                    "8748": [0.862, 1.36, 0.44445, 0, 0.55556],
                    "8749": [0.862, 1.36, 0.44445, 0, 0.55556],
                    "8750": [0.86225, 1.36, 0.44445, 0, 0.55556],
                    "8896": [0.55001, 1.05, 0, 0, 1.11111],
                    "8897": [0.55001, 1.05, 0, 0, 1.11111],
                    "8898": [0.55001, 1.05, 0, 0, 1.11111],
                    "8899": [0.55001, 1.05, 0, 0, 1.11111],
                    "8968": [0.65002, 1.15, 0, 0, 0.52778],
                    "8969": [0.65002, 1.15, 0, 0, 0.52778],
                    "8970": [0.65002, 1.15, 0, 0, 0.52778],
                    "8971": [0.65002, 1.15, 0, 0, 0.52778],
                    "10216": [0.65002, 1.15, 0, 0, 0.61111],
                    "10217": [0.65002, 1.15, 0, 0, 0.61111],
                    "10752": [0.55001, 1.05, 0, 0, 1.51112],
                    "10753": [0.55001, 1.05, 0, 0, 1.51112],
                    "10754": [0.55001, 1.05, 0, 0, 1.51112],
                    "10756": [0.55001, 1.05, 0, 0, 1.11111],
                    "10758": [0.55001, 1.05, 0, 0, 1.11111]
                },
                "Size3-Regular": {
                    "40": [0.95003, 1.45, 0, 0, 0.73611],
                    "41": [0.95003, 1.45, 0, 0, 0.73611],
                    "47": [0.95003, 1.45, 0, 0, 1.04445],
                    "91": [0.95003, 1.45, 0, 0, 0.52778],
                    "92": [0.95003, 1.45, 0, 0, 1.04445],
                    "93": [0.95003, 1.45, 0, 0, 0.52778],
                    "123": [0.95003, 1.45, 0, 0, 0.75],
                    "125": [0.95003, 1.45, 0, 0, 0.75],
                    "710": [0, 0.75, 0, 0, 1.44445],
                    "732": [0, 0.75, 0, 0, 1.44445],
                    "770": [0, 0.75, 0, 0, 1.44445],
                    "771": [0, 0.75, 0, 0, 1.44445],
                    "8730": [0.95003, 1.45, 0, 0, 1.0],
                    "8968": [0.95003, 1.45, 0, 0, 0.58334],
                    "8969": [0.95003, 1.45, 0, 0, 0.58334],
                    "8970": [0.95003, 1.45, 0, 0, 0.58334],
                    "8971": [0.95003, 1.45, 0, 0, 0.58334],
                    "10216": [0.95003, 1.45, 0, 0, 0.75],
                    "10217": [0.95003, 1.45, 0, 0, 0.75]
                },
                "Size4-Regular": {
                    "40": [1.25003, 1.75, 0, 0, 0.79167],
                    "41": [1.25003, 1.75, 0, 0, 0.79167],
                    "47": [1.25003, 1.75, 0, 0, 1.27778],
                    "91": [1.25003, 1.75, 0, 0, 0.58334],
                    "92": [1.25003, 1.75, 0, 0, 1.27778],
                    "93": [1.25003, 1.75, 0, 0, 0.58334],
                    "123": [1.25003, 1.75, 0, 0, 0.80556],
                    "125": [1.25003, 1.75, 0, 0, 0.80556],
                    "710": [0, 0.825, 0, 0, 1.8889],
                    "732": [0, 0.825, 0, 0, 1.8889],
                    "770": [0, 0.825, 0, 0, 1.8889],
                    "771": [0, 0.825, 0, 0, 1.8889],
                    "8730": [1.25003, 1.75, 0, 0, 1.0],
                    "8968": [1.25003, 1.75, 0, 0, 0.63889],
                    "8969": [1.25003, 1.75, 0, 0, 0.63889],
                    "8970": [1.25003, 1.75, 0, 0, 0.63889],
                    "8971": [1.25003, 1.75, 0, 0, 0.63889],
                    "9115": [0.64502, 1.155, 0, 0, 0.875],
                    "9116": [1e-05, 0.6, 0, 0, 0.875],
                    "9117": [0.64502, 1.155, 0, 0, 0.875],
                    "9118": [0.64502, 1.155, 0, 0, 0.875],
                    "9119": [1e-05, 0.6, 0, 0, 0.875],
                    "9120": [0.64502, 1.155, 0, 0, 0.875],
                    "9121": [0.64502, 1.155, 0, 0, 0.66667],
                    "9122": [-0.00099, 0.601, 0, 0, 0.66667],
                    "9123": [0.64502, 1.155, 0, 0, 0.66667],
                    "9124": [0.64502, 1.155, 0, 0, 0.66667],
                    "9125": [-0.00099, 0.601, 0, 0, 0.66667],
                    "9126": [0.64502, 1.155, 0, 0, 0.66667],
                    "9127": [1e-05, 0.9, 0, 0, 0.88889],
                    "9128": [0.65002, 1.15, 0, 0, 0.88889],
                    "9129": [0.90001, 0, 0, 0, 0.88889],
                    "9130": [0, 0.3, 0, 0, 0.88889],
                    "9131": [1e-05, 0.9, 0, 0, 0.88889],
                    "9132": [0.65002, 1.15, 0, 0, 0.88889],
                    "9133": [0.90001, 0, 0, 0, 0.88889],
                    "9143": [0.88502, 0.915, 0, 0, 1.05556],
                    "10216": [1.25003, 1.75, 0, 0, 0.80556],
                    "10217": [1.25003, 1.75, 0, 0, 0.80556],
                    "57344": [-0.00499, 0.605, 0, 0, 1.05556],
                    "57345": [-0.00499, 0.605, 0, 0, 1.05556],
                    "57680": [0, 0.12, 0, 0, 0.45],
                    "57681": [0, 0.12, 0, 0, 0.45],
                    "57682": [0, 0.12, 0, 0, 0.45],
                    "57683": [0, 0.12, 0, 0, 0.45]
                },
                "Typewriter-Regular": {
                    "32": [0, 0, 0, 0, 0.525],
                    "33": [0, 0.61111, 0, 0, 0.525],
                    "34": [0, 0.61111, 0, 0, 0.525],
                    "35": [0, 0.61111, 0, 0, 0.525],
                    "36": [0.08333, 0.69444, 0, 0, 0.525],
                    "37": [0.08333, 0.69444, 0, 0, 0.525],
                    "38": [0, 0.61111, 0, 0, 0.525],
                    "39": [0, 0.61111, 0, 0, 0.525],
                    "40": [0.08333, 0.69444, 0, 0, 0.525],
                    "41": [0.08333, 0.69444, 0, 0, 0.525],
                    "42": [0, 0.52083, 0, 0, 0.525],
                    "43": [-0.08056, 0.53055, 0, 0, 0.525],
                    "44": [0.13889, 0.125, 0, 0, 0.525],
                    "45": [-0.08056, 0.53055, 0, 0, 0.525],
                    "46": [0, 0.125, 0, 0, 0.525],
                    "47": [0.08333, 0.69444, 0, 0, 0.525],
                    "48": [0, 0.61111, 0, 0, 0.525],
                    "49": [0, 0.61111, 0, 0, 0.525],
                    "50": [0, 0.61111, 0, 0, 0.525],
                    "51": [0, 0.61111, 0, 0, 0.525],
                    "52": [0, 0.61111, 0, 0, 0.525],
                    "53": [0, 0.61111, 0, 0, 0.525],
                    "54": [0, 0.61111, 0, 0, 0.525],
                    "55": [0, 0.61111, 0, 0, 0.525],
                    "56": [0, 0.61111, 0, 0, 0.525],
                    "57": [0, 0.61111, 0, 0, 0.525],
                    "58": [0, 0.43056, 0, 0, 0.525],
                    "59": [0.13889, 0.43056, 0, 0, 0.525],
                    "60": [-0.05556, 0.55556, 0, 0, 0.525],
                    "61": [-0.19549, 0.41562, 0, 0, 0.525],
                    "62": [-0.05556, 0.55556, 0, 0, 0.525],
                    "63": [0, 0.61111, 0, 0, 0.525],
                    "64": [0, 0.61111, 0, 0, 0.525],
                    "65": [0, 0.61111, 0, 0, 0.525],
                    "66": [0, 0.61111, 0, 0, 0.525],
                    "67": [0, 0.61111, 0, 0, 0.525],
                    "68": [0, 0.61111, 0, 0, 0.525],
                    "69": [0, 0.61111, 0, 0, 0.525],
                    "70": [0, 0.61111, 0, 0, 0.525],
                    "71": [0, 0.61111, 0, 0, 0.525],
                    "72": [0, 0.61111, 0, 0, 0.525],
                    "73": [0, 0.61111, 0, 0, 0.525],
                    "74": [0, 0.61111, 0, 0, 0.525],
                    "75": [0, 0.61111, 0, 0, 0.525],
                    "76": [0, 0.61111, 0, 0, 0.525],
                    "77": [0, 0.61111, 0, 0, 0.525],
                    "78": [0, 0.61111, 0, 0, 0.525],
                    "79": [0, 0.61111, 0, 0, 0.525],
                    "80": [0, 0.61111, 0, 0, 0.525],
                    "81": [0.13889, 0.61111, 0, 0, 0.525],
                    "82": [0, 0.61111, 0, 0, 0.525],
                    "83": [0, 0.61111, 0, 0, 0.525],
                    "84": [0, 0.61111, 0, 0, 0.525],
                    "85": [0, 0.61111, 0, 0, 0.525],
                    "86": [0, 0.61111, 0, 0, 0.525],
                    "87": [0, 0.61111, 0, 0, 0.525],
                    "88": [0, 0.61111, 0, 0, 0.525],
                    "89": [0, 0.61111, 0, 0, 0.525],
                    "90": [0, 0.61111, 0, 0, 0.525],
                    "91": [0.08333, 0.69444, 0, 0, 0.525],
                    "92": [0.08333, 0.69444, 0, 0, 0.525],
                    "93": [0.08333, 0.69444, 0, 0, 0.525],
                    "94": [0, 0.61111, 0, 0, 0.525],
                    "95": [0.09514, 0, 0, 0, 0.525],
                    "96": [0, 0.61111, 0, 0, 0.525],
                    "97": [0, 0.43056, 0, 0, 0.525],
                    "98": [0, 0.61111, 0, 0, 0.525],
                    "99": [0, 0.43056, 0, 0, 0.525],
                    "100": [0, 0.61111, 0, 0, 0.525],
                    "101": [0, 0.43056, 0, 0, 0.525],
                    "102": [0, 0.61111, 0, 0, 0.525],
                    "103": [0.22222, 0.43056, 0, 0, 0.525],
                    "104": [0, 0.61111, 0, 0, 0.525],
                    "105": [0, 0.61111, 0, 0, 0.525],
                    "106": [0.22222, 0.61111, 0, 0, 0.525],
                    "107": [0, 0.61111, 0, 0, 0.525],
                    "108": [0, 0.61111, 0, 0, 0.525],
                    "109": [0, 0.43056, 0, 0, 0.525],
                    "110": [0, 0.43056, 0, 0, 0.525],
                    "111": [0, 0.43056, 0, 0, 0.525],
                    "112": [0.22222, 0.43056, 0, 0, 0.525],
                    "113": [0.22222, 0.43056, 0, 0, 0.525],
                    "114": [0, 0.43056, 0, 0, 0.525],
                    "115": [0, 0.43056, 0, 0, 0.525],
                    "116": [0, 0.55358, 0, 0, 0.525],
                    "117": [0, 0.43056, 0, 0, 0.525],
                    "118": [0, 0.43056, 0, 0, 0.525],
                    "119": [0, 0.43056, 0, 0, 0.525],
                    "120": [0, 0.43056, 0, 0, 0.525],
                    "121": [0.22222, 0.43056, 0, 0, 0.525],
                    "122": [0, 0.43056, 0, 0, 0.525],
                    "123": [0.08333, 0.69444, 0, 0, 0.525],
                    "124": [0.08333, 0.69444, 0, 0, 0.525],
                    "125": [0.08333, 0.69444, 0, 0, 0.525],
                    "126": [0, 0.61111, 0, 0, 0.525],
                    "127": [0, 0.61111, 0, 0, 0.525],
                    "160": [0, 0, 0, 0, 0.525],
                    "176": [0, 0.61111, 0, 0, 0.525],
                    "184": [0.19445, 0, 0, 0, 0.525],
                    "305": [0, 0.43056, 0, 0, 0.525],
                    "567": [0.22222, 0.43056, 0, 0, 0.525],
                    "711": [0, 0.56597, 0, 0, 0.525],
                    "713": [0, 0.56555, 0, 0, 0.525],
                    "714": [0, 0.61111, 0, 0, 0.525],
                    "715": [0, 0.61111, 0, 0, 0.525],
                    "728": [0, 0.61111, 0, 0, 0.525],
                    "730": [0, 0.61111, 0, 0, 0.525],
                    "770": [0, 0.61111, 0, 0, 0.525],
                    "771": [0, 0.61111, 0, 0, 0.525],
                    "776": [0, 0.61111, 0, 0, 0.525],
                    "915": [0, 0.61111, 0, 0, 0.525],
                    "916": [0, 0.61111, 0, 0, 0.525],
                    "920": [0, 0.61111, 0, 0, 0.525],
                    "923": [0, 0.61111, 0, 0, 0.525],
                    "926": [0, 0.61111, 0, 0, 0.525],
                    "928": [0, 0.61111, 0, 0, 0.525],
                    "931": [0, 0.61111, 0, 0, 0.525],
                    "933": [0, 0.61111, 0, 0, 0.525],
                    "934": [0, 0.61111, 0, 0, 0.525],
                    "936": [0, 0.61111, 0, 0, 0.525],
                    "937": [0, 0.61111, 0, 0, 0.525],
                    "8216": [0, 0.61111, 0, 0, 0.525],
                    "8217": [0, 0.61111, 0, 0, 0.525],
                    "8242": [0, 0.61111, 0, 0, 0.525],
                    "9251": [0.11111, 0.21944, 0, 0, 0.525]
                }
            };
            /**
             * This file contains metrics regarding fonts and individual symbols. The sigma
             * and xi variables, as well as the metricMap map contain data extracted from
             * TeX, TeX font metrics, and the TTF files. These data are then exposed via the
             * `metrics` variable and the getCharacterMetrics function.
             */
            // In TeX, there are actually three sets of dimensions, one for each of
            // textstyle (size index 5 and higher: >=9pt), scriptstyle (size index 3 and 4:
            // 7-8pt), and scriptscriptstyle (size index 1 and 2: 5-6pt).  These are
            // provided in the the arrays below, in that order.
            //
            // The font metrics are stored in fonts cmsy10, cmsy7, and cmsy5 respsectively.
            // This was determined by running the following script:
            //
            //     latex -interaction=nonstopmode \
            //     '\documentclass{article}\usepackage{amsmath}\begin{document}' \
            //     '$a$ \expandafter\show\the\textfont2' \
            //     '\expandafter\show\the\scriptfont2' \
            //     '\expandafter\show\the\scriptscriptfont2' \
            //     '\stop'
            //
            // The metrics themselves were retreived using the following commands:
            //
            //     tftopl cmsy10
            //     tftopl cmsy7
            //     tftopl cmsy5
            //
            // The output of each of these commands is quite lengthy.  The only part we
            // care about is the FONTDIMEN section. Each value is measured in EMs.
            sigmasAndXis = {
                slant: [0.250, 0.250, 0.250],
                // sigma1
                space: [0.000, 0.000, 0.000],
                // sigma2
                stretch: [0.000, 0.000, 0.000],
                // sigma3
                shrink: [0.000, 0.000, 0.000],
                // sigma4
                xHeight: [0.431, 0.431, 0.431],
                // sigma5
                quad: [1.000, 1.171, 1.472],
                // sigma6
                extraSpace: [0.000, 0.000, 0.000],
                // sigma7
                num1: [0.677, 0.732, 0.925],
                // sigma8
                num2: [0.394, 0.384, 0.387],
                // sigma9
                num3: [0.444, 0.471, 0.504],
                // sigma10
                denom1: [0.686, 0.752, 1.025],
                // sigma11
                denom2: [0.345, 0.344, 0.532],
                // sigma12
                sup1: [0.413, 0.503, 0.504],
                // sigma13
                sup2: [0.363, 0.431, 0.404],
                // sigma14
                sup3: [0.289, 0.286, 0.294],
                // sigma15
                sub1: [0.150, 0.143, 0.200],
                // sigma16
                sub2: [0.247, 0.286, 0.400],
                // sigma17
                supDrop: [0.386, 0.353, 0.494],
                // sigma18
                subDrop: [0.050, 0.071, 0.100],
                // sigma19
                delim1: [2.390, 1.700, 1.980],
                // sigma20
                delim2: [1.010, 1.157, 1.420],
                // sigma21
                axisHeight: [0.250, 0.250, 0.250],
                // sigma22
                // These font metrics are extracted from TeX by using tftopl on cmex10.tfm;
                // they correspond to the font parameters of the extension fonts (family 3).
                // See the TeXbook, page 441. In AMSTeX, the extension fonts scale; to
                // match cmex7, we'd use cmex7.tfm values for script and scriptscript
                // values.
                defaultRuleThickness: [0.04, 0.049, 0.049],
                // xi8; cmex7: 0.049
                bigOpSpacing1: [0.111, 0.111, 0.111],
                // xi9
                bigOpSpacing2: [0.166, 0.166, 0.166],
                // xi10
                bigOpSpacing3: [0.2, 0.2, 0.2],
                // xi11
                bigOpSpacing4: [0.6, 0.611, 0.611],
                // xi12; cmex7: 0.611
                bigOpSpacing5: [0.1, 0.143, 0.143],
                // xi13; cmex7: 0.143
                // The \sqrt rule width is taken from the height of the surd character.
                // Since we use the same font at all sizes, this thickness doesn't scale.
                sqrtRuleThickness: [0.04, 0.04, 0.04],
                // This value determines how large a pt is, for metrics which are defined
                // in terms of pts.
                // This value is also used in katex.less; if you change it make sure the
                // values match.
                ptPerEm: [10.0, 10.0, 10.0],
                // The space between adjacent `|` columns in an array definition. From
                // `\showthe\doublerulesep` in LaTeX. Equals 2.0 / ptPerEm.
                doubleRuleSep: [0.2, 0.2, 0.2],
                // The width of separator lines in {array} environments. From
                // `\showthe\arrayrulewidth` in LaTeX. Equals 0.4 / ptPerEm.
                arrayRuleWidth: [0.04, 0.04, 0.04],
                // Two values from LaTeX source2e:
                fboxsep: [0.3, 0.3, 0.3],
                //        3 pt / ptPerEm
                fboxrule: [0.04, 0.04, 0.04] // 0.4 pt / ptPerEm
            }; // This map contains a mapping from font name and character code to character
            // should have Latin-1 and Cyrillic characters, but may not depending on the
            // operating system.  The metrics do not account for extra height from the
            // accents.  In the case of Cyrillic characters which have both ascenders and
            // descenders we prefer approximations with ascenders, primarily to prevent
            // the fraction bar or root line from intersecting the glyph.
            // TODO(kevinb) allow union of multiple glyph metrics for better accuracy.
            extraCharacterMap = {
                // Latin-1
                '': 'A',
                '': 'C',
                '': 'D',
                '': 'o',
                '': 'a',
                '': 'c',
                '': 'd',
                '': 'o',
                // Cyrillic
                '': 'A',
                '': 'B',
                '': 'B',
                '': 'F',
                '': 'A',
                '': 'E',
                '': 'K',
                '': '3',
                '': 'N',
                '': 'N',
                '': 'K',
                '': 'N',
                '': 'M',
                '': 'H',
                '': 'O',
                '': 'N',
                '': 'P',
                '': 'C',
                '': 'T',
                '': 'y',
                '': 'O',
                '': 'X',
                '': 'U',
                '': 'h',
                '': 'W',
                '': 'W',
                '': 'B',
                '': 'X',
                '': 'B',
                '': '3',
                '': 'X',
                '': 'R',
                '': 'a',
                '': 'b',
                '': 'a',
                '': 'r',
                '': 'y',
                '': 'e',
                '': 'm',
                '': 'e',
                '': 'n',
                '': 'n',
                '': 'n',
                '': 'n',
                '': 'm',
                '': 'n',
                '': 'o',
                '': 'n',
                '': 'p',
                '': 'c',
                '': 'o',
                '': 'y',
                '': 'b',
                '': 'x',
                '': 'n',
                '': 'n',
                '': 'w',
                '': 'w',
                '': 'a',
                '': 'm',
                '': 'a',
                '': 'e',
                '': 'm',
                '': 'r'
            };
            fontMetricsBySizeIndex = {};
            /**
             * This file holds a list of all no-argument functions and single-character
             * symbols (like 'a' or ';').
             *
             * For each of the symbols, there are three properties they can have:
             * - font (required): the font to be used for this symbol. Either "main" (the
                 normal font), or "ams" (the ams fonts).
             * - group (required): the ParseNode group type the symbol should have (i.e.
                 "textord", "mathord", etc).
                 See https://github.com/KaTeX/KaTeX/wiki/Examining-TeX#group-types
             * - replace: the character that this symbol or function should be
             *   replaced with (i.e. "\phi" has a replace value of "\u03d5", the phi
             *   character in the main font).
             *
             * The outermost map in the table indicates what mode the symbols should be
             * accepted in (e.g. "math" or "text").
             */
            // Some of these have a "-token" suffix since these are also used as `ParseNode`
            // types for raw text tokens, and we want to avoid conflicts with higher-level
            // `ParseNode` types. These `ParseNode`s are constructed within `Parser` by
            // looking up the `symbols` map.
            ATOMS = {
                "bin": 1,
                "close": 1,
                "inner": 1,
                "open": 1,
                "punct": 1,
                "rel": 1
            };
            NON_ATOMS = {
                "accent-token": 1,
                "mathord": 1,
                "op-token": 1,
                "spacing": 1,
                "textord": 1
            };
            symbols = {
                "math": {},
                "text": {}
            };
            // This helps minify the code, and also spotting typos using jshint.
            // modes:
            math = "math";
            text$1 = "text"; // fonts:
            main = "main";
            ams = "ams"; // groups:
            accent = "accent-token";
            bin = "bin";
            close = "close";
            inner = "inner";
            mathord = "mathord";
            op = "op-token";
            open = "open";
            punct = "punct";
            rel = "rel";
            spacing = "spacing";
            textord = "textord"; // Now comes the symbol table
            // Relation Symbols
            defineSymbol(math, main, rel, "\u2261", "\\equiv", true);
            defineSymbol(math, main, rel, "\u227a", "\\prec", true);
            defineSymbol(math, main, rel, "\u227b", "\\succ", true);
            defineSymbol(math, main, rel, "\u223c", "\\sim", true);
            defineSymbol(math, main, rel, "\u22a5", "\\perp");
            defineSymbol(math, main, rel, "\u2aaf", "\\preceq", true);
            defineSymbol(math, main, rel, "\u2ab0", "\\succeq", true);
            defineSymbol(math, main, rel, "\u2243", "\\simeq", true);
            defineSymbol(math, main, rel, "\u2223", "\\mid", true);
            defineSymbol(math, main, rel, "\u226a", "\\ll", true);
            defineSymbol(math, main, rel, "\u226b", "\\gg", true);
            defineSymbol(math, main, rel, "\u224d", "\\asymp", true);
            defineSymbol(math, main, rel, "\u2225", "\\parallel");
            defineSymbol(math, main, rel, "\u22c8", "\\bowtie", true);
            defineSymbol(math, main, rel, "\u2323", "\\smile", true);
            defineSymbol(math, main, rel, "\u2291", "\\sqsubseteq", true);
            defineSymbol(math, main, rel, "\u2292", "\\sqsupseteq", true);
            defineSymbol(math, main, rel, "\u2250", "\\doteq", true);
            defineSymbol(math, main, rel, "\u2322", "\\frown", true);
            defineSymbol(math, main, rel, "\u220b", "\\ni", true);
            defineSymbol(math, main, rel, "\u221d", "\\propto", true);
            defineSymbol(math, main, rel, "\u22a2", "\\vdash", true);
            defineSymbol(math, main, rel, "\u22a3", "\\dashv", true);
            defineSymbol(math, main, rel, "\u220b", "\\owns"); // Punctuation
            defineSymbol(math, main, punct, "\u002e", "\\ldotp");
            defineSymbol(math, main, punct, "\u22c5", "\\cdotp"); // Misc Symbols
            defineSymbol(math, main, textord, "\u0023", "\\#");
            defineSymbol(text$1, main, textord, "\u0023", "\\#");
            defineSymbol(math, main, textord, "\u0026", "\\&");
            defineSymbol(text$1, main, textord, "\u0026", "\\&");
            defineSymbol(math, main, textord, "\u2135", "\\aleph", true);
            defineSymbol(math, main, textord, "\u2200", "\\forall", true);
            defineSymbol(math, main, textord, "\u210f", "\\hbar", true);
            defineSymbol(math, main, textord, "\u2203", "\\exists", true);
            defineSymbol(math, main, textord, "\u2207", "\\nabla", true);
            defineSymbol(math, main, textord, "\u266d", "\\flat", true);
            defineSymbol(math, main, textord, "\u2113", "\\ell", true);
            defineSymbol(math, main, textord, "\u266e", "\\natural", true);
            defineSymbol(math, main, textord, "\u2663", "\\clubsuit", true);
            defineSymbol(math, main, textord, "\u2118", "\\wp", true);
            defineSymbol(math, main, textord, "\u266f", "\\sharp", true);
            defineSymbol(math, main, textord, "\u2662", "\\diamondsuit", true);
            defineSymbol(math, main, textord, "\u211c", "\\Re", true);
            defineSymbol(math, main, textord, "\u2661", "\\heartsuit", true);
            defineSymbol(math, main, textord, "\u2111", "\\Im", true);
            defineSymbol(math, main, textord, "\u2660", "\\spadesuit", true);
            defineSymbol(text$1, main, textord, "\u00a7", "\\S", true);
            defineSymbol(text$1, main, textord, "\u00b6", "\\P", true); // Math and Text
            defineSymbol(math, main, textord, "\u2020", "\\dag");
            defineSymbol(text$1, main, textord, "\u2020", "\\dag");
            defineSymbol(text$1, main, textord, "\u2020", "\\textdagger");
            defineSymbol(math, main, textord, "\u2021", "\\ddag");
            defineSymbol(text$1, main, textord, "\u2021", "\\ddag");
            defineSymbol(text$1, main, textord, "\u2021", "\\textdaggerdbl"); // Large Delimiters
            defineSymbol(math, main, close, "\u23b1", "\\rmoustache", true);
            defineSymbol(math, main, open, "\u23b0", "\\lmoustache", true);
            defineSymbol(math, main, close, "\u27ef", "\\rgroup", true);
            defineSymbol(math, main, open, "\u27ee", "\\lgroup", true); // Binary Operators
            defineSymbol(math, main, bin, "\u2213", "\\mp", true);
            defineSymbol(math, main, bin, "\u2296", "\\ominus", true);
            defineSymbol(math, main, bin, "\u228e", "\\uplus", true);
            defineSymbol(math, main, bin, "\u2293", "\\sqcap", true);
            defineSymbol(math, main, bin, "\u2217", "\\ast");
            defineSymbol(math, main, bin, "\u2294", "\\sqcup", true);
            defineSymbol(math, main, bin, "\u25ef", "\\bigcirc");
            defineSymbol(math, main, bin, "\u2219", "\\bullet");
            defineSymbol(math, main, bin, "\u2021", "\\ddagger");
            defineSymbol(math, main, bin, "\u2240", "\\wr", true);
            defineSymbol(math, main, bin, "\u2a3f", "\\amalg");
            defineSymbol(math, main, bin, "\u0026", "\\And"); // from amsmath
            // Arrow Symbols
            defineSymbol(math, main, rel, "\u27f5", "\\longleftarrow", true);
            defineSymbol(math, main, rel, "\u21d0", "\\Leftarrow", true);
            defineSymbol(math, main, rel, "\u27f8", "\\Longleftarrow", true);
            defineSymbol(math, main, rel, "\u27f6", "\\longrightarrow", true);
            defineSymbol(math, main, rel, "\u21d2", "\\Rightarrow", true);
            defineSymbol(math, main, rel, "\u27f9", "\\Longrightarrow", true);
            defineSymbol(math, main, rel, "\u2194", "\\leftrightarrow", true);
            defineSymbol(math, main, rel, "\u27f7", "\\longleftrightarrow", true);
            defineSymbol(math, main, rel, "\u21d4", "\\Leftrightarrow", true);
            defineSymbol(math, main, rel, "\u27fa", "\\Longleftrightarrow", true);
            defineSymbol(math, main, rel, "\u21a6", "\\mapsto", true);
            defineSymbol(math, main, rel, "\u27fc", "\\longmapsto", true);
            defineSymbol(math, main, rel, "\u2197", "\\nearrow", true);
            defineSymbol(math, main, rel, "\u21a9", "\\hookleftarrow", true);
            defineSymbol(math, main, rel, "\u21aa", "\\hookrightarrow", true);
            defineSymbol(math, main, rel, "\u2198", "\\searrow", true);
            defineSymbol(math, main, rel, "\u21bc", "\\leftharpoonup", true);
            defineSymbol(math, main, rel, "\u21c0", "\\rightharpoonup", true);
            defineSymbol(math, main, rel, "\u2199", "\\swarrow", true);
            defineSymbol(math, main, rel, "\u21bd", "\\leftharpoondown", true);
            defineSymbol(math, main, rel, "\u21c1", "\\rightharpoondown", true);
            defineSymbol(math, main, rel, "\u2196", "\\nwarrow", true);
            defineSymbol(math, main, rel, "\u21cc", "\\rightleftharpoons", true); // AMS Negated Binary Relations
            defineSymbol(math, ams, rel, "\u226e", "\\nless", true); // Symbol names preceeded by "@" each have a corresponding macro.
            defineSymbol(math, ams, rel, "\ue010", "\\@nleqslant");
            defineSymbol(math, ams, rel, "\ue011", "\\@nleqq");
            defineSymbol(math, ams, rel, "\u2a87", "\\lneq", true);
            defineSymbol(math, ams, rel, "\u2268", "\\lneqq", true);
            defineSymbol(math, ams, rel, "\ue00c", "\\@lvertneqq");
            defineSymbol(math, ams, rel, "\u22e6", "\\lnsim", true);
            defineSymbol(math, ams, rel, "\u2a89", "\\lnapprox", true);
            defineSymbol(math, ams, rel, "\u2280", "\\nprec", true); // unicode-math maps \u22e0 to \npreccurlyeq. We'll use the AMS synonym.
            defineSymbol(math, ams, rel, "\u22e0", "\\npreceq", true);
            defineSymbol(math, ams, rel, "\u22e8", "\\precnsim", true);
            defineSymbol(math, ams, rel, "\u2ab9", "\\precnapprox", true);
            defineSymbol(math, ams, rel, "\u2241", "\\nsim", true);
            defineSymbol(math, ams, rel, "\ue006", "\\@nshortmid");
            defineSymbol(math, ams, rel, "\u2224", "\\nmid", true);
            defineSymbol(math, ams, rel, "\u22ac", "\\nvdash", true);
            defineSymbol(math, ams, rel, "\u22ad", "\\nvDash", true);
            defineSymbol(math, ams, rel, "\u22ea", "\\ntriangleleft");
            defineSymbol(math, ams, rel, "\u22ec", "\\ntrianglelefteq", true);
            defineSymbol(math, ams, rel, "\u228a", "\\subsetneq", true);
            defineSymbol(math, ams, rel, "\ue01a", "\\@varsubsetneq");
            defineSymbol(math, ams, rel, "\u2acb", "\\subsetneqq", true);
            defineSymbol(math, ams, rel, "\ue017", "\\@varsubsetneqq");
            defineSymbol(math, ams, rel, "\u226f", "\\ngtr", true);
            defineSymbol(math, ams, rel, "\ue00f", "\\@ngeqslant");
            defineSymbol(math, ams, rel, "\ue00e", "\\@ngeqq");
            defineSymbol(math, ams, rel, "\u2a88", "\\gneq", true);
            defineSymbol(math, ams, rel, "\u2269", "\\gneqq", true);
            defineSymbol(math, ams, rel, "\ue00d", "\\@gvertneqq");
            defineSymbol(math, ams, rel, "\u22e7", "\\gnsim", true);
            defineSymbol(math, ams, rel, "\u2a8a", "\\gnapprox", true);
            defineSymbol(math, ams, rel, "\u2281", "\\nsucc", true); // unicode-math maps \u22e1 to \nsucccurlyeq. We'll use the AMS synonym.
            defineSymbol(math, ams, rel, "\u22e1", "\\nsucceq", true);
            defineSymbol(math, ams, rel, "\u22e9", "\\succnsim", true);
            defineSymbol(math, ams, rel, "\u2aba", "\\succnapprox", true); // unicode-math maps \u2246 to \simneqq. We'll use the AMS synonym.
            defineSymbol(math, ams, rel, "\u2246", "\\ncong", true);
            defineSymbol(math, ams, rel, "\ue007", "\\@nshortparallel");
            defineSymbol(math, ams, rel, "\u2226", "\\nparallel", true);
            defineSymbol(math, ams, rel, "\u22af", "\\nVDash", true);
            defineSymbol(math, ams, rel, "\u22eb", "\\ntriangleright");
            defineSymbol(math, ams, rel, "\u22ed", "\\ntrianglerighteq", true);
            defineSymbol(math, ams, rel, "\ue018", "\\@nsupseteqq");
            defineSymbol(math, ams, rel, "\u228b", "\\supsetneq", true);
            defineSymbol(math, ams, rel, "\ue01b", "\\@varsupsetneq");
            defineSymbol(math, ams, rel, "\u2acc", "\\supsetneqq", true);
            defineSymbol(math, ams, rel, "\ue019", "\\@varsupsetneqq");
            defineSymbol(math, ams, rel, "\u22ae", "\\nVdash", true);
            defineSymbol(math, ams, rel, "\u2ab5", "\\precneqq", true);
            defineSymbol(math, ams, rel, "\u2ab6", "\\succneqq", true);
            defineSymbol(math, ams, rel, "\ue016", "\\@nsubseteqq");
            defineSymbol(math, ams, bin, "\u22b4", "\\unlhd");
            defineSymbol(math, ams, bin, "\u22b5", "\\unrhd"); // AMS Negated Arrows
            defineSymbol(math, ams, rel, "\u219a", "\\nleftarrow", true);
            defineSymbol(math, ams, rel, "\u219b", "\\nrightarrow", true);
            defineSymbol(math, ams, rel, "\u21cd", "\\nLeftarrow", true);
            defineSymbol(math, ams, rel, "\u21cf", "\\nRightarrow", true);
            defineSymbol(math, ams, rel, "\u21ae", "\\nleftrightarrow", true);
            defineSymbol(math, ams, rel, "\u21ce", "\\nLeftrightarrow", true); // AMS Misc
            defineSymbol(math, ams, rel, "\u25b3", "\\vartriangle");
            defineSymbol(math, ams, textord, "\u210f", "\\hslash");
            defineSymbol(math, ams, textord, "\u25bd", "\\triangledown");
            defineSymbol(math, ams, textord, "\u25ca", "\\lozenge");
            defineSymbol(math, ams, textord, "\u24c8", "\\circledS");
            defineSymbol(math, ams, textord, "\u00ae", "\\circledR");
            defineSymbol(text$1, ams, textord, "\u00ae", "\\circledR");
            defineSymbol(math, ams, textord, "\u2221", "\\measuredangle", true);
            defineSymbol(math, ams, textord, "\u2204", "\\nexists");
            defineSymbol(math, ams, textord, "\u2127", "\\mho");
            defineSymbol(math, ams, textord, "\u2132", "\\Finv", true);
            defineSymbol(math, ams, textord, "\u2141", "\\Game", true);
            defineSymbol(math, ams, textord, "\u2035", "\\backprime");
            defineSymbol(math, ams, textord, "\u25b2", "\\blacktriangle");
            defineSymbol(math, ams, textord, "\u25bc", "\\blacktriangledown");
            defineSymbol(math, ams, textord, "\u25a0", "\\blacksquare");
            defineSymbol(math, ams, textord, "\u29eb", "\\blacklozenge");
            defineSymbol(math, ams, textord, "\u2605", "\\bigstar");
            defineSymbol(math, ams, textord, "\u2222", "\\sphericalangle", true);
            defineSymbol(math, ams, textord, "\u2201", "\\complement", true); // unicode-math maps U+F0 () to \matheth. We map to AMS function \eth
            defineSymbol(math, ams, textord, "\u00f0", "\\eth", true);
            defineSymbol(math, ams, textord, "\u2571", "\\diagup");
            defineSymbol(math, ams, textord, "\u2572", "\\diagdown");
            defineSymbol(math, ams, textord, "\u25a1", "\\square");
            defineSymbol(math, ams, textord, "\u25a1", "\\Box");
            defineSymbol(math, ams, textord, "\u25ca", "\\Diamond"); // unicode-math maps U+A5 to \mathyen. We map to AMS function \yen
            defineSymbol(math, ams, textord, "\u00a5", "\\yen", true);
            defineSymbol(text$1, ams, textord, "\u00a5", "\\yen", true);
            defineSymbol(math, ams, textord, "\u2713", "\\checkmark", true);
            defineSymbol(text$1, ams, textord, "\u2713", "\\checkmark"); // AMS Hebrew
            defineSymbol(math, ams, textord, "\u2136", "\\beth", true);
            defineSymbol(math, ams, textord, "\u2138", "\\daleth", true);
            defineSymbol(math, ams, textord, "\u2137", "\\gimel", true); // AMS Greek
            defineSymbol(math, ams, textord, "\u03dd", "\\digamma", true);
            defineSymbol(math, ams, textord, "\u03f0", "\\varkappa"); // AMS Delimiters
            defineSymbol(math, ams, open, "\u250c", "\\ulcorner", true);
            defineSymbol(math, ams, close, "\u2510", "\\urcorner", true);
            defineSymbol(math, ams, open, "\u2514", "\\llcorner", true);
            defineSymbol(math, ams, close, "\u2518", "\\lrcorner", true); // AMS Binary Relations
            defineSymbol(math, ams, rel, "\u2266", "\\leqq", true);
            defineSymbol(math, ams, rel, "\u2a7d", "\\leqslant", true);
            defineSymbol(math, ams, rel, "\u2a95", "\\eqslantless", true);
            defineSymbol(math, ams, rel, "\u2272", "\\lesssim", true);
            defineSymbol(math, ams, rel, "\u2a85", "\\lessapprox", true);
            defineSymbol(math, ams, rel, "\u224a", "\\approxeq", true);
            defineSymbol(math, ams, bin, "\u22d6", "\\lessdot");
            defineSymbol(math, ams, rel, "\u22d8", "\\lll", true);
            defineSymbol(math, ams, rel, "\u2276", "\\lessgtr", true);
            defineSymbol(math, ams, rel, "\u22da", "\\lesseqgtr", true);
            defineSymbol(math, ams, rel, "\u2a8b", "\\lesseqqgtr", true);
            defineSymbol(math, ams, rel, "\u2251", "\\doteqdot");
            defineSymbol(math, ams, rel, "\u2253", "\\risingdotseq", true);
            defineSymbol(math, ams, rel, "\u2252", "\\fallingdotseq", true);
            defineSymbol(math, ams, rel, "\u223d", "\\backsim", true);
            defineSymbol(math, ams, rel, "\u22cd", "\\backsimeq", true);
            defineSymbol(math, ams, rel, "\u2ac5", "\\subseteqq", true);
            defineSymbol(math, ams, rel, "\u22d0", "\\Subset", true);
            defineSymbol(math, ams, rel, "\u228f", "\\sqsubset", true);
            defineSymbol(math, ams, rel, "\u227c", "\\preccurlyeq", true);
            defineSymbol(math, ams, rel, "\u22de", "\\curlyeqprec", true);
            defineSymbol(math, ams, rel, "\u227e", "\\precsim", true);
            defineSymbol(math, ams, rel, "\u2ab7", "\\precapprox", true);
            defineSymbol(math, ams, rel, "\u22b2", "\\vartriangleleft");
            defineSymbol(math, ams, rel, "\u22b4", "\\trianglelefteq");
            defineSymbol(math, ams, rel, "\u22a8", "\\vDash", true);
            defineSymbol(math, ams, rel, "\u22aa", "\\Vvdash", true);
            defineSymbol(math, ams, rel, "\u2323", "\\smallsmile");
            defineSymbol(math, ams, rel, "\u2322", "\\smallfrown");
            defineSymbol(math, ams, rel, "\u224f", "\\bumpeq", true);
            defineSymbol(math, ams, rel, "\u224e", "\\Bumpeq", true);
            defineSymbol(math, ams, rel, "\u2267", "\\geqq", true);
            defineSymbol(math, ams, rel, "\u2a7e", "\\geqslant", true);
            defineSymbol(math, ams, rel, "\u2a96", "\\eqslantgtr", true);
            defineSymbol(math, ams, rel, "\u2273", "\\gtrsim", true);
            defineSymbol(math, ams, rel, "\u2a86", "\\gtrapprox", true);
            defineSymbol(math, ams, bin, "\u22d7", "\\gtrdot");
            defineSymbol(math, ams, rel, "\u22d9", "\\ggg", true);
            defineSymbol(math, ams, rel, "\u2277", "\\gtrless", true);
            defineSymbol(math, ams, rel, "\u22db", "\\gtreqless", true);
            defineSymbol(math, ams, rel, "\u2a8c", "\\gtreqqless", true);
            defineSymbol(math, ams, rel, "\u2256", "\\eqcirc", true);
            defineSymbol(math, ams, rel, "\u2257", "\\circeq", true);
            defineSymbol(math, ams, rel, "\u225c", "\\triangleq", true);
            defineSymbol(math, ams, rel, "\u223c", "\\thicksim");
            defineSymbol(math, ams, rel, "\u2248", "\\thickapprox");
            defineSymbol(math, ams, rel, "\u2ac6", "\\supseteqq", true);
            defineSymbol(math, ams, rel, "\u22d1", "\\Supset", true);
            defineSymbol(math, ams, rel, "\u2290", "\\sqsupset", true);
            defineSymbol(math, ams, rel, "\u227d", "\\succcurlyeq", true);
            defineSymbol(math, ams, rel, "\u22df", "\\curlyeqsucc", true);
            defineSymbol(math, ams, rel, "\u227f", "\\succsim", true);
            defineSymbol(math, ams, rel, "\u2ab8", "\\succapprox", true);
            defineSymbol(math, ams, rel, "\u22b3", "\\vartriangleright");
            defineSymbol(math, ams, rel, "\u22b5", "\\trianglerighteq");
            defineSymbol(math, ams, rel, "\u22a9", "\\Vdash", true);
            defineSymbol(math, ams, rel, "\u2223", "\\shortmid");
            defineSymbol(math, ams, rel, "\u2225", "\\shortparallel");
            defineSymbol(math, ams, rel, "\u226c", "\\between", true);
            defineSymbol(math, ams, rel, "\u22d4", "\\pitchfork", true);
            defineSymbol(math, ams, rel, "\u221d", "\\varpropto");
            defineSymbol(math, ams, rel, "\u25c0", "\\blacktriangleleft"); // unicode-math says that \therefore is a mathord atom.
            // We kept the amssymb atom type, which is rel.
            defineSymbol(math, ams, rel, "\u2234", "\\therefore", true);
            defineSymbol(math, ams, rel, "\u220d", "\\backepsilon");
            defineSymbol(math, ams, rel, "\u25b6", "\\blacktriangleright"); // unicode-math says that \because is a mathord atom.
            // We kept the amssymb atom type, which is rel.
            defineSymbol(math, ams, rel, "\u2235", "\\because", true);
            defineSymbol(math, ams, rel, "\u22d8", "\\llless");
            defineSymbol(math, ams, rel, "\u22d9", "\\gggtr");
            defineSymbol(math, ams, bin, "\u22b2", "\\lhd");
            defineSymbol(math, ams, bin, "\u22b3", "\\rhd");
            defineSymbol(math, ams, rel, "\u2242", "\\eqsim", true);
            defineSymbol(math, main, rel, "\u22c8", "\\Join");
            defineSymbol(math, ams, rel, "\u2251", "\\Doteq", true); // AMS Binary Operators
            defineSymbol(math, ams, bin, "\u2214", "\\dotplus", true);
            defineSymbol(math, ams, bin, "\u2216", "\\smallsetminus");
            defineSymbol(math, ams, bin, "\u22d2", "\\Cap", true);
            defineSymbol(math, ams, bin, "\u22d3", "\\Cup", true);
            defineSymbol(math, ams, bin, "\u2a5e", "\\doublebarwedge", true);
            defineSymbol(math, ams, bin, "\u229f", "\\boxminus", true);
            defineSymbol(math, ams, bin, "\u229e", "\\boxplus", true);
            defineSymbol(math, ams, bin, "\u22c7", "\\divideontimes", true);
            defineSymbol(math, ams, bin, "\u22c9", "\\ltimes", true);
            defineSymbol(math, ams, bin, "\u22ca", "\\rtimes", true);
            defineSymbol(math, ams, bin, "\u22cb", "\\leftthreetimes", true);
            defineSymbol(math, ams, bin, "\u22cc", "\\rightthreetimes", true);
            defineSymbol(math, ams, bin, "\u22cf", "\\curlywedge", true);
            defineSymbol(math, ams, bin, "\u22ce", "\\curlyvee", true);
            defineSymbol(math, ams, bin, "\u229d", "\\circleddash", true);
            defineSymbol(math, ams, bin, "\u229b", "\\circledast", true);
            defineSymbol(math, ams, bin, "\u22c5", "\\centerdot");
            defineSymbol(math, ams, bin, "\u22ba", "\\intercal", true);
            defineSymbol(math, ams, bin, "\u22d2", "\\doublecap");
            defineSymbol(math, ams, bin, "\u22d3", "\\doublecup");
            defineSymbol(math, ams, bin, "\u22a0", "\\boxtimes", true); // AMS Arrows
            // Note: unicode-math maps \u21e2 to their own function \rightdasharrow.
            // We'll map it to AMS function \dashrightarrow. It produces the same atom.
            defineSymbol(math, ams, rel, "\u21e2", "\\dashrightarrow", true); // unicode-math maps \u21e0 to \leftdasharrow. We'll use the AMS synonym.
            defineSymbol(math, ams, rel, "\u21e0", "\\dashleftarrow", true);
            defineSymbol(math, ams, rel, "\u21c7", "\\leftleftarrows", true);
            defineSymbol(math, ams, rel, "\u21c6", "\\leftrightarrows", true);
            defineSymbol(math, ams, rel, "\u21da", "\\Lleftarrow", true);
            defineSymbol(math, ams, rel, "\u219e", "\\twoheadleftarrow", true);
            defineSymbol(math, ams, rel, "\u21a2", "\\leftarrowtail", true);
            defineSymbol(math, ams, rel, "\u21ab", "\\looparrowleft", true);
            defineSymbol(math, ams, rel, "\u21cb", "\\leftrightharpoons", true);
            defineSymbol(math, ams, rel, "\u21b6", "\\curvearrowleft", true); // unicode-math maps \u21ba to \acwopencirclearrow. We'll use the AMS synonym.
            defineSymbol(math, ams, rel, "\u21ba", "\\circlearrowleft", true);
            defineSymbol(math, ams, rel, "\u21b0", "\\Lsh", true);
            defineSymbol(math, ams, rel, "\u21c8", "\\upuparrows", true);
            defineSymbol(math, ams, rel, "\u21bf", "\\upharpoonleft", true);
            defineSymbol(math, ams, rel, "\u21c3", "\\downharpoonleft", true);
            defineSymbol(math, ams, rel, "\u22b8", "\\multimap", true);
            defineSymbol(math, ams, rel, "\u21ad", "\\leftrightsquigarrow", true);
            defineSymbol(math, ams, rel, "\u21c9", "\\rightrightarrows", true);
            defineSymbol(math, ams, rel, "\u21c4", "\\rightleftarrows", true);
            defineSymbol(math, ams, rel, "\u21a0", "\\twoheadrightarrow", true);
            defineSymbol(math, ams, rel, "\u21a3", "\\rightarrowtail", true);
            defineSymbol(math, ams, rel, "\u21ac", "\\looparrowright", true);
            defineSymbol(math, ams, rel, "\u21b7", "\\curvearrowright", true); // unicode-math maps \u21bb to \cwopencirclearrow. We'll use the AMS synonym.
            defineSymbol(math, ams, rel, "\u21bb", "\\circlearrowright", true);
            defineSymbol(math, ams, rel, "\u21b1", "\\Rsh", true);
            defineSymbol(math, ams, rel, "\u21ca", "\\downdownarrows", true);
            defineSymbol(math, ams, rel, "\u21be", "\\upharpoonright", true);
            defineSymbol(math, ams, rel, "\u21c2", "\\downharpoonright", true);
            defineSymbol(math, ams, rel, "\u21dd", "\\rightsquigarrow", true);
            defineSymbol(math, ams, rel, "\u21dd", "\\leadsto");
            defineSymbol(math, ams, rel, "\u21db", "\\Rrightarrow", true);
            defineSymbol(math, ams, rel, "\u21be", "\\restriction");
            defineSymbol(math, main, textord, "\u2018", "`");
            defineSymbol(math, main, textord, "$", "\\$");
            defineSymbol(text$1, main, textord, "$", "\\$");
            defineSymbol(text$1, main, textord, "$", "\\textdollar");
            defineSymbol(math, main, textord, "%", "\\%");
            defineSymbol(text$1, main, textord, "%", "\\%");
            defineSymbol(math, main, textord, "_", "\\_");
            defineSymbol(text$1, main, textord, "_", "\\_");
            defineSymbol(text$1, main, textord, "_", "\\textunderscore");
            defineSymbol(math, main, textord, "\u2220", "\\angle", true);
            defineSymbol(math, main, textord, "\u221e", "\\infty", true);
            defineSymbol(math, main, textord, "\u2032", "\\prime");
            defineSymbol(math, main, textord, "\u25b3", "\\triangle");
            defineSymbol(math, main, textord, "\u0393", "\\Gamma", true);
            defineSymbol(math, main, textord, "\u0394", "\\Delta", true);
            defineSymbol(math, main, textord, "\u0398", "\\Theta", true);
            defineSymbol(math, main, textord, "\u039b", "\\Lambda", true);
            defineSymbol(math, main, textord, "\u039e", "\\Xi", true);
            defineSymbol(math, main, textord, "\u03a0", "\\Pi", true);
            defineSymbol(math, main, textord, "\u03a3", "\\Sigma", true);
            defineSymbol(math, main, textord, "\u03a5", "\\Upsilon", true);
            defineSymbol(math, main, textord, "\u03a6", "\\Phi", true);
            defineSymbol(math, main, textord, "\u03a8", "\\Psi", true);
            defineSymbol(math, main, textord, "\u03a9", "\\Omega", true);
            defineSymbol(math, main, textord, "A", "\u0391");
            defineSymbol(math, main, textord, "B", "\u0392");
            defineSymbol(math, main, textord, "E", "\u0395");
            defineSymbol(math, main, textord, "Z", "\u0396");
            defineSymbol(math, main, textord, "H", "\u0397");
            defineSymbol(math, main, textord, "I", "\u0399");
            defineSymbol(math, main, textord, "K", "\u039A");
            defineSymbol(math, main, textord, "M", "\u039C");
            defineSymbol(math, main, textord, "N", "\u039D");
            defineSymbol(math, main, textord, "O", "\u039F");
            defineSymbol(math, main, textord, "P", "\u03A1");
            defineSymbol(math, main, textord, "T", "\u03A4");
            defineSymbol(math, main, textord, "X", "\u03A7");
            defineSymbol(math, main, textord, "\u00ac", "\\neg", true);
            defineSymbol(math, main, textord, "\u00ac", "\\lnot");
            defineSymbol(math, main, textord, "\u22a4", "\\top");
            defineSymbol(math, main, textord, "\u22a5", "\\bot");
            defineSymbol(math, main, textord, "\u2205", "\\emptyset");
            defineSymbol(math, ams, textord, "\u2205", "\\varnothing");
            defineSymbol(math, main, mathord, "\u03b1", "\\alpha", true);
            defineSymbol(math, main, mathord, "\u03b2", "\\beta", true);
            defineSymbol(math, main, mathord, "\u03b3", "\\gamma", true);
            defineSymbol(math, main, mathord, "\u03b4", "\\delta", true);
            defineSymbol(math, main, mathord, "\u03f5", "\\epsilon", true);
            defineSymbol(math, main, mathord, "\u03b6", "\\zeta", true);
            defineSymbol(math, main, mathord, "\u03b7", "\\eta", true);
            defineSymbol(math, main, mathord, "\u03b8", "\\theta", true);
            defineSymbol(math, main, mathord, "\u03b9", "\\iota", true);
            defineSymbol(math, main, mathord, "\u03ba", "\\kappa", true);
            defineSymbol(math, main, mathord, "\u03bb", "\\lambda", true);
            defineSymbol(math, main, mathord, "\u03bc", "\\mu", true);
            defineSymbol(math, main, mathord, "\u03bd", "\\nu", true);
            defineSymbol(math, main, mathord, "\u03be", "\\xi", true);
            defineSymbol(math, main, mathord, "\u03bf", "\\omicron", true);
            defineSymbol(math, main, mathord, "\u03c0", "\\pi", true);
            defineSymbol(math, main, mathord, "\u03c1", "\\rho", true);
            defineSymbol(math, main, mathord, "\u03c3", "\\sigma", true);
            defineSymbol(math, main, mathord, "\u03c4", "\\tau", true);
            defineSymbol(math, main, mathord, "\u03c5", "\\upsilon", true);
            defineSymbol(math, main, mathord, "\u03d5", "\\phi", true);
            defineSymbol(math, main, mathord, "\u03c7", "\\chi", true);
            defineSymbol(math, main, mathord, "\u03c8", "\\psi", true);
            defineSymbol(math, main, mathord, "\u03c9", "\\omega", true);
            defineSymbol(math, main, mathord, "\u03b5", "\\varepsilon", true);
            defineSymbol(math, main, mathord, "\u03d1", "\\vartheta", true);
            defineSymbol(math, main, mathord, "\u03d6", "\\varpi", true);
            defineSymbol(math, main, mathord, "\u03f1", "\\varrho", true);
            defineSymbol(math, main, mathord, "\u03c2", "\\varsigma", true);
            defineSymbol(math, main, mathord, "\u03c6", "\\varphi", true);
            defineSymbol(math, main, bin, "\u2217", "*");
            defineSymbol(math, main, bin, "+", "+");
            defineSymbol(math, main, bin, "\u2212", "-");
            defineSymbol(math, main, bin, "\u22c5", "\\cdot", true);
            defineSymbol(math, main, bin, "\u2218", "\\circ");
            defineSymbol(math, main, bin, "\u00f7", "\\div", true);
            defineSymbol(math, main, bin, "\u00b1", "\\pm", true);
            defineSymbol(math, main, bin, "\u00d7", "\\times", true);
            defineSymbol(math, main, bin, "\u2229", "\\cap", true);
            defineSymbol(math, main, bin, "\u222a", "\\cup", true);
            defineSymbol(math, main, bin, "\u2216", "\\setminus");
            defineSymbol(math, main, bin, "\u2227", "\\land");
            defineSymbol(math, main, bin, "\u2228", "\\lor");
            defineSymbol(math, main, bin, "\u2227", "\\wedge", true);
            defineSymbol(math, main, bin, "\u2228", "\\vee", true);
            defineSymbol(math, main, textord, "\u221a", "\\surd");
            defineSymbol(math, main, open, "(", "(");
            defineSymbol(math, main, open, "[", "[");
            defineSymbol(math, main, open, "\u27e8", "\\langle", true);
            defineSymbol(math, main, open, "\u2223", "\\lvert");
            defineSymbol(math, main, open, "\u2225", "\\lVert");
            defineSymbol(math, main, close, ")", ")");
            defineSymbol(math, main, close, "]", "]");
            defineSymbol(math, main, close, "?", "?");
            defineSymbol(math, main, close, "!", "!");
            defineSymbol(math, main, close, "\u27e9", "\\rangle", true);
            defineSymbol(math, main, close, "\u2223", "\\rvert");
            defineSymbol(math, main, close, "\u2225", "\\rVert");
            defineSymbol(math, main, rel, "=", "=");
            defineSymbol(math, main, rel, "<", "<");
            defineSymbol(math, main, rel, ">", ">");
            defineSymbol(math, main, rel, ":", ":");
            defineSymbol(math, main, rel, "\u2248", "\\approx", true);
            defineSymbol(math, main, rel, "\u2245", "\\cong", true);
            defineSymbol(math, main, rel, "\u2265", "\\ge");
            defineSymbol(math, main, rel, "\u2265", "\\geq", true);
            defineSymbol(math, main, rel, "\u2190", "\\gets");
            defineSymbol(math, main, rel, ">", "\\gt");
            defineSymbol(math, main, rel, "\u2208", "\\in", true);
            defineSymbol(math, main, rel, "\ue020", "\\@not");
            defineSymbol(math, main, rel, "\u2282", "\\subset", true);
            defineSymbol(math, main, rel, "\u2283", "\\supset", true);
            defineSymbol(math, main, rel, "\u2286", "\\subseteq", true);
            defineSymbol(math, main, rel, "\u2287", "\\supseteq", true);
            defineSymbol(math, ams, rel, "\u2288", "\\nsubseteq", true);
            defineSymbol(math, ams, rel, "\u2289", "\\nsupseteq", true);
            defineSymbol(math, main, rel, "\u22a8", "\\models");
            defineSymbol(math, main, rel, "\u2190", "\\leftarrow", true);
            defineSymbol(math, main, rel, "\u2264", "\\le");
            defineSymbol(math, main, rel, "\u2264", "\\leq", true);
            defineSymbol(math, main, rel, "<", "\\lt");
            defineSymbol(math, main, rel, "\u2192", "\\rightarrow", true);
            defineSymbol(math, main, rel, "\u2192", "\\to");
            defineSymbol(math, ams, rel, "\u2271", "\\ngeq", true);
            defineSymbol(math, ams, rel, "\u2270", "\\nleq", true);
            defineSymbol(math, main, spacing, "\u00a0", "\\ ");
            defineSymbol(math, main, spacing, "\u00a0", "~");
            defineSymbol(math, main, spacing, "\u00a0", "\\space"); // Ref: LaTeX Source 2e: \DeclareRobustCommand{\nobreakspace}{%
            defineSymbol(math, main, spacing, "\u00a0", "\\nobreakspace");
            defineSymbol(text$1, main, spacing, "\u00a0", "\\ ");
            defineSymbol(text$1, main, spacing, "\u00a0", "~");
            defineSymbol(text$1, main, spacing, "\u00a0", "\\space");
            defineSymbol(text$1, main, spacing, "\u00a0", "\\nobreakspace");
            defineSymbol(math, main, spacing, null, "\\nobreak");
            defineSymbol(math, main, spacing, null, "\\allowbreak");
            defineSymbol(math, main, punct, ",", ",");
            defineSymbol(math, main, punct, ";", ";");
            defineSymbol(math, ams, bin, "\u22bc", "\\barwedge", true);
            defineSymbol(math, ams, bin, "\u22bb", "\\veebar", true);
            defineSymbol(math, main, bin, "\u2299", "\\odot", true);
            defineSymbol(math, main, bin, "\u2295", "\\oplus", true);
            defineSymbol(math, main, bin, "\u2297", "\\otimes", true);
            defineSymbol(math, main, textord, "\u2202", "\\partial", true);
            defineSymbol(math, main, bin, "\u2298", "\\oslash", true);
            defineSymbol(math, ams, bin, "\u229a", "\\circledcirc", true);
            defineSymbol(math, ams, bin, "\u22a1", "\\boxdot", true);
            defineSymbol(math, main, bin, "\u25b3", "\\bigtriangleup");
            defineSymbol(math, main, bin, "\u25bd", "\\bigtriangledown");
            defineSymbol(math, main, bin, "\u2020", "\\dagger");
            defineSymbol(math, main, bin, "\u22c4", "\\diamond");
            defineSymbol(math, main, bin, "\u22c6", "\\star");
            defineSymbol(math, main, bin, "\u25c3", "\\triangleleft");
            defineSymbol(math, main, bin, "\u25b9", "\\triangleright");
            defineSymbol(math, main, open, "{", "\\{");
            defineSymbol(text$1, main, textord, "{", "\\{");
            defineSymbol(text$1, main, textord, "{", "\\textbraceleft");
            defineSymbol(math, main, close, "}", "\\}");
            defineSymbol(text$1, main, textord, "}", "\\}");
            defineSymbol(text$1, main, textord, "}", "\\textbraceright");
            defineSymbol(math, main, open, "{", "\\lbrace");
            defineSymbol(math, main, close, "}", "\\rbrace");
            defineSymbol(math, main, open, "[", "\\lbrack");
            defineSymbol(text$1, main, textord, "[", "\\lbrack");
            defineSymbol(math, main, close, "]", "\\rbrack");
            defineSymbol(text$1, main, textord, "]", "\\rbrack");
            defineSymbol(math, main, open, "(", "\\lparen");
            defineSymbol(math, main, close, ")", "\\rparen");
            defineSymbol(text$1, main, textord, "<", "\\textless"); // in T1 fontenc
            defineSymbol(text$1, main, textord, ">", "\\textgreater"); // in T1 fontenc
            defineSymbol(math, main, open, "\u230a", "\\lfloor", true);
            defineSymbol(math, main, close, "\u230b", "\\rfloor", true);
            defineSymbol(math, main, open, "\u2308", "\\lceil", true);
            defineSymbol(math, main, close, "\u2309", "\\rceil", true);
            defineSymbol(math, main, textord, "\\", "\\backslash");
            defineSymbol(math, main, textord, "\u2223", "|");
            defineSymbol(math, main, textord, "\u2223", "\\vert");
            defineSymbol(text$1, main, textord, "|", "\\textbar"); // in T1 fontenc
            defineSymbol(math, main, textord, "\u2225", "\\|");
            defineSymbol(math, main, textord, "\u2225", "\\Vert");
            defineSymbol(text$1, main, textord, "\u2225", "\\textbardbl");
            defineSymbol(text$1, main, textord, "~", "\\textasciitilde");
            defineSymbol(text$1, main, textord, "\\", "\\textbackslash");
            defineSymbol(text$1, main, textord, "^", "\\textasciicircum");
            defineSymbol(math, main, rel, "\u2191", "\\uparrow", true);
            defineSymbol(math, main, rel, "\u21d1", "\\Uparrow", true);
            defineSymbol(math, main, rel, "\u2193", "\\downarrow", true);
            defineSymbol(math, main, rel, "\u21d3", "\\Downarrow", true);
            defineSymbol(math, main, rel, "\u2195", "\\updownarrow", true);
            defineSymbol(math, main, rel, "\u21d5", "\\Updownarrow", true);
            defineSymbol(math, main, op, "\u2210", "\\coprod");
            defineSymbol(math, main, op, "\u22c1", "\\bigvee");
            defineSymbol(math, main, op, "\u22c0", "\\bigwedge");
            defineSymbol(math, main, op, "\u2a04", "\\biguplus");
            defineSymbol(math, main, op, "\u22c2", "\\bigcap");
            defineSymbol(math, main, op, "\u22c3", "\\bigcup");
            defineSymbol(math, main, op, "\u222b", "\\int");
            defineSymbol(math, main, op, "\u222b", "\\intop");
            defineSymbol(math, main, op, "\u222c", "\\iint");
            defineSymbol(math, main, op, "\u222d", "\\iiint");
            defineSymbol(math, main, op, "\u220f", "\\prod");
            defineSymbol(math, main, op, "\u2211", "\\sum");
            defineSymbol(math, main, op, "\u2a02", "\\bigotimes");
            defineSymbol(math, main, op, "\u2a01", "\\bigoplus");
            defineSymbol(math, main, op, "\u2a00", "\\bigodot");
            defineSymbol(math, main, op, "\u222e", "\\oint");
            defineSymbol(math, main, op, "\u222f", "\\oiint");
            defineSymbol(math, main, op, "\u2230", "\\oiiint");
            defineSymbol(math, main, op, "\u2a06", "\\bigsqcup");
            defineSymbol(math, main, op, "\u222b", "\\smallint");
            defineSymbol(text$1, main, inner, "\u2026", "\\textellipsis");
            defineSymbol(math, main, inner, "\u2026", "\\mathellipsis");
            defineSymbol(text$1, main, inner, "\u2026", "\\ldots", true);
            defineSymbol(math, main, inner, "\u2026", "\\ldots", true);
            defineSymbol(math, main, inner, "\u22ef", "\\@cdots", true);
            defineSymbol(math, main, inner, "\u22f1", "\\ddots", true);
            defineSymbol(math, main, textord, "\u22ee", "\\varvdots"); // \vdots is a macro
            defineSymbol(math, main, accent, "\u02ca", "\\acute");
            defineSymbol(math, main, accent, "\u02cb", "\\grave");
            defineSymbol(math, main, accent, "\u00a8", "\\ddot");
            defineSymbol(math, main, accent, "\u007e", "\\tilde");
            defineSymbol(math, main, accent, "\u02c9", "\\bar");
            defineSymbol(math, main, accent, "\u02d8", "\\breve");
            defineSymbol(math, main, accent, "\u02c7", "\\check");
            defineSymbol(math, main, accent, "\u005e", "\\hat");
            defineSymbol(math, main, accent, "\u20d7", "\\vec");
            defineSymbol(math, main, accent, "\u02d9", "\\dot");
            defineSymbol(math, main, accent, "\u02da", "\\mathring");
            defineSymbol(math, main, mathord, "\u0131", "\\imath", true);
            defineSymbol(math, main, mathord, "\u0237", "\\jmath", true);
            defineSymbol(text$1, main, textord, "\u0131", "\\i", true);
            defineSymbol(text$1, main, textord, "\u0237", "\\j", true);
            defineSymbol(text$1, main, textord, "\u00df", "\\ss", true);
            defineSymbol(text$1, main, textord, "\u00e6", "\\ae", true);
            defineSymbol(text$1, main, textord, "\u00e6", "\\ae", true);
            defineSymbol(text$1, main, textord, "\u0153", "\\oe", true);
            defineSymbol(text$1, main, textord, "\u00f8", "\\o", true);
            defineSymbol(text$1, main, textord, "\u00c6", "\\AE", true);
            defineSymbol(text$1, main, textord, "\u0152", "\\OE", true);
            defineSymbol(text$1, main, textord, "\u00d8", "\\O", true);
            defineSymbol(text$1, main, accent, "\u02ca", "\\'"); // acute
            defineSymbol(text$1, main, accent, "\u02cb", "\\`"); // grave
            defineSymbol(text$1, main, accent, "\u02c6", "\\^"); // circumflex
            defineSymbol(text$1, main, accent, "\u02dc", "\\~"); // tilde
            defineSymbol(text$1, main, accent, "\u02c9", "\\="); // macron
            defineSymbol(text$1, main, accent, "\u02d8", "\\u"); // breve
            defineSymbol(text$1, main, accent, "\u02d9", "\\."); // dot above
            defineSymbol(text$1, main, accent, "\u02da", "\\r"); // ring above
            defineSymbol(text$1, main, accent, "\u02c7", "\\v"); // caron
            defineSymbol(text$1, main, accent, "\u00a8", '\\"'); // diaresis
            defineSymbol(text$1, main, accent, "\u02dd", "\\H"); // double acute
            defineSymbol(text$1, main, accent, "\u25ef", "\\textcircled"); // \bigcirc glyph
            // These ligatures are detected and created in Parser.js's `formLigatures`.
            ligatures = {
                "--": true,
                "---": true,
                "``": true,
                "''": true
            };
            defineSymbol(text$1, main, textord, "\u2013", "--");
            defineSymbol(text$1, main, textord, "\u2013", "\\textendash");
            defineSymbol(text$1, main, textord, "\u2014", "---");
            defineSymbol(text$1, main, textord, "\u2014", "\\textemdash");
            defineSymbol(text$1, main, textord, "\u2018", "`");
            defineSymbol(text$1, main, textord, "\u2018", "\\textquoteleft");
            defineSymbol(text$1, main, textord, "\u2019", "'");
            defineSymbol(text$1, main, textord, "\u2019", "\\textquoteright");
            defineSymbol(text$1, main, textord, "\u201c", "``");
            defineSymbol(text$1, main, textord, "\u201c", "\\textquotedblleft");
            defineSymbol(text$1, main, textord, "\u201d", "''");
            defineSymbol(text$1, main, textord, "\u201d", "\\textquotedblright"); //  \degree from gensymb package
            defineSymbol(math, main, textord, "\u00b0", "\\degree", true);
            defineSymbol(text$1, main, textord, "\u00b0", "\\degree"); // \textdegree from inputenc package
            defineSymbol(text$1, main, textord, "\u00b0", "\\textdegree", true); // TODO: In LaTeX, \pounds can generate a different character in text and math
            // mode, but among our fonts, only Main-Italic defines this character "163".
            defineSymbol(math, main, mathord, "\u00a3", "\\pounds");
            defineSymbol(math, main, mathord, "\u00a3", "\\mathsterling", true);
            defineSymbol(text$1, main, mathord, "\u00a3", "\\pounds");
            defineSymbol(text$1, main, mathord, "\u00a3", "\\textsterling", true);
            defineSymbol(math, ams, textord, "\u2720", "\\maltese");
            defineSymbol(text$1, ams, textord, "\u2720", "\\maltese");
            defineSymbol(text$1, main, spacing, "\u00a0", "\\ ");
            defineSymbol(text$1, main, spacing, "\u00a0", " ");
            defineSymbol(text$1, main, spacing, "\u00a0", "~"); // There are lots of symbols which are the same, so we add them in afterwards.
            // All of these are textords in math mode
            mathTextSymbols = "0123456789/@.\"";
            for (let i = 0; i < mathTextSymbols.length; i++) {
                const ch = mathTextSymbols.charAt(i);
                defineSymbol(math, main, textord, ch, ch);
            } // All of these are textords in text mode
            textSymbols = "0123456789!@*()-=+[]<>|\";:?/.,";
            for (let i = 0; i < textSymbols.length; i++) {
                const ch = textSymbols.charAt(i);
                defineSymbol(text$1, main, textord, ch, ch);
            } // All of these are textords in text mode, and mathords in math mode
            letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
            for (let i = 0; i < letters.length; i++) {
                const ch = letters.charAt(i);
                defineSymbol(math, main, mathord, ch, ch);
                defineSymbol(text$1, main, textord, ch, ch);
            } // Blackboard bold and script letters in Unicode range
            defineSymbol(math, ams, textord, "C", "\u2102"); // blackboard bold
            defineSymbol(text$1, ams, textord, "C", "\u2102");
            defineSymbol(math, ams, textord, "H", "\u210D");
            defineSymbol(text$1, ams, textord, "H", "\u210D");
            defineSymbol(math, ams, textord, "N", "\u2115");
            defineSymbol(text$1, ams, textord, "N", "\u2115");
            defineSymbol(math, ams, textord, "P", "\u2119");
            defineSymbol(text$1, ams, textord, "P", "\u2119");
            defineSymbol(math, ams, textord, "Q", "\u211A");
            defineSymbol(text$1, ams, textord, "Q", "\u211A");
            defineSymbol(math, ams, textord, "R", "\u211D");
            defineSymbol(text$1, ams, textord, "R", "\u211D");
            defineSymbol(math, ams, textord, "Z", "\u2124");
            defineSymbol(text$1, ams, textord, "Z", "\u2124");
            defineSymbol(math, main, mathord, "h", "\u210E"); // italic h, Planck constant
            defineSymbol(text$1, main, mathord, "h", "\u210E"); // The next loop loads wide (surrogate pair) characters.
            // We support some letters in the Unicode range U+1D400 to U+1D7FF,
            // Mathematical Alphanumeric Symbols.
            // Some editors do not deal well with wide characters. So don't write the
            // string into this file. Instead, create the string from the surrogate pair.
            wideChar = "";
            for (let i = 0; i < letters.length; i++) {
                const ch = letters.charAt(i); // The hex numbers in the next line are a surrogate pair.
                // 0xD835 is the high surrogate for all letters in the range we support.
                // 0xDC00 is the low surrogate for bold A.
                wideChar = String.fromCharCode(0xD835, 0xDC00 + i); // A-Z a-z bold
                defineSymbol(math, main, mathord, ch, wideChar);
                defineSymbol(text$1, main, textord, ch, wideChar);
                wideChar = String.fromCharCode(0xD835, 0xDC34 + i); // A-Z a-z italic
                defineSymbol(math, main, mathord, ch, wideChar);
                defineSymbol(text$1, main, textord, ch, wideChar);
                wideChar = String.fromCharCode(0xD835, 0xDC68 + i); // A-Z a-z bold italic
                defineSymbol(math, main, mathord, ch, wideChar);
                defineSymbol(text$1, main, textord, ch, wideChar);
                wideChar = String.fromCharCode(0xD835, 0xDD04 + i); // A-Z a-z Fractur
                defineSymbol(math, main, mathord, ch, wideChar);
                defineSymbol(text$1, main, textord, ch, wideChar);
                wideChar = String.fromCharCode(0xD835, 0xDDA0 + i); // A-Z a-z sans-serif
                defineSymbol(math, main, mathord, ch, wideChar);
                defineSymbol(text$1, main, textord, ch, wideChar);
                wideChar = String.fromCharCode(0xD835, 0xDDD4 + i); // A-Z a-z sans bold
                defineSymbol(math, main, mathord, ch, wideChar);
                defineSymbol(text$1, main, textord, ch, wideChar);
                wideChar = String.fromCharCode(0xD835, 0xDE08 + i); // A-Z a-z sans italic
                defineSymbol(math, main, mathord, ch, wideChar);
                defineSymbol(text$1, main, textord, ch, wideChar);
                wideChar = String.fromCharCode(0xD835, 0xDE70 + i); // A-Z a-z monospace
                defineSymbol(math, main, mathord, ch, wideChar);
                defineSymbol(text$1, main, textord, ch, wideChar);
                if (i < 26) {
                    // KaTeX fonts have only capital letters for blackboard bold and script.
                    // See exception for k below.
                    wideChar = String.fromCharCode(0xD835, 0xDD38 + i); // A-Z double struck
                    defineSymbol(math, main, mathord, ch, wideChar);
                    defineSymbol(text$1, main, textord, ch, wideChar);
                    wideChar = String.fromCharCode(0xD835, 0xDC9C + i); // A-Z script
                    defineSymbol(math, main, mathord, ch, wideChar);
                    defineSymbol(text$1, main, textord, ch, wideChar);
                } // TODO: Add bold script when it is supported by a KaTeX font.
            } // "k" is the only double struck lower case letter in the KaTeX fonts.
            wideChar = String.fromCharCode(0xD835, 0xDD5C); // k double struck
            defineSymbol(math, main, mathord, "k", wideChar);
            defineSymbol(text$1, main, textord, "k", wideChar); // Next, some wide character numerals
            for (let i = 0; i < 10; i++) {
                const ch = i.toString();
                wideChar = String.fromCharCode(0xD835, 0xDFCE + i); // 0-9 bold
                defineSymbol(math, main, mathord, ch, wideChar);
                defineSymbol(text$1, main, textord, ch, wideChar);
                wideChar = String.fromCharCode(0xD835, 0xDFE2 + i); // 0-9 sans serif
                defineSymbol(math, main, mathord, ch, wideChar);
                defineSymbol(text$1, main, textord, ch, wideChar);
                wideChar = String.fromCharCode(0xD835, 0xDFEC + i); // 0-9 bold sans
                defineSymbol(math, main, mathord, ch, wideChar);
                defineSymbol(text$1, main, textord, ch, wideChar);
                wideChar = String.fromCharCode(0xD835, 0xDFF6 + i); // 0-9 monospace
                defineSymbol(math, main, mathord, ch, wideChar);
                defineSymbol(text$1, main, textord, ch, wideChar);
            } // We add these Latin-1 letters as symbols for backwards-compatibility,
            // but they are not actually in the font, nor are they supported by the
            // Unicode accent mechanism, so they fall back to Times font and look ugly.
            // TODO(edemaine): Fix this.
            extraLatin = "";
            for (let i = 0; i < extraLatin.length; i++) {
                const ch = extraLatin.charAt(i);
                defineSymbol(math, main, mathord, ch, ch);
                defineSymbol(text$1, main, textord, ch, ch);
            }
            defineSymbol(text$1, main, textord, "", ""); // Unicode versions of existing characters
            defineSymbol(text$1, main, textord, "\u2013", "");
            defineSymbol(text$1, main, textord, "\u2014", "");
            defineSymbol(text$1, main, textord, "\u2018", "");
            defineSymbol(text$1, main, textord, "\u2019", "");
            defineSymbol(text$1, main, textord, "\u201c", "");
            defineSymbol(text$1, main, textord, "\u201d", "");
            /**
             * This file provides support for Unicode range U+1D400 to U+1D7FF,
             * Mathematical Alphanumeric Symbols.
             *
             * Function wideCharacterFont takes a wide character as input and returns
             * the font information necessary to render it properly.
             */
            /**
             * Data below is from https://www.unicode.org/charts/PDF/U1D400.pdf
             * That document sorts characters into groups by font type, say bold or italic.
             *
             * In the arrays below, each subarray consists three elements:
             *      * The CSS class of that group when in math mode.
             *      * The CSS class of that group when in text mode.
             *      * The font name, so that KaTeX can get font metrics.
             */
            wideLatinLetterData = [["mathbf", "textbf", "Main-Bold"],
                ["mathbf", "textbf", "Main-Bold"],
                ["mathdefault", "textit", "Math-Italic"],
                ["mathdefault", "textit", "Math-Italic"],
                ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
                ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
                // Map fancy A-Z letters to script, not calligraphic.
                // This aligns with unicode-math and math fonts (except Cambria Math).
                ["mathscr", "textscr", "Script-Regular"],
                ["", "", ""],
                ["", "", ""],
                ["", "", ""],
                ["mathfrak", "textfrak", "Fraktur-Regular"],
                ["mathfrak", "textfrak", "Fraktur-Regular"],
                ["mathbb", "textbb", "AMS-Regular"],
                ["mathbb", "textbb", "AMS-Regular"],
                ["", "", ""],
                ["", "", ""],
                ["mathsf", "textsf", "SansSerif-Regular"],
                ["mathsf", "textsf", "SansSerif-Regular"],
                ["mathboldsf", "textboldsf", "SansSerif-Bold"],
                ["mathboldsf", "textboldsf", "SansSerif-Bold"],
                ["mathitsf", "textitsf", "SansSerif-Italic"],
                ["mathitsf", "textitsf", "SansSerif-Italic"],
                ["", "", ""],
                ["", "", ""],
                ["mathtt", "texttt", "Typewriter-Regular"],
                ["mathtt", "texttt", "Typewriter-Regular"]];
            wideNumeralData = [["mathbf", "textbf", "Main-Bold"],
                ["", "", ""],
                ["mathsf", "textsf", "SansSerif-Regular"],
                ["mathboldsf", "textboldsf", "SansSerif-Bold"],
                ["mathtt", "texttt", "Typewriter-Regular"]];
            wideCharacterFont = function wideCharacterFont(wideChar, mode) {
                // IE doesn't support codePointAt(). So work with the surrogate pair.
                const H = wideChar.charCodeAt(0); // high surrogate
                const L = wideChar.charCodeAt(1); // low surrogate
                const codePoint = (H - 0xD800) * 0x400 + (L - 0xDC00) + 0x10000;
                const j = mode === "math" ? 0 : 1; // column index for CSS class.
                if (0x1D400 <= codePoint && codePoint < 0x1D6A4) {
                    // wideLatinLetterData contains exactly 26 chars on each row.
                    // So we can calculate the relevant row. No traverse necessary.
                    const i = Math.floor((codePoint - 0x1D400) / 26);
                    return [wideLatinLetterData[i][2], wideLatinLetterData[i][j]];
                }
                else if (0x1D7CE <= codePoint && codePoint <= 0x1D7FF) {
                    // Numerals, ten per row.
                    const i = Math.floor((codePoint - 0x1D7CE) / 10);
                    return [wideNumeralData[i][2], wideNumeralData[i][j]];
                }
                else if (codePoint === 0x1D6A5 || codePoint === 0x1D6A6) {
                    // dotless i or j
                    return [wideLatinLetterData[0][2], wideLatinLetterData[0][j]];
                }
                else if (0x1D6A6 < codePoint && codePoint < 0x1D7CE) {
                    // Greek letters. Not supported, yet.
                    return ["", ""];
                }
                else {
                    // We don't support any wide characters outside 1D4001D7FF.
                    throw new ParseError("Unsupported character: " + wideChar);
                }
            };
            /**
             * This file contains information about the options that the Parser carries
             * around with it while parsing. Data is held in an `Options` object, and when
             * recursing, a new `Options` object can be created with the `.with*` and
             * `.reset` functions.
             */
            sizeStyleMap = [
                // The size mappings are taken from TeX with \normalsize=10pt.
                [1, 1, 1],
                [2, 1, 1],
                [3, 1, 1],
                [4, 2, 1],
                [5, 2, 1],
                [6, 3, 1],
                [7, 4, 2],
                [8, 6, 3],
                [9, 7, 6],
                [10, 8, 7],
                [11, 10, 9]
            ];
            sizeMultipliers = [
                // you change size indexes, change that function.
                0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.2, 1.44, 1.728, 2.074, 2.488
            ];
            sizeAtStyle = function sizeAtStyle(size, style) {
                return style.size < 2 ? size : sizeStyleMap[size - 1][style.size - 1];
            }; // In these types, "" (empty string) means "no change".
            /**
             * This is the main options class. It contains the current style, size, color,
             * and font.
             *
             * Options objects should not be modified. To create a new Options with
             * different properties, call a `.having*` method.
             */
            Options = class Options {
                // A font family applies to a group of fonts (i.e. SansSerif), while a font
                // represents a specific font (i.e. SansSerif Bold).
                // See: https://tex.stackexchange.com/questions/22350/difference-between-textrm-and-mathrm
                /**
                 * The base size index.
                 */
                constructor(data) {
                    this.style = void 0;
                    this.color = void 0;
                    this.size = void 0;
                    this.textSize = void 0;
                    this.phantom = void 0;
                    this.font = void 0;
                    this.fontFamily = void 0;
                    this.fontWeight = void 0;
                    this.fontShape = void 0;
                    this.sizeMultiplier = void 0;
                    this.maxSize = void 0;
                    this.minRuleThickness = void 0;
                    this._fontMetrics = void 0;
                    this.style = data.style;
                    this.color = data.color;
                    this.size = data.size || Options.BASESIZE;
                    this.textSize = data.textSize || this.size;
                    this.phantom = !!data.phantom;
                    this.font = data.font || "";
                    this.fontFamily = data.fontFamily || "";
                    this.fontWeight = data.fontWeight || '';
                    this.fontShape = data.fontShape || '';
                    this.sizeMultiplier = sizeMultipliers[this.size - 1];
                    this.maxSize = data.maxSize;
                    this.minRuleThickness = data.minRuleThickness;
                    this._fontMetrics = undefined;
                }
                /**
                 * Returns a new options object with the same properties as "this".  Properties
                 * from "extension" will be copied to the new options object.
                 */
                extend(extension) {
                    const data = {
                        style: this.style,
                        size: this.size,
                        textSize: this.textSize,
                        color: this.color,
                        phantom: this.phantom,
                        font: this.font,
                        fontFamily: this.fontFamily,
                        fontWeight: this.fontWeight,
                        fontShape: this.fontShape,
                        maxSize: this.maxSize,
                        minRuleThickness: this.minRuleThickness
                    };
                    for (const key in extension) {
                        if (extension.hasOwnProperty(key)) {
                            data[key] = extension[key];
                        }
                    }
                    return new Options(data);
                }
                /**
                 * Return an options object with the given style. If `this.style === style`,
                 * returns `this`.
                 */
                havingStyle(style) {
                    if (this.style === style) {
                        return this;
                    }
                    else {
                        return this.extend({
                            style: style,
                            size: sizeAtStyle(this.textSize, style)
                        });
                    }
                }
                /**
                 * Return an options object with a cramped version of the current style. If
                 * the current style is cramped, returns `this`.
                 */
                havingCrampedStyle() {
                    return this.havingStyle(this.style.cramp());
                }
                /**
                 * Return an options object with the given size and in at least `\textstyle`.
                 * Returns `this` if appropriate.
                 */
                havingSize(size) {
                    if (this.size === size && this.textSize === size) {
                        return this;
                    }
                    else {
                        return this.extend({
                            style: this.style.text(),
                            size: size,
                            textSize: size,
                            sizeMultiplier: sizeMultipliers[size - 1]
                        });
                    }
                }
                /**
                 * Like `this.havingSize(BASESIZE).havingStyle(style)`. If `style` is omitted,
                 * changes to at least `\textstyle`.
                 */
                havingBaseStyle(style) {
                    style = style || this.style.text();
                    const wantSize = sizeAtStyle(Options.BASESIZE, style);
                    if (this.size === wantSize && this.textSize === Options.BASESIZE && this.style === style) {
                        return this;
                    }
                    else {
                        return this.extend({
                            style: style,
                            size: wantSize
                        });
                    }
                }
                /**
                 * Remove the effect of sizing changes such as \Huge.
                 * Keep the effect of the current style, such as \scriptstyle.
                 */
                havingBaseSizing() {
                    let size;
                    switch (this.style.id) {
                        case 4:
                        case 5:
                            size = 3; // normalsize in scriptstyle
                            break;
                        case 6:
                        case 7:
                            size = 1; // normalsize in scriptscriptstyle
                            break;
                        default:
                            size = 6;
                        // normalsize in textstyle or displaystyle
                    }
                    return this.extend({
                        style: this.style.text(),
                        size: size
                    });
                }
                /**
                 * Create a new options object with the given color.
                 */
                withColor(color) {
                    return this.extend({
                        color: color
                    });
                }
                /**
                 * Create a new options object with "phantom" set to true.
                 */
                withPhantom() {
                    return this.extend({
                        phantom: true
                    });
                }
                /**
                 * Creates a new options object with the given math font or old text font.
                 * @type {[type]}
                 */
                withFont(font) {
                    return this.extend({
                        font
                    });
                }
                /**
                 * Create a new options objects with the given fontFamily.
                 */
                withTextFontFamily(fontFamily) {
                    return this.extend({
                        fontFamily,
                        font: ""
                    });
                }
                /**
                 * Creates a new options object with the given font weight
                 */
                withTextFontWeight(fontWeight) {
                    return this.extend({
                        fontWeight,
                        font: ""
                    });
                }
                /**
                 * Creates a new options object with the given font weight
                 */
                withTextFontShape(fontShape) {
                    return this.extend({
                        fontShape,
                        font: ""
                    });
                }
                /**
                 * Return the CSS sizing classes required to switch from enclosing options
                 * `oldOptions` to `this`. Returns an array of classes.
                 */
                sizingClasses(oldOptions) {
                    if (oldOptions.size !== this.size) {
                        return ["sizing", "reset-size" + oldOptions.size, "size" + this.size];
                    }
                    else {
                        return [];
                    }
                }
                /**
                 * Return the CSS sizing classes required to switch to the base size. Like
                 * `this.havingSize(BASESIZE).sizingClasses(this)`.
                 */
                baseSizingClasses() {
                    if (this.size !== Options.BASESIZE) {
                        return ["sizing", "reset-size" + this.size, "size" + Options.BASESIZE];
                    }
                    else {
                        return [];
                    }
                }
                /**
                 * Return the font metrics for this size.
                 */
                fontMetrics() {
                    if (!this._fontMetrics) {
                        this._fontMetrics = getGlobalMetrics(this.size);
                    }
                    return this._fontMetrics;
                }
                /**
                 * Gets the CSS color of the current options object
                 */
                getColor() {
                    if (this.phantom) {
                        return "transparent";
                    }
                    else {
                        return this.color;
                    }
                }
            };
            Options.BASESIZE = 6;
            /**
             * This file does conversion between units.  In particular, it provides
             * calculateSize to convert other units into ems.
             */
            // Thus, multiplying a length by this number converts the length from units
            // into pts.  Dividing the result by ptPerEm gives the number of ems
            // *assuming* a font size of ptPerEm (normal size, normal style).
            ptPerUnit = {
                // https://en.wikibooks.org/wiki/LaTeX/Lengths and
                // https://tex.stackexchange.com/a/8263
                "pt": 1,
                // TeX point
                "mm": 7227 / 2540,
                // millimeter
                "cm": 7227 / 254,
                // centimeter
                "in": 72.27,
                // inch
                "bp": 803 / 800,
                // big (PostScript) points
                "pc": 12,
                // pica
                "dd": 1238 / 1157,
                // didot
                "cc": 14856 / 1157,
                // cicero (12 didot)
                "nd": 685 / 642,
                // new didot
                "nc": 1370 / 107,
                // new cicero (12 new didot)
                "sp": 1 / 65536,
                // scaled point (TeX's internal smallest unit)
                // https://tex.stackexchange.com/a/41371
                "px": 803 / 800 // \pdfpxdimen defaults to 1 bp in pdfTeX and LuaTeX
            }; // Dictionary of relative units, for fast validity testing.
            relativeUnit = {
                "ex": true,
                "em": true,
                "mu": true
            };
            /**
             * Determine whether the specified unit (either a string defining the unit
             * or a "size" parse node containing a unit field) is valid.
             */
            validUnit = function validUnit(unit) {
                if (typeof unit !== "string") {
                    unit = unit.unit;
                }
                return unit in ptPerUnit || unit in relativeUnit || unit === "ex";
            };
            /*
             * Convert a "size" parse node (with numeric "number" and string "unit" fields,
             * as parsed by functions.js argType "size") into a CSS em value for the
             * current style/scale.  `options` gives the current options.
             */
            calculateSize = function calculateSize(sizeValue, options) {
                let scale;
                if (sizeValue.unit in ptPerUnit) {
                    // Absolute units
                    scale = ptPerUnit[sizeValue.unit] // Convert unit to pt
                        / options.fontMetrics().ptPerEm // Convert pt to CSS em
                        / options.sizeMultiplier; // Unscale to make absolute units
                }
                else if (sizeValue.unit === "mu") {
                    // `mu` units scale with scriptstyle/scriptscriptstyle.
                    scale = options.fontMetrics().cssEmPerMu;
                }
                else {
                    // Other relative units always refer to the *textstyle* font
                    // in the current size.
                    let unitOptions;
                    if (options.style.isTight()) {
                        // isTight() means current style is script/scriptscript.
                        unitOptions = options.havingStyle(options.style.text());
                    }
                    else {
                        unitOptions = options;
                    } // TODO: In TeX these units are relative to the quad of the current
                    // *text* font, e.g. cmr10. KaTeX instead uses values from the
                    // comparably-sized *Computer Modern symbol* font. At 10pt, these
                    // match. At 7pt and 5pt, they differ: cmr7=1.138894, cmsy7=1.170641;
                    // cmr5=1.361133, cmsy5=1.472241. Consider $\scriptsize a\kern1emb$.
                    // TeX \showlists shows a kern of 1.13889 * fontsize;
                    // KaTeX shows a kern of 1.171 * fontsize.
                    if (sizeValue.unit === "ex") {
                        scale = unitOptions.fontMetrics().xHeight;
                    }
                    else if (sizeValue.unit === "em") {
                        scale = unitOptions.fontMetrics().quad;
                    }
                    else {
                        throw new ParseError("Invalid unit: '" + sizeValue.unit + "'");
                    }
                    if (unitOptions !== options) {
                        scale *= unitOptions.sizeMultiplier / options.sizeMultiplier;
                    }
                }
                return Math.min(sizeValue.number * scale, options.maxSize);
            };
            /* eslint no-console:0 */
            // The following have to be loaded from Main-Italic font, using class mathit
            mathitLetters = ["\\imath", "",
                "\\jmath", "",
                "\\pounds", "\\mathsterling", "\\textsterling", ""];
            /**
             * Looks up the given symbol in fontMetrics, after applying any symbol
             * replacements defined in symbol.js
             */
            lookupSymbol = function lookupSymbol(value, // TODO(#963): Use a union type for this.
            fontName, mode) {
                // Replace the value with its replaced value from symbol.js
                if (symbols[mode][value] && symbols[mode][value].replace) {
                    value = symbols[mode][value].replace;
                }
                return {
                    value: value,
                    metrics: getCharacterMetrics(value, fontName, mode)
                };
            };
            /**
             * Makes a symbolNode after translation via the list of symbols in symbols.js.
             * Correctly pulls out metrics for the character, and optionally takes a list of
             * classes to be attached to the node.
             *
             * TODO: make argument order closer to makeSpan
             * TODO: add a separate argument for math class (e.g. `mop`, `mbin`), which
             * should if present come first in `classes`.
             * TODO(#953): Make `options` mandatory and always pass it in.
             */
            makeSymbol = function makeSymbol(value, fontName, mode, options, classes) {
                const lookup = lookupSymbol(value, fontName, mode);
                const metrics = lookup.metrics;
                value = lookup.value;
                let symbolNode;
                if (metrics) {
                    let italic = metrics.italic;
                    if (mode === "text" || options && options.font === "mathit") {
                        italic = 0;
                    }
                    symbolNode = new SymbolNode(value, metrics.height, metrics.depth, italic, metrics.skew, metrics.width, classes);
                }
                else {
                    // TODO(emily): Figure out a good way to only print this in development
                    typeof console !== "undefined" && console.warn("No character metrics " + `for '${value}' in style '${fontName}' and mode '${mode}'`);
                    symbolNode = new SymbolNode(value, 0, 0, 0, 0, 0, classes);
                }
                if (options) {
                    symbolNode.maxFontSize = options.sizeMultiplier;
                    if (options.style.isTight()) {
                        symbolNode.classes.push("mtight");
                    }
                    const color = options.getColor();
                    if (color) {
                        symbolNode.style.color = color;
                    }
                }
                return symbolNode;
            };
            /**
             * Makes a symbol in Main-Regular or AMS-Regular.
             * Used for rel, bin, open, close, inner, and punct.
             */
            mathsym = function mathsym(value, mode, options, classes) {
                if (classes === void 0) {
                    classes = [];
                }
                // Decide what font to render the symbol in by its entry in the symbols
                // table.
                // Have a special case for when the value = \ because the \ is used as a
                // textord in unsupported command errors but cannot be parsed as a regular
                // text ordinal and is therefore not present as a symbol in the symbols
                // table for text, as well as a special case for boldsymbol because it
                // can be used for bold + and -
                if (options.font === "boldsymbol" && lookupSymbol(value, "Main-Bold", mode).metrics) {
                    return makeSymbol(value, "Main-Bold", mode, options, classes.concat(["mathbf"]));
                }
                else if (value === "\\" || symbols[mode][value].font === "main") {
                    return makeSymbol(value, "Main-Regular", mode, options, classes);
                }
                else {
                    return makeSymbol(value, "AMS-Regular", mode, options, classes.concat(["amsrm"]));
                }
            };
            /**
             * Determines which of the two font names (Main-Italic and Math-Italic) and
             * corresponding style tags (maindefault or mathit) to use for default math font,
             * depending on the symbol.
             */
            mathdefault = function mathdefault(value, mode, options, classes) {
                if (/[0-9]/.test(value.charAt(0)) || // glyphs for \imath and \jmath do not exist in Math-Italic so we
                    // need to use Main-Italic instead
                    utils.contains(mathitLetters, value)) {
                    return {
                        fontName: "Main-Italic",
                        fontClass: "mathit"
                    };
                }
                else {
                    return {
                        fontName: "Math-Italic",
                        fontClass: "mathdefault"
                    };
                }
            };
            /**
             * Determines which of the font names (Main-Italic, Math-Italic, and Caligraphic)
             * and corresponding style tags (mathit, mathdefault, or mathcal) to use for font
             * "mathnormal", depending on the symbol.  Use this function instead of fontMap for
             * font "mathnormal".
             */
            mathnormal = function mathnormal(value, mode, options, classes) {
                if (utils.contains(mathitLetters, value)) {
                    return {
                        fontName: "Main-Italic",
                        fontClass: "mathit"
                    };
                }
                else if (/[0-9]/.test(value.charAt(0))) {
                    return {
                        fontName: "Caligraphic-Regular",
                        fontClass: "mathcal"
                    };
                }
                else {
                    return {
                        fontName: "Math-Italic",
                        fontClass: "mathdefault"
                    };
                }
            };
            /**
             * Determines which of the two font names (Main-Bold and Math-BoldItalic) and
             * corresponding style tags (mathbf or boldsymbol) to use for font "boldsymbol",
             * depending on the symbol.  Use this function instead of fontMap for font
             * "boldsymbol".
             */
            boldsymbol = function boldsymbol(value, mode, options, classes) {
                if (lookupSymbol(value, "Math-BoldItalic", mode).metrics) {
                    return {
                        fontName: "Math-BoldItalic",
                        fontClass: "boldsymbol"
                    };
                }
                else {
                    // Some glyphs do not exist in Math-BoldItalic so we need to use
                    // Main-Bold instead.
                    return {
                        fontName: "Main-Bold",
                        fontClass: "mathbf"
                    };
                }
            };
            /**
             * Makes either a mathord or textord in the correct font and color.
             */
            makeOrd = function makeOrd(group, options, type) {
                const mode = group.mode;
                const text = group.text;
                const classes = ["mord"]; // Math mode or Old font (i.e. \rm)
                const isFont = mode === "math" || mode === "text" && options.font;
                const fontOrFamily = isFont ? options.font : options.fontFamily;
                if (text.charCodeAt(0) === 0xD835) {
                    // surrogate pairs get special treatment
                    const _wideCharacterFont = wideCharacterFont(text, mode), wideFontName = _wideCharacterFont[0], wideFontClass = _wideCharacterFont[1];
                    return makeSymbol(text, wideFontName, mode, options, classes.concat(wideFontClass));
                }
                else if (fontOrFamily) {
                    let fontName;
                    let fontClasses;
                    if (fontOrFamily === "boldsymbol" || fontOrFamily === "mathnormal") {
                        const fontData = fontOrFamily === "boldsymbol" ? boldsymbol(text, mode, options, classes) : mathnormal(text, mode, options, classes);
                        fontName = fontData.fontName;
                        fontClasses = [fontData.fontClass];
                    }
                    else if (utils.contains(mathitLetters, text)) {
                        fontName = "Main-Italic";
                        fontClasses = ["mathit"];
                    }
                    else if (isFont) {
                        fontName = fontMap[fontOrFamily].fontName;
                        fontClasses = [fontOrFamily];
                    }
                    else {
                        fontName = retrieveTextFontName(fontOrFamily, options.fontWeight, options.fontShape);
                        fontClasses = [fontOrFamily, options.fontWeight, options.fontShape];
                    }
                    if (lookupSymbol(text, fontName, mode).metrics) {
                        return makeSymbol(text, fontName, mode, options, classes.concat(fontClasses));
                    }
                    else if (ligatures.hasOwnProperty(text) && fontName.substr(0, 10) === "Typewriter") {
                        // Deconstruct ligatures in monospace fonts (\texttt, \tt).
                        const parts = [];
                        for (let i = 0; i < text.length; i++) {
                            parts.push(makeSymbol(text[i], fontName, mode, options, classes.concat(fontClasses)));
                        }
                        return makeFragment(parts);
                    }
                } // Makes a symbol in the default font for mathords and textords.
                if (type === "mathord") {
                    const fontLookup = mathdefault(text, mode, options, classes);
                    return makeSymbol(text, fontLookup.fontName, mode, options, classes.concat([fontLookup.fontClass]));
                }
                else if (type === "textord") {
                    const font = symbols[mode][text] && symbols[mode][text].font;
                    if (font === "ams") {
                        const fontName = retrieveTextFontName("amsrm", options.fontWeight, options.fontShape);
                        return makeSymbol(text, fontName, mode, options, classes.concat("amsrm", options.fontWeight, options.fontShape));
                    }
                    else if (font === "main" || !font) {
                        const fontName = retrieveTextFontName("textrm", options.fontWeight, options.fontShape);
                        return makeSymbol(text, fontName, mode, options, classes.concat(options.fontWeight, options.fontShape));
                    }
                    else {
                        // fonts added by plugins
                        const fontName = retrieveTextFontName(font, options.fontWeight, options.fontShape); // We add font name as a css class
                        return makeSymbol(text, fontName, mode, options, classes.concat(fontName, options.fontWeight, options.fontShape));
                    }
                }
                else {
                    throw new Error("unexpected type: " + type + " in makeOrd");
                }
            };
            /**
             * Returns true if subsequent symbolNodes have the same classes, skew, maxFont,
             * and styles.
             */
            canCombine = (prev, next) => {
                if (createClass(prev.classes) !== createClass(next.classes) || prev.skew !== next.skew || prev.maxFontSize !== next.maxFontSize) {
                    return false;
                }
                for (const style in prev.style) {
                    if (prev.style.hasOwnProperty(style) && prev.style[style] !== next.style[style]) {
                        return false;
                    }
                }
                for (const style in next.style) {
                    if (next.style.hasOwnProperty(style) && prev.style[style] !== next.style[style]) {
                        return false;
                    }
                }
                return true;
            };
            /**
             * Combine consequetive domTree.symbolNodes into a single symbolNode.
             * Note: this function mutates the argument.
             */
            tryCombineChars = chars => {
                for (let i = 0; i < chars.length - 1; i++) {
                    const prev = chars[i];
                    const next = chars[i + 1];
                    if (prev instanceof SymbolNode && next instanceof SymbolNode && canCombine(prev, next)) {
                        prev.text += next.text;
                        prev.height = Math.max(prev.height, next.height);
                        prev.depth = Math.max(prev.depth, next.depth); // Use the last character's italic correction since we use
                        // it to add padding to the right of the span created from
                        // the combined characters.
                        prev.italic = next.italic;
                        chars.splice(i + 1, 1);
                        i--;
                    }
                }
                return chars;
            };
            /**
             * Calculate the height, depth, and maxFontSize of an element based on its
             * children.
             */
            sizeElementFromChildren = function sizeElementFromChildren(elem) {
                let height = 0;
                let depth = 0;
                let maxFontSize = 0;
                for (let i = 0; i < elem.children.length; i++) {
                    const child = elem.children[i];
                    if (child.height > height) {
                        height = child.height;
                    }
                    if (child.depth > depth) {
                        depth = child.depth;
                    }
                    if (child.maxFontSize > maxFontSize) {
                        maxFontSize = child.maxFontSize;
                    }
                }
                elem.height = height;
                elem.depth = depth;
                elem.maxFontSize = maxFontSize;
            };
            /**
             * Makes a span with the given list of classes, list of children, and options.
             *
             * TODO(#953): Ensure that `options` is always provided (currently some call
             * sites don't pass it) and make the type below mandatory.
             * TODO: add a separate argument for math class (e.g. `mop`, `mbin`), which
             * should if present come first in `classes`.
             */
            makeSpan = function makeSpan(classes, children, options, style) {
                const span = new Span(classes, children, options, style);
                sizeElementFromChildren(span);
                return span;
            }; // SVG one is simpler -- doesn't require height, depth, max-font setting.
            // This is also a separate method for typesafety.
            makeSvgSpan = (classes, children, options, style) => new Span(classes, children, options, style);
            makeLineSpan = function makeLineSpan(className, options, thickness) {
                const line = makeSpan([className], [], options);
                line.height = Math.max(thickness || options.fontMetrics().defaultRuleThickness, options.minRuleThickness);
                line.style.borderBottomWidth = line.height + "em";
                line.maxFontSize = 1.0;
                return line;
            };
            /**
             * Makes an anchor with the given href, list of classes, list of children,
             * and options.
             */
            makeAnchor = function makeAnchor(href, classes, children, options) {
                const anchor = new Anchor(href, classes, children, options);
                sizeElementFromChildren(anchor);
                return anchor;
            };
            /**
             * Makes a document fragment with the given list of children.
             */
            makeFragment = function makeFragment(children) {
                const fragment = new DocumentFragment(children);
                sizeElementFromChildren(fragment);
                return fragment;
            };
            /**
             * Wraps group in a span if it's a document fragment, allowing to apply classes
             * and styles
             */
            wrapFragment = function wrapFragment(group, options) {
                if (group instanceof DocumentFragment) {
                    return makeSpan([], [group], options);
                }
                return group;
            }; // These are exact object types to catch typos in the names of the optional fields.
            // Computes the updated `children` list and the overall depth.
            //
            // This helper function for makeVList makes it easier to enforce type safety by
            // allowing early exits (returns) in the logic.
            getVListChildrenAndDepth = function getVListChildrenAndDepth(params) {
                if (params.positionType === "individualShift") {
                    const oldChildren = params.children;
                    const children = [oldChildren[0]]; // Add in kerns to the list of params.children to get each element to be
                    // shifted to the correct specified shift
                    const depth = -oldChildren[0].shift - oldChildren[0].elem.depth;
                    let currPos = depth;
                    for (let i = 1; i < oldChildren.length; i++) {
                        const diff = -oldChildren[i].shift - currPos - oldChildren[i].elem.depth;
                        const size = diff - (oldChildren[i - 1].elem.height + oldChildren[i - 1].elem.depth);
                        currPos = currPos + diff;
                        children.push({
                            type: "kern",
                            size
                        });
                        children.push(oldChildren[i]);
                    }
                    return {
                        children,
                        depth
                    };
                }
                let depth;
                if (params.positionType === "top") {
                    // We always start at the bottom, so calculate the bottom by adding up
                    // all the sizes
                    let bottom = params.positionData;
                    for (let i = 0; i < params.children.length; i++) {
                        const child = params.children[i];
                        bottom -= child.type === "kern" ? child.size : child.elem.height + child.elem.depth;
                    }
                    depth = bottom;
                }
                else if (params.positionType === "bottom") {
                    depth = -params.positionData;
                }
                else {
                    const firstChild = params.children[0];
                    if (firstChild.type !== "elem") {
                        throw new Error('First child must have type "elem".');
                    }
                    if (params.positionType === "shift") {
                        depth = -firstChild.elem.depth - params.positionData;
                    }
                    else if (params.positionType === "firstBaseline") {
                        depth = -firstChild.elem.depth;
                    }
                    else {
                        throw new Error(`Invalid positionType ${params.positionType}.`);
                    }
                }
                return {
                    children: params.children,
                    depth
                };
            };
            /**
             * Makes a vertical list by stacking elements and kerns on top of each other.
             * Allows for many different ways of specifying the positioning method.
             *
             * See VListParam documentation above.
             */
            makeVList = function makeVList(params, options) {
                const _getVListChildrenAndD = getVListChildrenAndDepth(params), children = _getVListChildrenAndD.children, depth = _getVListChildrenAndD.depth; // Create a strut that is taller than any list item. The strut is added to
                // each item, where it will determine the item's baseline. Since it has
                // `overflow:hidden`, the strut's top edge will sit on the item's line box's
                // top edge and the strut's bottom edge will sit on the item's baseline,
                // with no additional line-height spacing. This allows the item baseline to
                // be positioned precisely without worrying about font ascent and
                // line-height.
                let pstrutSize = 0;
                for (let i = 0; i < children.length; i++) {
                    const child = children[i];
                    if (child.type === "elem") {
                        const elem = child.elem;
                        pstrutSize = Math.max(pstrutSize, elem.maxFontSize, elem.height);
                    }
                }
                pstrutSize += 2;
                const pstrut = makeSpan(["pstrut"], []);
                pstrut.style.height = pstrutSize + "em"; // Create a new list of actual children at the correct offsets
                const realChildren = [];
                let minPos = depth;
                let maxPos = depth;
                let currPos = depth;
                for (let i = 0; i < children.length; i++) {
                    const child = children[i];
                    if (child.type === "kern") {
                        currPos += child.size;
                    }
                    else {
                        const elem = child.elem;
                        const classes = child.wrapperClasses || [];
                        const style = child.wrapperStyle || {};
                        const childWrap = makeSpan(classes, [pstrut, elem], undefined, style);
                        childWrap.style.top = -pstrutSize - currPos - elem.depth + "em";
                        if (child.marginLeft) {
                            childWrap.style.marginLeft = child.marginLeft;
                        }
                        if (child.marginRight) {
                            childWrap.style.marginRight = child.marginRight;
                        }
                        realChildren.push(childWrap);
                        currPos += elem.height + elem.depth;
                    }
                    minPos = Math.min(minPos, currPos);
                    maxPos = Math.max(maxPos, currPos);
                } // The vlist contents go in a table-cell with `vertical-align:bottom`.
                // This cell's bottom edge will determine the containing table's baseline
                // without overly expanding the containing line-box.
                const vlist = makeSpan(["vlist"], realChildren);
                vlist.style.height = maxPos + "em"; // A second row is used if necessary to represent the vlist's depth.
                let rows;
                if (minPos < 0) {
                    // We will define depth in an empty span with display: table-cell.
                    // It should render with the height that we define. But Chrome, in
                    // contenteditable mode only, treats that span as if it contains some
                    // text content. And that min-height over-rides our desired height.
                    // So we put another empty span inside the depth strut span.
                    const emptySpan = makeSpan([], []);
                    const depthStrut = makeSpan(["vlist"], [emptySpan]);
                    depthStrut.style.height = -minPos + "em"; // Safari wants the first row to have inline content; otherwise it
                    // puts the bottom of the *second* row on the baseline.
                    const topStrut = makeSpan(["vlist-s"], [new SymbolNode("\u200b")]);
                    rows = [makeSpan(["vlist-r"], [vlist, topStrut]), makeSpan(["vlist-r"], [depthStrut])];
                }
                else {
                    rows = [makeSpan(["vlist-r"], [vlist])];
                }
                const vtable = makeSpan(["vlist-t"], rows);
                if (rows.length === 2) {
                    vtable.classes.push("vlist-t2");
                }
                vtable.height = maxPos;
                vtable.depth = -minPos;
                return vtable;
            }; // Glue is a concept from TeX which is a flexible space between elements in
            // either a vertical or horizontal list. In KaTeX, at least for now, it's
            // static space between elements in a horizontal layout.
            makeGlue = (measurement, options) => {
                // Make an empty span for the space
                const rule = makeSpan(["mspace"], [], options);
                const size = calculateSize(measurement, options);
                rule.style.marginRight = `${size}em`;
                return rule;
            }; // Takes font options, and returns the appropriate fontLookup name
            retrieveTextFontName = function retrieveTextFontName(fontFamily, fontWeight, fontShape) {
                let baseFontName = "";
                switch (fontFamily) {
                    case "amsrm":
                        baseFontName = "AMS";
                        break;
                    case "textrm":
                        baseFontName = "Main";
                        break;
                    case "textsf":
                        baseFontName = "SansSerif";
                        break;
                    case "texttt":
                        baseFontName = "Typewriter";
                        break;
                    default:
                        baseFontName = fontFamily;
                    // use fonts added by a plugin
                }
                let fontStylesName;
                if (fontWeight === "textbf" && fontShape === "textit") {
                    fontStylesName = "BoldItalic";
                }
                else if (fontWeight === "textbf") {
                    fontStylesName = "Bold";
                }
                else if (fontWeight === "textit") {
                    fontStylesName = "Italic";
                }
                else {
                    fontStylesName = "Regular";
                }
                return `${baseFontName}-${fontStylesName}`;
            };
            /**
             * Maps TeX font commands to objects containing:
             * - variant: string used for "mathvariant" attribute in buildMathML.js
             * - fontName: the "style" parameter to fontMetrics.getCharacterMetrics
             */
            // A map between tex font commands an MathML mathvariant attribute values
            fontMap = {
                // styles
                "mathbf": {
                    variant: "bold",
                    fontName: "Main-Bold"
                },
                "mathrm": {
                    variant: "normal",
                    fontName: "Main-Regular"
                },
                "textit": {
                    variant: "italic",
                    fontName: "Main-Italic"
                },
                "mathit": {
                    variant: "italic",
                    fontName: "Main-Italic"
                },
                // Default math font, "mathnormal" and "boldsymbol" are missing because they
                // require the use of several fonts: Main-Italic and Math-Italic for default
                // math font, Main-Italic, Math-Italic, Caligraphic for "mathnormal", and
                // Math-BoldItalic and Main-Bold for "boldsymbol".  This is handled by a
                // special case in makeOrd which ends up calling mathdefault, mathnormal,
                // and boldsymbol.
                // families
                "mathbb": {
                    variant: "double-struck",
                    fontName: "AMS-Regular"
                },
                "mathcal": {
                    variant: "script",
                    fontName: "Caligraphic-Regular"
                },
                "mathfrak": {
                    variant: "fraktur",
                    fontName: "Fraktur-Regular"
                },
                "mathscr": {
                    variant: "script",
                    fontName: "Script-Regular"
                },
                "mathsf": {
                    variant: "sans-serif",
                    fontName: "SansSerif-Regular"
                },
                "mathtt": {
                    variant: "monospace",
                    fontName: "Typewriter-Regular"
                }
            };
            svgData = {
                //   path, width, height
                vec: ["vec", 0.471, 0.714],
                // values from the font glyph
                oiintSize1: ["oiintSize1", 0.957, 0.499],
                // oval to overlay the integrand
                oiintSize2: ["oiintSize2", 1.472, 0.659],
                oiiintSize1: ["oiiintSize1", 1.304, 0.499],
                oiiintSize2: ["oiiintSize2", 1.98, 0.659]
            };
            staticSvg = function staticSvg(value, options) {
                // Create a span with inline SVG for the element.
                const _svgData$value = svgData[value], pathName = _svgData$value[0], width = _svgData$value[1], height = _svgData$value[2];
                const path = new PathNode(pathName);
                const svgNode = new SvgNode([path], {
                    "width": width + "em",
                    "height": height + "em",
                    // Override CSS rule `.katex svg { width: 100% }`
                    "style": "width:" + width + "em",
                    "viewBox": "0 0 " + 1000 * width + " " + 1000 * height,
                    "preserveAspectRatio": "xMinYMin"
                });
                const span = makeSvgSpan(["overlay"], [svgNode], options);
                span.height = height;
                span.style.height = height + "em";
                span.style.width = width + "em";
                return span;
            };
            buildCommon = {
                fontMap,
                makeSymbol,
                mathsym,
                makeSpan,
                makeSvgSpan,
                makeLineSpan,
                makeAnchor,
                makeFragment,
                wrapFragment,
                makeVList,
                makeOrd,
                makeGlue,
                staticSvg,
                svgData,
                tryCombineChars
            };
            /**
             * Describes spaces between different classes of atoms.
             */
            thinspace = {
                number: 3,
                unit: "mu"
            };
            mediumspace = {
                number: 4,
                unit: "mu"
            };
            thickspace = {
                number: 5,
                unit: "mu"
            }; // Making the type below exact with all optional fields doesn't work due to
            // - https://github.com/facebook/flow/issues/4582
            // - https://github.com/facebook/flow/issues/5688
            // However, since *all* fields are optional, $Shape<> works as suggested in 5688
            // above.
            // Spacing relationships for display and text styles
            spacings = {
                mord: {
                    mop: thinspace,
                    mbin: mediumspace,
                    mrel: thickspace,
                    minner: thinspace
                },
                mop: {
                    mord: thinspace,
                    mop: thinspace,
                    mrel: thickspace,
                    minner: thinspace
                },
                mbin: {
                    mord: mediumspace,
                    mop: mediumspace,
                    mopen: mediumspace,
                    minner: mediumspace
                },
                mrel: {
                    mord: thickspace,
                    mop: thickspace,
                    mopen: thickspace,
                    minner: thickspace
                },
                mopen: {},
                mclose: {
                    mop: thinspace,
                    mbin: mediumspace,
                    mrel: thickspace,
                    minner: thinspace
                },
                mpunct: {
                    mord: thinspace,
                    mop: thinspace,
                    mrel: thickspace,
                    mopen: thinspace,
                    mclose: thinspace,
                    mpunct: thinspace,
                    minner: thinspace
                },
                minner: {
                    mord: thinspace,
                    mop: thinspace,
                    mbin: mediumspace,
                    mrel: thickspace,
                    mopen: thinspace,
                    mpunct: thinspace,
                    minner: thinspace
                }
            }; // Spacing relationships for script and scriptscript styles
            tightSpacings = {
                mord: {
                    mop: thinspace
                },
                mop: {
                    mord: thinspace,
                    mop: thinspace
                },
                mbin: {},
                mrel: {},
                mopen: {},
                mclose: {
                    mop: thinspace
                },
                mpunct: {},
                minner: {
                    mop: thinspace
                }
            };
            /**
             * All registered functions.
             * `functions.js` just exports this same dictionary again and makes it public.
             * `Parser.js` requires this dictionary.
             */
            _functions = {};
            /**
             * All HTML builders. Should be only used in the `define*` and the `build*ML`
             * functions.
             */
            _htmlGroupBuilders = {};
            /**
             * All MathML builders. Should be only used in the `define*` and the `build*ML`
             * functions.
             */
            _mathmlGroupBuilders = {};
            // list of elements, we normalize for different kinds of arguments
            ordargument = function ordargument(arg) {
                const node = checkNodeType(arg, "ordgroup");
                return node ? node.body : [arg];
            };
            /**
             * This file does the main work of building a domTree structure from a parse
             * tree. The entry point is the `buildHTML` function, which takes a parse tree.
             * Then, the buildExpression, buildGroup, and various groupBuilders functions
             * are called, to produce a final HTML tree.
             */
            makeSpan$1 = buildCommon.makeSpan; // Binary atoms (first class `mbin`) change into ordinary atoms (`mord`)
            // depending on their surroundings. See TeXbook pg. 442-446, Rules 5 and 6,
            // and the text before Rule 19.
            binLeftCanceller = ["leftmost", "mbin", "mopen", "mrel", "mop", "mpunct"];
            binRightCanceller = ["rightmost", "mrel", "mclose", "mpunct"];
            styleMap = {
                "display": Style$1.DISPLAY,
                "text": Style$1.TEXT,
                "script": Style$1.SCRIPT,
                "scriptscript": Style$1.SCRIPTSCRIPT
            };
            DomEnum = {
                mord: "mord",
                mop: "mop",
                mbin: "mbin",
                mrel: "mrel",
                mopen: "mopen",
                mclose: "mclose",
                mpunct: "mpunct",
                minner: "minner"
            };
            /**
             * Take a list of nodes, build them in order, and return a list of the built
             * nodes. documentFragments are flattened into their contents, so the
             * returned list contains no fragments. `isRealGroup` is true if `expression`
             * is a real group (no atoms will be added on either side), as opposed to
             * a partial group (e.g. one created by \color). `surrounding` is an array
             * consisting type of nodes that will be added to the left and right.
             */
            buildExpression = function buildExpression(expression, options, isRealGroup, surrounding) {
                if (surrounding === void 0) {
                    surrounding = [null, null];
                }
                // Parse expressions into `groups`.
                const groups = [];
                for (let i = 0; i < expression.length; i++) {
                    const output = buildGroup(expression[i], options);
                    if (output instanceof DocumentFragment) {
                        const children = output.children;
                        groups.push(...children);
                    }
                    else {
                        groups.push(output);
                    }
                } // If `expression` is a partial group, let the parent handle spacings
                // to avoid processing groups multiple times.
                if (!isRealGroup) {
                    return groups;
                }
                let glueOptions = options;
                if (expression.length === 1) {
                    const node = checkNodeType(expression[0], "sizing") || checkNodeType(expression[0], "styling");
                    if (!node)
                        ;
                    else if (node.type === "sizing") {
                        glueOptions = options.havingSize(node.size);
                    }
                    else if (node.type === "styling") {
                        glueOptions = options.havingStyle(styleMap[node.style]);
                    }
                } // Dummy spans for determining spacings between surrounding atoms.
                // If `expression` has no atoms on the left or right, class "leftmost"
                // or "rightmost", respectively, is used to indicate it.
                const dummyPrev = makeSpan$1([surrounding[0] || "leftmost"], [], options);
                const dummyNext = makeSpan$1([surrounding[1] || "rightmost"], [], options); // TODO: These code assumes that a node's math class is the first element
                // of its `classes` array. A later cleanup should ensure this, for
                // instance by changing the signature of `makeSpan`.
                // Before determining what spaces to insert, perform bin cancellation.
                // Binary operators change to ordinary symbols in some contexts.
                traverseNonSpaceNodes(groups, (node, prev) => {
                    const prevType = prev.classes[0];
                    const type = node.classes[0];
                    if (prevType === "mbin" && utils.contains(binRightCanceller, type)) {
                        prev.classes[0] = "mord";
                    }
                    else if (type === "mbin" && utils.contains(binLeftCanceller, prevType)) {
                        node.classes[0] = "mord";
                    }
                }, {
                    node: dummyPrev
                }, dummyNext);
                traverseNonSpaceNodes(groups, (node, prev) => {
                    const prevType = getTypeOfDomTree(prev);
                    const type = getTypeOfDomTree(node); // 'mtight' indicates that the node is script or scriptscript style.
                    const space = prevType && type ? node.hasClass("mtight") ? tightSpacings[prevType][type] : spacings[prevType][type] : null;
                    if (space) {
                        // Insert glue (spacing) after the `prev`.
                        return buildCommon.makeGlue(space, glueOptions);
                    }
                }, {
                    node: dummyPrev
                }, dummyNext);
                return groups;
            }; // Depth-first traverse non-space `nodes`, calling `callback` with the current and
            // previous node as arguments, optionally returning a node to insert after the
            // previous node. `prev` is an object with the previous node and `insertAfter`
            // function to insert after it. `next` is a node that will be added to the right.
            // Used for bin cancellation and inserting spacings.
            traverseNonSpaceNodes = function traverseNonSpaceNodes(nodes, callback, prev, next) {
                if (next) {
                    // temporarily append the right node, if exists
                    nodes.push(next);
                }
                let i = 0;
                for (; i < nodes.length; i++) {
                    const node = nodes[i];
                    const partialGroup = checkPartialGroup(node);
                    if (partialGroup) {
                        // Recursive DFS
                        // $FlowFixMe: make nodes a $ReadOnlyArray by returning a new array
                        traverseNonSpaceNodes(partialGroup.children, callback, prev);
                        continue;
                    } // Ignore explicit spaces (e.g., \;, \,) when determining what implicit
                    // spacing should go between atoms of different classes
                    if (node.classes[0] === "mspace") {
                        continue;
                    }
                    const result = callback(node, prev.node);
                    if (result) {
                        if (prev.insertAfter) {
                            prev.insertAfter(result);
                        }
                        else {
                            // insert at front
                            nodes.unshift(result);
                            i++;
                        }
                    }
                    prev.node = node;
                    prev.insertAfter = (index => n => {
                        nodes.splice(index + 1, 0, n);
                        i++;
                    })(i);
                }
                if (next) {
                    nodes.pop();
                }
            }; // Check if given node is a partial group, i.e., does not affect spacing around.
            checkPartialGroup = function checkPartialGroup(node) {
                if (node instanceof DocumentFragment || node instanceof Anchor) {
                    return node;
                }
                return null;
            }; // Return the outermost node of a domTree.
            getOutermostNode = function getOutermostNode(node, side) {
                const partialGroup = checkPartialGroup(node);
                if (partialGroup) {
                    const children = partialGroup.children;
                    if (children.length) {
                        if (side === "right") {
                            return getOutermostNode(children[children.length - 1], "right");
                        }
                        else if (side === "left") {
                            return getOutermostNode(children[0], "left");
                        }
                    }
                }
                return node;
            }; // Return math atom class (mclass) of a domTree.
            // If `side` is given, it will get the type of the outermost node at given side.
            getTypeOfDomTree = function getTypeOfDomTree(node, side) {
                if (!node) {
                    return null;
                }
                if (side) {
                    node = getOutermostNode(node, side);
                } // This makes a lot of assumptions as to where the type of atom
                // appears.  We should do a better job of enforcing this.
                return DomEnum[node.classes[0]] || null;
            };
            makeNullDelimiter = function makeNullDelimiter(options, classes) {
                const moreClasses = ["nulldelimiter"].concat(options.baseSizingClasses());
                return makeSpan$1(classes.concat(moreClasses));
            };
            /**
             * buildGroup is the function that takes a group and calls the correct groupType
             * function for it. It also handles the interaction of size and style changes
             * between parents and children.
             */
            buildGroup = function buildGroup(group, options, baseOptions) {
                if (!group) {
                    return makeSpan$1();
                }
                if (_htmlGroupBuilders[group.type]) {
                    // Call the groupBuilders function
                    let groupNode = _htmlGroupBuilders[group.type](group, options); // If the size changed between the parent and the current group, account
                    // for that size difference.
                    if (baseOptions && options.size !== baseOptions.size) {
                        groupNode = makeSpan$1(options.sizingClasses(baseOptions), [groupNode], options);
                        const multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier;
                        groupNode.height *= multiplier;
                        groupNode.depth *= multiplier;
                    }
                    return groupNode;
                }
                else {
                    throw new ParseError("Got group of unknown type: '" + group.type + "'");
                }
            };
            /**
             * This node represents a general purpose MathML node of any type. The
             * constructor requires the type of node to create (for example, `"mo"` or
             * `"mspace"`, corresponding to `<mo>` and `<mspace>` tags).
             */
            MathNode = class MathNode {
                constructor(type, children) {
                    this.type = void 0;
                    this.attributes = void 0;
                    this.children = void 0;
                    this.type = type;
                    this.attributes = {};
                    this.children = children || [];
                }
                /**
                 * Sets an attribute on a MathML node. MathML depends on attributes to convey a
                 * semantic content, so this is used heavily.
                 */
                setAttribute(name, value) {
                    this.attributes[name] = value;
                }
                /**
                 * Gets an attribute on a MathML node.
                 */
                getAttribute(name) {
                    return this.attributes[name];
                }
                /**
                 * Converts the math node into a MathML-namespaced DOM element.
                 */
                toNode() {
                    const node = document.createElementNS("http://www.w3.org/1998/Math/MathML", this.type);
                    for (const attr in this.attributes) {
                        if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
                            node.setAttribute(attr, this.attributes[attr]);
                        }
                    }
                    for (let i = 0; i < this.children.length; i++) {
                        node.appendChild(this.children[i].toNode());
                    }
                    return node;
                }
                /**
                 * Converts the math node into an HTML markup string.
                 */
                toMarkup() {
                    let markup = "<" + this.type; // Add the attributes
                    for (const attr in this.attributes) {
                        if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
                            markup += " " + attr + "=\"";
                            markup += utils.escape(this.attributes[attr]);
                            markup += "\"";
                        }
                    }
                    markup += ">";
                    for (let i = 0; i < this.children.length; i++) {
                        markup += this.children[i].toMarkup();
                    }
                    markup += "</" + this.type + ">";
                    return markup;
                }
                /**
                 * Converts the math node into a string, similar to innerText, but escaped.
                 */
                toText() {
                    return this.children.map(child => child.toText()).join("");
                }
            };
            /**
             * This node represents a piece of text.
             */
            TextNode = class TextNode {
                constructor(text) {
                    this.text = void 0;
                    this.text = text;
                }
                /**
                 * Converts the text node into a DOM text node.
                 */
                toNode() {
                    return document.createTextNode(this.text);
                }
                /**
                 * Converts the text node into escaped HTML markup
                 * (representing the text itself).
                 */
                toMarkup() {
                    return utils.escape(this.toText());
                }
                /**
                 * Converts the text node into a string
                 * (representing the text iteself).
                 */
                toText() {
                    return this.text;
                }
            };
            /**
             * This node represents a space, but may render as <mspace.../> or as text,
             * depending on the width.
             */
            SpaceNode = class SpaceNode {
                /**
                 * Create a Space node with width given in CSS ems.
                 */
                constructor(width) {
                    this.width = void 0;
                    this.character = void 0;
                    this.width = width; // See https://www.w3.org/TR/2000/WD-MathML2-20000328/chapter6.html
                    // for a table of space-like characters.  We use Unicode
                    // representations instead of &LongNames; as it's not clear how to
                    // make the latter via document.createTextNode.
                    if (width >= 0.05555 && width <= 0.05556) {
                        this.character = "\u200a"; // &VeryThinSpace;
                    }
                    else if (width >= 0.1666 && width <= 0.1667) {
                        this.character = "\u2009"; // &ThinSpace;
                    }
                    else if (width >= 0.2222 && width <= 0.2223) {
                        this.character = "\u2005"; // &MediumSpace;
                    }
                    else if (width >= 0.2777 && width <= 0.2778) {
                        this.character = "\u2005\u200a"; // &ThickSpace;
                    }
                    else if (width >= -0.05556 && width <= -0.05555) {
                        this.character = "\u200a\u2063"; // &NegativeVeryThinSpace;
                    }
                    else if (width >= -0.1667 && width <= -0.1666) {
                        this.character = "\u2009\u2063"; // &NegativeThinSpace;
                    }
                    else if (width >= -0.2223 && width <= -0.2222) {
                        this.character = "\u205f\u2063"; // &NegativeMediumSpace;
                    }
                    else if (width >= -0.2778 && width <= -0.2777) {
                        this.character = "\u2005\u2063"; // &NegativeThickSpace;
                    }
                    else {
                        this.character = null;
                    }
                }
                /**
                 * Converts the math node into a MathML-namespaced DOM element.
                 */
                toNode() {
                    if (this.character) {
                        return document.createTextNode(this.character);
                    }
                    else {
                        const node = document.createElementNS("http://www.w3.org/1998/Math/MathML", "mspace");
                        node.setAttribute("width", this.width + "em");
                        return node;
                    }
                }
                /**
                 * Converts the math node into an HTML markup string.
                 */
                toMarkup() {
                    if (this.character) {
                        return `<mtext>${this.character}</mtext>`;
                    }
                    else {
                        return `<mspace width="${this.width}em"/>`;
                    }
                }
                /**
                 * Converts the math node into a string, similar to innerText.
                 */
                toText() {
                    if (this.character) {
                        return this.character;
                    }
                    else {
                        return " ";
                    }
                }
            };
            mathMLTree = {
                MathNode,
                TextNode,
                SpaceNode,
                newDocumentFragment
            };
            /**
             * This file converts a parse tree into a cooresponding MathML tree. The main
             * entry point is the `buildMathML` function, which takes a parse tree from the
             * parser.
             */
            /**
             * Takes a symbol and converts it into a MathML text node after performing
             * optional replacement from symbols.js.
             */
            makeText = function makeText(text, mode, options) {
                if (symbols[mode][text] && symbols[mode][text].replace && text.charCodeAt(0) !== 0xD835 && !(ligatures.hasOwnProperty(text) && options && (options.fontFamily && options.fontFamily.substr(4, 2) === "tt" || options.font && options.font.substr(4, 2) === "tt"))) {
                    text = symbols[mode][text].replace;
                }
                return new mathMLTree.TextNode(text);
            };
            /**
             * Wrap the given array of nodes in an <mrow> node if needed, i.e.,
             * unless the array has length 1.  Always returns a single node.
             */
            makeRow = function makeRow(body) {
                if (body.length === 1) {
                    return body[0];
                }
                else {
                    return new mathMLTree.MathNode("mrow", body);
                }
            };
            /**
             * Returns the math variant as a string or null if none is required.
             */
            getVariant = function getVariant(group, options) {
                // Handle \text... font specifiers as best we can.
                // MathML has a limited list of allowable mathvariant specifiers; see
                // https://www.w3.org/TR/MathML3/chapter3.html#presm.commatt
                if (options.fontFamily === "texttt") {
                    return "monospace";
                }
                else if (options.fontFamily === "textsf") {
                    if (options.fontShape === "textit" && options.fontWeight === "textbf") {
                        return "sans-serif-bold-italic";
                    }
                    else if (options.fontShape === "textit") {
                        return "sans-serif-italic";
                    }
                    else if (options.fontWeight === "textbf") {
                        return "bold-sans-serif";
                    }
                    else {
                        return "sans-serif";
                    }
                }
                else if (options.fontShape === "textit" && options.fontWeight === "textbf") {
                    return "bold-italic";
                }
                else if (options.fontShape === "textit") {
                    return "italic";
                }
                else if (options.fontWeight === "textbf") {
                    return "bold";
                }
                const font = options.font;
                if (!font || font === "mathnormal") {
                    return null;
                }
                const mode = group.mode;
                if (font === "mathit") {
                    return "italic";
                }
                else if (font === "boldsymbol") {
                    return "bold-italic";
                }
                else if (font === "mathbf") {
                    return "bold";
                }
                else if (font === "mathbb") {
                    return "double-struck";
                }
                else if (font === "mathfrak") {
                    return "fraktur";
                }
                else if (font === "mathscr" || font === "mathcal") {
                    // MathML makes no distinction between script and caligrahpic
                    return "script";
                }
                else if (font === "mathsf") {
                    return "sans-serif";
                }
                else if (font === "mathtt") {
                    return "monospace";
                }
                let text = group.text;
                if (utils.contains(["\\imath", "\\jmath"], text)) {
                    return null;
                }
                if (symbols[mode][text] && symbols[mode][text].replace) {
                    text = symbols[mode][text].replace;
                }
                const fontName = buildCommon.fontMap[font].fontName;
                if (getCharacterMetrics(text, fontName, mode)) {
                    return buildCommon.fontMap[font].variant;
                }
                return null;
            };
            /**
             * Takes a list of nodes, builds them, and returns a list of the generated
             * MathML nodes.  Also combine consecutive <mtext> outputs into a single
             * <mtext> tag.
             */
            buildExpression$1 = function buildExpression(expression, options, isOrdgroup) {
                if (expression.length === 1) {
                    const group = buildGroup$1(expression[0], options);
                    if (isOrdgroup && group instanceof MathNode && group.type === "mo") {
                        // When TeX writers want to suppress spacing on an operator,
                        // they often put the operator by itself inside braces.
                        group.setAttribute("lspace", "0em");
                        group.setAttribute("rspace", "0em");
                    }
                    return [group];
                }
                const groups = [];
                let lastGroup;
                for (let i = 0; i < expression.length; i++) {
                    const group = buildGroup$1(expression[i], options);
                    if (group instanceof MathNode && lastGroup instanceof MathNode) {
                        // Concatenate adjacent <mtext>s
                        if (group.type === 'mtext' && lastGroup.type === 'mtext' && group.getAttribute('mathvariant') === lastGroup.getAttribute('mathvariant')) {
                            lastGroup.children.push(...group.children);
                            continue; // Concatenate adjacent <mn>s
                        }
                        else if (group.type === 'mn' && lastGroup.type === 'mn') {
                            lastGroup.children.push(...group.children);
                            continue; // Concatenate <mn>...</mn> followed by <mi>.</mi>
                        }
                        else if (group.type === 'mi' && group.children.length === 1 && lastGroup.type === 'mn') {
                            const child = group.children[0];
                            if (child instanceof TextNode && child.text === '.') {
                                lastGroup.children.push(...group.children);
                                continue;
                            }
                        }
                        else if (lastGroup.type === 'mi' && lastGroup.children.length === 1) {
                            const lastChild = lastGroup.children[0];
                            if (lastChild instanceof TextNode && lastChild.text === '\u0338' && (group.type === 'mo' || group.type === 'mi' || group.type === 'mn')) {
                                const child = group.children[0];
                                if (child instanceof TextNode && child.text.length > 0) {
                                    // Overlay with combining character long solidus
                                    child.text = child.text.slice(0, 1) + "\u0338" + child.text.slice(1);
                                    groups.pop();
                                }
                            }
                        }
                    }
                    groups.push(group);
                    lastGroup = group;
                }
                return groups;
            };
            /**
             * Equivalent to buildExpression, but wraps the elements in an <mrow>
             * if there's more than one.  Returns a single node instead of an array.
             */
            buildExpressionRow = function buildExpressionRow(expression, options, isOrdgroup) {
                return makeRow(buildExpression$1(expression, options, isOrdgroup));
            };
            /**
             * Takes a group from the parser and calls the appropriate groupBuilders function
             * on it to produce a MathML node.
             */
            buildGroup$1 = function buildGroup(group, options) {
                if (!group) {
                    return new mathMLTree.MathNode("mrow");
                }
                if (_mathmlGroupBuilders[group.type]) {
                    // Call the groupBuilders function
                    const result = _mathmlGroupBuilders[group.type](group, options);
                    return result;
                }
                else {
                    throw new ParseError("Got group of unknown type: '" + group.type + "'");
                }
            };
            optionsFromSettings = function optionsFromSettings(settings) {
                return new Options({
                    style: settings.displayMode ? Style$1.DISPLAY : Style$1.TEXT,
                    maxSize: settings.maxSize,
                    minRuleThickness: settings.minRuleThickness
                });
            };
            displayWrap = function displayWrap(node, settings) {
                if (settings.displayMode) {
                    const classes = ["katex-display"];
                    if (settings.leqno) {
                        classes.push("leqno");
                    }
                    if (settings.fleqn) {
                        classes.push("fleqn");
                    }
                    node = buildCommon.makeSpan(classes, [node]);
                }
                return node;
            };
            buildTree = function buildTree(tree, expression, settings) {
                const options = optionsFromSettings(settings);
                let katexNode;
                if (settings.output === "mathml") {
                    return buildMathML(tree, expression, options, true);
                }
                else if (settings.output === "html") {
                    const htmlNode = buildHTML(tree, options);
                    katexNode = buildCommon.makeSpan(["katex"], [htmlNode]);
                }
                else {
                    const mathMLNode = buildMathML(tree, expression, options, false);
                    const htmlNode = buildHTML(tree, options);
                    katexNode = buildCommon.makeSpan(["katex"], [mathMLNode, htmlNode]);
                }
                return displayWrap(katexNode, settings);
            };
            buildHTMLTree = function buildHTMLTree(tree, expression, settings) {
                const options = optionsFromSettings(settings);
                const htmlNode = buildHTML(tree, options);
                const katexNode = buildCommon.makeSpan(["katex"], [htmlNode]);
                return displayWrap(katexNode, settings);
            };
            /**
             * This file provides support to buildMathML.js and buildHTML.js
             * for stretchy wide elements rendered from SVG files
             * and other CSS trickery.
             */
            stretchyCodePoint = {
                widehat: "^",
                widecheck: "",
                widetilde: "~",
                utilde: "~",
                overleftarrow: "\u2190",
                underleftarrow: "\u2190",
                xleftarrow: "\u2190",
                overrightarrow: "\u2192",
                underrightarrow: "\u2192",
                xrightarrow: "\u2192",
                underbrace: "\u23df",
                overbrace: "\u23de",
                overgroup: "\u23e0",
                undergroup: "\u23e1",
                overleftrightarrow: "\u2194",
                underleftrightarrow: "\u2194",
                xleftrightarrow: "\u2194",
                Overrightarrow: "\u21d2",
                xRightarrow: "\u21d2",
                overleftharpoon: "\u21bc",
                xleftharpoonup: "\u21bc",
                overrightharpoon: "\u21c0",
                xrightharpoonup: "\u21c0",
                xLeftarrow: "\u21d0",
                xLeftrightarrow: "\u21d4",
                xhookleftarrow: "\u21a9",
                xhookrightarrow: "\u21aa",
                xmapsto: "\u21a6",
                xrightharpoondown: "\u21c1",
                xleftharpoondown: "\u21bd",
                xrightleftharpoons: "\u21cc",
                xleftrightharpoons: "\u21cb",
                xtwoheadleftarrow: "\u219e",
                xtwoheadrightarrow: "\u21a0",
                xlongequal: "=",
                xtofrom: "\u21c4",
                xrightleftarrows: "\u21c4",
                xrightequilibrium: "\u21cc",
                // Not a perfect match.
                xleftequilibrium: "\u21cb" // None better available.
            };
            mathMLnode = function mathMLnode(label) {
                const node = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(stretchyCodePoint[label.substr(1)])]);
                node.setAttribute("stretchy", "true");
                return node;
            }; // Many of the KaTeX SVG images have been adapted from glyphs in KaTeX fonts.
            // Copyright (c) 2009-2010, Design Science, Inc. (<www.mathjax.org>)
            // Copyright (c) 2014-2017 Khan Academy (<www.khanacademy.org>)
            // Licensed under the SIL Open Font License, Version 1.1.
            // See \nhttp://scripts.sil.org/OFL
            // Very Long SVGs
            //    Many of the KaTeX stretchy wide elements use a long SVG image and an
            //    overflow: hidden tactic to achieve a stretchy image while avoiding
            //    distortion of arrowheads or brace corners.
            //    The SVG typically contains a very long (400 em) arrow.
            //    The SVG is in a container span that has overflow: hidden, so the span
            //    acts like a window that exposes only part of the  SVG.
            //    The SVG always has a longer, thinner aspect ratio than the container span.
            //    After the SVG fills 100% of the height of the container span,
            //    there is a long arrow shaft left over. That left-over shaft is not shown.
            //    Instead, it is sliced off because the span's CSS has overflow: hidden.
            //    Thus, the reader sees an arrow that matches the subject matter width
            //    without distortion.
            //    Some functions, such as \cancel, need to vary their aspect ratio. These
            //    functions do not get the overflow SVG treatment.
            // Second Brush Stroke
            //    Low resolution monitors struggle to display images in fine detail.
            //    So browsers apply anti-aliasing. A long straight arrow shaft therefore
            //    will sometimes appear as if it has a blurred edge.
            //    To mitigate this, these SVG files contain a second "brush-stroke" on the
            //    arrow shafts. That is, a second long thin rectangular SVG path has been
            //    written directly on top of each arrow shaft. This reinforcement causes
            //    some of the screen pixels to display as black instead of the anti-aliased
            //    gray pixel that a  single path would generate. So we get arrow shafts
            //    whose edges appear to be sharper.
            // In the katexImagesData object just below, the dimensions all
            // correspond to path geometry inside the relevant SVG.
            // For example, \overrightarrow uses the same arrowhead as glyph U+2192
            // from the KaTeX Main font. The scaling factor is 1000.
            // That is, inside the font, that arrowhead is 522 units tall, which
            // corresponds to 0.522 em inside the document.
            katexImagesData = {
                //   path(s), minWidth, height, align
                overrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
                overleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
                underrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
                underleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
                xrightarrow: [["rightarrow"], 1.469, 522, "xMaxYMin"],
                xleftarrow: [["leftarrow"], 1.469, 522, "xMinYMin"],
                Overrightarrow: [["doublerightarrow"], 0.888, 560, "xMaxYMin"],
                xRightarrow: [["doublerightarrow"], 1.526, 560, "xMaxYMin"],
                xLeftarrow: [["doubleleftarrow"], 1.526, 560, "xMinYMin"],
                overleftharpoon: [["leftharpoon"], 0.888, 522, "xMinYMin"],
                xleftharpoonup: [["leftharpoon"], 0.888, 522, "xMinYMin"],
                xleftharpoondown: [["leftharpoondown"], 0.888, 522, "xMinYMin"],
                overrightharpoon: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
                xrightharpoonup: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
                xrightharpoondown: [["rightharpoondown"], 0.888, 522, "xMaxYMin"],
                xlongequal: [["longequal"], 0.888, 334, "xMinYMin"],
                xtwoheadleftarrow: [["twoheadleftarrow"], 0.888, 334, "xMinYMin"],
                xtwoheadrightarrow: [["twoheadrightarrow"], 0.888, 334, "xMaxYMin"],
                overleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
                overbrace: [["leftbrace", "midbrace", "rightbrace"], 1.6, 548],
                underbrace: [["leftbraceunder", "midbraceunder", "rightbraceunder"], 1.6, 548],
                underleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
                xleftrightarrow: [["leftarrow", "rightarrow"], 1.75, 522],
                xLeftrightarrow: [["doubleleftarrow", "doublerightarrow"], 1.75, 560],
                xrightleftharpoons: [["leftharpoondownplus", "rightharpoonplus"], 1.75, 716],
                xleftrightharpoons: [["leftharpoonplus", "rightharpoondownplus"], 1.75, 716],
                xhookleftarrow: [["leftarrow", "righthook"], 1.08, 522],
                xhookrightarrow: [["lefthook", "rightarrow"], 1.08, 522],
                overlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
                underlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
                overgroup: [["leftgroup", "rightgroup"], 0.888, 342],
                undergroup: [["leftgroupunder", "rightgroupunder"], 0.888, 342],
                xmapsto: [["leftmapsto", "rightarrow"], 1.5, 522],
                xtofrom: [["leftToFrom", "rightToFrom"], 1.75, 528],
                // The next three arrows are from the mhchem package.
                // In mhchem.sty, min-length is 2.0em. But these arrows might appear in the
                // document as \xrightarrow or \xrightleftharpoons. Those have
                // min-length = 1.75em, so we set min-length on these next three to match.
                xrightleftarrows: [["baraboveleftarrow", "rightarrowabovebar"], 1.75, 901],
                xrightequilibrium: [["baraboveshortleftharpoon", "rightharpoonaboveshortbar"], 1.75, 716],
                xleftequilibrium: [["shortbaraboveleftharpoon", "shortrightharpoonabovebar"], 1.75, 716]
            };
            groupLength = function groupLength(arg) {
                if (arg.type === "ordgroup") {
                    return arg.body.length;
                }
                else {
                    return 1;
                }
            };
            svgSpan = function svgSpan(group, options) {
                // Create a span with inline SVG for the element.
                function buildSvgSpan_() {
                    let viewBoxWidth = 400000; // default
                    const label = group.label.substr(1);
                    if (utils.contains(["widehat", "widecheck", "widetilde", "utilde"], label)) {
                        // Each type in the `if` statement corresponds to one of the ParseNode
                        // types below. This narrowing is required to access `grp.base`.
                        const grp = group; // There are four SVG images available for each function.
                        // Choose a taller image when there are more characters.
                        const numChars = groupLength(grp.base);
                        let viewBoxHeight;
                        let pathName;
                        let height;
                        if (numChars > 5) {
                            if (label === "widehat" || label === "widecheck") {
                                viewBoxHeight = 420;
                                viewBoxWidth = 2364;
                                height = 0.42;
                                pathName = label + "4";
                            }
                            else {
                                viewBoxHeight = 312;
                                viewBoxWidth = 2340;
                                height = 0.34;
                                pathName = "tilde4";
                            }
                        }
                        else {
                            const imgIndex = [1, 1, 2, 2, 3, 3][numChars];
                            if (label === "widehat" || label === "widecheck") {
                                viewBoxWidth = [0, 1062, 2364, 2364, 2364][imgIndex];
                                viewBoxHeight = [0, 239, 300, 360, 420][imgIndex];
                                height = [0, 0.24, 0.3, 0.3, 0.36, 0.42][imgIndex];
                                pathName = label + imgIndex;
                            }
                            else {
                                viewBoxWidth = [0, 600, 1033, 2339, 2340][imgIndex];
                                viewBoxHeight = [0, 260, 286, 306, 312][imgIndex];
                                height = [0, 0.26, 0.286, 0.3, 0.306, 0.34][imgIndex];
                                pathName = "tilde" + imgIndex;
                            }
                        }
                        const path = new PathNode(pathName);
                        const svgNode = new SvgNode([path], {
                            "width": "100%",
                            "height": height + "em",
                            "viewBox": `0 0 ${viewBoxWidth} ${viewBoxHeight}`,
                            "preserveAspectRatio": "none"
                        });
                        return {
                            span: buildCommon.makeSvgSpan([], [svgNode], options),
                            minWidth: 0,
                            height
                        };
                    }
                    else {
                        const spans = [];
                        const data = katexImagesData[label];
                        const paths = data[0], minWidth = data[1], viewBoxHeight = data[2];
                        const height = viewBoxHeight / 1000;
                        const numSvgChildren = paths.length;
                        let widthClasses;
                        let aligns;
                        if (numSvgChildren === 1) {
                            // $FlowFixMe: All these cases must be of the 4-tuple type.
                            const align1 = data[3];
                            widthClasses = ["hide-tail"];
                            aligns = [align1];
                        }
                        else if (numSvgChildren === 2) {
                            widthClasses = ["halfarrow-left", "halfarrow-right"];
                            aligns = ["xMinYMin", "xMaxYMin"];
                        }
                        else if (numSvgChildren === 3) {
                            widthClasses = ["brace-left", "brace-center", "brace-right"];
                            aligns = ["xMinYMin", "xMidYMin", "xMaxYMin"];
                        }
                        else {
                            throw new Error(`Correct katexImagesData or update code here to support
                    ${numSvgChildren} children.`);
                        }
                        for (let i = 0; i < numSvgChildren; i++) {
                            const path = new PathNode(paths[i]);
                            const svgNode = new SvgNode([path], {
                                "width": "400em",
                                "height": height + "em",
                                "viewBox": `0 0 ${viewBoxWidth} ${viewBoxHeight}`,
                                "preserveAspectRatio": aligns[i] + " slice"
                            });
                            const span = buildCommon.makeSvgSpan([widthClasses[i]], [svgNode], options);
                            if (numSvgChildren === 1) {
                                return {
                                    span,
                                    minWidth,
                                    height
                                };
                            }
                            else {
                                span.style.height = height + "em";
                                spans.push(span);
                            }
                        }
                        return {
                            span: buildCommon.makeSpan(["stretchy"], spans, options),
                            minWidth,
                            height
                        };
                    }
                } // buildSvgSpan_()
                const _buildSvgSpan_ = buildSvgSpan_(), span = _buildSvgSpan_.span, minWidth = _buildSvgSpan_.minWidth, height = _buildSvgSpan_.height; // Note that we are returning span.depth = 0.
                // Any adjustments relative to the baseline must be done in buildHTML.
                span.height = height;
                span.style.height = height + "em";
                if (minWidth > 0) {
                    span.style.minWidth = minWidth + "em";
                }
                return span;
            };
            encloseSpan = function encloseSpan(inner, label, pad, options) {
                // Return an image span for \cancel, \bcancel, \xcancel, or \fbox
                let img;
                const totalHeight = inner.height + inner.depth + 2 * pad;
                if (/fbox|color/.test(label)) {
                    img = buildCommon.makeSpan(["stretchy", label], [], options);
                    if (label === "fbox") {
                        const color = options.color && options.getColor();
                        if (color) {
                            img.style.borderColor = color;
                        }
                    }
                }
                else {
                    // \cancel, \bcancel, or \xcancel
                    // Since \cancel's SVG is inline and it omits the viewBox attribute,
                    // its stroke-width will not vary with span area.
                    const lines = [];
                    if (/^[bx]cancel$/.test(label)) {
                        lines.push(new LineNode({
                            "x1": "0",
                            "y1": "0",
                            "x2": "100%",
                            "y2": "100%",
                            "stroke-width": "0.046em"
                        }));
                    }
                    if (/^x?cancel$/.test(label)) {
                        lines.push(new LineNode({
                            "x1": "0",
                            "y1": "100%",
                            "x2": "100%",
                            "y2": "0",
                            "stroke-width": "0.046em"
                        }));
                    }
                    const svgNode = new SvgNode(lines, {
                        "width": "100%",
                        "height": totalHeight + "em"
                    });
                    img = buildCommon.makeSvgSpan([], [svgNode], options);
                }
                img.height = totalHeight;
                img.style.height = totalHeight + "em";
                return img;
            };
            stretchy = {
                encloseSpan,
                mathMLnode,
                svgSpan
            };
            // NOTE: Unlike most `htmlBuilder`s, this one handles not only "accent", but
            htmlBuilder = (grp, options) => {
                // Accents are handled in the TeXbook pg. 443, rule 12.
                let base;
                let group;
                const supSub = checkNodeType(grp, "supsub");
                let supSubGroup;
                if (supSub) {
                    // If our base is a character box, and we have superscripts and
                    // subscripts, the supsub will defer to us. In particular, we want
                    // to attach the superscripts and subscripts to the inner body (so
                    // that the position of the superscripts and subscripts won't be
                    // affected by the height of the accent). We accomplish this by
                    // sticking the base of the accent into the base of the supsub, and
                    // rendering that, while keeping track of where the accent is.
                    // The real accent group is the base of the supsub group
                    group = assertNodeType(supSub.base, "accent"); // The character box is the base of the accent group
                    base = group.base; // Stick the character box into the base of the supsub group
                    supSub.base = base; // Rerender the supsub group with its new base, and store that
                    // result.
                    supSubGroup = assertSpan(buildGroup(supSub, options)); // reset original base
                    supSub.base = group;
                }
                else {
                    group = assertNodeType(grp, "accent");
                    base = group.base;
                } // Build the base group
                const body = buildGroup(base, options.havingCrampedStyle()); // Does the accent need to shift for the skew of a character?
                const mustShift = group.isShifty && utils.isCharacterBox(base); // Calculate the skew of the accent. This is based on the line "If the
                // nucleus is not a single character, let s = 0; otherwise set s to the
                // kern amount for the nucleus followed by the \skewchar of its font."
                // Note that our skew metrics are just the kern between each character
                // and the skewchar.
                let skew = 0;
                if (mustShift) {
                    // If the base is a character box, then we want the skew of the
                    // innermost character. To do that, we find the innermost character:
                    const baseChar = utils.getBaseElem(base); // Then, we render its group to get the symbol inside it
                    const baseGroup = buildGroup(baseChar, options.havingCrampedStyle()); // Finally, we pull the skew off of the symbol.
                    skew = assertSymbolDomNode(baseGroup).skew; // Note that we now throw away baseGroup, because the layers we
                    // removed with getBaseElem might contain things like \color which
                    // we can't get rid of.
                    // TODO(emily): Find a better way to get the skew
                } // calculate the amount of space between the body and the accent
                let clearance = Math.min(body.height, options.fontMetrics().xHeight); // Build the accent
                let accentBody;
                if (!group.isStretchy) {
                    let accent;
                    let width;
                    if (group.label === "\\vec") {
                        // Before version 0.9, \vec used the combining font glyph U+20D7.
                        // But browsers, especially Safari, are not consistent in how they
                        // render combining characters when not preceded by a character.
                        // So now we use an SVG.
                        // If Safari reforms, we should consider reverting to the glyph.
                        accent = buildCommon.staticSvg("vec", options);
                        width = buildCommon.svgData.vec[1];
                    }
                    else {
                        accent = buildCommon.makeOrd({
                            mode: group.mode,
                            text: group.label
                        }, options, "textord");
                        accent = assertSymbolDomNode(accent); // Remove the italic correction of the accent, because it only serves to
                        // shift the accent over to a place we don't want.
                        accent.italic = 0;
                        width = accent.width;
                    }
                    accentBody = buildCommon.makeSpan(["accent-body"], [accent]); // "Full" accents expand the width of the resulting symbol to be
                    // at least the width of the accent, and overlap directly onto the
                    // character without any vertical offset.
                    const accentFull = group.label === "\\textcircled";
                    if (accentFull) {
                        accentBody.classes.push('accent-full');
                        clearance = body.height;
                    } // Shift the accent over by the skew.
                    let left = skew; // CSS defines `.katex .accent .accent-body:not(.accent-full) { width: 0 }`
                    // so that the accent doesn't contribute to the bounding box.
                    // We need to shift the character by its width (effectively half
                    // its width) to compensate.
                    if (!accentFull) {
                        left -= width / 2;
                    }
                    accentBody.style.left = left + "em"; // \textcircled uses the \bigcirc glyph, so it needs some
                    // vertical adjustment to match LaTeX.
                    if (group.label === "\\textcircled") {
                        accentBody.style.top = ".2em";
                    }
                    accentBody = buildCommon.makeVList({
                        positionType: "firstBaseline",
                        children: [{
                                type: "elem",
                                elem: body
                            }, {
                                type: "kern",
                                size: -clearance
                            }, {
                                type: "elem",
                                elem: accentBody
                            }]
                    }, options);
                }
                else {
                    accentBody = stretchy.svgSpan(group, options);
                    accentBody = buildCommon.makeVList({
                        positionType: "firstBaseline",
                        children: [{
                                type: "elem",
                                elem: body
                            }, {
                                type: "elem",
                                elem: accentBody,
                                wrapperClasses: ["svg-align"],
                                wrapperStyle: skew > 0 ? {
                                    width: `calc(100% - ${2 * skew}em)`,
                                    marginLeft: `${2 * skew}em`
                                } : undefined
                            }]
                    }, options);
                }
                const accentWrap = buildCommon.makeSpan(["mord", "accent"], [accentBody], options);
                if (supSubGroup) {
                    // Here, we replace the "base" child of the supsub with our newly
                    // generated accent.
                    supSubGroup.children[0] = accentWrap; // Since we don't rerun the height calculation after replacing the
                    // accent, we manually recalculate height.
                    supSubGroup.height = Math.max(accentWrap.height, supSubGroup.height); // Accents should always be ords, even when their innards are not.
                    supSubGroup.classes[0] = "mord";
                    return supSubGroup;
                }
                else {
                    return accentWrap;
                }
            };
            mathmlBuilder = (group, options) => {
                const accentNode = group.isStretchy ? stretchy.mathMLnode(group.label) : new mathMLTree.MathNode("mo", [makeText(group.label, group.mode)]);
                const node = new mathMLTree.MathNode("mover", [buildGroup$1(group.base, options), accentNode]);
                node.setAttribute("accent", "true");
                return node;
            };
            NON_STRETCHY_ACCENT_REGEX = new RegExp(["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring"].map(accent => `\\${accent}`).join("|")); // Accents
            defineFunction({
                type: "accent",
                names: ["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring", "\\widecheck", "\\widehat", "\\widetilde", "\\overrightarrow", "\\overleftarrow", "\\Overrightarrow", "\\overleftrightarrow", "\\overgroup", "\\overlinesegment", "\\overleftharpoon", "\\overrightharpoon"],
                props: {
                    numArgs: 1
                },
                handler: (context, args) => {
                    const base = args[0];
                    const isStretchy = !NON_STRETCHY_ACCENT_REGEX.test(context.funcName);
                    const isShifty = !isStretchy || context.funcName === "\\widehat" || context.funcName === "\\widetilde" || context.funcName === "\\widecheck";
                    return {
                        type: "accent",
                        mode: context.parser.mode,
                        label: context.funcName,
                        isStretchy: isStretchy,
                        isShifty: isShifty,
                        base: base
                    };
                },
                htmlBuilder,
                mathmlBuilder
            }); // Text-mode accents
            defineFunction({
                type: "accent",
                names: ["\\'", "\\`", "\\^", "\\~", "\\=", "\\u", "\\.", '\\"', "\\r", "\\H", "\\v", "\\textcircled"],
                props: {
                    numArgs: 1,
                    allowedInText: true,
                    allowedInMath: false
                },
                handler: (context, args) => {
                    const base = args[0];
                    return {
                        type: "accent",
                        mode: context.parser.mode,
                        label: context.funcName,
                        isStretchy: false,
                        isShifty: true,
                        base: base
                    };
                },
                htmlBuilder,
                mathmlBuilder
            });
            // Horizontal overlap functions
            defineFunction({
                type: "accentUnder",
                names: ["\\underleftarrow", "\\underrightarrow", "\\underleftrightarrow", "\\undergroup", "\\underlinesegment", "\\utilde"],
                props: {
                    numArgs: 1
                },
                handler: (_ref, args) => {
                    let parser = _ref.parser, funcName = _ref.funcName;
                    const base = args[0];
                    return {
                        type: "accentUnder",
                        mode: parser.mode,
                        label: funcName,
                        base: base
                    };
                },
                htmlBuilder: (group, options) => {
                    // Treat under accents much like underlines.
                    const innerGroup = buildGroup(group.base, options);
                    const accentBody = stretchy.svgSpan(group, options);
                    const kern = group.label === "\\utilde" ? 0.12 : 0; // Generate the vlist, with the appropriate kerns
                    const vlist = buildCommon.makeVList({
                        positionType: "bottom",
                        positionData: accentBody.height + kern,
                        children: [{
                                type: "elem",
                                elem: accentBody,
                                wrapperClasses: ["svg-align"]
                            }, {
                                type: "kern",
                                size: kern
                            }, {
                                type: "elem",
                                elem: innerGroup
                            }]
                    }, options);
                    return buildCommon.makeSpan(["mord", "accentunder"], [vlist], options);
                },
                mathmlBuilder: (group, options) => {
                    const accentNode = stretchy.mathMLnode(group.label);
                    const node = new mathMLTree.MathNode("munder", [buildGroup$1(group.base, options), accentNode]);
                    node.setAttribute("accentunder", "true");
                    return node;
                }
            });
            // Helper function
            paddedNode = group => {
                const node = new mathMLTree.MathNode("mpadded", group ? [group] : []);
                node.setAttribute("width", "+0.6em");
                node.setAttribute("lspace", "0.3em");
                return node;
            }; // Stretchy arrows with an optional argument
            defineFunction({
                type: "xArrow",
                names: ["\\xleftarrow", "\\xrightarrow", "\\xLeftarrow", "\\xRightarrow", "\\xleftrightarrow", "\\xLeftrightarrow", "\\xhookleftarrow", "\\xhookrightarrow", "\\xmapsto", "\\xrightharpoondown", "\\xrightharpoonup", "\\xleftharpoondown", "\\xleftharpoonup", "\\xrightleftharpoons", "\\xleftrightharpoons", "\\xlongequal", "\\xtwoheadrightarrow", "\\xtwoheadleftarrow", "\\xtofrom",
                    // Direct use of these functions is discouraged and may break someday.
                    "\\xrightleftarrows", "\\xrightequilibrium", "\\xleftequilibrium"],
                props: {
                    numArgs: 1,
                    numOptionalArgs: 1
                },
                handler(_ref, args, optArgs) {
                    let parser = _ref.parser, funcName = _ref.funcName;
                    return {
                        type: "xArrow",
                        mode: parser.mode,
                        label: funcName,
                        body: args[0],
                        below: optArgs[0]
                    };
                },
                // Flow is unable to correctly infer the type of `group`, even though it's
                // unamibiguously determined from the passed-in `type` above.
                htmlBuilder(group, options) {
                    const style = options.style; // Build the argument groups in the appropriate style.
                    // Ref: amsmath.dtx:   \hbox{$\scriptstyle\mkern#3mu{#6}\mkern#4mu$}%
                    // Some groups can return document fragments.  Handle those by wrapping
                    // them in a span.
                    let newOptions = options.havingStyle(style.sup());
                    const upperGroup = buildCommon.wrapFragment(buildGroup(group.body, newOptions, options), options);
                    upperGroup.classes.push("x-arrow-pad");
                    let lowerGroup;
                    if (group.below) {
                        // Build the lower group
                        newOptions = options.havingStyle(style.sub());
                        lowerGroup = buildCommon.wrapFragment(buildGroup(group.below, newOptions, options), options);
                        lowerGroup.classes.push("x-arrow-pad");
                    }
                    const arrowBody = stretchy.svgSpan(group, options); // Re shift: Note that stretchy.svgSpan returned arrowBody.depth = 0.
                    // The point we want on the math axis is at 0.5 * arrowBody.height.
                    const arrowShift = -options.fontMetrics().axisHeight + 0.5 * arrowBody.height; // 2 mu kern. Ref: amsmath.dtx: #7\if0#2\else\mkern#2mu\fi
                    let upperShift = -options.fontMetrics().axisHeight - 0.5 * arrowBody.height - 0.111; // 0.111 em = 2 mu
                    if (upperGroup.depth > 0.25 || group.label === "\\xleftequilibrium") {
                        upperShift -= upperGroup.depth; // shift up if depth encroaches
                    } // Generate the vlist
                    let vlist;
                    if (lowerGroup) {
                        const lowerShift = -options.fontMetrics().axisHeight + lowerGroup.height + 0.5 * arrowBody.height + 0.111;
                        vlist = buildCommon.makeVList({
                            positionType: "individualShift",
                            children: [{
                                    type: "elem",
                                    elem: upperGroup,
                                    shift: upperShift
                                }, {
                                    type: "elem",
                                    elem: arrowBody,
                                    shift: arrowShift
                                }, {
                                    type: "elem",
                                    elem: lowerGroup,
                                    shift: lowerShift
                                }]
                        }, options);
                    }
                    else {
                        vlist = buildCommon.makeVList({
                            positionType: "individualShift",
                            children: [{
                                    type: "elem",
                                    elem: upperGroup,
                                    shift: upperShift
                                }, {
                                    type: "elem",
                                    elem: arrowBody,
                                    shift: arrowShift
                                }]
                        }, options);
                    } // $FlowFixMe: Replace this with passing "svg-align" into makeVList.
                    vlist.children[0].children[0].children[1].classes.push("svg-align");
                    return buildCommon.makeSpan(["mrel", "x-arrow"], [vlist], options);
                },
                mathmlBuilder(group, options) {
                    const arrowNode = stretchy.mathMLnode(group.label);
                    let node;
                    if (group.body) {
                        const upperNode = paddedNode(buildGroup$1(group.body, options));
                        if (group.below) {
                            const lowerNode = paddedNode(buildGroup$1(group.below, options));
                            node = new mathMLTree.MathNode("munderover", [arrowNode, lowerNode, upperNode]);
                        }
                        else {
                            node = new mathMLTree.MathNode("mover", [arrowNode, upperNode]);
                        }
                    }
                    else if (group.below) {
                        const lowerNode = paddedNode(buildGroup$1(group.below, options));
                        node = new mathMLTree.MathNode("munder", [arrowNode, lowerNode]);
                    }
                    else {
                        // This should never happen.
                        // Parser.js throws an error if there is no argument.
                        node = paddedNode();
                        node = new mathMLTree.MathNode("mover", [arrowNode, node]);
                    }
                    return node;
                }
            });
            // {123} and converts into symbol with code 123.  It is used by the *macro*
            // \char defined in macros.js.
            defineFunction({
                type: "textord",
                names: ["\\@char"],
                props: {
                    numArgs: 1,
                    allowedInText: true
                },
                handler(_ref, args) {
                    let parser = _ref.parser;
                    const arg = assertNodeType(args[0], "ordgroup");
                    const group = arg.body;
                    let number = "";
                    for (let i = 0; i < group.length; i++) {
                        const node = assertNodeType(group[i], "textord");
                        number += node.text;
                    }
                    const code = parseInt(number);
                    if (isNaN(code)) {
                        throw new ParseError(`\\@char has non-numeric argument ${number}`);
                    }
                    return {
                        type: "textord",
                        mode: parser.mode,
                        text: String.fromCharCode(code)
                    };
                }
            });
            htmlBuilder$1 = (group, options) => {
                const elements = buildExpression(group.body, options.withColor(group.color), false); // \color isn't supposed to affect the type of the elements it contains.
                // To accomplish this, we wrap the results in a fragment, so the inner
                // elements will be able to directly interact with their neighbors. For
                // example, `\color{red}{2 +} 3` has the same spacing as `2 + 3`
                return buildCommon.makeFragment(elements);
            };
            mathmlBuilder$1 = (group, options) => {
                const inner = buildExpression$1(group.body, options.withColor(group.color));
                const node = new mathMLTree.MathNode("mstyle", inner);
                node.setAttribute("mathcolor", group.color);
                return node;
            };
            defineFunction({
                type: "color",
                names: ["\\textcolor"],
                props: {
                    numArgs: 2,
                    allowedInText: true,
                    greediness: 3,
                    argTypes: ["color", "original"]
                },
                handler(_ref, args) {
                    let parser = _ref.parser;
                    const color = assertNodeType(args[0], "color-token").color;
                    const body = args[1];
                    return {
                        type: "color",
                        mode: parser.mode,
                        color,
                        body: ordargument(body)
                    };
                },
                htmlBuilder: htmlBuilder$1,
                mathmlBuilder: mathmlBuilder$1
            });
            defineFunction({
                type: "color",
                names: ["\\color"],
                props: {
                    numArgs: 1,
                    allowedInText: true,
                    greediness: 3,
                    argTypes: ["color"]
                },
                handler(_ref2, args) {
                    let parser = _ref2.parser, breakOnTokenText = _ref2.breakOnTokenText;
                    const color = assertNodeType(args[0], "color-token").color; // Set macro \current@color in current namespace to store the current
                    // color, mimicking the behavior of color.sty.
                    // This is currently used just to correctly color a \right
                    // that follows a \color command.
                    parser.gullet.macros.set("\\current@color", color); // Parse out the implicit body that should be colored.
                    const body = parser.parseExpression(true, breakOnTokenText);
                    return {
                        type: "color",
                        mode: parser.mode,
                        color,
                        body
                    };
                },
                htmlBuilder: htmlBuilder$1,
                mathmlBuilder: mathmlBuilder$1
            });
            // Row breaks within tabular environments, and line breaks at top level
            // same signature, we implement them as one megafunction, with newRow
            // indicating whether we're in the \cr case, and newLine indicating whether
            // to break the line in the \newline case.
            defineFunction({
                type: "cr",
                names: ["\\cr", "\\newline"],
                props: {
                    numArgs: 0,
                    numOptionalArgs: 1,
                    argTypes: ["size"],
                    allowedInText: true
                },
                handler(_ref, args, optArgs) {
                    let parser = _ref.parser, funcName = _ref.funcName;
                    const size = optArgs[0];
                    const newRow = funcName === "\\cr";
                    let newLine = false;
                    if (!newRow) {
                        if (parser.settings.displayMode && parser.settings.useStrictBehavior("newLineInDisplayMode", "In LaTeX, \\\\ or \\newline " + "does nothing in display mode")) {
                            newLine = false;
                        }
                        else {
                            newLine = true;
                        }
                    }
                    return {
                        type: "cr",
                        mode: parser.mode,
                        newLine,
                        newRow,
                        size: size && assertNodeType(size, "size").value
                    };
                },
                // The following builders are called only at the top level,
                // not within tabular/array environments.
                htmlBuilder(group, options) {
                    if (group.newRow) {
                        throw new ParseError("\\cr valid only within a tabular/array environment");
                    }
                    const span = buildCommon.makeSpan(["mspace"], [], options);
                    if (group.newLine) {
                        span.classes.push("newline");
                        if (group.size) {
                            span.style.marginTop = calculateSize(group.size, options) + "em";
                        }
                    }
                    return span;
                },
                mathmlBuilder(group, options) {
                    const node = new mathMLTree.MathNode("mspace");
                    if (group.newLine) {
                        node.setAttribute("linebreak", "newline");
                        if (group.size) {
                            node.setAttribute("height", calculateSize(group.size, options) + "em");
                        }
                    }
                    return node;
                }
            });
            /**
             * This file deals with creating delimiters of various sizes. The TeXbook
             * discusses these routines on page 441-442, in the "Another subroutine sets box
             * x to a specified variable delimiter" paragraph.
             *
             * There are three main routines here. `makeSmallDelim` makes a delimiter in the
             * normal font, but in either text, script, or scriptscript style.
             * `makeLargeDelim` makes a delimiter in textstyle, but in one of the Size1,
             * Size2, Size3, or Size4 fonts. `makeStackedDelim` makes a delimiter out of
             * smaller pieces that are stacked on top of one another.
             *
             * The functions take a parameter `center`, which determines if the delimiter
             * should be centered around the axis.
             *
             * Then, there are three exposed functions. `sizedDelim` makes a delimiter in
             * one of the given sizes. This is used for things like `\bigl`.
             * `customSizedDelim` makes a delimiter with a given total height+depth. It is
             * called in places like `\sqrt`. `leftRightDelim` makes an appropriate
             * delimiter which surrounds an expression of a given height an depth. It is
             * used in `\left` and `\right`.
             */
            /**
             * Get the metrics for a given symbol and font, after transformation (i.e.
             * after following replacement from symbols.js)
             */
            getMetrics = function getMetrics(symbol, font, mode) {
                const replace = symbols.math[symbol] && symbols.math[symbol].replace;
                const metrics = getCharacterMetrics(replace || symbol, font, mode);
                if (!metrics) {
                    throw new Error(`Unsupported symbol ${symbol} and font size ${font}.`);
                }
                return metrics;
            };
            /**
             * Puts a delimiter span in a given style, and adds appropriate height, depth,
             * and maxFontSizes.
             */
            styleWrap = function styleWrap(delim, toStyle, options, classes) {
                const newOptions = options.havingBaseStyle(toStyle);
                const span = buildCommon.makeSpan(classes.concat(newOptions.sizingClasses(options)), [delim], options);
                const delimSizeMultiplier = newOptions.sizeMultiplier / options.sizeMultiplier;
                span.height *= delimSizeMultiplier;
                span.depth *= delimSizeMultiplier;
                span.maxFontSize = newOptions.sizeMultiplier;
                return span;
            };
            centerSpan = function centerSpan(span, options, style) {
                const newOptions = options.havingBaseStyle(style);
                const shift = (1 - options.sizeMultiplier / newOptions.sizeMultiplier) * options.fontMetrics().axisHeight;
                span.classes.push("delimcenter");
                span.style.top = shift + "em";
                span.height -= shift;
                span.depth += shift;
            };
            /**
             * Makes a small delimiter. This is a delimiter that comes in the Main-Regular
             * font, but is restyled to either be in textstyle, scriptstyle, or
             * scriptscriptstyle.
             */
            makeSmallDelim = function makeSmallDelim(delim, style, center, options, mode, classes) {
                const text = buildCommon.makeSymbol(delim, "Main-Regular", mode, options);
                const span = styleWrap(text, style, options, classes);
                if (center) {
                    centerSpan(span, options, style);
                }
                return span;
            };
            /**
             * Builds a symbol in the given font size (note size is an integer)
             */
            mathrmSize = function mathrmSize(value, size, mode, options) {
                return buildCommon.makeSymbol(value, "Size" + size + "-Regular", mode, options);
            };
            /**
             * Makes a large delimiter. This is a delimiter that comes in the Size1, Size2,
             * Size3, or Size4 fonts. It is always rendered in textstyle.
             */
            makeLargeDelim = function makeLargeDelim(delim, size, center, options, mode, classes) {
                const inner = mathrmSize(delim, size, mode, options);
                const span = styleWrap(buildCommon.makeSpan(["delimsizing", "size" + size], [inner], options), Style$1.TEXT, options, classes);
                if (center) {
                    centerSpan(span, options, Style$1.TEXT);
                }
                return span;
            };
            /**
             * Make an inner span with the given offset and in the given font. This is used
             * in `makeStackedDelim` to make the stacking pieces for the delimiter.
             */
            makeInner = function makeInner(symbol, font, mode) {
                let sizeClass; // Apply the correct CSS class to choose the right font.
                if (font === "Size1-Regular") {
                    sizeClass = "delim-size1";
                }
                else 
                /* if (font === "Size4-Regular") */
                {
                    sizeClass = "delim-size4";
                }
                const inner = buildCommon.makeSpan(["delimsizinginner", sizeClass], [buildCommon.makeSpan([], [buildCommon.makeSymbol(symbol, font, mode)])]); // Since this will be passed into `makeVList` in the end, wrap the element
                // in the appropriate tag that VList uses.
                return {
                    type: "elem",
                    elem: inner
                };
            }; // Helper for makeStackedDelim
            lap = {
                type: "kern",
                size: -0.005
            };
            /**
             * Make a stacked delimiter out of a given delimiter, with the total height at
             * least `heightTotal`. This routine is mentioned on page 442 of the TeXbook.
             */
            makeStackedDelim = function makeStackedDelim(delim, heightTotal, center, options, mode, classes) {
                // There are four parts, the top, an optional middle, a repeated part, and a
                // bottom.
                let top;
                let middle;
                let repeat;
                let bottom;
                top = repeat = bottom = delim;
                middle = null; // Also keep track of what font the delimiters are in
                let font = "Size1-Regular"; // We set the parts and font based on the symbol. Note that we use
                // '\u23d0' instead of '|' and '\u2016' instead of '\\|' for the
                // repeats of the arrows
                if (delim === "\\uparrow") {
                    repeat = bottom = "\u23d0";
                }
                else if (delim === "\\Uparrow") {
                    repeat = bottom = "\u2016";
                }
                else if (delim === "\\downarrow") {
                    top = repeat = "\u23d0";
                }
                else if (delim === "\\Downarrow") {
                    top = repeat = "\u2016";
                }
                else if (delim === "\\updownarrow") {
                    top = "\\uparrow";
                    repeat = "\u23d0";
                    bottom = "\\downarrow";
                }
                else if (delim === "\\Updownarrow") {
                    top = "\\Uparrow";
                    repeat = "\u2016";
                    bottom = "\\Downarrow";
                }
                else if (delim === "[" || delim === "\\lbrack") {
                    top = "\u23a1";
                    repeat = "\u23a2";
                    bottom = "\u23a3";
                    font = "Size4-Regular";
                }
                else if (delim === "]" || delim === "\\rbrack") {
                    top = "\u23a4";
                    repeat = "\u23a5";
                    bottom = "\u23a6";
                    font = "Size4-Regular";
                }
                else if (delim === "\\lfloor" || delim === "\u230a") {
                    repeat = top = "\u23a2";
                    bottom = "\u23a3";
                    font = "Size4-Regular";
                }
                else if (delim === "\\lceil" || delim === "\u2308") {
                    top = "\u23a1";
                    repeat = bottom = "\u23a2";
                    font = "Size4-Regular";
                }
                else if (delim === "\\rfloor" || delim === "\u230b") {
                    repeat = top = "\u23a5";
                    bottom = "\u23a6";
                    font = "Size4-Regular";
                }
                else if (delim === "\\rceil" || delim === "\u2309") {
                    top = "\u23a4";
                    repeat = bottom = "\u23a5";
                    font = "Size4-Regular";
                }
                else if (delim === "(" || delim === "\\lparen") {
                    top = "\u239b";
                    repeat = "\u239c";
                    bottom = "\u239d";
                    font = "Size4-Regular";
                }
                else if (delim === ")" || delim === "\\rparen") {
                    top = "\u239e";
                    repeat = "\u239f";
                    bottom = "\u23a0";
                    font = "Size4-Regular";
                }
                else if (delim === "\\{" || delim === "\\lbrace") {
                    top = "\u23a7";
                    middle = "\u23a8";
                    bottom = "\u23a9";
                    repeat = "\u23aa";
                    font = "Size4-Regular";
                }
                else if (delim === "\\}" || delim === "\\rbrace") {
                    top = "\u23ab";
                    middle = "\u23ac";
                    bottom = "\u23ad";
                    repeat = "\u23aa";
                    font = "Size4-Regular";
                }
                else if (delim === "\\lgroup" || delim === "\u27ee") {
                    top = "\u23a7";
                    bottom = "\u23a9";
                    repeat = "\u23aa";
                    font = "Size4-Regular";
                }
                else if (delim === "\\rgroup" || delim === "\u27ef") {
                    top = "\u23ab";
                    bottom = "\u23ad";
                    repeat = "\u23aa";
                    font = "Size4-Regular";
                }
                else if (delim === "\\lmoustache" || delim === "\u23b0") {
                    top = "\u23a7";
                    bottom = "\u23ad";
                    repeat = "\u23aa";
                    font = "Size4-Regular";
                }
                else if (delim === "\\rmoustache" || delim === "\u23b1") {
                    top = "\u23ab";
                    bottom = "\u23a9";
                    repeat = "\u23aa";
                    font = "Size4-Regular";
                } // Get the metrics of the four sections
                const topMetrics = getMetrics(top, font, mode);
                const topHeightTotal = topMetrics.height + topMetrics.depth;
                const repeatMetrics = getMetrics(repeat, font, mode);
                const repeatHeightTotal = repeatMetrics.height + repeatMetrics.depth;
                const bottomMetrics = getMetrics(bottom, font, mode);
                const bottomHeightTotal = bottomMetrics.height + bottomMetrics.depth;
                let middleHeightTotal = 0;
                let middleFactor = 1;
                if (middle !== null) {
                    const middleMetrics = getMetrics(middle, font, mode);
                    middleHeightTotal = middleMetrics.height + middleMetrics.depth;
                    middleFactor = 2; // repeat symmetrically above and below middle
                } // Calcuate the minimal height that the delimiter can have.
                // It is at least the size of the top, bottom, and optional middle combined.
                const minHeight = topHeightTotal + bottomHeightTotal + middleHeightTotal; // Compute the number of copies of the repeat symbol we will need
                const repeatCount = Math.max(0, Math.ceil((heightTotal - minHeight) / (middleFactor * repeatHeightTotal))); // Compute the total height of the delimiter including all the symbols
                const realHeightTotal = minHeight + repeatCount * middleFactor * repeatHeightTotal; // The center of the delimiter is placed at the center of the axis. Note
                // that in this context, "center" means that the delimiter should be
                // centered around the axis in the current style, while normally it is
                // centered around the axis in textstyle.
                let axisHeight = options.fontMetrics().axisHeight;
                if (center) {
                    axisHeight *= options.sizeMultiplier;
                } // Calculate the depth
                const depth = realHeightTotal / 2 - axisHeight; // This function differs from the TeX procedure in one way.
                // We shift each repeat element downwards by 0.005em, to prevent a gap
                // due to browser floating point rounding error.
                // Then, at the last element-to element joint, we add one extra repeat
                // element to cover the gap created by the shifts.
                // Find the shift needed to align the upper end of the extra element at a point
                // 0.005em above the lower end of the top element.
                const shiftOfExtraElement = (repeatCount + 1) * 0.005 - repeatHeightTotal; // Now, we start building the pieces that will go into the vlist
                // Keep a list of the inner pieces
                const inners = []; // Add the bottom symbol
                inners.push(makeInner(bottom, font, mode));
                if (middle === null) {
                    // Add that many symbols
                    for (let i = 0; i < repeatCount; i++) {
                        inners.push(lap); // overlap
                        inners.push(makeInner(repeat, font, mode));
                    }
                }
                else {
                    // When there is a middle bit, we need the middle part and two repeated
                    // sections
                    for (let i = 0; i < repeatCount; i++) {
                        inners.push(lap);
                        inners.push(makeInner(repeat, font, mode));
                    } // Insert one extra repeat element.
                    inners.push({
                        type: "kern",
                        size: shiftOfExtraElement
                    });
                    inners.push(makeInner(repeat, font, mode));
                    inners.push(lap); // Now insert the middle of the brace.
                    inners.push(makeInner(middle, font, mode));
                    for (let i = 0; i < repeatCount; i++) {
                        inners.push(lap);
                        inners.push(makeInner(repeat, font, mode));
                    }
                } // To cover the gap create by the overlaps, insert one more repeat element,
                // at a position that juts 0.005 above the bottom of the top element.
                inners.push({
                    type: "kern",
                    size: shiftOfExtraElement
                });
                inners.push(makeInner(repeat, font, mode));
                inners.push(lap); // Add the top symbol
                inners.push(makeInner(top, font, mode)); // Finally, build the vlist
                const newOptions = options.havingBaseStyle(Style$1.TEXT);
                const inner = buildCommon.makeVList({
                    positionType: "bottom",
                    positionData: depth,
                    children: inners
                }, newOptions);
                return styleWrap(buildCommon.makeSpan(["delimsizing", "mult"], [inner], newOptions), Style$1.TEXT, options, classes);
            }; // All surds have 0.08em padding above the viniculum inside the SVG.
            // That keeps browser span height rounding error from pinching the line.
            vbPad = 80; // padding above the surd, measured inside the viewBox.
            emPad = 0.08; // padding, in ems, measured in the document.
            sqrtSvg = function sqrtSvg(sqrtName, height, viewBoxHeight, extraViniculum, options) {
                const path = sqrtPath(sqrtName, extraViniculum, viewBoxHeight);
                const pathNode = new PathNode(sqrtName, path);
                const svg = new SvgNode([pathNode], {
                    // Note: 1000:1 ratio of viewBox to document em width.
                    "width": "400em",
                    "height": height + "em",
                    "viewBox": "0 0 400000 " + viewBoxHeight,
                    "preserveAspectRatio": "xMinYMin slice"
                });
                return buildCommon.makeSvgSpan(["hide-tail"], [svg], options);
            };
            /**
             * Make a sqrt image of the given height,
             */
            makeSqrtImage = function makeSqrtImage(height, options) {
                // Define a newOptions that removes the effect of size changes such as \Huge.
                // We don't pick different a height surd for \Huge. For it, we scale up.
                const newOptions = options.havingBaseSizing(); // Pick the desired surd glyph from a sequence of surds.
                const delim = traverseSequence("\\surd", height * newOptions.sizeMultiplier, stackLargeDelimiterSequence, newOptions);
                let sizeMultiplier = newOptions.sizeMultiplier; // default
                // The standard sqrt SVGs each have a 0.04em thick viniculum.
                // If Settings.minRuleThickness is larger than that, we add extraViniculum.
                const extraViniculum = Math.max(0, options.minRuleThickness - options.fontMetrics().sqrtRuleThickness); // Create a span containing an SVG image of a sqrt symbol.
                let span;
                let spanHeight = 0;
                let texHeight = 0;
                let viewBoxHeight = 0;
                let advanceWidth; // We create viewBoxes with 80 units of "padding" above each surd.
                // Then browser rounding error on the parent span height will not
                // encroach on the ink of the viniculum. But that padding is not
                // included in the TeX-like `height` used for calculation of
                // vertical alignment. So texHeight = span.height < span.style.height.
                if (delim.type === "small") {
                    // Get an SVG that is derived from glyph U+221A in font KaTeX-Main.
                    // 1000 unit normal glyph height.
                    viewBoxHeight = 1000 + 1000 * extraViniculum + vbPad;
                    if (height < 1.0) {
                        sizeMultiplier = 1.0; // mimic a \textfont radical
                    }
                    else if (height < 1.4) {
                        sizeMultiplier = 0.7; // mimic a \scriptfont radical
                    }
                    spanHeight = (1.0 + extraViniculum + emPad) / sizeMultiplier;
                    texHeight = (1.00 + extraViniculum) / sizeMultiplier;
                    span = sqrtSvg("sqrtMain", spanHeight, viewBoxHeight, extraViniculum, options);
                    span.style.minWidth = "0.853em";
                    advanceWidth = 0.833 / sizeMultiplier; // from the font.
                }
                else if (delim.type === "large") {
                    // These SVGs come from fonts: KaTeX_Size1, _Size2, etc.
                    viewBoxHeight = (1000 + vbPad) * sizeToMaxHeight[delim.size];
                    texHeight = (sizeToMaxHeight[delim.size] + extraViniculum) / sizeMultiplier;
                    spanHeight = (sizeToMaxHeight[delim.size] + extraViniculum + emPad) / sizeMultiplier;
                    span = sqrtSvg("sqrtSize" + delim.size, spanHeight, viewBoxHeight, extraViniculum, options);
                    span.style.minWidth = "1.02em";
                    advanceWidth = 1.0 / sizeMultiplier; // 1.0 from the font.
                }
                else {
                    // Tall sqrt. In TeX, this would be stacked using multiple glyphs.
                    // We'll use a single SVG to accomplish the same thing.
                    spanHeight = height + extraViniculum + emPad;
                    texHeight = height + extraViniculum;
                    viewBoxHeight = Math.floor(1000 * height + extraViniculum) + vbPad;
                    span = sqrtSvg("sqrtTall", spanHeight, viewBoxHeight, extraViniculum, options);
                    span.style.minWidth = "0.742em";
                    advanceWidth = 1.056;
                }
                span.height = texHeight;
                span.style.height = spanHeight + "em";
                return {
                    span,
                    advanceWidth,
                    // Calculate the actual line width.
                    // This actually should depend on the chosen font -- e.g. \boldmath
                    // should use the thicker surd symbols from e.g. KaTeX_Main-Bold, and
                    // have thicker rules.
                    ruleWidth: (options.fontMetrics().sqrtRuleThickness + extraViniculum) * sizeMultiplier
                };
            }; // There are three kinds of delimiters, delimiters that stack when they become
            // too large
            stackLargeDelimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "\u230a", "\u230b", "\\lceil", "\\rceil", "\u2308", "\u2309", "\\surd"]; // delimiters that always stack
            stackAlwaysDelimiters = ["\\uparrow", "\\downarrow", "\\updownarrow", "\\Uparrow", "\\Downarrow", "\\Updownarrow", "|", "\\|", "\\vert", "\\Vert", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "\u27ee", "\u27ef", "\\lmoustache", "\\rmoustache", "\u23b0", "\u23b1"]; // and delimiters that never stack
            stackNeverDelimiters = ["<", ">", "\\langle", "\\rangle", "/", "\\backslash", "\\lt", "\\gt"]; // Metrics of the different sizes. Found by looking at TeX's output of
            // $\bigl| // \Bigl| \biggl| \Biggl| \showlists$
            // Used to create stacked delimiters of appropriate sizes in makeSizedDelim.
            sizeToMaxHeight = [0, 1.2, 1.8, 2.4, 3.0];
            /**
             * Used to create a delimiter of a specific size, where `size` is 1, 2, 3, or 4.
             */
            makeSizedDelim = function makeSizedDelim(delim, size, options, mode, classes) {
                // < and > turn into \langle and \rangle in delimiters
                if (delim === "<" || delim === "\\lt" || delim === "\u27e8") {
                    delim = "\\langle";
                }
                else if (delim === ">" || delim === "\\gt" || delim === "\u27e9") {
                    delim = "\\rangle";
                } // Sized delimiters are never centered.
                if (utils.contains(stackLargeDelimiters, delim) || utils.contains(stackNeverDelimiters, delim)) {
                    return makeLargeDelim(delim, size, false, options, mode, classes);
                }
                else if (utils.contains(stackAlwaysDelimiters, delim)) {
                    return makeStackedDelim(delim, sizeToMaxHeight[size], false, options, mode, classes);
                }
                else {
                    throw new ParseError("Illegal delimiter: '" + delim + "'");
                }
            };
            /**
             * There are three different sequences of delimiter sizes that the delimiters
             * follow depending on the kind of delimiter. This is used when creating custom
             * sized delimiters to decide whether to create a small, large, or stacked
             * delimiter.
             *
             * In real TeX, these sequences aren't explicitly defined, but are instead
             * defined inside the font metrics. Since there are only three sequences that
             * are possible for the delimiters that TeX defines, it is easier to just encode
             * them explicitly here.
             */
            // Delimiters that never stack try small delimiters and large delimiters only
            stackNeverDelimiterSequence = [{
                    type: "small",
                    style: Style$1.SCRIPTSCRIPT
                }, {
                    type: "small",
                    style: Style$1.SCRIPT
                }, {
                    type: "small",
                    style: Style$1.TEXT
                }, {
                    type: "large",
                    size: 1
                }, {
                    type: "large",
                    size: 2
                }, {
                    type: "large",
                    size: 3
                }, {
                    type: "large",
                    size: 4
                }]; // Delimiters that always stack try the small delimiters first, then stack
            stackAlwaysDelimiterSequence = [{
                    type: "small",
                    style: Style$1.SCRIPTSCRIPT
                }, {
                    type: "small",
                    style: Style$1.SCRIPT
                }, {
                    type: "small",
                    style: Style$1.TEXT
                }, {
                    type: "stack"
                }]; // Delimiters that stack when large try the small and then large delimiters, and
            // stack afterwards
            stackLargeDelimiterSequence = [{
                    type: "small",
                    style: Style$1.SCRIPTSCRIPT
                }, {
                    type: "small",
                    style: Style$1.SCRIPT
                }, {
                    type: "small",
                    style: Style$1.TEXT
                }, {
                    type: "large",
                    size: 1
                }, {
                    type: "large",
                    size: 2
                }, {
                    type: "large",
                    size: 3
                }, {
                    type: "large",
                    size: 4
                }, {
                    type: "stack"
                }];
            /**
             * Get the font used in a delimiter based on what kind of delimiter it is.
             * TODO(#963) Use more specific font family return type once that is introduced.
             */
            delimTypeToFont = function delimTypeToFont(type) {
                if (type.type === "small") {
                    return "Main-Regular";
                }
                else if (type.type === "large") {
                    return "Size" + type.size + "-Regular";
                }
                else if (type.type === "stack") {
                    return "Size4-Regular";
                }
                else {
                    throw new Error(`Add support for delim type '${type.type}' here.`);
                }
            };
            /**
             * Traverse a sequence of types of delimiters to decide what kind of delimiter
             * should be used to create a delimiter of the given height+depth.
             */
            traverseSequence = function traverseSequence(delim, height, sequence, options) {
                // Here, we choose the index we should start at in the sequences. In smaller
                // sizes (which correspond to larger numbers in style.size) we start earlier
                // in the sequence. Thus, scriptscript starts at index 3-3=0, script starts
                // at index 3-2=1, text starts at 3-1=2, and display starts at min(2,3-0)=2
                const start = Math.min(2, 3 - options.style.size);
                for (let i = start; i < sequence.length; i++) {
                    if (sequence[i].type === "stack") {
                        // This is always the last delimiter, so we just break the loop now.
                        break;
                    }
                    const metrics = getMetrics(delim, delimTypeToFont(sequence[i]), "math");
                    let heightDepth = metrics.height + metrics.depth; // Small delimiters are scaled down versions of the same font, so we
                    // account for the style change size.
                    if (sequence[i].type === "small") {
                        const newOptions = options.havingBaseStyle(sequence[i].style);
                        heightDepth *= newOptions.sizeMultiplier;
                    } // Check if the delimiter at this size works for the given height.
                    if (heightDepth > height) {
                        return sequence[i];
                    }
                } // If we reached the end of the sequence, return the last sequence element.
                return sequence[sequence.length - 1];
            };
            /**
             * Make a delimiter of a given height+depth, with optional centering. Here, we
             * traverse the sequences, and create a delimiter that the sequence tells us to.
             */
            makeCustomSizedDelim = function makeCustomSizedDelim(delim, height, center, options, mode, classes) {
                if (delim === "<" || delim === "\\lt" || delim === "\u27e8") {
                    delim = "\\langle";
                }
                else if (delim === ">" || delim === "\\gt" || delim === "\u27e9") {
                    delim = "\\rangle";
                } // Decide what sequence to use
                let sequence;
                if (utils.contains(stackNeverDelimiters, delim)) {
                    sequence = stackNeverDelimiterSequence;
                }
                else if (utils.contains(stackLargeDelimiters, delim)) {
                    sequence = stackLargeDelimiterSequence;
                }
                else {
                    sequence = stackAlwaysDelimiterSequence;
                } // Look through the sequence
                const delimType = traverseSequence(delim, height, sequence, options); // Get the delimiter from font glyphs.
                // Depending on the sequence element we decided on, call the
                // appropriate function.
                if (delimType.type === "small") {
                    return makeSmallDelim(delim, delimType.style, center, options, mode, classes);
                }
                else if (delimType.type === "large") {
                    return makeLargeDelim(delim, delimType.size, center, options, mode, classes);
                }
                else 
                /* if (delimType.type === "stack") */
                {
                    return makeStackedDelim(delim, height, center, options, mode, classes);
                }
            };
            /**
             * Make a delimiter for use with `\left` and `\right`, given a height and depth
             * of an expression that the delimiters surround.
             */
            makeLeftRightDelim = function makeLeftRightDelim(delim, height, depth, options, mode, classes) {
                // We always center \left/\right delimiters, so the axis is always shifted
                const axisHeight = options.fontMetrics().axisHeight * options.sizeMultiplier; // Taken from TeX source, tex.web, function make_left_right
                const delimiterFactor = 901;
                const delimiterExtend = 5.0 / options.fontMetrics().ptPerEm;
                const maxDistFromAxis = Math.max(height - axisHeight, depth + axisHeight);
                const totalHeight = Math.max(// In real TeX, calculations are done using integral values which are
                // 65536 per pt, or 655360 per em. So, the division here truncates in
                // TeX but doesn't here, producing different results. If we wanted to
                // exactly match TeX's calculation, we could do
                //   Math.floor(655360 * maxDistFromAxis / 500) *
                //    delimiterFactor / 655360
                // (To see the difference, compare
                //    x^{x^{\left(\rule{0.1em}{0.68em}\right)}}
                // in TeX and KaTeX)
                maxDistFromAxis / 500 * delimiterFactor, 2 * maxDistFromAxis - delimiterExtend); // Finally, we defer to `makeCustomSizedDelim` with our calculated total
                // height
                return makeCustomSizedDelim(delim, totalHeight, true, options, mode, classes);
            };
            delimiter = {
                sqrtImage: makeSqrtImage,
                sizedDelim: makeSizedDelim,
                customSizedDelim: makeCustomSizedDelim,
                leftRightDelim: makeLeftRightDelim
            };
            // Extra data needed for the delimiter handler down below
            delimiterSizes = {
                "\\bigl": {
                    mclass: "mopen",
                    size: 1
                },
                "\\Bigl": {
                    mclass: "mopen",
                    size: 2
                },
                "\\biggl": {
                    mclass: "mopen",
                    size: 3
                },
                "\\Biggl": {
                    mclass: "mopen",
                    size: 4
                },
                "\\bigr": {
                    mclass: "mclose",
                    size: 1
                },
                "\\Bigr": {
                    mclass: "mclose",
                    size: 2
                },
                "\\biggr": {
                    mclass: "mclose",
                    size: 3
                },
                "\\Biggr": {
                    mclass: "mclose",
                    size: 4
                },
                "\\bigm": {
                    mclass: "mrel",
                    size: 1
                },
                "\\Bigm": {
                    mclass: "mrel",
                    size: 2
                },
                "\\biggm": {
                    mclass: "mrel",
                    size: 3
                },
                "\\Biggm": {
                    mclass: "mrel",
                    size: 4
                },
                "\\big": {
                    mclass: "mord",
                    size: 1
                },
                "\\Big": {
                    mclass: "mord",
                    size: 2
                },
                "\\bigg": {
                    mclass: "mord",
                    size: 3
                },
                "\\Bigg": {
                    mclass: "mord",
                    size: 4
                }
            };
            delimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "\u230a", "\u230b", "\\lceil", "\\rceil", "\u2308", "\u2309", "<", ">", "\\langle", "\u27e8", "\\rangle", "\u27e9", "\\lt", "\\gt", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "\u27ee", "\u27ef", "\\lmoustache", "\\rmoustache", "\u23b0", "\u23b1", "/", "\\backslash", "|", "\\vert", "\\|", "\\Vert", "\\uparrow", "\\Uparrow", "\\downarrow", "\\Downarrow", "\\updownarrow", "\\Updownarrow", "."];
            defineFunction({
                type: "delimsizing",
                names: ["\\bigl", "\\Bigl", "\\biggl", "\\Biggl", "\\bigr", "\\Bigr", "\\biggr", "\\Biggr", "\\bigm", "\\Bigm", "\\biggm", "\\Biggm", "\\big", "\\Big", "\\bigg", "\\Bigg"],
                props: {
                    numArgs: 1
                },
                handler: (context, args) => {
                    const delim = checkDelimiter(args[0], context);
                    return {
                        type: "delimsizing",
                        mode: context.parser.mode,
                        size: delimiterSizes[context.funcName].size,
                        mclass: delimiterSizes[context.funcName].mclass,
                        delim: delim.text
                    };
                },
                htmlBuilder: (group, options) => {
                    if (group.delim === ".") {
                        // Empty delimiters still count as elements, even though they don't
                        // show anything.
                        return buildCommon.makeSpan([group.mclass]);
                    } // Use delimiter.sizedDelim to generate the delimiter.
                    return delimiter.sizedDelim(group.delim, group.size, options, group.mode, [group.mclass]);
                },
                mathmlBuilder: group => {
                    const children = [];
                    if (group.delim !== ".") {
                        children.push(makeText(group.delim, group.mode));
                    }
                    const node = new mathMLTree.MathNode("mo", children);
                    if (group.mclass === "mopen" || group.mclass === "mclose") {
                        // Only some of the delimsizing functions act as fences, and they
                        // return "mopen" or "mclose" mclass.
                        node.setAttribute("fence", "true");
                    }
                    else {
                        // Explicitly disable fencing if it's not a fence, to override the
                        // defaults.
                        node.setAttribute("fence", "false");
                    }
                    return node;
                }
            });
            defineFunction({
                type: "leftright-right",
                names: ["\\right"],
                props: {
                    numArgs: 1
                },
                handler: (context, args) => {
                    // \left case below triggers parsing of \right in
                    //   `const right = parser.parseFunction();`
                    // uses this return value.
                    const color = context.parser.gullet.macros.get("\\current@color");
                    if (color && typeof color !== "string") {
                        throw new ParseError("\\current@color set to non-string in \\right");
                    }
                    return {
                        type: "leftright-right",
                        mode: context.parser.mode,
                        delim: checkDelimiter(args[0], context).text,
                        color // undefined if not set via \color
                    };
                }
            });
            defineFunction({
                type: "leftright",
                names: ["\\left"],
                props: {
                    numArgs: 1
                },
                handler: (context, args) => {
                    const delim = checkDelimiter(args[0], context);
                    const parser = context.parser; // Parse out the implicit body
                    ++parser.leftrightDepth; // parseExpression stops before '\\right'
                    const body = parser.parseExpression(false);
                    --parser.leftrightDepth; // Check the next token
                    parser.expect("\\right", false);
                    const right = assertNodeType(parser.parseFunction(), "leftright-right");
                    return {
                        type: "leftright",
                        mode: parser.mode,
                        body,
                        left: delim.text,
                        right: right.delim,
                        rightColor: right.color
                    };
                },
                htmlBuilder: (group, options) => {
                    assertParsed(group); // Build the inner expression
                    const inner = buildExpression(group.body, options, true, ["mopen", "mclose"]);
                    let innerHeight = 0;
                    let innerDepth = 0;
                    let hadMiddle = false; // Calculate its height and depth
                    for (let i = 0; i < inner.length; i++) {
                        // Property `isMiddle` not defined on `span`. See comment in
                        // "middle"'s htmlBuilder.
                        // $FlowFixMe
                        if (inner[i].isMiddle) {
                            hadMiddle = true;
                        }
                        else {
                            innerHeight = Math.max(inner[i].height, innerHeight);
                            innerDepth = Math.max(inner[i].depth, innerDepth);
                        }
                    } // The size of delimiters is the same, regardless of what style we are
                    // in. Thus, to correctly calculate the size of delimiter we need around
                    // a group, we scale down the inner size based on the size.
                    innerHeight *= options.sizeMultiplier;
                    innerDepth *= options.sizeMultiplier;
                    let leftDelim;
                    if (group.left === ".") {
                        // Empty delimiters in \left and \right make null delimiter spaces.
                        leftDelim = makeNullDelimiter(options, ["mopen"]);
                    }
                    else {
                        // Otherwise, use leftRightDelim to generate the correct sized
                        // delimiter.
                        leftDelim = delimiter.leftRightDelim(group.left, innerHeight, innerDepth, options, group.mode, ["mopen"]);
                    } // Add it to the beginning of the expression
                    inner.unshift(leftDelim); // Handle middle delimiters
                    if (hadMiddle) {
                        for (let i = 1; i < inner.length; i++) {
                            const middleDelim = inner[i]; // Property `isMiddle` not defined on `span`. See comment in
                            // "middle"'s htmlBuilder.
                            // $FlowFixMe
                            const isMiddle = middleDelim.isMiddle;
                            if (isMiddle) {
                                // Apply the options that were active when \middle was called
                                inner[i] = delimiter.leftRightDelim(isMiddle.delim, innerHeight, innerDepth, isMiddle.options, group.mode, []);
                            }
                        }
                    }
                    let rightDelim; // Same for the right delimiter, but using color specified by \color
                    if (group.right === ".") {
                        rightDelim = makeNullDelimiter(options, ["mclose"]);
                    }
                    else {
                        const colorOptions = group.rightColor ? options.withColor(group.rightColor) : options;
                        rightDelim = delimiter.leftRightDelim(group.right, innerHeight, innerDepth, colorOptions, group.mode, ["mclose"]);
                    } // Add it to the end of the expression.
                    inner.push(rightDelim);
                    return buildCommon.makeSpan(["minner"], inner, options);
                },
                mathmlBuilder: (group, options) => {
                    assertParsed(group);
                    const inner = buildExpression$1(group.body, options);
                    if (group.left !== ".") {
                        const leftNode = new mathMLTree.MathNode("mo", [makeText(group.left, group.mode)]);
                        leftNode.setAttribute("fence", "true");
                        inner.unshift(leftNode);
                    }
                    if (group.right !== ".") {
                        const rightNode = new mathMLTree.MathNode("mo", [makeText(group.right, group.mode)]);
                        rightNode.setAttribute("fence", "true");
                        if (group.rightColor) {
                            rightNode.setAttribute("mathcolor", group.rightColor);
                        }
                        inner.push(rightNode);
                    }
                    return makeRow(inner);
                }
            });
            defineFunction({
                type: "middle",
                names: ["\\middle"],
                props: {
                    numArgs: 1
                },
                handler: (context, args) => {
                    const delim = checkDelimiter(args[0], context);
                    if (!context.parser.leftrightDepth) {
                        throw new ParseError("\\middle without preceding \\left", delim);
                    }
                    return {
                        type: "middle",
                        mode: context.parser.mode,
                        delim: delim.text
                    };
                },
                htmlBuilder: (group, options) => {
                    let middleDelim;
                    if (group.delim === ".") {
                        middleDelim = makeNullDelimiter(options, []);
                    }
                    else {
                        middleDelim = delimiter.sizedDelim(group.delim, 1, options, group.mode, []);
                        const isMiddle = {
                            delim: group.delim,
                            options
                        }; // Property `isMiddle` not defined on `span`. It is only used in
                        // this file above.
                        // TODO: Fix this violation of the `span` type and possibly rename
                        // things since `isMiddle` sounds like a boolean, but is a struct.
                        // $FlowFixMe
                        middleDelim.isMiddle = isMiddle;
                    }
                    return middleDelim;
                },
                mathmlBuilder: (group, options) => {
                    // A Firefox \middle will strech a character vertically only if it
                    // is in the fence part of the operator dictionary at:
                    // https://www.w3.org/TR/MathML3/appendixc.html.
                    // So we need to avoid U+2223 and use plain "|" instead.
                    const textNode = group.delim === "\\vert" || group.delim === "|" ? makeText("|", "text") : makeText(group.delim, group.mode);
                    const middleNode = new mathMLTree.MathNode("mo", [textNode]);
                    middleNode.setAttribute("fence", "true"); // MathML gives 5/18em spacing to each <mo> element.
                    // \middle should get delimiter spacing instead.
                    middleNode.setAttribute("lspace", "0.05em");
                    middleNode.setAttribute("rspace", "0.05em");
                    return middleNode;
                }
            });
            htmlBuilder$2 = (group, options) => {
                // \cancel, \bcancel, \xcancel, \sout, \fbox, \colorbox, \fcolorbox
                // Some groups can return document fragments.  Handle those by wrapping
                // them in a span.
                const inner = buildCommon.wrapFragment(buildGroup(group.body, options), options);
                const label = group.label.substr(1);
                const scale = options.sizeMultiplier;
                let img;
                let imgShift = 0; // In the LaTeX cancel package, line geometry is slightly different
                // depending on whether the subject is wider than it is tall, or vice versa.
                // We don't know the width of a group, so as a proxy, we test if
                // the subject is a single character. This captures most of the
                // subjects that should get the "tall" treatment.
                const isSingleChar = utils.isCharacterBox(group.body);
                if (label === "sout") {
                    img = buildCommon.makeSpan(["stretchy", "sout"]);
                    img.height = options.fontMetrics().defaultRuleThickness / scale;
                    imgShift = -0.5 * options.fontMetrics().xHeight;
                }
                else {
                    // Add horizontal padding
                    if (/cancel/.test(label)) {
                        if (!isSingleChar) {
                            inner.classes.push("cancel-pad");
                        }
                    }
                    else {
                        inner.classes.push("boxpad");
                    } // Add vertical padding
                    let vertPad = 0;
                    let ruleThickness = 0; // ref: cancel package: \advance\totalheight2\p@ % "+2"
                    if (/box/.test(label)) {
                        ruleThickness = Math.max(options.fontMetrics().fboxrule, // default
                        options.minRuleThickness // User override.
                        );
                        vertPad = options.fontMetrics().fboxsep + (label === "colorbox" ? 0 : ruleThickness);
                    }
                    else {
                        vertPad = isSingleChar ? 0.2 : 0;
                    }
                    img = stretchy.encloseSpan(inner, label, vertPad, options);
                    if (/fbox|boxed|fcolorbox/.test(label)) {
                        img.style.borderStyle = "solid";
                        img.style.borderWidth = `${ruleThickness}em`;
                    }
                    imgShift = inner.depth + vertPad;
                    if (group.backgroundColor) {
                        img.style.backgroundColor = group.backgroundColor;
                        if (group.borderColor) {
                            img.style.borderColor = group.borderColor;
                        }
                    }
                }
                let vlist;
                if (group.backgroundColor) {
                    vlist = buildCommon.makeVList({
                        positionType: "individualShift",
                        children: [
                            {
                                type: "elem",
                                elem: img,
                                shift: imgShift
                            }, {
                                type: "elem",
                                elem: inner,
                                shift: 0
                            }
                        ]
                    }, options);
                }
                else {
                    vlist = buildCommon.makeVList({
                        positionType: "individualShift",
                        children: [
                            {
                                type: "elem",
                                elem: inner,
                                shift: 0
                            }, {
                                type: "elem",
                                elem: img,
                                shift: imgShift,
                                wrapperClasses: /cancel/.test(label) ? ["svg-align"] : []
                            }
                        ]
                    }, options);
                }
                if (/cancel/.test(label)) {
                    // The cancel package documentation says that cancel lines add their height
                    // to the expression, but tests show that isn't how it actually works.
                    vlist.height = inner.height;
                    vlist.depth = inner.depth;
                }
                if (/cancel/.test(label) && !isSingleChar) {
                    // cancel does not create horiz space for its line extension.
                    return buildCommon.makeSpan(["mord", "cancel-lap"], [vlist], options);
                }
                else {
                    return buildCommon.makeSpan(["mord"], [vlist], options);
                }
            };
            mathmlBuilder$2 = (group, options) => {
                let fboxsep = 0;
                const node = new mathMLTree.MathNode(group.label.indexOf("colorbox") > -1 ? "mpadded" : "menclose", [buildGroup$1(group.body, options)]);
                switch (group.label) {
                    case "\\cancel":
                        node.setAttribute("notation", "updiagonalstrike");
                        break;
                    case "\\bcancel":
                        node.setAttribute("notation", "downdiagonalstrike");
                        break;
                    case "\\sout":
                        node.setAttribute("notation", "horizontalstrike");
                        break;
                    case "\\fbox":
                        node.setAttribute("notation", "box");
                        break;
                    case "\\fcolorbox":
                    case "\\colorbox":
                        // <menclose> doesn't have a good notation option. So use <mpadded>
                        // instead. Set some attributes that come included with <menclose>.
                        fboxsep = options.fontMetrics().fboxsep * options.fontMetrics().ptPerEm;
                        node.setAttribute("width", `+${2 * fboxsep}pt`);
                        node.setAttribute("height", `+${2 * fboxsep}pt`);
                        node.setAttribute("lspace", `${fboxsep}pt`); //
                        node.setAttribute("voffset", `${fboxsep}pt`);
                        if (group.label === "\\fcolorbox") {
                            const thk = Math.max(options.fontMetrics().fboxrule, // default
                            options.minRuleThickness // user override
                            );
                            node.setAttribute("style", "border: " + thk + "em solid " + String(group.borderColor));
                        }
                        break;
                    case "\\xcancel":
                        node.setAttribute("notation", "updiagonalstrike downdiagonalstrike");
                        break;
                }
                if (group.backgroundColor) {
                    node.setAttribute("mathbackground", group.backgroundColor);
                }
                return node;
            };
            defineFunction({
                type: "enclose",
                names: ["\\colorbox"],
                props: {
                    numArgs: 2,
                    allowedInText: true,
                    greediness: 3,
                    argTypes: ["color", "text"]
                },
                handler(_ref, args, optArgs) {
                    let parser = _ref.parser, funcName = _ref.funcName;
                    const color = assertNodeType(args[0], "color-token").color;
                    const body = args[1];
                    return {
                        type: "enclose",
                        mode: parser.mode,
                        label: funcName,
                        backgroundColor: color,
                        body
                    };
                },
                htmlBuilder: htmlBuilder$2,
                mathmlBuilder: mathmlBuilder$2
            });
            defineFunction({
                type: "enclose",
                names: ["\\fcolorbox"],
                props: {
                    numArgs: 3,
                    allowedInText: true,
                    greediness: 3,
                    argTypes: ["color", "color", "text"]
                },
                handler(_ref2, args, optArgs) {
                    let parser = _ref2.parser, funcName = _ref2.funcName;
                    const borderColor = assertNodeType(args[0], "color-token").color;
                    const backgroundColor = assertNodeType(args[1], "color-token").color;
                    const body = args[2];
                    return {
                        type: "enclose",
                        mode: parser.mode,
                        label: funcName,
                        backgroundColor,
                        borderColor,
                        body
                    };
                },
                htmlBuilder: htmlBuilder$2,
                mathmlBuilder: mathmlBuilder$2
            });
            defineFunction({
                type: "enclose",
                names: ["\\fbox"],
                props: {
                    numArgs: 1,
                    argTypes: ["hbox"],
                    allowedInText: true
                },
                handler(_ref3, args) {
                    let parser = _ref3.parser;
                    return {
                        type: "enclose",
                        mode: parser.mode,
                        label: "\\fbox",
                        body: args[0]
                    };
                }
            });
            defineFunction({
                type: "enclose",
                names: ["\\cancel", "\\bcancel", "\\xcancel", "\\sout"],
                props: {
                    numArgs: 1
                },
                handler(_ref4, args, optArgs) {
                    let parser = _ref4.parser, funcName = _ref4.funcName;
                    const body = args[0];
                    return {
                        type: "enclose",
                        mode: parser.mode,
                        label: funcName,
                        body
                    };
                },
                htmlBuilder: htmlBuilder$2,
                mathmlBuilder: mathmlBuilder$2
            });
            /**
             * All registered environments.
             * `environments.js` exports this same dictionary again and makes it public.
             * `Parser.js` requires this dictionary via `environments.js`.
             */
            _environments = {};
            htmlBuilder$3 = function htmlBuilder(group, options) {
                let r;
                let c;
                const nr = group.body.length;
                const hLinesBeforeRow = group.hLinesBeforeRow;
                let nc = 0;
                let body = new Array(nr);
                const hlines = [];
                const ruleThickness = Math.max(// From LaTeX \showthe\arrayrulewidth. Equals 0.04 em.
                options.fontMetrics().arrayRuleWidth, options.minRuleThickness // User override.
                ); // Horizontal spacing
                const pt = 1 / options.fontMetrics().ptPerEm;
                let arraycolsep = 5 * pt; // default value, i.e. \arraycolsep in article.cls
                if (group.colSeparationType && group.colSeparationType === "small") {
                    // We're in a {smallmatrix}. Default column space is \thickspace,
                    // i.e. 5/18em = 0.2778em, per amsmath.dtx for {smallmatrix}.
                    // But that needs adjustment because LaTeX applies \scriptstyle to the
                    // entire array, including the colspace, but this function applies
                    // \scriptstyle only inside each element.
                    const localMultiplier = options.havingStyle(Style$1.SCRIPT).sizeMultiplier;
                    arraycolsep = 0.2778 * (localMultiplier / options.sizeMultiplier);
                } // Vertical spacing
                const baselineskip = 12 * pt; // see size10.clo
                // Default \jot from ltmath.dtx
                // TODO(edemaine): allow overriding \jot via \setlength (#687)
                const jot = 3 * pt;
                const arrayskip = group.arraystretch * baselineskip;
                const arstrutHeight = 0.7 * arrayskip; // \strutbox in ltfsstrc.dtx and
                const arstrutDepth = 0.3 * arrayskip; // \@arstrutbox in lttab.dtx
                let totalHeight = 0; // Set a position for \hline(s) at the top of the array, if any.
                function setHLinePos(hlinesInGap) {
                    for (let i = 0; i < hlinesInGap.length; ++i) {
                        if (i > 0) {
                            totalHeight += 0.25;
                        }
                        hlines.push({
                            pos: totalHeight,
                            isDashed: hlinesInGap[i]
                        });
                    }
                }
                setHLinePos(hLinesBeforeRow[0]);
                for (r = 0; r < group.body.length; ++r) {
                    const inrow = group.body[r];
                    let height = arstrutHeight; // \@array adds an \@arstrut
                    let depth = arstrutDepth; // to each tow (via the template)
                    if (nc < inrow.length) {
                        nc = inrow.length;
                    }
                    const outrow = new Array(inrow.length);
                    for (c = 0; c < inrow.length; ++c) {
                        const elt = buildGroup(inrow[c], options);
                        if (depth < elt.depth) {
                            depth = elt.depth;
                        }
                        if (height < elt.height) {
                            height = elt.height;
                        }
                        outrow[c] = elt;
                    }
                    const rowGap = group.rowGaps[r];
                    let gap = 0;
                    if (rowGap) {
                        gap = calculateSize(rowGap, options);
                        if (gap > 0) {
                            // \@argarraycr
                            gap += arstrutDepth;
                            if (depth < gap) {
                                depth = gap; // \@xargarraycr
                            }
                            gap = 0;
                        }
                    } // In AMS multiline environments such as aligned and gathered, rows
                    // correspond to lines that have additional \jot added to the
                    // \baselineskip via \openup.
                    if (group.addJot) {
                        depth += jot;
                    }
                    outrow.height = height;
                    outrow.depth = depth;
                    totalHeight += height;
                    outrow.pos = totalHeight;
                    totalHeight += depth + gap; // \@yargarraycr
                    body[r] = outrow; // Set a position for \hline(s), if any.
                    setHLinePos(hLinesBeforeRow[r + 1]);
                }
                const offset = totalHeight / 2 + options.fontMetrics().axisHeight;
                const colDescriptions = group.cols || [];
                const cols = [];
                let colSep;
                let colDescrNum;
                for (c = 0, colDescrNum = 0; // Continue while either there are more columns or more column
                 
                // descriptions, so trailing separators don't get lost.
                c < nc || colDescrNum < colDescriptions.length; ++c, ++colDescrNum) {
                    let colDescr = colDescriptions[colDescrNum] || {};
                    let firstSeparator = true;
                    while (colDescr.type === "separator") {
                        // If there is more than one separator in a row, add a space
                        // between them.
                        if (!firstSeparator) {
                            colSep = buildCommon.makeSpan(["arraycolsep"], []);
                            colSep.style.width = options.fontMetrics().doubleRuleSep + "em";
                            cols.push(colSep);
                        }
                        if (colDescr.separator === "|" || colDescr.separator === ":") {
                            const lineType = colDescr.separator === "|" ? "solid" : "dashed";
                            const separator = buildCommon.makeSpan(["vertical-separator"], [], options);
                            separator.style.height = totalHeight + "em";
                            separator.style.borderRightWidth = `${ruleThickness}em`;
                            separator.style.borderRightStyle = lineType;
                            separator.style.margin = `0 -${ruleThickness / 2}em`;
                            separator.style.verticalAlign = -(totalHeight - offset) + "em";
                            cols.push(separator);
                        }
                        else {
                            throw new ParseError("Invalid separator type: " + colDescr.separator);
                        }
                        colDescrNum++;
                        colDescr = colDescriptions[colDescrNum] || {};
                        firstSeparator = false;
                    }
                    if (c >= nc) {
                        continue;
                    }
                    let sepwidth;
                    if (c > 0 || group.hskipBeforeAndAfter) {
                        sepwidth = utils.deflt(colDescr.pregap, arraycolsep);
                        if (sepwidth !== 0) {
                            colSep = buildCommon.makeSpan(["arraycolsep"], []);
                            colSep.style.width = sepwidth + "em";
                            cols.push(colSep);
                        }
                    }
                    let col = [];
                    for (r = 0; r < nr; ++r) {
                        const row = body[r];
                        const elem = row[c];
                        if (!elem) {
                            continue;
                        }
                        const shift = row.pos - offset;
                        elem.depth = row.depth;
                        elem.height = row.height;
                        col.push({
                            type: "elem",
                            elem: elem,
                            shift: shift
                        });
                    }
                    col = buildCommon.makeVList({
                        positionType: "individualShift",
                        children: col
                    }, options);
                    col = buildCommon.makeSpan(["col-align-" + (colDescr.align || "c")], [col]);
                    cols.push(col);
                    if (c < nc - 1 || group.hskipBeforeAndAfter) {
                        sepwidth = utils.deflt(colDescr.postgap, arraycolsep);
                        if (sepwidth !== 0) {
                            colSep = buildCommon.makeSpan(["arraycolsep"], []);
                            colSep.style.width = sepwidth + "em";
                            cols.push(colSep);
                        }
                    }
                }
                body = buildCommon.makeSpan(["mtable"], cols); // Add \hline(s), if any.
                if (hlines.length > 0) {
                    const line = buildCommon.makeLineSpan("hline", options, ruleThickness);
                    const dashes = buildCommon.makeLineSpan("hdashline", options, ruleThickness);
                    const vListElems = [{
                            type: "elem",
                            elem: body,
                            shift: 0
                        }];
                    while (hlines.length > 0) {
                        const hline = hlines.pop();
                        const lineShift = hline.pos - offset;
                        if (hline.isDashed) {
                            vListElems.push({
                                type: "elem",
                                elem: dashes,
                                shift: lineShift
                            });
                        }
                        else {
                            vListElems.push({
                                type: "elem",
                                elem: line,
                                shift: lineShift
                            });
                        }
                    }
                    body = buildCommon.makeVList({
                        positionType: "individualShift",
                        children: vListElems
                    }, options);
                }
                return buildCommon.makeSpan(["mord"], [body], options);
            };
            alignMap = {
                c: "center ",
                l: "left ",
                r: "right "
            };
            mathmlBuilder$3 = function mathmlBuilder(group, options) {
                let table = new mathMLTree.MathNode("mtable", group.body.map(function (row) {
                    return new mathMLTree.MathNode("mtr", row.map(function (cell) {
                        return new mathMLTree.MathNode("mtd", [buildGroup$1(cell, options)]);
                    }));
                })); // Set column alignment, row spacing, column spacing, and
                // array lines by setting attributes on the table element.
                // Set the row spacing. In MathML, we specify a gap distance.
                // We do not use rowGap[] because MathML automatically increases
                // cell height with the height/depth of the element content.
                // LaTeX \arraystretch multiplies the row baseline-to-baseline distance.
                // We simulate this by adding (arraystretch - 1)em to the gap. This
                // does a reasonable job of adjusting arrays containing 1 em tall content.
                // The 0.16 and 0.09 values are found emprically. They produce an array
                // similar to LaTeX and in which content does not interfere with \hines.
                const gap = group.arraystretch === 0.5 ? 0.1 // {smallmatrix}, {subarray}
                    : 0.16 + group.arraystretch - 1 + (group.addJot ? 0.09 : 0);
                table.setAttribute("rowspacing", gap + "em"); // MathML table lines go only between cells.
                // To place a line on an edge we'll use <menclose>, if necessary.
                let menclose = "";
                let align = "";
                if (group.cols) {
                    // Find column alignment, column spacing, and  vertical lines.
                    const cols = group.cols;
                    let columnLines = "";
                    let prevTypeWasAlign = false;
                    let iStart = 0;
                    let iEnd = cols.length;
                    if (cols[0].type === "separator") {
                        menclose += "top ";
                        iStart = 1;
                    }
                    if (cols[cols.length - 1].type === "separator") {
                        menclose += "bottom ";
                        iEnd -= 1;
                    }
                    for (let i = iStart; i < iEnd; i++) {
                        if (cols[i].type === "align") {
                            align += alignMap[cols[i].align];
                            if (prevTypeWasAlign) {
                                columnLines += "none ";
                            }
                            prevTypeWasAlign = true;
                        }
                        else if (cols[i].type === "separator") {
                            // MathML accepts only single lines between cells.
                            // So we read only the first of consecutive separators.
                            if (prevTypeWasAlign) {
                                columnLines += cols[i].separator === "|" ? "solid " : "dashed ";
                                prevTypeWasAlign = false;
                            }
                        }
                    }
                    table.setAttribute("columnalign", align.trim());
                    if (/[sd]/.test(columnLines)) {
                        table.setAttribute("columnlines", columnLines.trim());
                    }
                } // Set column spacing.
                if (group.colSeparationType === "align") {
                    const cols = group.cols || [];
                    let spacing = "";
                    for (let i = 1; i < cols.length; i++) {
                        spacing += i % 2 ? "0em " : "1em ";
                    }
                    table.setAttribute("columnspacing", spacing.trim());
                }
                else if (group.colSeparationType === "alignat") {
                    table.setAttribute("columnspacing", "0em");
                }
                else if (group.colSeparationType === "small") {
                    table.setAttribute("columnspacing", "0.2778em");
                }
                else {
                    table.setAttribute("columnspacing", "1em");
                } // Address \hline and \hdashline
                let rowLines = "";
                const hlines = group.hLinesBeforeRow;
                menclose += hlines[0].length > 0 ? "left " : "";
                menclose += hlines[hlines.length - 1].length > 0 ? "right " : "";
                for (let i = 1; i < hlines.length - 1; i++) {
                    rowLines += hlines[i].length === 0 ? "none " // MathML accepts only a single line between rows. Read one element.
                        : hlines[i][0] ? "dashed " : "solid ";
                }
                if (/[sd]/.test(rowLines)) {
                    table.setAttribute("rowlines", rowLines.trim());
                }
                if (menclose !== "") {
                    table = new mathMLTree.MathNode("menclose", [table]);
                    table.setAttribute("notation", menclose.trim());
                }
                if (group.arraystretch && group.arraystretch < 1) {
                    // A small array. Wrap in scriptstyle so row gap is not too large.
                    table = new mathMLTree.MathNode("mstyle", [table]);
                    table.setAttribute("scriptlevel", "1");
                }
                return table;
            }; // Convenience function for aligned and alignedat environments.
            alignedHandler = function alignedHandler(context, args) {
                const cols = [];
                const res = parseArray(context.parser, {
                    cols,
                    addJot: true
                }, "display"); // Determining number of columns.
                // 1. If the first argument is given, we use it as a number of columns,
                //    and makes sure that each row doesn't exceed that number.
                // 2. Otherwise, just count number of columns = maximum number
                //    of cells in each row ("aligned" mode -- isAligned will be true).
                //
                // At the same time, prepend empty group {} at beginning of every second
                // cell in each row (starting with second cell) so that operators become
                // binary.  This behavior is implemented in amsmath's \start@aligned.
                let numMaths;
                let numCols = 0;
                const emptyGroup = {
                    type: "ordgroup",
                    mode: context.mode,
                    body: []
                };
                const ordgroup = checkNodeType(args[0], "ordgroup");
                if (ordgroup) {
                    let arg0 = "";
                    for (let i = 0; i < ordgroup.body.length; i++) {
                        const textord = assertNodeType(ordgroup.body[i], "textord");
                        arg0 += textord.text;
                    }
                    numMaths = Number(arg0);
                    numCols = numMaths * 2;
                }
                const isAligned = !numCols;
                res.body.forEach(function (row) {
                    for (let i = 1; i < row.length; i += 2) {
                        // Modify ordgroup node within styling node
                        const styling = assertNodeType(row[i], "styling");
                        const ordgroup = assertNodeType(styling.body[0], "ordgroup");
                        ordgroup.body.unshift(emptyGroup);
                    }
                    if (!isAligned) {
                        // Case 1
                        const curMaths = row.length / 2;
                        if (numMaths < curMaths) {
                            throw new ParseError("Too many math in a row: " + `expected ${numMaths}, but got ${curMaths}`, row[0]);
                        }
                    }
                    else if (numCols < row.length) {
                        // Case 2
                        numCols = row.length;
                    }
                }); // Adjusting alignment.
                // In aligned mode, we add one \qquad between columns;
                // otherwise we add nothing.
                for (let i = 0; i < numCols; ++i) {
                    let align = "r";
                    let pregap = 0;
                    if (i % 2 === 1) {
                        align = "l";
                    }
                    else if (i > 0 && isAligned) {
                        // "aligned" mode.
                        pregap = 1; // add one \quad
                    }
                    cols[i] = {
                        type: "align",
                        align: align,
                        pregap: pregap,
                        postgap: 0
                    };
                }
                res.colSeparationType = isAligned ? "align" : "alignat";
                return res;
            }; // Arrays are part of LaTeX, defined in lttab.dtx so its documentation
            // is part of the source2e.pdf file of LaTeX2e source documentation.
            // {darray} is an {array} environment where cells are set in \displaystyle,
            // as defined in nccmath.sty.
            defineEnvironment({
                type: "array",
                names: ["array", "darray"],
                props: {
                    numArgs: 1
                },
                handler(context, args) {
                    // Since no types are specified above, the two possibilities are
                    // - The argument is wrapped in {} or [], in which case Parser's
                    //   parseGroup() returns an "ordgroup" wrapping some symbol node.
                    // - The argument is a bare symbol node.
                    const symNode = checkSymbolNodeType(args[0]);
                    const colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
                    const cols = colalign.map(function (nde) {
                        const node = assertSymbolNodeType(nde);
                        const ca = node.text;
                        if ("lcr".indexOf(ca) !== -1) {
                            return {
                                type: "align",
                                align: ca
                            };
                        }
                        else if (ca === "|") {
                            return {
                                type: "separator",
                                separator: "|"
                            };
                        }
                        else if (ca === ":") {
                            return {
                                type: "separator",
                                separator: ":"
                            };
                        }
                        throw new ParseError("Unknown column alignment: " + ca, nde);
                    });
                    const res = {
                        cols,
                        hskipBeforeAndAfter: true // \@preamble in lttab.dtx
                    };
                    return parseArray(context.parser, res, dCellStyle(context.envName));
                },
                htmlBuilder: htmlBuilder$3,
                mathmlBuilder: mathmlBuilder$3
            }); // The matrix environments of amsmath builds on the array environment
            // of LaTeX, which is discussed above.
            defineEnvironment({
                type: "array",
                names: ["matrix", "pmatrix", "bmatrix", "Bmatrix", "vmatrix", "Vmatrix"],
                props: {
                    numArgs: 0
                },
                handler(context) {
                    const delimiters = {
                        "matrix": null,
                        "pmatrix": ["(", ")"],
                        "bmatrix": ["[", "]"],
                        "Bmatrix": ["\\{", "\\}"],
                        "vmatrix": ["|", "|"],
                        "Vmatrix": ["\\Vert", "\\Vert"]
                    }[context.envName]; // \hskip -\arraycolsep in amsmath
                    const payload = {
                        hskipBeforeAndAfter: false
                    };
                    const res = parseArray(context.parser, payload, dCellStyle(context.envName));
                    return delimiters ? {
                        type: "leftright",
                        mode: context.mode,
                        body: [res],
                        left: delimiters[0],
                        right: delimiters[1],
                        rightColor: undefined // \right uninfluenced by \color in array
                    } : res;
                },
                htmlBuilder: htmlBuilder$3,
                mathmlBuilder: mathmlBuilder$3
            });
            defineEnvironment({
                type: "array",
                names: ["smallmatrix"],
                props: {
                    numArgs: 0
                },
                handler(context) {
                    const payload = {
                        arraystretch: 0.5
                    };
                    const res = parseArray(context.parser, payload, "script");
                    res.colSeparationType = "small";
                    return res;
                },
                htmlBuilder: htmlBuilder$3,
                mathmlBuilder: mathmlBuilder$3
            });
            defineEnvironment({
                type: "array",
                names: ["subarray"],
                props: {
                    numArgs: 1
                },
                handler(context, args) {
                    // Parsing of {subarray} is similar to {array}
                    const symNode = checkSymbolNodeType(args[0]);
                    const colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
                    const cols = colalign.map(function (nde) {
                        const node = assertSymbolNodeType(nde);
                        const ca = node.text; // {subarray} only recognizes "l" & "c"
                        if ("lc".indexOf(ca) !== -1) {
                            return {
                                type: "align",
                                align: ca
                            };
                        }
                        throw new ParseError("Unknown column alignment: " + ca, nde);
                    });
                    if (cols.length > 1) {
                        throw new ParseError("{subarray} can contain only one column");
                    }
                    let res = {
                        cols,
                        hskipBeforeAndAfter: false,
                        arraystretch: 0.5
                    };
                    res = parseArray(context.parser, res, "script");
                    if (res.body[0].length > 1) {
                        throw new ParseError("{subarray} can contain only one column");
                    }
                    return res;
                },
                htmlBuilder: htmlBuilder$3,
                mathmlBuilder: mathmlBuilder$3
            }); // A cases environment (in amsmath.sty) is almost equivalent to
            // \def\arraystretch{1.2}%
            // \left\{\begin{array}{@{}l@{\quad}l@{}}  \end{array}\right.
            // {dcases} is a {cases} environment where cells are set in \displaystyle,
            // as defined in mathtools.sty.
            defineEnvironment({
                type: "array",
                names: ["cases", "dcases"],
                props: {
                    numArgs: 0
                },
                handler(context) {
                    const payload = {
                        arraystretch: 1.2,
                        cols: [{
                                type: "align",
                                align: "l",
                                pregap: 0,
                                // TODO(kevinb) get the current style.
                                // For now we use the metrics for TEXT style which is what we were
                                // doing before.  Before attempting to get the current style we
                                // should look at TeX's behavior especially for \over and matrices.
                                postgap: 1.0
                                /* 1em quad */
                            }, {
                                type: "align",
                                align: "l",
                                pregap: 0,
                                postgap: 0
                            }]
                    };
                    const res = parseArray(context.parser, payload, dCellStyle(context.envName));
                    return {
                        type: "leftright",
                        mode: context.mode,
                        body: [res],
                        left: "\\{",
                        right: ".",
                        rightColor: undefined
                    };
                },
                htmlBuilder: htmlBuilder$3,
                mathmlBuilder: mathmlBuilder$3
            }); // An aligned environment is like the align* environment
            // except it operates within math mode.
            // Note that we assume \nomallineskiplimit to be zero,
            // so that \strut@ is the same as \strut.
            defineEnvironment({
                type: "array",
                names: ["aligned"],
                props: {
                    numArgs: 0
                },
                handler: alignedHandler,
                htmlBuilder: htmlBuilder$3,
                mathmlBuilder: mathmlBuilder$3
            }); // A gathered environment is like an array environment with one centered
            // column, but where rows are considered lines so get \jot line spacing
            // and contents are set in \displaystyle.
            defineEnvironment({
                type: "array",
                names: ["gathered"],
                props: {
                    numArgs: 0
                },
                handler(context) {
                    const res = {
                        cols: [{
                                type: "align",
                                align: "c"
                            }],
                        addJot: true
                    };
                    return parseArray(context.parser, res, "display");
                },
                htmlBuilder: htmlBuilder$3,
                mathmlBuilder: mathmlBuilder$3
            }); // alignat environment is like an align environment, but one must explicitly
            // specify maximum number of columns in each row, and can adjust spacing between
            // each columns.
            defineEnvironment({
                type: "array",
                names: ["alignedat"],
                // One for numbered and for unnumbered;
                // but, KaTeX doesn't supports math numbering yet,
                // they make no difference for now.
                props: {
                    numArgs: 1
                },
                handler: alignedHandler,
                htmlBuilder: htmlBuilder$3,
                mathmlBuilder: mathmlBuilder$3
            }); // Catch \hline outside array environment
            defineFunction({
                type: "text",
                // Doesn't matter what this is.
                names: ["\\hline", "\\hdashline"],
                props: {
                    numArgs: 0,
                    allowedInText: true,
                    allowedInMath: true
                },
                handler(context, args) {
                    throw new ParseError(`${context.funcName} valid only within array environment`);
                }
            });
            environments = _environments;
            // defineEnvironment definitions.
            // $FlowFixMe, "environment" handler returns an environment ParseNode
            defineFunction({
                type: "environment",
                names: ["\\begin", "\\end"],
                props: {
                    numArgs: 1,
                    argTypes: ["text"]
                },
                handler(_ref, args) {
                    let parser = _ref.parser, funcName = _ref.funcName;
                    const nameGroup = args[0];
                    if (nameGroup.type !== "ordgroup") {
                        throw new ParseError("Invalid environment name", nameGroup);
                    }
                    let envName = "";
                    for (let i = 0; i < nameGroup.body.length; ++i) {
                        envName += assertNodeType(nameGroup.body[i], "textord").text;
                    }
                    if (funcName === "\\begin") {
                        // begin...end is similar to left...right
                        if (!environments.hasOwnProperty(envName)) {
                            throw new ParseError("No such environment: " + envName, nameGroup);
                        } // Build the environment object. Arguments and other information will
                        // be made available to the begin and end methods using properties.
                        const env = environments[envName];
                        const _parser$parseArgument = parser.parseArguments("\\begin{" + envName + "}", env), args = _parser$parseArgument.args, optArgs = _parser$parseArgument.optArgs;
                        const context = {
                            mode: parser.mode,
                            envName,
                            parser
                        };
                        const result = env.handler(context, args, optArgs);
                        parser.expect("\\end", false);
                        const endNameToken = parser.nextToken;
                        const end = assertNodeType(parser.parseFunction(), "environment");
                        if (end.name !== envName) {
                            throw new ParseError(`Mismatch: \\begin{${envName}} matched by \\end{${end.name}}`, endNameToken);
                        }
                        return result;
                    }
                    return {
                        type: "environment",
                        mode: parser.mode,
                        name: envName,
                        nameGroup
                    };
                }
            });
            makeSpan$2 = buildCommon.makeSpan;
            defineFunction({
                type: "mclass",
                names: ["\\mathord", "\\mathbin", "\\mathrel", "\\mathopen", "\\mathclose", "\\mathpunct", "\\mathinner"],
                props: {
                    numArgs: 1
                },
                handler(_ref, args) {
                    let parser = _ref.parser, funcName = _ref.funcName;
                    const body = args[0];
                    return {
                        type: "mclass",
                        mode: parser.mode,
                        mclass: "m" + funcName.substr(5),
                        // TODO(kevinb): don't prefix with 'm'
                        body: ordargument(body),
                        isCharacterBox: utils.isCharacterBox(body)
                    };
                },
                htmlBuilder: htmlBuilder$4,
                mathmlBuilder: mathmlBuilder$4
            });
            binrelClass = arg => {
                // \binrel@ spacing varies with (bin|rel|ord) of the atom in the argument.
                // (by rendering separately and with {}s before and after, and measuring
                // the change in spacing).  We'll do roughly the same by detecting the
                // atom type directly.
                const atom = arg.type === "ordgroup" && arg.body.length ? arg.body[0] : arg;
                if (atom.type === "atom" && (atom.family === "bin" || atom.family === "rel")) {
                    return "m" + atom.family;
                }
                else {
                    return "mord";
                }
            }; // \@binrel{x}{y} renders like y but as mbin/mrel/mord if x is mbin/mrel/mord.
            // This is equivalent to \binrel@{x}\binrel@@{y} in AMSTeX.
            defineFunction({
                type: "mclass",
                names: ["\\@binrel"],
                props: {
                    numArgs: 2
                },
                handler(_ref2, args) {
                    let parser = _ref2.parser;
                    return {
                        type: "mclass",
                        mode: parser.mode,
                        mclass: binrelClass(args[0]),
                        body: [args[1]],
                        isCharacterBox: utils.isCharacterBox(args[1])
                    };
                }
            }); // Build a relation or stacked op by placing one symbol on top of another
            defineFunction({
                type: "mclass",
                names: ["\\stackrel", "\\overset", "\\underset"],
                props: {
                    numArgs: 2
                },
                handler(_ref3, args) {
                    let parser = _ref3.parser, funcName = _ref3.funcName;
                    const baseArg = args[1];
                    const shiftedArg = args[0];
                    let mclass;
                    if (funcName !== "\\stackrel") {
                        // LaTeX applies \binrel spacing to \overset and \underset.
                        mclass = binrelClass(baseArg);
                    }
                    else {
                        mclass = "mrel"; // for \stackrel
                    }
                    const baseOp = {
                        type: "op",
                        mode: baseArg.mode,
                        limits: true,
                        alwaysHandleSupSub: true,
                        parentIsSupSub: false,
                        symbol: false,
                        suppressBaseShift: funcName !== "\\stackrel",
                        body: ordargument(baseArg)
                    };
                    const supsub = {
                        type: "supsub",
                        mode: shiftedArg.mode,
                        base: baseOp,
                        sup: funcName === "\\underset" ? null : shiftedArg,
                        sub: funcName === "\\underset" ? shiftedArg : null
                    };
                    return {
                        type: "mclass",
                        mode: parser.mode,
                        mclass,
                        body: [supsub],
                        isCharacterBox: utils.isCharacterBox(supsub)
                    };
                },
                htmlBuilder: htmlBuilder$4,
                mathmlBuilder: mathmlBuilder$4
            });
            // TODO(kevinb): implement \\sl and \\sc
            htmlBuilder$5 = (group, options) => {
                const font = group.font;
                const newOptions = options.withFont(font);
                return buildGroup(group.body, newOptions);
            };
            mathmlBuilder$5 = (group, options) => {
                const font = group.font;
                const newOptions = options.withFont(font);
                return buildGroup$1(group.body, newOptions);
            };
            fontAliases = {
                "\\Bbb": "\\mathbb",
                "\\bold": "\\mathbf",
                "\\frak": "\\mathfrak",
                "\\bm": "\\boldsymbol"
            };
            defineFunction({
                type: "font",
                names: [
                    "\\mathrm", "\\mathit", "\\mathbf", "\\mathnormal",
                    "\\mathbb", "\\mathcal", "\\mathfrak", "\\mathscr", "\\mathsf", "\\mathtt",
                    "\\Bbb", "\\bold", "\\frak"
                ],
                props: {
                    numArgs: 1,
                    greediness: 2
                },
                handler: (_ref, args) => {
                    let parser = _ref.parser, funcName = _ref.funcName;
                    const body = args[0];
                    let func = funcName;
                    if (func in fontAliases) {
                        func = fontAliases[func];
                    }
                    return {
                        type: "font",
                        mode: parser.mode,
                        font: func.slice(1),
                        body
                    };
                },
                htmlBuilder: htmlBuilder$5,
                mathmlBuilder: mathmlBuilder$5
            });
            defineFunction({
                type: "mclass",
                names: ["\\boldsymbol", "\\bm"],
                props: {
                    numArgs: 1,
                    greediness: 2
                },
                handler: (_ref2, args) => {
                    let parser = _ref2.parser;
                    const body = args[0];
                    const isCharacterBox = utils.isCharacterBox(body); // amsbsy.sty's \boldsymbol uses \binrel spacing to inherit the
                    // argument's bin|rel|ord status
                    return {
                        type: "mclass",
                        mode: parser.mode,
                        mclass: binrelClass(body),
                        body: [{
                                type: "font",
                                mode: parser.mode,
                                font: "boldsymbol",
                                body
                            }],
                        isCharacterBox: isCharacterBox
                    };
                }
            }); // Old font changing functions
            defineFunction({
                type: "font",
                names: ["\\rm", "\\sf", "\\tt", "\\bf", "\\it"],
                props: {
                    numArgs: 0,
                    allowedInText: true
                },
                handler: (_ref3, args) => {
                    let parser = _ref3.parser, funcName = _ref3.funcName, breakOnTokenText = _ref3.breakOnTokenText;
                    const mode = parser.mode;
                    const body = parser.parseExpression(true, breakOnTokenText);
                    const style = `math${funcName.slice(1)}`;
                    return {
                        type: "font",
                        mode: mode,
                        font: style,
                        body: {
                            type: "ordgroup",
                            mode: parser.mode,
                            body
                        }
                    };
                },
                htmlBuilder: htmlBuilder$5,
                mathmlBuilder: mathmlBuilder$5
            });
            adjustStyle = (size, originalStyle) => {
                // Figure out what style this fraction should be in based on the
                // function used
                let style = originalStyle;
                if (size === "display") {
                    // Get display style as a default.
                    // If incoming style is sub/sup, use style.text() to get correct size.
                    style = style.id >= Style$1.SCRIPT.id ? style.text() : Style$1.DISPLAY;
                }
                else if (size === "text" && style.size === Style$1.DISPLAY.size) {
                    // We're in a \tfrac but incoming style is displaystyle, so:
                    style = Style$1.TEXT;
                }
                else if (size === "script") {
                    style = Style$1.SCRIPT;
                }
                else if (size === "scriptscript") {
                    style = Style$1.SCRIPTSCRIPT;
                }
                return style;
            };
            htmlBuilder$6 = (group, options) => {
                // Fractions are handled in the TeXbook on pages 444-445, rules 15(a-e).
                const style = adjustStyle(group.size, options.style);
                const nstyle = style.fracNum();
                const dstyle = style.fracDen();
                let newOptions;
                newOptions = options.havingStyle(nstyle);
                const numerm = buildGroup(group.numer, newOptions, options);
                if (group.continued) {
                    // \cfrac inserts a \strut into the numerator.
                    // Get \strut dimensions from TeXbook page 353.
                    const hStrut = 8.5 / options.fontMetrics().ptPerEm;
                    const dStrut = 3.5 / options.fontMetrics().ptPerEm;
                    numerm.height = numerm.height < hStrut ? hStrut : numerm.height;
                    numerm.depth = numerm.depth < dStrut ? dStrut : numerm.depth;
                }
                newOptions = options.havingStyle(dstyle);
                const denomm = buildGroup(group.denom, newOptions, options);
                let rule;
                let ruleWidth;
                let ruleSpacing;
                if (group.hasBarLine) {
                    if (group.barSize) {
                        ruleWidth = calculateSize(group.barSize, options);
                        rule = buildCommon.makeLineSpan("frac-line", options, ruleWidth);
                    }
                    else {
                        rule = buildCommon.makeLineSpan("frac-line", options);
                    }
                    ruleWidth = rule.height;
                    ruleSpacing = rule.height;
                }
                else {
                    rule = null;
                    ruleWidth = 0;
                    ruleSpacing = options.fontMetrics().defaultRuleThickness;
                } // Rule 15b
                let numShift;
                let clearance;
                let denomShift;
                if (style.size === Style$1.DISPLAY.size || group.size === "display") {
                    numShift = options.fontMetrics().num1;
                    if (ruleWidth > 0) {
                        clearance = 3 * ruleSpacing;
                    }
                    else {
                        clearance = 7 * ruleSpacing;
                    }
                    denomShift = options.fontMetrics().denom1;
                }
                else {
                    if (ruleWidth > 0) {
                        numShift = options.fontMetrics().num2;
                        clearance = ruleSpacing;
                    }
                    else {
                        numShift = options.fontMetrics().num3;
                        clearance = 3 * ruleSpacing;
                    }
                    denomShift = options.fontMetrics().denom2;
                }
                let frac;
                if (!rule) {
                    // Rule 15c
                    const candidateClearance = numShift - numerm.depth - (denomm.height - denomShift);
                    if (candidateClearance < clearance) {
                        numShift += 0.5 * (clearance - candidateClearance);
                        denomShift += 0.5 * (clearance - candidateClearance);
                    }
                    frac = buildCommon.makeVList({
                        positionType: "individualShift",
                        children: [{
                                type: "elem",
                                elem: denomm,
                                shift: denomShift
                            }, {
                                type: "elem",
                                elem: numerm,
                                shift: -numShift
                            }]
                    }, options);
                }
                else {
                    // Rule 15d
                    const axisHeight = options.fontMetrics().axisHeight;
                    if (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth) < clearance) {
                        numShift += clearance - (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth));
                    }
                    if (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift) < clearance) {
                        denomShift += clearance - (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift));
                    }
                    const midShift = -(axisHeight - 0.5 * ruleWidth);
                    frac = buildCommon.makeVList({
                        positionType: "individualShift",
                        children: [{
                                type: "elem",
                                elem: denomm,
                                shift: denomShift
                            }, {
                                type: "elem",
                                elem: rule,
                                shift: midShift
                            }, {
                                type: "elem",
                                elem: numerm,
                                shift: -numShift
                            }]
                    }, options);
                } // Since we manually change the style sometimes (with \dfrac or \tfrac),
                // account for the possible size change here.
                newOptions = options.havingStyle(style);
                frac.height *= newOptions.sizeMultiplier / options.sizeMultiplier;
                frac.depth *= newOptions.sizeMultiplier / options.sizeMultiplier; // Rule 15e
                let delimSize;
                if (style.size === Style$1.DISPLAY.size) {
                    delimSize = options.fontMetrics().delim1;
                }
                else {
                    delimSize = options.fontMetrics().delim2;
                }
                let leftDelim;
                let rightDelim;
                if (group.leftDelim == null) {
                    leftDelim = makeNullDelimiter(options, ["mopen"]);
                }
                else {
                    leftDelim = delimiter.customSizedDelim(group.leftDelim, delimSize, true, options.havingStyle(style), group.mode, ["mopen"]);
                }
                if (group.continued) {
                    rightDelim = buildCommon.makeSpan([]); // zero width for \cfrac
                }
                else if (group.rightDelim == null) {
                    rightDelim = makeNullDelimiter(options, ["mclose"]);
                }
                else {
                    rightDelim = delimiter.customSizedDelim(group.rightDelim, delimSize, true, options.havingStyle(style), group.mode, ["mclose"]);
                }
                return buildCommon.makeSpan(["mord"].concat(newOptions.sizingClasses(options)), [leftDelim, buildCommon.makeSpan(["mfrac"], [frac]), rightDelim], options);
            };
            mathmlBuilder$6 = (group, options) => {
                let node = new mathMLTree.MathNode("mfrac", [buildGroup$1(group.numer, options), buildGroup$1(group.denom, options)]);
                if (!group.hasBarLine) {
                    node.setAttribute("linethickness", "0px");
                }
                else if (group.barSize) {
                    const ruleWidth = calculateSize(group.barSize, options);
                    node.setAttribute("linethickness", ruleWidth + "em");
                }
                const style = adjustStyle(group.size, options.style);
                if (style.size !== options.style.size) {
                    node = new mathMLTree.MathNode("mstyle", [node]);
                    const isDisplay = style.size === Style$1.DISPLAY.size ? "true" : "false";
                    node.setAttribute("displaystyle", isDisplay);
                    node.setAttribute("scriptlevel", "0");
                }
                if (group.leftDelim != null || group.rightDelim != null) {
                    const withDelims = [];
                    if (group.leftDelim != null) {
                        const leftOp = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group.leftDelim.replace("\\", ""))]);
                        leftOp.setAttribute("fence", "true");
                        withDelims.push(leftOp);
                    }
                    withDelims.push(node);
                    if (group.rightDelim != null) {
                        const rightOp = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group.rightDelim.replace("\\", ""))]);
                        rightOp.setAttribute("fence", "true");
                        withDelims.push(rightOp);
                    }
                    return makeRow(withDelims);
                }
                return node;
            };
            defineFunction({
                type: "genfrac",
                names: ["\\cfrac", "\\dfrac", "\\frac", "\\tfrac", "\\dbinom", "\\binom", "\\tbinom", "\\\\atopfrac",
                    "\\\\bracefrac", "\\\\brackfrac"],
                props: {
                    numArgs: 2,
                    greediness: 2
                },
                handler: (_ref, args) => {
                    let parser = _ref.parser, funcName = _ref.funcName;
                    const numer = args[0];
                    const denom = args[1];
                    let hasBarLine;
                    let leftDelim = null;
                    let rightDelim = null;
                    let size = "auto";
                    switch (funcName) {
                        case "\\cfrac":
                        case "\\dfrac":
                        case "\\frac":
                        case "\\tfrac":
                            hasBarLine = true;
                            break;
                        case "\\\\atopfrac":
                            hasBarLine = false;
                            break;
                        case "\\dbinom":
                        case "\\binom":
                        case "\\tbinom":
                            hasBarLine = false;
                            leftDelim = "(";
                            rightDelim = ")";
                            break;
                        case "\\\\bracefrac":
                            hasBarLine = false;
                            leftDelim = "\\{";
                            rightDelim = "\\}";
                            break;
                        case "\\\\brackfrac":
                            hasBarLine = false;
                            leftDelim = "[";
                            rightDelim = "]";
                            break;
                        default:
                            throw new Error("Unrecognized genfrac command");
                    }
                    switch (funcName) {
                        case "\\cfrac":
                        case "\\dfrac":
                        case "\\dbinom":
                            size = "display";
                            break;
                        case "\\tfrac":
                        case "\\tbinom":
                            size = "text";
                            break;
                    }
                    return {
                        type: "genfrac",
                        mode: parser.mode,
                        continued: funcName === "\\cfrac",
                        numer,
                        denom,
                        hasBarLine,
                        leftDelim,
                        rightDelim,
                        size,
                        barSize: null
                    };
                },
                htmlBuilder: htmlBuilder$6,
                mathmlBuilder: mathmlBuilder$6
            }); // Infix generalized fractions -- these are not rendered directly, but replaced
            // immediately by one of the variants above.
            defineFunction({
                type: "infix",
                names: ["\\over", "\\choose", "\\atop", "\\brace", "\\brack"],
                props: {
                    numArgs: 0,
                    infix: true
                },
                handler(_ref2) {
                    let parser = _ref2.parser, funcName = _ref2.funcName, token = _ref2.token;
                    let replaceWith;
                    switch (funcName) {
                        case "\\over":
                            replaceWith = "\\frac";
                            break;
                        case "\\choose":
                            replaceWith = "\\binom";
                            break;
                        case "\\atop":
                            replaceWith = "\\\\atopfrac";
                            break;
                        case "\\brace":
                            replaceWith = "\\\\bracefrac";
                            break;
                        case "\\brack":
                            replaceWith = "\\\\brackfrac";
                            break;
                        default:
                            throw new Error("Unrecognized infix genfrac command");
                    }
                    return {
                        type: "infix",
                        mode: parser.mode,
                        replaceWith,
                        token
                    };
                }
            });
            stylArray = ["display", "text", "script", "scriptscript"];
            delimFromValue = function delimFromValue(delimString) {
                let delim = null;
                if (delimString.length > 0) {
                    delim = delimString;
                    delim = delim === "." ? null : delim;
                }
                return delim;
            };
            defineFunction({
                type: "genfrac",
                names: ["\\genfrac"],
                props: {
                    numArgs: 6,
                    greediness: 6,
                    argTypes: ["math", "math", "size", "text", "math", "math"]
                },
                handler(_ref3, args) {
                    let parser = _ref3.parser;
                    const numer = args[4];
                    const denom = args[5]; // Look into the parse nodes to get the desired delimiters.
                    let leftNode = checkNodeType(args[0], "atom");
                    if (leftNode) {
                        leftNode = assertAtomFamily(args[0], "open");
                    }
                    const leftDelim = leftNode ? delimFromValue(leftNode.text) : null;
                    let rightNode = checkNodeType(args[1], "atom");
                    if (rightNode) {
                        rightNode = assertAtomFamily(args[1], "close");
                    }
                    const rightDelim = rightNode ? delimFromValue(rightNode.text) : null;
                    const barNode = assertNodeType(args[2], "size");
                    let hasBarLine;
                    let barSize = null;
                    if (barNode.isBlank) {
                        // \genfrac acts differently than \above.
                        // \genfrac treats an empty size group as a signal to use a
                        // standard bar size. \above would see size = 0 and omit the bar.
                        hasBarLine = true;
                    }
                    else {
                        barSize = barNode.value;
                        hasBarLine = barSize.number > 0;
                    } // Find out if we want displaystyle, textstyle, etc.
                    let size = "auto";
                    let styl = checkNodeType(args[3], "ordgroup");
                    if (styl) {
                        if (styl.body.length > 0) {
                            const textOrd = assertNodeType(styl.body[0], "textord");
                            size = stylArray[Number(textOrd.text)];
                        }
                    }
                    else {
                        styl = assertNodeType(args[3], "textord");
                        size = stylArray[Number(styl.text)];
                    }
                    return {
                        type: "genfrac",
                        mode: parser.mode,
                        numer,
                        denom,
                        continued: false,
                        hasBarLine,
                        barSize,
                        leftDelim,
                        rightDelim,
                        size
                    };
                },
                htmlBuilder: htmlBuilder$6,
                mathmlBuilder: mathmlBuilder$6
            }); // \above is an infix fraction that also defines a fraction bar size.
            defineFunction({
                type: "infix",
                names: ["\\above"],
                props: {
                    numArgs: 1,
                    argTypes: ["size"],
                    infix: true
                },
                handler(_ref4, args) {
                    let parser = _ref4.parser, funcName = _ref4.funcName, token = _ref4.token;
                    return {
                        type: "infix",
                        mode: parser.mode,
                        replaceWith: "\\\\abovefrac",
                        size: assertNodeType(args[0], "size").value,
                        token
                    };
                }
            });
            defineFunction({
                type: "genfrac",
                names: ["\\\\abovefrac"],
                props: {
                    numArgs: 3,
                    argTypes: ["math", "size", "math"]
                },
                handler: (_ref5, args) => {
                    let parser = _ref5.parser, funcName = _ref5.funcName;
                    const numer = args[0];
                    const barSize = assert(assertNodeType(args[1], "infix").size);
                    const denom = args[2];
                    const hasBarLine = barSize.number > 0;
                    return {
                        type: "genfrac",
                        mode: parser.mode,
                        numer,
                        denom,
                        continued: false,
                        hasBarLine,
                        barSize,
                        leftDelim: null,
                        rightDelim: null,
                        size: "auto"
                    };
                },
                htmlBuilder: htmlBuilder$6,
                mathmlBuilder: mathmlBuilder$6
            });
            // NOTE: Unlike most `htmlBuilder`s, this one handles not only "horizBrace", but
            htmlBuilder$7 = (grp, options) => {
                const style = options.style; // Pull out the `ParseNode<"horizBrace">` if `grp` is a "supsub" node.
                let supSubGroup;
                let group;
                const supSub = checkNodeType(grp, "supsub");
                if (supSub) {
                    // Ref: LaTeX source2e: }}}}\limits}
                    // i.e. LaTeX treats the brace similar to an op and passes it
                    // with \limits, so we need to assign supsub style.
                    supSubGroup = supSub.sup ? buildGroup(supSub.sup, options.havingStyle(style.sup()), options) : buildGroup(supSub.sub, options.havingStyle(style.sub()), options);
                    group = assertNodeType(supSub.base, "horizBrace");
                }
                else {
                    group = assertNodeType(grp, "horizBrace");
                } // Build the base group
                const body = buildGroup(group.base, options.havingBaseStyle(Style$1.DISPLAY)); // Create the stretchy element
                const braceBody = stretchy.svgSpan(group, options); // Generate the vlist, with the appropriate kerns        
                // This first vlist contains the content and the brace:   equation
                let vlist;
                if (group.isOver) {
                    vlist = buildCommon.makeVList({
                        positionType: "firstBaseline",
                        children: [{
                                type: "elem",
                                elem: body
                            }, {
                                type: "kern",
                                size: 0.1
                            }, {
                                type: "elem",
                                elem: braceBody
                            }]
                    }, options); // $FlowFixMe: Replace this with passing "svg-align" into makeVList.
                    vlist.children[0].children[0].children[1].classes.push("svg-align");
                }
                else {
                    vlist = buildCommon.makeVList({
                        positionType: "bottom",
                        positionData: body.depth + 0.1 + braceBody.height,
                        children: [{
                                type: "elem",
                                elem: braceBody
                            }, {
                                type: "kern",
                                size: 0.1
                            }, {
                                type: "elem",
                                elem: body
                            }]
                    }, options); // $FlowFixMe: Replace this with passing "svg-align" into makeVList.
                    vlist.children[0].children[0].children[0].classes.push("svg-align");
                }
                if (supSubGroup) {
                    // To write the supsub, wrap the first vlist in another vlist:
                    // They can't all go in the same vlist, because the note might be
                    // wider than the equation. We want the equation to control the
                    // brace width.
                    //      note          long note           long note
                    //      or         not    
                    //    equation           eqn                 eqn
                    const vSpan = buildCommon.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options);
                    if (group.isOver) {
                        vlist = buildCommon.makeVList({
                            positionType: "firstBaseline",
                            children: [{
                                    type: "elem",
                                    elem: vSpan
                                }, {
                                    type: "kern",
                                    size: 0.2
                                }, {
                                    type: "elem",
                                    elem: supSubGroup
                                }]
                        }, options);
                    }
                    else {
                        vlist = buildCommon.makeVList({
                            positionType: "bottom",
                            positionData: vSpan.depth + 0.2 + supSubGroup.height + supSubGroup.depth,
                            children: [{
                                    type: "elem",
                                    elem: supSubGroup
                                }, {
                                    type: "kern",
                                    size: 0.2
                                }, {
                                    type: "elem",
                                    elem: vSpan
                                }]
                        }, options);
                    }
                }
                return buildCommon.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options);
            };
            mathmlBuilder$7 = (group, options) => {
                const accentNode = stretchy.mathMLnode(group.label);
                return new mathMLTree.MathNode(group.isOver ? "mover" : "munder", [buildGroup$1(group.base, options), accentNode]);
            }; // Horizontal stretchy braces
            defineFunction({
                type: "horizBrace",
                names: ["\\overbrace", "\\underbrace"],
                props: {
                    numArgs: 1
                },
                handler(_ref, args) {
                    let parser = _ref.parser, funcName = _ref.funcName;
                    return {
                        type: "horizBrace",
                        mode: parser.mode,
                        label: funcName,
                        isOver: /^\\over/.test(funcName),
                        base: args[0]
                    };
                },
                htmlBuilder: htmlBuilder$7,
                mathmlBuilder: mathmlBuilder$7
            });
            defineFunction({
                type: "href",
                names: ["\\href"],
                props: {
                    numArgs: 2,
                    argTypes: ["url", "original"],
                    allowedInText: true
                },
                handler: (_ref, args) => {
                    let parser = _ref.parser;
                    const body = args[1];
                    const href = assertNodeType(args[0], "url").url;
                    if (!parser.settings.isTrusted({
                        command: "\\href",
                        url: href
                    })) {
                        return parser.formatUnsupportedCmd("\\href");
                    }
                    return {
                        type: "href",
                        mode: parser.mode,
                        href,
                        body: ordargument(body)
                    };
                },
                htmlBuilder: (group, options) => {
                    const elements = buildExpression(group.body, options, false);
                    return buildCommon.makeAnchor(group.href, [], elements, options);
                },
                mathmlBuilder: (group, options) => {
                    let math = buildExpressionRow(group.body, options);
                    if (!(math instanceof MathNode)) {
                        math = new MathNode("mrow", [math]);
                    }
                    math.setAttribute("href", group.href);
                    return math;
                }
            });
            defineFunction({
                type: "href",
                names: ["\\url"],
                props: {
                    numArgs: 1,
                    argTypes: ["url"],
                    allowedInText: true
                },
                handler: (_ref2, args) => {
                    let parser = _ref2.parser;
                    const href = assertNodeType(args[0], "url").url;
                    if (!parser.settings.isTrusted({
                        command: "\\url",
                        url: href
                    })) {
                        return parser.formatUnsupportedCmd("\\url");
                    }
                    const chars = [];
                    for (let i = 0; i < href.length; i++) {
                        let c = href[i];
                        if (c === "~") {
                            c = "\\textasciitilde";
                        }
                        chars.push({
                            type: "textord",
                            mode: "text",
                            text: c
                        });
                    }
                    const body = {
                        type: "text",
                        mode: parser.mode,
                        font: "\\texttt",
                        body: chars
                    };
                    return {
                        type: "href",
                        mode: parser.mode,
                        href,
                        body: ordargument(body)
                    };
                }
            });
            defineFunction({
                type: "htmlmathml",
                names: ["\\html@mathml"],
                props: {
                    numArgs: 2,
                    allowedInText: true
                },
                handler: (_ref, args) => {
                    let parser = _ref.parser;
                    return {
                        type: "htmlmathml",
                        mode: parser.mode,
                        html: ordargument(args[0]),
                        mathml: ordargument(args[1])
                    };
                },
                htmlBuilder: (group, options) => {
                    const elements = buildExpression(group.html, options, false);
                    return buildCommon.makeFragment(elements);
                },
                mathmlBuilder: (group, options) => {
                    return buildExpressionRow(group.mathml, options);
                }
            });
            sizeData = function sizeData(str) {
                if (/^[-+]? *(\d+(\.\d*)?|\.\d+)$/.test(str)) {
                    // str is a number with no unit specified.
                    // default unit is bp, per graphix package.
                    return {
                        number: +str,
                        unit: "bp"
                    };
                }
                else {
                    const match = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(str);
                    if (!match) {
                        throw new ParseError("Invalid size: '" + str + "' in \\includegraphics");
                    }
                    const data = {
                        number: +(match[1] + match[2]),
                        // sign + magnitude, cast to number
                        unit: match[3]
                    };
                    if (!validUnit(data)) {
                        throw new ParseError("Invalid unit: '" + data.unit + "' in \\includegraphics.");
                    }
                    return data;
                }
            };
            defineFunction({
                type: "includegraphics",
                names: ["\\includegraphics"],
                props: {
                    numArgs: 1,
                    numOptionalArgs: 1,
                    argTypes: ["raw", "url"],
                    allowedInText: false
                },
                handler: (_ref, args, optArgs) => {
                    let parser = _ref.parser;
                    let width = {
                        number: 0,
                        unit: "em"
                    };
                    let height = {
                        number: 0.9,
                        unit: "em"
                    }; // sorta character sized.
                    let totalheight = {
                        number: 0,
                        unit: "em"
                    };
                    let alt = "";
                    if (optArgs[0]) {
                        const attributeStr = assertNodeType(optArgs[0], "raw").string; // Parser.js does not parse key/value pairs. We get a string.
                        const attributes = attributeStr.split(",");
                        for (let i = 0; i < attributes.length; i++) {
                            const keyVal = attributes[i].split("=");
                            if (keyVal.length === 2) {
                                const str = keyVal[1].trim();
                                switch (keyVal[0].trim()) {
                                    case "alt":
                                        alt = str;
                                        break;
                                    case "width":
                                        width = sizeData(str);
                                        break;
                                    case "height":
                                        height = sizeData(str);
                                        break;
                                    case "totalheight":
                                        totalheight = sizeData(str);
                                        break;
                                    default:
                                        throw new ParseError("Invalid key: '" + keyVal[0] + "' in \\includegraphics.");
                                }
                            }
                        }
                    }
                    const src = assertNodeType(args[0], "url").url;
                    if (alt === "") {
                        // No alt given. Use the file name. Strip away the path.
                        alt = src;
                        alt = alt.replace(/^.*[\\/]/, '');
                        alt = alt.substring(0, alt.lastIndexOf('.'));
                    }
                    if (!parser.settings.isTrusted({
                        command: "\\includegraphics",
                        url: src
                    })) {
                        return parser.formatUnsupportedCmd("\\includegraphics");
                    }
                    return {
                        type: "includegraphics",
                        mode: parser.mode,
                        alt: alt,
                        width: width,
                        height: height,
                        totalheight: totalheight,
                        src: src
                    };
                },
                htmlBuilder: (group, options) => {
                    const height = calculateSize(group.height, options);
                    let depth = 0;
                    if (group.totalheight.number > 0) {
                        depth = calculateSize(group.totalheight, options) - height;
                        depth = Number(depth.toFixed(2));
                    }
                    let width = 0;
                    if (group.width.number > 0) {
                        width = calculateSize(group.width, options);
                    }
                    const style = {
                        height: height + depth + "em"
                    };
                    if (width > 0) {
                        style.width = width + "em";
                    }
                    if (depth > 0) {
                        style.verticalAlign = -depth + "em";
                    }
                    const node = new Img(group.src, group.alt, style);
                    node.height = height;
                    node.depth = depth;
                    return node;
                },
                mathmlBuilder: (group, options) => {
                    const node = new mathMLTree.MathNode("mglyph", []);
                    node.setAttribute("alt", group.alt);
                    const height = calculateSize(group.height, options);
                    let depth = 0;
                    if (group.totalheight.number > 0) {
                        depth = calculateSize(group.totalheight, options) - height;
                        depth = depth.toFixed(2);
                        node.setAttribute("valign", "-" + depth + "em");
                    }
                    node.setAttribute("height", height + depth + "em");
                    if (group.width.number > 0) {
                        const width = calculateSize(group.width, options);
                        node.setAttribute("width", width + "em");
                    }
                    node.setAttribute("src", group.src);
                    return node;
                }
            });
            // Horizontal spacing commands
            defineFunction({
                type: "kern",
                names: ["\\kern", "\\mkern", "\\hskip", "\\mskip"],
                props: {
                    numArgs: 1,
                    argTypes: ["size"],
                    allowedInText: true
                },
                handler(_ref, args) {
                    let parser = _ref.parser, funcName = _ref.funcName;
                    const size = assertNodeType(args[0], "size");
                    if (parser.settings.strict) {
                        const mathFunction = funcName[1] === 'm'; // \mkern, \mskip
                        const muUnit = size.value.unit === 'mu';
                        if (mathFunction) {
                            if (!muUnit) {
                                parser.settings.reportNonstrict("mathVsTextUnits", `LaTeX's ${funcName} supports only mu units, ` + `not ${size.value.unit} units`);
                            }
                            if (parser.mode !== "math") {
                                parser.settings.reportNonstrict("mathVsTextUnits", `LaTeX's ${funcName} works only in math mode`);
                            }
                        }
                        else {
                            // !mathFunction
                            if (muUnit) {
                                parser.settings.reportNonstrict("mathVsTextUnits", `LaTeX's ${funcName} doesn't support mu units`);
                            }
                        }
                    }
                    return {
                        type: "kern",
                        mode: parser.mode,
                        dimension: size.value
                    };
                },
                htmlBuilder(group, options) {
                    return buildCommon.makeGlue(group.dimension, options);
                },
                mathmlBuilder(group, options) {
                    const dimension = calculateSize(group.dimension, options);
                    return new mathMLTree.SpaceNode(dimension);
                }
            });
            // Horizontal overlap functions
            defineFunction({
                type: "lap",
                names: ["\\mathllap", "\\mathrlap", "\\mathclap"],
                props: {
                    numArgs: 1,
                    allowedInText: true
                },
                handler: (_ref, args) => {
                    let parser = _ref.parser, funcName = _ref.funcName;
                    const body = args[0];
                    return {
                        type: "lap",
                        mode: parser.mode,
                        alignment: funcName.slice(5),
                        body
                    };
                },
                htmlBuilder: (group, options) => {
                    // mathllap, mathrlap, mathclap
                    let inner;
                    if (group.alignment === "clap") {
                        // ref: https://www.math.lsu.edu/~aperlis/publications/mathclap/
                        inner = buildCommon.makeSpan([], [buildGroup(group.body, options)]); // wrap, since CSS will center a .clap > .inner > span
                        inner = buildCommon.makeSpan(["inner"], [inner], options);
                    }
                    else {
                        inner = buildCommon.makeSpan(["inner"], [buildGroup(group.body, options)]);
                    }
                    const fix = buildCommon.makeSpan(["fix"], []);
                    let node = buildCommon.makeSpan([group.alignment], [inner, fix], options); // At this point, we have correctly set horizontal alignment of the
                    // two items involved in the lap.
                    // Next, use a strut to set the height of the HTML bounding box.
                    // Otherwise, a tall argument may be misplaced.
                    const strut = buildCommon.makeSpan(["strut"]);
                    strut.style.height = node.height + node.depth + "em";
                    strut.style.verticalAlign = -node.depth + "em";
                    node.children.unshift(strut); // Next, prevent vertical misplacement when next to something tall.
                    node = buildCommon.makeVList({
                        positionType: "firstBaseline",
                        children: [{
                                type: "elem",
                                elem: node
                            }]
                    }, options); // Get the horizontal spacing correct relative to adjacent items.
                    return buildCommon.makeSpan(["mord"], [node], options);
                },
                mathmlBuilder: (group, options) => {
                    // mathllap, mathrlap, mathclap
                    const node = new mathMLTree.MathNode("mpadded", [buildGroup$1(group.body, options)]);
                    if (group.alignment !== "rlap") {
                        const offset = group.alignment === "llap" ? "-1" : "-0.5";
                        node.setAttribute("lspace", offset + "width");
                    }
                    node.setAttribute("width", "0px");
                    return node;
                }
            });
            defineFunction({
                type: "styling",
                names: ["\\(", "$"],
                props: {
                    numArgs: 0,
                    allowedInText: true,
                    allowedInMath: false
                },
                handler(_ref, args) {
                    let funcName = _ref.funcName, parser = _ref.parser;
                    const outerMode = parser.mode;
                    parser.switchMode("math");
                    const close = funcName === "\\(" ? "\\)" : "$";
                    const body = parser.parseExpression(false, close);
                    parser.expect(close);
                    parser.switchMode(outerMode);
                    return {
                        type: "styling",
                        mode: parser.mode,
                        style: "text",
                        body
                    };
                }
            }); // Check for extra closing math delimiters
            defineFunction({
                type: "text",
                // Doesn't matter what this is.
                names: ["\\)", "\\]"],
                props: {
                    numArgs: 0,
                    allowedInText: true,
                    allowedInMath: false
                },
                handler(context, args) {
                    throw new ParseError(`Mismatched ${context.funcName}`);
                }
            });
            chooseMathStyle = (group, options) => {
                switch (options.style.size) {
                    case Style$1.DISPLAY.size:
                        return group.display;
                    case Style$1.TEXT.size:
                        return group.text;
                    case Style$1.SCRIPT.size:
                        return group.script;
                    case Style$1.SCRIPTSCRIPT.size:
                        return group.scriptscript;
                    default:
                        return group.text;
                }
            };
            defineFunction({
                type: "mathchoice",
                names: ["\\mathchoice"],
                props: {
                    numArgs: 4
                },
                handler: (_ref, args) => {
                    let parser = _ref.parser;
                    return {
                        type: "mathchoice",
                        mode: parser.mode,
                        display: ordargument(args[0]),
                        text: ordargument(args[1]),
                        script: ordargument(args[2]),
                        scriptscript: ordargument(args[3])
                    };
                },
                htmlBuilder: (group, options) => {
                    const body = chooseMathStyle(group, options);
                    const elements = buildExpression(body, options, false);
                    return buildCommon.makeFragment(elements);
                },
                mathmlBuilder: (group, options) => {
                    const body = chooseMathStyle(group, options);
                    return buildExpressionRow(body, options);
                }
            });
            // For an operator with limits, assemble the base, sup, and sub into a span.
            assembleSupSub = (base, supGroup, subGroup, options, style, slant, baseShift) => {
                // IE 8 clips \int if it is in a display: inline-block. We wrap it
                // in a new span so it is an inline, and works.
                base = buildCommon.makeSpan([], [base]);
                let sub;
                let sup; // We manually have to handle the superscripts and subscripts. This,
                // aside from the kern calculations, is copied from supsub.
                if (supGroup) {
                    const elem = buildGroup(supGroup, options.havingStyle(style.sup()), options);
                    sup = {
                        elem,
                        kern: Math.max(options.fontMetrics().bigOpSpacing1, options.fontMetrics().bigOpSpacing3 - elem.depth)
                    };
                }
                if (subGroup) {
                    const elem = buildGroup(subGroup, options.havingStyle(style.sub()), options);
                    sub = {
                        elem,
                        kern: Math.max(options.fontMetrics().bigOpSpacing2, options.fontMetrics().bigOpSpacing4 - elem.height)
                    };
                } // Build the final group as a vlist of the possible subscript, base,
                // and possible superscript.
                let finalGroup;
                if (sup && sub) {
                    const bottom = options.fontMetrics().bigOpSpacing5 + sub.elem.height + sub.elem.depth + sub.kern + base.depth + baseShift;
                    finalGroup = buildCommon.makeVList({
                        positionType: "bottom",
                        positionData: bottom,
                        children: [{
                                type: "kern",
                                size: options.fontMetrics().bigOpSpacing5
                            }, {
                                type: "elem",
                                elem: sub.elem,
                                marginLeft: -slant + "em"
                            }, {
                                type: "kern",
                                size: sub.kern
                            }, {
                                type: "elem",
                                elem: base
                            }, {
                                type: "kern",
                                size: sup.kern
                            }, {
                                type: "elem",
                                elem: sup.elem,
                                marginLeft: slant + "em"
                            }, {
                                type: "kern",
                                size: options.fontMetrics().bigOpSpacing5
                            }]
                    }, options);
                }
                else if (sub) {
                    const top = base.height - baseShift; // Shift the limits by the slant of the symbol. Note
                    // that we are supposed to shift the limits by 1/2 of the slant,
                    // but since we are centering the limits adding a full slant of
                    // margin will shift by 1/2 that.
                    finalGroup = buildCommon.makeVList({
                        positionType: "top",
                        positionData: top,
                        children: [{
                                type: "kern",
                                size: options.fontMetrics().bigOpSpacing5
                            }, {
                                type: "elem",
                                elem: sub.elem,
                                marginLeft: -slant + "em"
                            }, {
                                type: "kern",
                                size: sub.kern
                            }, {
                                type: "elem",
                                elem: base
                            }]
                    }, options);
                }
                else if (sup) {
                    const bottom = base.depth + baseShift;
                    finalGroup = buildCommon.makeVList({
                        positionType: "bottom",
                        positionData: bottom,
                        children: [{
                                type: "elem",
                                elem: base
                            }, {
                                type: "kern",
                                size: sup.kern
                            }, {
                                type: "elem",
                                elem: sup.elem,
                                marginLeft: slant + "em"
                            }, {
                                type: "kern",
                                size: options.fontMetrics().bigOpSpacing5
                            }]
                    }, options);
                }
                else {
                    // This case probably shouldn't occur (this would mean the
                    // supsub was sending us a group with no superscript or
                    // subscript) but be safe.
                    return base;
                }
                return buildCommon.makeSpan(["mop", "op-limits"], [finalGroup], options);
            };
            // Limits, symbols
            // Most operators have a large successor symbol, but these don't.
            noSuccessor = ["\\smallint"]; // NOTE: Unlike most `htmlBuilder`s, this one handles not only "op", but also
            // "supsub" since some of them (like \int) can affect super/subscripting.
            htmlBuilder$8 = (grp, options) => {
                // Operators are handled in the TeXbook pg. 443-444, rule 13(a).
                let supGroup;
                let subGroup;
                let hasLimits = false;
                let group;
                const supSub = checkNodeType(grp, "supsub");
                if (supSub) {
                    // If we have limits, supsub will pass us its group to handle. Pull
                    // out the superscript and subscript and set the group to the op in
                    // its base.
                    supGroup = supSub.sup;
                    subGroup = supSub.sub;
                    group = assertNodeType(supSub.base, "op");
                    hasLimits = true;
                }
                else {
                    group = assertNodeType(grp, "op");
                }
                const style = options.style;
                let large = false;
                if (style.size === Style$1.DISPLAY.size && group.symbol && !utils.contains(noSuccessor, group.name)) {
                    // Most symbol operators get larger in displaystyle (rule 13)
                    large = true;
                }
                let base;
                if (group.symbol) {
                    // If this is a symbol, create the symbol.
                    const fontName = large ? "Size2-Regular" : "Size1-Regular";
                    let stash = "";
                    if (group.name === "\\oiint" || group.name === "\\oiiint") {
                        // No font glyphs yet, so use a glyph w/o the oval.
                        // TODO: When font glyphs are available, delete this code.
                        stash = group.name.substr(1); // $FlowFixMe
                        group.name = stash === "oiint" ? "\\iint" : "\\iiint";
                    }
                    base = buildCommon.makeSymbol(group.name, fontName, "math", options, ["mop", "op-symbol", large ? "large-op" : "small-op"]);
                    if (stash.length > 0) {
                        // We're in \oiint or \oiiint. Overlay the oval.
                        // TODO: When font glyphs are available, delete this code.
                        const italic = base.italic;
                        const oval = buildCommon.staticSvg(stash + "Size" + (large ? "2" : "1"), options);
                        base = buildCommon.makeVList({
                            positionType: "individualShift",
                            children: [{
                                    type: "elem",
                                    elem: base,
                                    shift: 0
                                }, {
                                    type: "elem",
                                    elem: oval,
                                    shift: large ? 0.08 : 0
                                }]
                        }, options); // $FlowFixMe
                        group.name = "\\" + stash;
                        base.classes.unshift("mop"); // $FlowFixMe
                        base.italic = italic;
                    }
                }
                else if (group.body) {
                    // If this is a list, compose that list.
                    const inner = buildExpression(group.body, options, true);
                    if (inner.length === 1 && inner[0] instanceof SymbolNode) {
                        base = inner[0];
                        base.classes[0] = "mop"; // replace old mclass
                    }
                    else {
                        base = buildCommon.makeSpan(["mop"], buildCommon.tryCombineChars(inner), options);
                    }
                }
                else {
                    // Otherwise, this is a text operator. Build the text from the
                    // operator's name.
                    // TODO(emily): Add a space in the middle of some of these
                    // operators, like \limsup
                    const output = [];
                    for (let i = 1; i < group.name.length; i++) {
                        output.push(buildCommon.mathsym(group.name[i], group.mode, options));
                    }
                    base = buildCommon.makeSpan(["mop"], output, options);
                } // If content of op is a single symbol, shift it vertically.
                let baseShift = 0;
                let slant = 0;
                if ((base instanceof SymbolNode || group.name === "\\oiint" || group.name === "\\oiiint") && !group.suppressBaseShift) {
                    // We suppress the shift of the base of \overset and \underset. Otherwise,
                    // shift the symbol so its center lies on the axis (rule 13). It
                    // appears that our fonts have the centers of the symbols already
                    // almost on the axis, so these numbers are very small. Note we
                    // don't actually apply this here, but instead it is used either in
                    // the vlist creation or separately when there are no limits.
                    baseShift = (base.height - base.depth) / 2 - options.fontMetrics().axisHeight; // The slant of the symbol is just its italic correction.
                    // $FlowFixMe
                    slant = base.italic;
                }
                if (hasLimits) {
                    return assembleSupSub(base, supGroup, subGroup, options, style, slant, baseShift);
                }
                else {
                    if (baseShift) {
                        base.style.position = "relative";
                        base.style.top = baseShift + "em";
                    }
                    return base;
                }
            };
            mathmlBuilder$8 = (group, options) => {
                let node;
                if (group.symbol) {
                    // This is a symbol. Just add the symbol.
                    node = new MathNode("mo", [makeText(group.name, group.mode)]);
                    if (utils.contains(noSuccessor, group.name)) {
                        node.setAttribute("largeop", "false");
                    }
                }
                else if (group.body) {
                    // This is an operator with children. Add them.
                    node = new MathNode("mo", buildExpression$1(group.body, options));
                }
                else {
                    // This is a text operator. Add all of the characters from the
                    // operator's name.
                    node = new MathNode("mi", [new TextNode(group.name.slice(1))]); // Append an <mo>&ApplyFunction;</mo>.
                    // ref: https://www.w3.org/TR/REC-MathML/chap3_2.html#sec3.2.4
                    const operator = new MathNode("mo", [makeText("\u2061", "text")]);
                    if (group.parentIsSupSub) {
                        node = new MathNode("mo", [node, operator]);
                    }
                    else {
                        node = newDocumentFragment([node, operator]);
                    }
                }
                return node;
            };
            singleCharBigOps = {
                "\u220F": "\\prod",
                "\u2210": "\\coprod",
                "\u2211": "\\sum",
                "\u22c0": "\\bigwedge",
                "\u22c1": "\\bigvee",
                "\u22c2": "\\bigcap",
                "\u22c3": "\\bigcup",
                "\u2a00": "\\bigodot",
                "\u2a01": "\\bigoplus",
                "\u2a02": "\\bigotimes",
                "\u2a04": "\\biguplus",
                "\u2a06": "\\bigsqcup"
            };
            defineFunction({
                type: "op",
                names: ["\\coprod", "\\bigvee", "\\bigwedge", "\\biguplus", "\\bigcap", "\\bigcup", "\\intop", "\\prod", "\\sum", "\\bigotimes", "\\bigoplus", "\\bigodot", "\\bigsqcup", "\\smallint", "\u220F", "\u2210", "\u2211", "\u22c0", "\u22c1", "\u22c2", "\u22c3", "\u2a00", "\u2a01", "\u2a02", "\u2a04", "\u2a06"],
                props: {
                    numArgs: 0
                },
                handler: (_ref, args) => {
                    let parser = _ref.parser, funcName = _ref.funcName;
                    let fName = funcName;
                    if (fName.length === 1) {
                        fName = singleCharBigOps[fName];
                    }
                    return {
                        type: "op",
                        mode: parser.mode,
                        limits: true,
                        parentIsSupSub: false,
                        symbol: true,
                        name: fName
                    };
                },
                htmlBuilder: htmlBuilder$8,
                mathmlBuilder: mathmlBuilder$8
            }); // Note: calling defineFunction with a type that's already been defined only
            // works because the same htmlBuilder and mathmlBuilder are being used.
            defineFunction({
                type: "op",
                names: ["\\mathop"],
                props: {
                    numArgs: 1
                },
                handler: (_ref2, args) => {
                    let parser = _ref2.parser;
                    const body = args[0];
                    return {
                        type: "op",
                        mode: parser.mode,
                        limits: false,
                        parentIsSupSub: false,
                        symbol: false,
                        body: ordargument(body)
                    };
                },
                htmlBuilder: htmlBuilder$8,
                mathmlBuilder: mathmlBuilder$8
            }); // There are 2 flags for operators; whether they produce limits in
            // displaystyle, and whether they are symbols and should grow in
            // displaystyle. These four groups cover the four possible choices.
            singleCharIntegrals = {
                "\u222b": "\\int",
                "\u222c": "\\iint",
                "\u222d": "\\iiint",
                "\u222e": "\\oint",
                "\u222f": "\\oiint",
                "\u2230": "\\oiiint"
            }; // No limits, not symbols
            defineFunction({
                type: "op",
                names: ["\\arcsin", "\\arccos", "\\arctan", "\\arctg", "\\arcctg", "\\arg", "\\ch", "\\cos", "\\cosec", "\\cosh", "\\cot", "\\cotg", "\\coth", "\\csc", "\\ctg", "\\cth", "\\deg", "\\dim", "\\exp", "\\hom", "\\ker", "\\lg", "\\ln", "\\log", "\\sec", "\\sin", "\\sinh", "\\sh", "\\tan", "\\tanh", "\\tg", "\\th"],
                props: {
                    numArgs: 0
                },
                handler(_ref3) {
                    let parser = _ref3.parser, funcName = _ref3.funcName;
                    return {
                        type: "op",
                        mode: parser.mode,
                        limits: false,
                        parentIsSupSub: false,
                        symbol: false,
                        name: funcName
                    };
                },
                htmlBuilder: htmlBuilder$8,
                mathmlBuilder: mathmlBuilder$8
            }); // Limits, not symbols
            defineFunction({
                type: "op",
                names: ["\\det", "\\gcd", "\\inf", "\\lim", "\\max", "\\min", "\\Pr", "\\sup"],
                props: {
                    numArgs: 0
                },
                handler(_ref4) {
                    let parser = _ref4.parser, funcName = _ref4.funcName;
                    return {
                        type: "op",
                        mode: parser.mode,
                        limits: true,
                        parentIsSupSub: false,
                        symbol: false,
                        name: funcName
                    };
                },
                htmlBuilder: htmlBuilder$8,
                mathmlBuilder: mathmlBuilder$8
            }); // No limits, symbols
            defineFunction({
                type: "op",
                names: ["\\int", "\\iint", "\\iiint", "\\oint", "\\oiint", "\\oiiint", "\u222b", "\u222c", "\u222d", "\u222e", "\u222f", "\u2230"],
                props: {
                    numArgs: 0
                },
                handler(_ref5) {
                    let parser = _ref5.parser, funcName = _ref5.funcName;
                    let fName = funcName;
                    if (fName.length === 1) {
                        fName = singleCharIntegrals[fName];
                    }
                    return {
                        type: "op",
                        mode: parser.mode,
                        limits: false,
                        parentIsSupSub: false,
                        symbol: true,
                        name: fName
                    };
                },
                htmlBuilder: htmlBuilder$8,
                mathmlBuilder: mathmlBuilder$8
            });
            // NOTE: Unlike most `htmlBuilder`s, this one handles not only
            // "operatorname", but also  "supsub" since \operatorname* can
            htmlBuilder$9 = (grp, options) => {
                // Operators are handled in the TeXbook pg. 443-444, rule 13(a).
                let supGroup;
                let subGroup;
                let hasLimits = false;
                let group;
                const supSub = checkNodeType(grp, "supsub");
                if (supSub) {
                    // If we have limits, supsub will pass us its group to handle. Pull
                    // out the superscript and subscript and set the group to the op in
                    // its base.
                    supGroup = supSub.sup;
                    subGroup = supSub.sub;
                    group = assertNodeType(supSub.base, "operatorname");
                    hasLimits = true;
                }
                else {
                    group = assertNodeType(grp, "operatorname");
                }
                let base;
                if (group.body.length > 0) {
                    const body = group.body.map(child => {
                        // $FlowFixMe: Check if the node has a string `text` property.
                        const childText = child.text;
                        if (typeof childText === "string") {
                            return {
                                type: "textord",
                                mode: child.mode,
                                text: childText
                            };
                        }
                        else {
                            return child;
                        }
                    }); // Consolidate function names into symbol characters.
                    const expression = buildExpression(body, options.withFont("mathrm"), true);
                    for (let i = 0; i < expression.length; i++) {
                        const child = expression[i];
                        if (child instanceof SymbolNode) {
                            // Per amsopn package,
                            // change minus to hyphen and \ast to asterisk
                            child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
                        }
                    }
                    base = buildCommon.makeSpan(["mop"], expression, options);
                }
                else {
                    base = buildCommon.makeSpan(["mop"], [], options);
                }
                if (hasLimits) {
                    return assembleSupSub(base, supGroup, subGroup, options, options.style, 0, 0);
                }
                else {
                    return base;
                }
            };
            mathmlBuilder$9 = (group, options) => {
                // The steps taken here are similar to the html version.
                let expression = buildExpression$1(group.body, options.withFont("mathrm")); // Is expression a string or has it something like a fraction?
                let isAllString = true; // default
                for (let i = 0; i < expression.length; i++) {
                    const node = expression[i];
                    if (node instanceof mathMLTree.SpaceNode)
                        ;
                    else if (node instanceof mathMLTree.MathNode) {
                        switch (node.type) {
                            case "mi":
                            case "mn":
                            case "ms":
                            case "mspace":
                            case "mtext":
                                break;
                            // Do nothing yet.
                            case "mo":
                                {
                                    const child = node.children[0];
                                    if (node.children.length === 1 && child instanceof mathMLTree.TextNode) {
                                        child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
                                    }
                                    else {
                                        isAllString = false;
                                    }
                                    break;
                                }
                            default:
                                isAllString = false;
                        }
                    }
                    else {
                        isAllString = false;
                    }
                }
                if (isAllString) {
                    // Write a single TextNode instead of multiple nested tags.
                    const word = expression.map(node => node.toText()).join("");
                    expression = [new mathMLTree.TextNode(word)];
                }
                const identifier = new mathMLTree.MathNode("mi", expression);
                identifier.setAttribute("mathvariant", "normal"); // \u2061 is the same as &ApplyFunction;
                // ref: https://www.w3schools.com/charsets/ref_html_entities_a.asp
                const operator = new mathMLTree.MathNode("mo", [makeText("\u2061", "text")]);
                if (group.parentIsSupSub) {
                    return new mathMLTree.MathNode("mo", [identifier, operator]);
                }
                else {
                    return mathMLTree.newDocumentFragment([identifier, operator]);
                }
            }; // \operatorname
            // amsopn.dtx: \mathop{#1\kern\z@\operator@font#3}\newmcodes@
            defineFunction({
                type: "operatorname",
                names: ["\\operatorname", "\\operatorname*"],
                props: {
                    numArgs: 1
                },
                handler: (_ref, args) => {
                    let parser = _ref.parser, funcName = _ref.funcName;
                    const body = args[0];
                    return {
                        type: "operatorname",
                        mode: parser.mode,
                        body: ordargument(body),
                        alwaysHandleSupSub: funcName === "\\operatorname*",
                        limits: false,
                        parentIsSupSub: false
                    };
                },
                htmlBuilder: htmlBuilder$9,
                mathmlBuilder: mathmlBuilder$9
            });
            defineFunctionBuilders({
                type: "ordgroup",
                htmlBuilder(group, options) {
                    if (group.semisimple) {
                        return buildCommon.makeFragment(buildExpression(group.body, options, false));
                    }
                    return buildCommon.makeSpan(["mord"], buildExpression(group.body, options, true), options);
                },
                mathmlBuilder(group, options) {
                    return buildExpressionRow(group.body, options, true);
                }
            });
            defineFunction({
                type: "overline",
                names: ["\\overline"],
                props: {
                    numArgs: 1
                },
                handler(_ref, args) {
                    let parser = _ref.parser;
                    const body = args[0];
                    return {
                        type: "overline",
                        mode: parser.mode,
                        body
                    };
                },
                htmlBuilder(group, options) {
                    // Overlines are handled in the TeXbook pg 443, Rule 9.
                    // Build the inner group in the cramped style.
                    const innerGroup = buildGroup(group.body, options.havingCrampedStyle()); // Create the line above the body
                    const line = buildCommon.makeLineSpan("overline-line", options); // Generate the vlist, with the appropriate kerns
                    const defaultRuleThickness = options.fontMetrics().defaultRuleThickness;
                    const vlist = buildCommon.makeVList({
                        positionType: "firstBaseline",
                        children: [{
                                type: "elem",
                                elem: innerGroup
                            }, {
                                type: "kern",
                                size: 3 * defaultRuleThickness
                            }, {
                                type: "elem",
                                elem: line
                            }, {
                                type: "kern",
                                size: defaultRuleThickness
                            }]
                    }, options);
                    return buildCommon.makeSpan(["mord", "overline"], [vlist], options);
                },
                mathmlBuilder(group, options) {
                    const operator = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("\u203e")]);
                    operator.setAttribute("stretchy", "true");
                    const node = new mathMLTree.MathNode("mover", [buildGroup$1(group.body, options), operator]);
                    node.setAttribute("accent", "true");
                    return node;
                }
            });
            defineFunction({
                type: "phantom",
                names: ["\\phantom"],
                props: {
                    numArgs: 1,
                    allowedInText: true
                },
                handler: (_ref, args) => {
                    let parser = _ref.parser;
                    const body = args[0];
                    return {
                        type: "phantom",
                        mode: parser.mode,
                        body: ordargument(body)
                    };
                },
                htmlBuilder: (group, options) => {
                    const elements = buildExpression(group.body, options.withPhantom(), false); // \phantom isn't supposed to affect the elements it contains.
                    // See "color" for more details.
                    return buildCommon.makeFragment(elements);
                },
                mathmlBuilder: (group, options) => {
                    const inner = buildExpression$1(group.body, options);
                    return new mathMLTree.MathNode("mphantom", inner);
                }
            });
            defineFunction({
                type: "hphantom",
                names: ["\\hphantom"],
                props: {
                    numArgs: 1,
                    allowedInText: true
                },
                handler: (_ref2, args) => {
                    let parser = _ref2.parser;
                    const body = args[0];
                    return {
                        type: "hphantom",
                        mode: parser.mode,
                        body
                    };
                },
                htmlBuilder: (group, options) => {
                    let node = buildCommon.makeSpan([], [buildGroup(group.body, options.withPhantom())]);
                    node.height = 0;
                    node.depth = 0;
                    if (node.children) {
                        for (let i = 0; i < node.children.length; i++) {
                            node.children[i].height = 0;
                            node.children[i].depth = 0;
                        }
                    } // See smash for comment re: use of makeVList
                    node = buildCommon.makeVList({
                        positionType: "firstBaseline",
                        children: [{
                                type: "elem",
                                elem: node
                            }]
                    }, options); // For spacing, TeX treats \smash as a math group (same spacing as ord).
                    return buildCommon.makeSpan(["mord"], [node], options);
                },
                mathmlBuilder: (group, options) => {
                    const inner = buildExpression$1(ordargument(group.body), options);
                    const phantom = new mathMLTree.MathNode("mphantom", inner);
                    const node = new mathMLTree.MathNode("mpadded", [phantom]);
                    node.setAttribute("height", "0px");
                    node.setAttribute("depth", "0px");
                    return node;
                }
            });
            defineFunction({
                type: "vphantom",
                names: ["\\vphantom"],
                props: {
                    numArgs: 1,
                    allowedInText: true
                },
                handler: (_ref3, args) => {
                    let parser = _ref3.parser;
                    const body = args[0];
                    return {
                        type: "vphantom",
                        mode: parser.mode,
                        body
                    };
                },
                htmlBuilder: (group, options) => {
                    const inner = buildCommon.makeSpan(["inner"], [buildGroup(group.body, options.withPhantom())]);
                    const fix = buildCommon.makeSpan(["fix"], []);
                    return buildCommon.makeSpan(["mord", "rlap"], [inner, fix], options);
                },
                mathmlBuilder: (group, options) => {
                    const inner = buildExpression$1(ordargument(group.body), options);
                    const phantom = new mathMLTree.MathNode("mphantom", inner);
                    const node = new mathMLTree.MathNode("mpadded", [phantom]);
                    node.setAttribute("width", "0px");
                    return node;
                }
            });
            defineFunction({
                type: "raisebox",
                names: ["\\raisebox"],
                props: {
                    numArgs: 2,
                    argTypes: ["size", "hbox"],
                    allowedInText: true
                },
                handler(_ref, args) {
                    let parser = _ref.parser;
                    const amount = assertNodeType(args[0], "size").value;
                    const body = args[1];
                    return {
                        type: "raisebox",
                        mode: parser.mode,
                        dy: amount,
                        body
                    };
                },
                htmlBuilder(group, options) {
                    const body = buildGroup(group.body, options);
                    const dy = calculateSize(group.dy, options);
                    return buildCommon.makeVList({
                        positionType: "shift",
                        positionData: -dy,
                        children: [{
                                type: "elem",
                                elem: body
                            }]
                    }, options);
                },
                mathmlBuilder(group, options) {
                    const node = new mathMLTree.MathNode("mpadded", [buildGroup$1(group.body, options)]);
                    const dy = group.dy.number + group.dy.unit;
                    node.setAttribute("voffset", dy);
                    return node;
                }
            });
            defineFunction({
                type: "rule",
                names: ["\\rule"],
                props: {
                    numArgs: 2,
                    numOptionalArgs: 1,
                    argTypes: ["size", "size", "size"]
                },
                handler(_ref, args, optArgs) {
                    let parser = _ref.parser;
                    const shift = optArgs[0];
                    const width = assertNodeType(args[0], "size");
                    const height = assertNodeType(args[1], "size");
                    return {
                        type: "rule",
                        mode: parser.mode,
                        shift: shift && assertNodeType(shift, "size").value,
                        width: width.value,
                        height: height.value
                    };
                },
                htmlBuilder(group, options) {
                    // Make an empty span for the rule
                    const rule = buildCommon.makeSpan(["mord", "rule"], [], options); // Calculate the shift, width, and height of the rule, and account for units
                    const width = calculateSize(group.width, options);
                    const height = calculateSize(group.height, options);
                    const shift = group.shift ? calculateSize(group.shift, options) : 0; // Style the rule to the right size
                    rule.style.borderRightWidth = width + "em";
                    rule.style.borderTopWidth = height + "em";
                    rule.style.bottom = shift + "em"; // Record the height and width
                    rule.width = width;
                    rule.height = height + shift;
                    rule.depth = -shift; // Font size is the number large enough that the browser will
                    // reserve at least `absHeight` space above the baseline.
                    // The 1.125 factor was empirically determined
                    rule.maxFontSize = height * 1.125 * options.sizeMultiplier;
                    return rule;
                },
                mathmlBuilder(group, options) {
                    const width = calculateSize(group.width, options);
                    const height = calculateSize(group.height, options);
                    const shift = group.shift ? calculateSize(group.shift, options) : 0;
                    const color = options.color && options.getColor() || "black";
                    const rule = new mathMLTree.MathNode("mspace");
                    rule.setAttribute("mathbackground", color);
                    rule.setAttribute("width", width + "em");
                    rule.setAttribute("height", height + "em");
                    const wrapper = new mathMLTree.MathNode("mpadded", [rule]);
                    if (shift >= 0) {
                        wrapper.setAttribute("height", "+" + shift + "em");
                    }
                    else {
                        wrapper.setAttribute("height", shift + "em");
                        wrapper.setAttribute("depth", "+" + -shift + "em");
                    }
                    wrapper.setAttribute("voffset", shift + "em");
                    return wrapper;
                }
            });
            sizeFuncs = ["\\tiny", "\\sixptsize", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"];
            htmlBuilder$a = (group, options) => {
                // Handle sizing operators like \Huge. Real TeX doesn't actually allow
                // these functions inside of math expressions, so we do some special
                // handling.
                const newOptions = options.havingSize(group.size);
                return sizingGroup(group.body, newOptions, options);
            };
            defineFunction({
                type: "sizing",
                names: sizeFuncs,
                props: {
                    numArgs: 0,
                    allowedInText: true
                },
                handler: (_ref, args) => {
                    let breakOnTokenText = _ref.breakOnTokenText, funcName = _ref.funcName, parser = _ref.parser;
                    const body = parser.parseExpression(false, breakOnTokenText);
                    return {
                        type: "sizing",
                        mode: parser.mode,
                        // Figure out what size to use based on the list of functions above
                        size: sizeFuncs.indexOf(funcName) + 1,
                        body
                    };
                },
                htmlBuilder: htmlBuilder$a,
                mathmlBuilder: (group, options) => {
                    const newOptions = options.havingSize(group.size);
                    const inner = buildExpression$1(group.body, newOptions);
                    const node = new mathMLTree.MathNode("mstyle", inner); // TODO(emily): This doesn't produce the correct size for nested size
                    // changes, because we don't keep state of what style we're currently
                    // in, so we can't reset the size to normal before changing it.  Now
                    // that we're passing an options parameter we should be able to fix
                    // this.
                    node.setAttribute("mathsize", newOptions.sizeMultiplier + "em");
                    return node;
                }
            });
            // smash, with optional [tb], as in AMS
            defineFunction({
                type: "smash",
                names: ["\\smash"],
                props: {
                    numArgs: 1,
                    numOptionalArgs: 1,
                    allowedInText: true
                },
                handler: (_ref, args, optArgs) => {
                    let parser = _ref.parser;
                    let smashHeight = false;
                    let smashDepth = false;
                    const tbArg = optArgs[0] && assertNodeType(optArgs[0], "ordgroup");
                    if (tbArg) {
                        // Optional [tb] argument is engaged.
                        // ref: amsmath: \renewcommand{\smash}[1][tb]{%
                        //               def\mb@t{\ht}\def\mb@b{\dp}\def\mb@tb{\ht\z@\z@\dp}%
                        let letter = "";
                        for (let i = 0; i < tbArg.body.length; ++i) {
                            const node = tbArg.body[i]; // $FlowFixMe: Not every node type has a `text` property.
                            letter = node.text;
                            if (letter === "t") {
                                smashHeight = true;
                            }
                            else if (letter === "b") {
                                smashDepth = true;
                            }
                            else {
                                smashHeight = false;
                                smashDepth = false;
                                break;
                            }
                        }
                    }
                    else {
                        smashHeight = true;
                        smashDepth = true;
                    }
                    const body = args[0];
                    return {
                        type: "smash",
                        mode: parser.mode,
                        body,
                        smashHeight,
                        smashDepth
                    };
                },
                htmlBuilder: (group, options) => {
                    const node = buildCommon.makeSpan([], [buildGroup(group.body, options)]);
                    if (!group.smashHeight && !group.smashDepth) {
                        return node;
                    }
                    if (group.smashHeight) {
                        node.height = 0; // In order to influence makeVList, we have to reset the children.
                        if (node.children) {
                            for (let i = 0; i < node.children.length; i++) {
                                node.children[i].height = 0;
                            }
                        }
                    }
                    if (group.smashDepth) {
                        node.depth = 0;
                        if (node.children) {
                            for (let i = 0; i < node.children.length; i++) {
                                node.children[i].depth = 0;
                            }
                        }
                    } // At this point, we've reset the TeX-like height and depth values.
                    // But the span still has an HTML line height.
                    // makeVList applies "display: table-cell", which prevents the browser
                    // from acting on that line height. So we'll call makeVList now.
                    const smashedNode = buildCommon.makeVList({
                        positionType: "firstBaseline",
                        children: [{
                                type: "elem",
                                elem: node
                            }]
                    }, options); // For spacing, TeX treats \hphantom as a math group (same spacing as ord).
                    return buildCommon.makeSpan(["mord"], [smashedNode], options);
                },
                mathmlBuilder: (group, options) => {
                    const node = new mathMLTree.MathNode("mpadded", [buildGroup$1(group.body, options)]);
                    if (group.smashHeight) {
                        node.setAttribute("height", "0px");
                    }
                    if (group.smashDepth) {
                        node.setAttribute("depth", "0px");
                    }
                    return node;
                }
            });
            defineFunction({
                type: "sqrt",
                names: ["\\sqrt"],
                props: {
                    numArgs: 1,
                    numOptionalArgs: 1
                },
                handler(_ref, args, optArgs) {
                    let parser = _ref.parser;
                    const index = optArgs[0];
                    const body = args[0];
                    return {
                        type: "sqrt",
                        mode: parser.mode,
                        body,
                        index
                    };
                },
                htmlBuilder(group, options) {
                    // Square roots are handled in the TeXbook pg. 443, Rule 11.
                    // First, we do the same steps as in overline to build the inner group
                    // and line
                    let inner = buildGroup(group.body, options.havingCrampedStyle());
                    if (inner.height === 0) {
                        // Render a small surd.
                        inner.height = options.fontMetrics().xHeight;
                    } // Some groups can return document fragments.  Handle those by wrapping
                    // them in a span.
                    inner = buildCommon.wrapFragment(inner, options); // Calculate the minimum size for the \surd delimiter
                    const metrics = options.fontMetrics();
                    const theta = metrics.defaultRuleThickness;
                    let phi = theta;
                    if (options.style.id < Style$1.TEXT.id) {
                        phi = options.fontMetrics().xHeight;
                    } // Calculate the clearance between the body and line
                    let lineClearance = theta + phi / 4;
                    const minDelimiterHeight = inner.height + inner.depth + lineClearance + theta; // Create a sqrt SVG of the required minimum size
                    const _delimiter$sqrtImage = delimiter.sqrtImage(minDelimiterHeight, options), img = _delimiter$sqrtImage.span, ruleWidth = _delimiter$sqrtImage.ruleWidth, advanceWidth = _delimiter$sqrtImage.advanceWidth;
                    const delimDepth = img.height - ruleWidth; // Adjust the clearance based on the delimiter size
                    if (delimDepth > inner.height + inner.depth + lineClearance) {
                        lineClearance = (lineClearance + delimDepth - inner.height - inner.depth) / 2;
                    } // Shift the sqrt image
                    const imgShift = img.height - inner.height - lineClearance - ruleWidth;
                    inner.style.paddingLeft = advanceWidth + "em"; // Overlay the image and the argument.
                    const body = buildCommon.makeVList({
                        positionType: "firstBaseline",
                        children: [{
                                type: "elem",
                                elem: inner,
                                wrapperClasses: ["svg-align"]
                            }, {
                                type: "kern",
                                size: -(inner.height + imgShift)
                            }, {
                                type: "elem",
                                elem: img
                            }, {
                                type: "kern",
                                size: ruleWidth
                            }]
                    }, options);
                    if (!group.index) {
                        return buildCommon.makeSpan(["mord", "sqrt"], [body], options);
                    }
                    else {
                        // Handle the optional root index
                        // The index is always in scriptscript style
                        const newOptions = options.havingStyle(Style$1.SCRIPTSCRIPT);
                        const rootm = buildGroup(group.index, newOptions, options); // The amount the index is shifted by. This is taken from the TeX
                        // source, in the definition of `\r@@t`.
                        const toShift = 0.6 * (body.height - body.depth); // Build a VList with the superscript shifted up correctly
                        const rootVList = buildCommon.makeVList({
                            positionType: "shift",
                            positionData: -toShift,
                            children: [{
                                    type: "elem",
                                    elem: rootm
                                }]
                        }, options); // Add a class surrounding it so we can add on the appropriate
                        // kerning
                        const rootVListWrap = buildCommon.makeSpan(["root"], [rootVList]);
                        return buildCommon.makeSpan(["mord", "sqrt"], [rootVListWrap, body], options);
                    }
                },
                mathmlBuilder(group, options) {
                    const body = group.body, index = group.index;
                    return index ? new mathMLTree.MathNode("mroot", [buildGroup$1(body, options), buildGroup$1(index, options)]) : new mathMLTree.MathNode("msqrt", [buildGroup$1(body, options)]);
                }
            });
            styleMap$1 = {
                "display": Style$1.DISPLAY,
                "text": Style$1.TEXT,
                "script": Style$1.SCRIPT,
                "scriptscript": Style$1.SCRIPTSCRIPT
            };
            defineFunction({
                type: "styling",
                names: ["\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"],
                props: {
                    numArgs: 0,
                    allowedInText: true
                },
                handler(_ref, args) {
                    let breakOnTokenText = _ref.breakOnTokenText, funcName = _ref.funcName, parser = _ref.parser;
                    // parse out the implicit body
                    const body = parser.parseExpression(true, breakOnTokenText); // TODO: Refactor to avoid duplicating styleMap in multiple places (e.g.
                    // here and in buildHTML and de-dupe the enumeration of all the styles).
                    // $FlowFixMe: The names above exactly match the styles.
                    const style = funcName.slice(1, funcName.length - 5);
                    return {
                        type: "styling",
                        mode: parser.mode,
                        // Figure out what style to use by pulling out the style from
                        // the function name
                        style,
                        body
                    };
                },
                htmlBuilder(group, options) {
                    // Style changes are handled in the TeXbook on pg. 442, Rule 3.
                    const newStyle = styleMap$1[group.style];
                    const newOptions = options.havingStyle(newStyle).withFont('');
                    return sizingGroup(group.body, newOptions, options);
                },
                mathmlBuilder(group, options) {
                    // Figure out what style we're changing to.
                    const newStyle = styleMap$1[group.style];
                    const newOptions = options.havingStyle(newStyle);
                    const inner = buildExpression$1(group.body, newOptions);
                    const node = new mathMLTree.MathNode("mstyle", inner);
                    const styleAttributes = {
                        "display": ["0", "true"],
                        "text": ["0", "false"],
                        "script": ["1", "false"],
                        "scriptscript": ["2", "false"]
                    };
                    const attr = styleAttributes[group.style];
                    node.setAttribute("scriptlevel", attr[0]);
                    node.setAttribute("displaystyle", attr[1]);
                    return node;
                }
            });
            /**
             * Sometimes, groups perform special rules when they have superscripts or
             * subscripts attached to them. This function lets the `supsub` group know that
             * Sometimes, groups perform special rules when they have superscripts or
             * its inner element should handle the superscripts and subscripts instead of
             * handling them itself.
             */
            htmlBuilderDelegate = function htmlBuilderDelegate(group, options) {
                const base = group.base;
                if (!base) {
                    return null;
                }
                else if (base.type === "op") {
                    // Operators handle supsubs differently when they have limits
                    // (e.g. `\displaystyle\sum_2^3`)
                    const delegate = base.limits && (options.style.size === Style$1.DISPLAY.size || base.alwaysHandleSupSub);
                    return delegate ? htmlBuilder$8 : null;
                }
                else if (base.type === "operatorname") {
                    const delegate = base.alwaysHandleSupSub && (options.style.size === Style$1.DISPLAY.size || base.limits);
                    return delegate ? htmlBuilder$9 : null;
                }
                else if (base.type === "accent") {
                    return utils.isCharacterBox(base.base) ? htmlBuilder : null;
                }
                else if (base.type === "horizBrace") {
                    const isSup = !group.sub;
                    return isSup === base.isOver ? htmlBuilder$7 : null;
                }
                else {
                    return null;
                }
            }; // Super scripts and subscripts, whose precise placement can depend on other
            // functions that precede them.
            defineFunctionBuilders({
                type: "supsub",
                htmlBuilder(group, options) {
                    // Superscript and subscripts are handled in the TeXbook on page
                    // 445-446, rules 18(a-f).
                    // Here is where we defer to the inner group if it should handle
                    // superscripts and subscripts itself.
                    const builderDelegate = htmlBuilderDelegate(group, options);
                    if (builderDelegate) {
                        return builderDelegate(group, options);
                    }
                    const valueBase = group.base, valueSup = group.sup, valueSub = group.sub;
                    const base = buildGroup(valueBase, options);
                    let supm;
                    let subm;
                    const metrics = options.fontMetrics(); // Rule 18a
                    let supShift = 0;
                    let subShift = 0;
                    const isCharacterBox = valueBase && utils.isCharacterBox(valueBase);
                    if (valueSup) {
                        const newOptions = options.havingStyle(options.style.sup());
                        supm = buildGroup(valueSup, newOptions, options);
                        if (!isCharacterBox) {
                            supShift = base.height - newOptions.fontMetrics().supDrop * newOptions.sizeMultiplier / options.sizeMultiplier;
                        }
                    }
                    if (valueSub) {
                        const newOptions = options.havingStyle(options.style.sub());
                        subm = buildGroup(valueSub, newOptions, options);
                        if (!isCharacterBox) {
                            subShift = base.depth + newOptions.fontMetrics().subDrop * newOptions.sizeMultiplier / options.sizeMultiplier;
                        }
                    } // Rule 18c
                    let minSupShift;
                    if (options.style === Style$1.DISPLAY) {
                        minSupShift = metrics.sup1;
                    }
                    else if (options.style.cramped) {
                        minSupShift = metrics.sup3;
                    }
                    else {
                        minSupShift = metrics.sup2;
                    } // scriptspace is a font-size-independent size, so scale it
                    // appropriately for use as the marginRight.
                    const multiplier = options.sizeMultiplier;
                    const marginRight = 0.5 / metrics.ptPerEm / multiplier + "em";
                    let marginLeft = null;
                    if (subm) {
                        // Subscripts shouldn't be shifted by the base's italic correction.
                        // Account for that by shifting the subscript back the appropriate
                        // amount. Note we only do this when the base is a single symbol.
                        const isOiint = group.base && group.base.type === "op" && group.base.name && (group.base.name === "\\oiint" || group.base.name === "\\oiiint");
                        if (base instanceof SymbolNode || isOiint) {
                            // $FlowFixMe
                            marginLeft = -base.italic + "em";
                        }
                    }
                    let supsub;
                    if (supm && subm) {
                        supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
                        subShift = Math.max(subShift, metrics.sub2);
                        const ruleWidth = metrics.defaultRuleThickness; // Rule 18e
                        const maxWidth = 4 * ruleWidth;
                        if (supShift - supm.depth - (subm.height - subShift) < maxWidth) {
                            subShift = maxWidth - (supShift - supm.depth) + subm.height;
                            const psi = 0.8 * metrics.xHeight - (supShift - supm.depth);
                            if (psi > 0) {
                                supShift += psi;
                                subShift -= psi;
                            }
                        }
                        const vlistElem = [{
                                type: "elem",
                                elem: subm,
                                shift: subShift,
                                marginRight,
                                marginLeft
                            }, {
                                type: "elem",
                                elem: supm,
                                shift: -supShift,
                                marginRight
                            }];
                        supsub = buildCommon.makeVList({
                            positionType: "individualShift",
                            children: vlistElem
                        }, options);
                    }
                    else if (subm) {
                        // Rule 18b
                        subShift = Math.max(subShift, metrics.sub1, subm.height - 0.8 * metrics.xHeight);
                        const vlistElem = [{
                                type: "elem",
                                elem: subm,
                                marginLeft,
                                marginRight
                            }];
                        supsub = buildCommon.makeVList({
                            positionType: "shift",
                            positionData: subShift,
                            children: vlistElem
                        }, options);
                    }
                    else if (supm) {
                        // Rule 18c, d
                        supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
                        supsub = buildCommon.makeVList({
                            positionType: "shift",
                            positionData: -supShift,
                            children: [{
                                    type: "elem",
                                    elem: supm,
                                    marginRight
                                }]
                        }, options);
                    }
                    else {
                        throw new Error("supsub must have either sup or sub.");
                    } // Wrap the supsub vlist in a span.msupsub to reset text-align.
                    const mclass = getTypeOfDomTree(base, "right") || "mord";
                    return buildCommon.makeSpan([mclass], [base, buildCommon.makeSpan(["msupsub"], [supsub])], options);
                },
                mathmlBuilder(group, options) {
                    // Is the inner group a relevant horizonal brace?
                    let isBrace = false;
                    let isOver;
                    let isSup;
                    const horizBrace = checkNodeType(group.base, "horizBrace");
                    if (horizBrace) {
                        isSup = !!group.sup;
                        if (isSup === horizBrace.isOver) {
                            isBrace = true;
                            isOver = horizBrace.isOver;
                        }
                    }
                    if (group.base && (group.base.type === "op" || group.base.type === "operatorname")) {
                        group.base.parentIsSupSub = true;
                    }
                    const children = [buildGroup$1(group.base, options)];
                    if (group.sub) {
                        children.push(buildGroup$1(group.sub, options));
                    }
                    if (group.sup) {
                        children.push(buildGroup$1(group.sup, options));
                    }
                    let nodeType;
                    if (isBrace) {
                        nodeType = isOver ? "mover" : "munder";
                    }
                    else if (!group.sub) {
                        const base = group.base;
                        if (base && base.type === "op" && base.limits && (options.style === Style$1.DISPLAY || base.alwaysHandleSupSub)) {
                            nodeType = "mover";
                        }
                        else if (base && base.type === "operatorname" && base.alwaysHandleSupSub && (base.limits || options.style === Style$1.DISPLAY)) {
                            nodeType = "mover";
                        }
                        else {
                            nodeType = "msup";
                        }
                    }
                    else if (!group.sup) {
                        const base = group.base;
                        if (base && base.type === "op" && base.limits && (options.style === Style$1.DISPLAY || base.alwaysHandleSupSub)) {
                            nodeType = "munder";
                        }
                        else if (base && base.type === "operatorname" && base.alwaysHandleSupSub && (base.limits || options.style === Style$1.DISPLAY)) {
                            nodeType = "munder";
                        }
                        else {
                            nodeType = "msub";
                        }
                    }
                    else {
                        const base = group.base;
                        if (base && base.type === "op" && base.limits && options.style === Style$1.DISPLAY) {
                            nodeType = "munderover";
                        }
                        else if (base && base.type === "operatorname" && base.alwaysHandleSupSub && (options.style === Style$1.DISPLAY || base.limits)) {
                            nodeType = "munderover";
                        }
                        else {
                            nodeType = "msubsup";
                        }
                    }
                    const node = new mathMLTree.MathNode(nodeType, children);
                    return node;
                }
            });
            defineFunctionBuilders({
                type: "atom",
                htmlBuilder(group, options) {
                    return buildCommon.mathsym(group.text, group.mode, options, ["m" + group.family]);
                },
                mathmlBuilder(group, options) {
                    const node = new mathMLTree.MathNode("mo", [makeText(group.text, group.mode)]);
                    if (group.family === "bin") {
                        const variant = getVariant(group, options);
                        if (variant === "bold-italic") {
                            node.setAttribute("mathvariant", variant);
                        }
                    }
                    else if (group.family === "punct") {
                        node.setAttribute("separator", "true");
                    }
                    else if (group.family === "open" || group.family === "close") {
                        // Delims built here should not stretch vertically.
                        // See delimsizing.js for stretchy delims.
                        node.setAttribute("stretchy", "false");
                    }
                    return node;
                }
            });
            // "mathord" and "textord" ParseNodes created in Parser.js from symbol Groups in
            defaultVariant = {
                "mi": "italic",
                "mn": "normal",
                "mtext": "normal"
            };
            defineFunctionBuilders({
                type: "mathord",
                htmlBuilder(group, options) {
                    return buildCommon.makeOrd(group, options, "mathord");
                },
                mathmlBuilder(group, options) {
                    const node = new mathMLTree.MathNode("mi", [makeText(group.text, group.mode, options)]);
                    const variant = getVariant(group, options) || "italic";
                    if (variant !== defaultVariant[node.type]) {
                        node.setAttribute("mathvariant", variant);
                    }
                    return node;
                }
            });
            defineFunctionBuilders({
                type: "textord",
                htmlBuilder(group, options) {
                    return buildCommon.makeOrd(group, options, "textord");
                },
                mathmlBuilder(group, options) {
                    const text = makeText(group.text, group.mode, options);
                    const variant = getVariant(group, options) || "normal";
                    let node;
                    if (group.mode === 'text') {
                        node = new mathMLTree.MathNode("mtext", [text]);
                    }
                    else if (/[0-9]/.test(group.text)) {
                        // TODO(kevinb) merge adjacent <mn> nodes
                        // do it as a post processing step
                        node = new mathMLTree.MathNode("mn", [text]);
                    }
                    else if (group.text === "\\prime") {
                        node = new mathMLTree.MathNode("mo", [text]);
                    }
                    else {
                        node = new mathMLTree.MathNode("mi", [text]);
                    }
                    if (variant !== defaultVariant[node.type]) {
                        node.setAttribute("mathvariant", variant);
                    }
                    return node;
                }
            });
            cssSpace = {
                "\\nobreak": "nobreak",
                "\\allowbreak": "allowbreak"
            }; // A lookup table to determine whether a spacing function/symbol should be
            // treated like a regular space character.  If a symbol or command is a key
            // in this table, then it should be a regular space character.  Furthermore,
            // the associated value may have a `className` specifying an extra CSS class
            // to add to the created `span`.
            regularSpace = {
                " ": {},
                "\\ ": {},
                "~": {
                    className: "nobreak"
                },
                "\\space": {},
                "\\nobreakspace": {
                    className: "nobreak"
                }
            }; // ParseNode<"spacing"> created in Parser.js from the "spacing" symbol Groups in
            // src/symbols.js.
            defineFunctionBuilders({
                type: "spacing",
                htmlBuilder(group, options) {
                    if (regularSpace.hasOwnProperty(group.text)) {
                        const className = regularSpace[group.text].className || ""; // Spaces are generated by adding an actual space. Each of these
                        // things has an entry in the symbols table, so these will be turned
                        // into appropriate outputs.
                        if (group.mode === "text") {
                            const ord = buildCommon.makeOrd(group, options, "textord");
                            ord.classes.push(className);
                            return ord;
                        }
                        else {
                            return buildCommon.makeSpan(["mspace", className], [buildCommon.mathsym(group.text, group.mode, options)], options);
                        }
                    }
                    else if (cssSpace.hasOwnProperty(group.text)) {
                        // Spaces based on just a CSS class.
                        return buildCommon.makeSpan(["mspace", cssSpace[group.text]], [], options);
                    }
                    else {
                        throw new ParseError(`Unknown type of space "${group.text}"`);
                    }
                },
                mathmlBuilder(group, options) {
                    let node;
                    if (regularSpace.hasOwnProperty(group.text)) {
                        node = new mathMLTree.MathNode("mtext", [new mathMLTree.TextNode("\u00a0")]);
                    }
                    else if (cssSpace.hasOwnProperty(group.text)) {
                        // CSS-based MathML spaces (\nobreak, \allowbreak) are ignored
                        return new mathMLTree.MathNode("mspace");
                    }
                    else {
                        throw new ParseError(`Unknown type of space "${group.text}"`);
                    }
                    return node;
                }
            });
            pad = () => {
                const padNode = new mathMLTree.MathNode("mtd", []);
                padNode.setAttribute("width", "50%");
                return padNode;
            };
            defineFunctionBuilders({
                type: "tag",
                mathmlBuilder(group, options) {
                    const table = new mathMLTree.MathNode("mtable", [new mathMLTree.MathNode("mtr", [pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(group.body, options)]), pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(group.tag, options)])])]);
                    table.setAttribute("width", "100%");
                    return table; // TODO: Left-aligned tags.
                    // Currently, the group and options passed here do not contain
                    // enough info to set tag alignment. `leqno` is in Settings but it is
                    // not passed to Options. On the HTML side, leqno is
                    // set by a CSS class applied in buildTree.js. That would have worked
                    // in MathML if browsers supported <mlabeledtr>. Since they don't, we
                    // need to rewrite the way this function is called.
                }
            });
            textFontFamilies = {
                "\\text": undefined,
                "\\textrm": "textrm",
                "\\textsf": "textsf",
                "\\texttt": "texttt",
                "\\textnormal": "textrm"
            };
            textFontWeights = {
                "\\textbf": "textbf",
                "\\textmd": "textmd"
            };
            textFontShapes = {
                "\\textit": "textit",
                "\\textup": "textup"
            };
            optionsWithFont = (group, options) => {
                const font = group.font; // Checks if the argument is a font family or a font style.
                if (!font) {
                    return options;
                }
                else if (textFontFamilies[font]) {
                    return options.withTextFontFamily(textFontFamilies[font]);
                }
                else if (textFontWeights[font]) {
                    return options.withTextFontWeight(textFontWeights[font]);
                }
                else {
                    return options.withTextFontShape(textFontShapes[font]);
                }
            };
            defineFunction({
                type: "text",
                names: [
                    "\\text", "\\textrm", "\\textsf", "\\texttt", "\\textnormal",
                    "\\textbf", "\\textmd",
                    "\\textit", "\\textup"
                ],
                props: {
                    numArgs: 1,
                    argTypes: ["text"],
                    greediness: 2,
                    allowedInText: true
                },
                handler(_ref, args) {
                    let parser = _ref.parser, funcName = _ref.funcName;
                    const body = args[0];
                    return {
                        type: "text",
                        mode: parser.mode,
                        body: ordargument(body),
                        font: funcName
                    };
                },
                htmlBuilder(group, options) {
                    const newOptions = optionsWithFont(group, options);
                    const inner = buildExpression(group.body, newOptions, true);
                    return buildCommon.makeSpan(["mord", "text"], buildCommon.tryCombineChars(inner), newOptions);
                },
                mathmlBuilder(group, options) {
                    const newOptions = optionsWithFont(group, options);
                    return buildExpressionRow(group.body, newOptions);
                }
            });
            defineFunction({
                type: "underline",
                names: ["\\underline"],
                props: {
                    numArgs: 1,
                    allowedInText: true
                },
                handler(_ref, args) {
                    let parser = _ref.parser;
                    return {
                        type: "underline",
                        mode: parser.mode,
                        body: args[0]
                    };
                },
                htmlBuilder(group, options) {
                    // Underlines are handled in the TeXbook pg 443, Rule 10.
                    // Build the inner group.
                    const innerGroup = buildGroup(group.body, options); // Create the line to go below the body
                    const line = buildCommon.makeLineSpan("underline-line", options); // Generate the vlist, with the appropriate kerns
                    const defaultRuleThickness = options.fontMetrics().defaultRuleThickness;
                    const vlist = buildCommon.makeVList({
                        positionType: "top",
                        positionData: innerGroup.height,
                        children: [{
                                type: "kern",
                                size: defaultRuleThickness
                            }, {
                                type: "elem",
                                elem: line
                            }, {
                                type: "kern",
                                size: 3 * defaultRuleThickness
                            }, {
                                type: "elem",
                                elem: innerGroup
                            }]
                    }, options);
                    return buildCommon.makeSpan(["mord", "underline"], [vlist], options);
                },
                mathmlBuilder(group, options) {
                    const operator = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("\u203e")]);
                    operator.setAttribute("stretchy", "true");
                    const node = new mathMLTree.MathNode("munder", [buildGroup$1(group.body, options), operator]);
                    node.setAttribute("accentunder", "true");
                    return node;
                }
            });
            defineFunction({
                type: "verb",
                names: ["\\verb"],
                props: {
                    numArgs: 0,
                    allowedInText: true
                },
                handler(context, args, optArgs) {
                    // \verb and \verb* are dealt with directly in Parser.js.
                    // If we end up here, it's because of a failure to match the two delimiters
                    // in the regex in Lexer.js.  LaTeX raises the following error when \verb is
                    // terminated by end of line (or file).
                    throw new ParseError("\\verb ended by end of line instead of matching delimiter");
                },
                htmlBuilder(group, options) {
                    const text = makeVerb(group);
                    const body = []; // \verb enters text mode and therefore is sized like \textstyle
                    const newOptions = options.havingStyle(options.style.text());
                    for (let i = 0; i < text.length; i++) {
                        let c = text[i];
                        if (c === '~') {
                            c = '\\textasciitilde';
                        }
                        body.push(buildCommon.makeSymbol(c, "Typewriter-Regular", group.mode, newOptions, ["mord", "texttt"]));
                    }
                    return buildCommon.makeSpan(["mord", "text"].concat(newOptions.sizingClasses(options)), buildCommon.tryCombineChars(body), newOptions);
                },
                mathmlBuilder(group, options) {
                    const text = new mathMLTree.TextNode(makeVerb(group));
                    const node = new mathMLTree.MathNode("mtext", [text]);
                    node.setAttribute("mathvariant", "monospace");
                    return node;
                }
            });
            /**
             * Converts verb group into body string.
             *
             * \verb* replaces each space with an open box \u2423
             * \verb replaces each space with a no-break space \xA0
             */
            makeVerb = group => group.body.replace(/ /g, group.star ? '\u2423' : '\xA0');
            /** Include this to ensure that all functions are defined. */
            functions = _functions;
            /**
             * The Lexer class handles tokenizing the input in various ways. Since our
             * parser expects us to be able to backtrack, the lexer allows lexing from any
             * given starting point.
             *
             * Its main exposed function is the `lex` function, which takes a position to
             * lex from and a type of token to lex. It defers to the appropriate `_innerLex`
             * function.
             *
             * The various `_innerLex` functions perform the actual lexing of different
             * kinds.
             */
            /* The following tokenRegex
             * - matches typical whitespace (but not NBSP etc.) using its first group
             * - does not match any control character \x00-\x1f except whitespace
             * - does not match a bare backslash
             * - matches any ASCII character except those just mentioned
             * - does not match the BMP private use area \uE000-\uF8FF
             * - does not match bare surrogate code units
             * - matches any BMP character except for those just described
             * - matches any valid Unicode surrogate pair
             * - matches a backslash followed by one or more letters
             * - matches a backslash followed by any BMP character, including newline
             * Just because the Lexer matches something doesn't mean it's valid input:
             * If there is no matching function or symbol definition, the Parser will
             * still reject the input.
             */
            spaceRegexString = "[ \r\n\t]";
            controlWordRegexString = "\\\\[a-zA-Z@]+";
            controlSymbolRegexString = "\\\\[^\uD800-\uDFFF]";
            controlWordWhitespaceRegexString = `${controlWordRegexString}${spaceRegexString}*`;
            controlWordWhitespaceRegex = new RegExp(`^(${controlWordRegexString})${spaceRegexString}*$`);
            combiningDiacriticalMarkString = "[\u0300-\u036f]";
            combiningDiacriticalMarksEndRegex = new RegExp(`${combiningDiacriticalMarkString}+$`);
            tokenRegexString = `(${spaceRegexString}+)|` + // whitespace
                "([!-\\[\\]-\u2027\u202A-\uD7FF\uF900-\uFFFF]" + // single codepoint
                `${combiningDiacriticalMarkString}*` + // ...plus accents
                "|[\uD800-\uDBFF][\uDC00-\uDFFF]" + // surrogate pair
                `${combiningDiacriticalMarkString}*` + // ...plus accents
                "|\\\\verb\\*([^]).*?\\3" + // \verb*
                "|\\\\verb([^*a-zA-Z]).*?\\4" + // \verb unstarred
                "|\\\\operatorname\\*" + // \operatorname*
                `|${controlWordWhitespaceRegexString}` + // \macroName + spaces
                `|${controlSymbolRegexString})`; // \\, \', etc.
            /** Main Lexer class */
            Lexer = class Lexer {
                // category codes, only supports comment characters (14) for now
                constructor(input, settings) {
                    this.input = void 0;
                    this.settings = void 0;
                    this.tokenRegex = void 0;
                    this.catcodes = void 0;
                    // Separate accents from characters
                    this.input = input;
                    this.settings = settings;
                    this.tokenRegex = new RegExp(tokenRegexString, 'g');
                    this.catcodes = {
                        "%": 14 // comment character
                    };
                }
                setCatcode(char, code) {
                    this.catcodes[char] = code;
                }
                /**
                 * This function lexes a single token.
                 */
                lex() {
                    const input = this.input;
                    const pos = this.tokenRegex.lastIndex;
                    if (pos === input.length) {
                        return new Token("EOF", new SourceLocation(this, pos, pos));
                    }
                    const match = this.tokenRegex.exec(input);
                    if (match === null || match.index !== pos) {
                        throw new ParseError(`Unexpected character: '${input[pos]}'`, new Token(input[pos], new SourceLocation(this, pos, pos + 1)));
                    }
                    let text = match[2] || " ";
                    if (this.catcodes[text] === 14) {
                        // comment character
                        const nlIndex = input.indexOf('\n', this.tokenRegex.lastIndex);
                        if (nlIndex === -1) {
                            this.tokenRegex.lastIndex = input.length; // EOF
                            this.settings.reportNonstrict("commentAtEnd", "% comment has no terminating newline; LaTeX would " + "fail because of commenting the end of math mode (e.g. $)");
                        }
                        else {
                            this.tokenRegex.lastIndex = nlIndex + 1;
                        }
                        return this.lex();
                    } // Trim any trailing whitespace from control word match
                    const controlMatch = text.match(controlWordWhitespaceRegex);
                    if (controlMatch) {
                        text = controlMatch[1];
                    }
                    return new Token(text, new SourceLocation(this, pos, this.tokenRegex.lastIndex));
                }
            };
            /**
             * A `Namespace` refers to a space of nameable things like macros or lengths,
             * which can be `set` either globally or local to a nested group, using an
             * undo stack similar to how TeX implements this functionality.
             * Performance-wise, `get` and local `set` take constant time, while global
             * `set` takes time proportional to the depth of group nesting.
             */
            Namespace = class Namespace {
                /**
                 * Both arguments are optional.  The first argument is an object of
                 * built-in mappings which never change.  The second argument is an object
                 * of initial (global-level) mappings, which will constantly change
                 * according to any global/top-level `set`s done.
                 */
                constructor(builtins, globalMacros) {
                    if (builtins === void 0) {
                        builtins = {};
                    }
                    if (globalMacros === void 0) {
                        globalMacros = {};
                    }
                    this.current = void 0;
                    this.builtins = void 0;
                    this.undefStack = void 0;
                    this.current = globalMacros;
                    this.builtins = builtins;
                    this.undefStack = [];
                }
                /**
                 * Start a new nested group, affecting future local `set`s.
                 */
                beginGroup() {
                    this.undefStack.push({});
                }
                /**
                 * End current nested group, restoring values before the group began.
                 */
                endGroup() {
                    if (this.undefStack.length === 0) {
                        throw new ParseError("Unbalanced namespace destruction: attempt " + "to pop global namespace; please report this as a bug");
                    }
                    const undefs = this.undefStack.pop();
                    for (const undef in undefs) {
                        if (undefs.hasOwnProperty(undef)) {
                            if (undefs[undef] === undefined) {
                                delete this.current[undef];
                            }
                            else {
                                this.current[undef] = undefs[undef];
                            }
                        }
                    }
                }
                /**
                 * Detect whether `name` has a definition.  Equivalent to
                 * `get(name) != null`.
                 */
                has(name) {
                    return this.current.hasOwnProperty(name) || this.builtins.hasOwnProperty(name);
                }
                /**
                 * Get the current value of a name, or `undefined` if there is no value.
                 *
                 * Note: Do not use `if (namespace.get(...))` to detect whether a macro
                 * is defined, as the definition may be the empty string which evaluates
                 * to `false` in JavaScript.  Use `if (namespace.get(...) != null)` or
                 * `if (namespace.has(...))`.
                 */
                get(name) {
                    if (this.current.hasOwnProperty(name)) {
                        return this.current[name];
                    }
                    else {
                        return this.builtins[name];
                    }
                }
                /**
                 * Set the current value of a name, and optionally set it globally too.
                 * Local set() sets the current value and (when appropriate) adds an undo
                 * operation to the undo stack.  Global set() may change the undo
                 * operation at every level, so takes time linear in their number.
                 */
                set(name, value, global) {
                    if (global === void 0) {
                        global = false;
                    }
                    if (global) {
                        // Global set is equivalent to setting in all groups.  Simulate this
                        // by destroying any undos currently scheduled for this name,
                        // and adding an undo with the *new* value (in case it later gets
                        // locally reset within this environment).
                        for (let i = 0; i < this.undefStack.length; i++) {
                            delete this.undefStack[i][name];
                        }
                        if (this.undefStack.length > 0) {
                            this.undefStack[this.undefStack.length - 1][name] = value;
                        }
                    }
                    else {
                        // Undo this set at end of this group (possibly to `undefined`),
                        // unless an undo is already in place, in which case that older
                        // value is the correct one.
                        const top = this.undefStack[this.undefStack.length - 1];
                        if (top && !top.hasOwnProperty(name)) {
                            top[name] = this.current[name];
                        }
                    }
                    this.current[name] = value;
                }
            };
            /**
             * Predefined macros for KaTeX.
             * This can be used to define some commands in terms of others.
             */
            builtinMacros = {};
            // macro tools
            // LaTeX's \@firstoftwo{#1}{#2} expands to #1, skipping #2
            // TeX source: \long\def\@firstoftwo#1#2{#1}
            defineMacro("\\@firstoftwo", function (context) {
                const args = context.consumeArgs(2);
                return {
                    tokens: args[0],
                    numArgs: 0
                };
            }); // LaTeX's \@secondoftwo{#1}{#2} expands to #2, skipping #1
            // TeX source: \long\def\@secondoftwo#1#2{#2}
            defineMacro("\\@secondoftwo", function (context) {
                const args = context.consumeArgs(2);
                return {
                    tokens: args[1],
                    numArgs: 0
                };
            }); // LaTeX's \@ifnextchar{#1}{#2}{#3} looks ahead to the next (unexpanded)
            // symbol.  If it matches #1, then the macro expands to #2; otherwise, #3.
            // Note, however, that it does not consume the next symbol in either case.
            defineMacro("\\@ifnextchar", function (context) {
                const args = context.consumeArgs(3); // symbol, if, else
                const nextToken = context.future();
                if (args[0].length === 1 && args[0][0].text === nextToken.text) {
                    return {
                        tokens: args[1],
                        numArgs: 0
                    };
                }
                else {
                    return {
                        tokens: args[2],
                        numArgs: 0
                    };
                }
            }); // LaTeX's \@ifstar{#1}{#2} looks ahead to the next (unexpanded) symbol.
            // If it is `*`, then it consumes the symbol, and the macro expands to #1;
            // otherwise, the macro expands to #2 (without consuming the symbol).
            // TeX source: \def\@ifstar#1{\@ifnextchar *{\@firstoftwo{#1}}}
            defineMacro("\\@ifstar", "\\@ifnextchar *{\\@firstoftwo{#1}}"); // LaTeX's \TextOrMath{#1}{#2} expands to #1 in text mode, #2 in math mode
            defineMacro("\\TextOrMath", function (context) {
                const args = context.consumeArgs(2);
                if (context.mode === 'text') {
                    return {
                        tokens: args[0],
                        numArgs: 0
                    };
                }
                else {
                    return {
                        tokens: args[1],
                        numArgs: 0
                    };
                }
            }); // Lookup table for parsing numbers in base 8 through 16
            digitToNumber = {
                "0": 0,
                "1": 1,
                "2": 2,
                "3": 3,
                "4": 4,
                "5": 5,
                "6": 6,
                "7": 7,
                "8": 8,
                "9": 9,
                "a": 10,
                "A": 10,
                "b": 11,
                "B": 11,
                "c": 12,
                "C": 12,
                "d": 13,
                "D": 13,
                "e": 14,
                "E": 14,
                "f": 15,
                "F": 15
            }; // TeX \char makes a literal character (catcode 12) using the following forms:
            // (see The TeXBook, p. 43)
            //   \char123  -- decimal
            //   \char'123 -- octal
            //   \char"123 -- hex
            //   \char`x   -- character that can be written (i.e. isn't active)
            //   \char`\x  -- character that cannot be written (e.g. %)
            // These all refer to characters from the font, so we turn them into special
            // calls to a function \@char dealt with in the Parser.
            defineMacro("\\char", function (context) {
                let token = context.popToken();
                let base;
                let number = '';
                if (token.text === "'") {
                    base = 8;
                    token = context.popToken();
                }
                else if (token.text === '"') {
                    base = 16;
                    token = context.popToken();
                }
                else if (token.text === "`") {
                    token = context.popToken();
                    if (token.text[0] === "\\") {
                        number = token.text.charCodeAt(1);
                    }
                    else if (token.text === "EOF") {
                        throw new ParseError("\\char` missing argument");
                    }
                    else {
                        number = token.text.charCodeAt(0);
                    }
                }
                else {
                    base = 10;
                }
                if (base) {
                    // Parse a number in the given base, starting with first `token`.
                    number = digitToNumber[token.text];
                    if (number == null || number >= base) {
                        throw new ParseError(`Invalid base-${base} digit ${token.text}`);
                    }
                    let digit;
                    while ((digit = digitToNumber[context.future().text]) != null && digit < base) {
                        number *= base;
                        number += digit;
                        context.popToken();
                    }
                }
                return `\\@char{${number}}`;
            }); // Basic support for macro definitions:
            //     \def\macro{expansion}
            //     \def\macro#1{expansion}
            //     \def\macro#1#2{expansion}
            //     \def\macro#1#2#3#4#5#6#7#8#9{expansion}
            // Also the \gdef and \global\def equivalents
            def = (context, global) => {
                let arg = context.consumeArgs(1)[0];
                if (arg.length !== 1) {
                    throw new ParseError("\\gdef's first argument must be a macro name");
                }
                const name = arg[0].text; // Count argument specifiers, and check they are in the order #1 #2 ...
                let numArgs = 0;
                arg = context.consumeArgs(1)[0];
                while (arg.length === 1 && arg[0].text === "#") {
                    arg = context.consumeArgs(1)[0];
                    if (arg.length !== 1) {
                        throw new ParseError(`Invalid argument number length "${arg.length}"`);
                    }
                    if (!/^[1-9]$/.test(arg[0].text)) {
                        throw new ParseError(`Invalid argument number "${arg[0].text}"`);
                    }
                    numArgs++;
                    if (parseInt(arg[0].text) !== numArgs) {
                        throw new ParseError(`Argument number "${arg[0].text}" out of order`);
                    }
                    arg = context.consumeArgs(1)[0];
                } // Final arg is the expansion of the macro
                context.macros.set(name, {
                    tokens: arg,
                    numArgs
                }, global);
                return '';
            };
            defineMacro("\\gdef", context => def(context, true));
            defineMacro("\\def", context => def(context, false));
            defineMacro("\\global", context => {
                const next = context.consumeArgs(1)[0];
                if (next.length !== 1) {
                    throw new ParseError("Invalid command after \\global");
                }
                const command = next[0].text; // TODO: Should expand command
                if (command === "\\def") {
                    // \global\def is equivalent to \gdef
                    return def(context, true);
                }
                else {
                    throw new ParseError(`Invalid command '${command}' after \\global`);
                }
            }); // \newcommand{\macro}[args]{definition}
            // \renewcommand{\macro}[args]{definition}
            // TODO: Optional arguments: \newcommand{\macro}[args][default]{definition}
            newcommand = (context, existsOK, nonexistsOK) => {
                let arg = context.consumeArgs(1)[0];
                if (arg.length !== 1) {
                    throw new ParseError("\\newcommand's first argument must be a macro name");
                }
                const name = arg[0].text;
                const exists = context.isDefined(name);
                if (exists && !existsOK) {
                    throw new ParseError(`\\newcommand{${name}} attempting to redefine ` + `${name}; use \\renewcommand`);
                }
                if (!exists && !nonexistsOK) {
                    throw new ParseError(`\\renewcommand{${name}} when command ${name} ` + `does not yet exist; use \\newcommand`);
                }
                let numArgs = 0;
                arg = context.consumeArgs(1)[0];
                if (arg.length === 1 && arg[0].text === "[") {
                    let argText = '';
                    let token = context.expandNextToken();
                    while (token.text !== "]" && token.text !== "EOF") {
                        // TODO: Should properly expand arg, e.g., ignore {}s
                        argText += token.text;
                        token = context.expandNextToken();
                    }
                    if (!argText.match(/^\s*[0-9]+\s*$/)) {
                        throw new ParseError(`Invalid number of arguments: ${argText}`);
                    }
                    numArgs = parseInt(argText);
                    arg = context.consumeArgs(1)[0];
                } // Final arg is the expansion of the macro
                context.macros.set(name, {
                    tokens: arg,
                    numArgs
                });
                return '';
            };
            defineMacro("\\newcommand", context => newcommand(context, false, true));
            defineMacro("\\renewcommand", context => newcommand(context, true, false));
            defineMacro("\\providecommand", context => newcommand(context, true, true)); //////////////////////////////////////////////////////////////////////
            // Grouping
            // \let\bgroup={ \let\egroup=}
            defineMacro("\\bgroup", "{");
            defineMacro("\\egroup", "}"); // Symbols from latex.ltx:
            // \def\lq{`}
            // \def\rq{'}
            // \def \aa {\r a}
            // \def \AA {\r A}
            defineMacro("\\lq", "`");
            defineMacro("\\rq", "'");
            defineMacro("\\aa", "\\r a");
            defineMacro("\\AA", "\\r A"); // Copyright (C) and registered (R) symbols. Use raw symbol in MathML.
            // \DeclareTextCommandDefault{\textcopyright}{\textcircled{c}}
            // \DeclareTextCommandDefault{\textregistered}{\textcircled{%
            //      \check@mathfonts\fontsize\sf@size\z@\math@fontsfalse\selectfont R}}
            // \DeclareRobustCommand{\copyright}{%
            //    \ifmmode{\nfss@text{\textcopyright}}\else\textcopyright\fi}
            defineMacro("\\textcopyright", "\\html@mathml{\\textcircled{c}}{\\char`}");
            defineMacro("\\copyright", "\\TextOrMath{\\textcopyright}{\\text{\\textcopyright}}");
            defineMacro("\\textregistered", "\\html@mathml{\\textcircled{\\scriptsize R}}{\\char`}"); // Characters omitted from Unicode range 1D4001D7FF
            defineMacro("\u212C", "\\mathscr{B}"); // script
            defineMacro("\u2130", "\\mathscr{E}");
            defineMacro("\u2131", "\\mathscr{F}");
            defineMacro("\u210B", "\\mathscr{H}");
            defineMacro("\u2110", "\\mathscr{I}");
            defineMacro("\u2112", "\\mathscr{L}");
            defineMacro("\u2133", "\\mathscr{M}");
            defineMacro("\u211B", "\\mathscr{R}");
            defineMacro("\u212D", "\\mathfrak{C}"); // Fraktur
            defineMacro("\u210C", "\\mathfrak{H}");
            defineMacro("\u2128", "\\mathfrak{Z}"); // Define \Bbbk with a macro that works in both HTML and MathML.
            defineMacro("\\Bbbk", "\\Bbb{k}"); // Unicode middle dot
            // The KaTeX fonts do not contain U+00B7. Instead, \cdotp displays
            // the dot at U+22C5 and gives it punct spacing.
            defineMacro("\u00b7", "\\cdotp"); // \llap and \rlap render their contents in text mode
            defineMacro("\\llap", "\\mathllap{\\textrm{#1}}");
            defineMacro("\\rlap", "\\mathrlap{\\textrm{#1}}");
            defineMacro("\\clap", "\\mathclap{\\textrm{#1}}"); // \not is defined by base/fontmath.ltx via
            // \DeclareMathSymbol{\not}{\mathrel}{symbols}{"36}
            // It's thus treated like a \mathrel, but defined by a symbol that has zero
            // width but extends to the right.  We use \rlap to get that spacing.
            // For MathML we write U+0338 here. buildMathML.js will then do the overlay.
            defineMacro("\\not", '\\html@mathml{\\mathrel{\\mathrlap\\@not}}{\\char"338}'); // Negated symbols from base/fontmath.ltx:
            // \def\neq{\not=} \let\ne=\neq
            // \DeclareRobustCommand
            //   \notin{\mathrel{\m@th\mathpalette\c@ncel\in}}
            // \def\c@ncel#1#2{\m@th\ooalign{$\hfil#1\mkern1mu/\hfil$\crcr$#1#2$}}
            defineMacro("\\neq", "\\html@mathml{\\mathrel{\\not=}}{\\mathrel{\\char`}}");
            defineMacro("\\ne", "\\neq");
            defineMacro("\u2260", "\\neq");
            defineMacro("\\notin", "\\html@mathml{\\mathrel{{\\in}\\mathllap{/\\mskip1mu}}}" + "{\\mathrel{\\char`}}");
            defineMacro("\u2209", "\\notin"); // Unicode stacked relations
            defineMacro("\u2258", "\\html@mathml{" + "\\mathrel{=\\kern{-1em}\\raisebox{0.4em}{$\\scriptsize\\frown$}}" + "}{\\mathrel{\\char`\u2258}}");
            defineMacro("\u2259", "\\html@mathml{\\stackrel{\\tiny\\wedge}{=}}{\\mathrel{\\char`\u2258}}");
            defineMacro("\u225A", "\\html@mathml{\\stackrel{\\tiny\\vee}{=}}{\\mathrel{\\char`\u225A}}");
            defineMacro("\u225B", "\\html@mathml{\\stackrel{\\scriptsize\\star}{=}}" + "{\\mathrel{\\char`\u225B}}");
            defineMacro("\u225D", "\\html@mathml{\\stackrel{\\tiny\\mathrm{def}}{=}}" + "{\\mathrel{\\char`\u225D}}");
            defineMacro("\u225E", "\\html@mathml{\\stackrel{\\tiny\\mathrm{m}}{=}}" + "{\\mathrel{\\char`\u225E}}");
            defineMacro("\u225F", "\\html@mathml{\\stackrel{\\tiny?}{=}}{\\mathrel{\\char`\u225F}}"); // Misc Unicode
            defineMacro("\u27C2", "\\perp");
            defineMacro("\u203C", "\\mathclose{!\\mkern-0.8mu!}");
            defineMacro("\u220C", "\\notni");
            defineMacro("\u231C", "\\ulcorner");
            defineMacro("\u231D", "\\urcorner");
            defineMacro("\u231E", "\\llcorner");
            defineMacro("\u231F", "\\lrcorner");
            defineMacro("\u00A9", "\\copyright");
            defineMacro("\u00AE", "\\textregistered");
            defineMacro("\uFE0F", "\\textregistered"); //////////////////////////////////////////////////////////////////////
            // LaTeX_2
            // \vdots{\vbox{\baselineskip4\p@  \lineskiplimit\z@
            // \kern6\p@\hbox{.}\hbox{.}\hbox{.}}}
            // We'll call \varvdots, which gets a glyph from symbols.js.
            // The zero-width rule gets us an equivalent to the vertical 6pt kern.
            defineMacro("\\vdots", "\\mathord{\\varvdots\\rule{0pt}{15pt}}");
            defineMacro("\u22ee", "\\vdots"); //////////////////////////////////////////////////////////////////////
            // amsmath.sty
            // http://mirrors.concertpass.com/tex-archive/macros/latex/required/amsmath/amsmath.pdf
            // Italic Greek capital letters.  AMS defines these with \DeclareMathSymbol,
            // but they are equivalent to \mathit{\Letter}.
            defineMacro("\\varGamma", "\\mathit{\\Gamma}");
            defineMacro("\\varDelta", "\\mathit{\\Delta}");
            defineMacro("\\varTheta", "\\mathit{\\Theta}");
            defineMacro("\\varLambda", "\\mathit{\\Lambda}");
            defineMacro("\\varXi", "\\mathit{\\Xi}");
            defineMacro("\\varPi", "\\mathit{\\Pi}");
            defineMacro("\\varSigma", "\\mathit{\\Sigma}");
            defineMacro("\\varUpsilon", "\\mathit{\\Upsilon}");
            defineMacro("\\varPhi", "\\mathit{\\Phi}");
            defineMacro("\\varPsi", "\\mathit{\\Psi}");
            defineMacro("\\varOmega", "\\mathit{\\Omega}"); //\newcommand{\substack}[1]{\subarray{c}#1\endsubarray}
            defineMacro("\\substack", "\\begin{subarray}{c}#1\\end{subarray}"); // \renewcommand{\colon}{\nobreak\mskip2mu\mathpunct{}\nonscript
            // \mkern-\thinmuskip{:}\mskip6muplus1mu\relax}
            defineMacro("\\colon", "\\nobreak\\mskip2mu\\mathpunct{}" + "\\mathchoice{\\mkern-3mu}{\\mkern-3mu}{}{}{:}\\mskip6mu"); // \newcommand{\boxed}[1]{\fbox{\m@th$\displaystyle#1$}}
            defineMacro("\\boxed", "\\fbox{$\\displaystyle{#1}$}"); // \def\iff{\DOTSB\;\Longleftrightarrow\;}
            // \def\implies{\DOTSB\;\Longrightarrow\;}
            // \def\impliedby{\DOTSB\;\Longleftarrow\;}
            defineMacro("\\iff", "\\DOTSB\\;\\Longleftrightarrow\\;");
            defineMacro("\\implies", "\\DOTSB\\;\\Longrightarrow\\;");
            defineMacro("\\impliedby", "\\DOTSB\\;\\Longleftarrow\\;"); // AMSMath's automatic \dots, based on \mdots@@ macro.
            dotsByToken = {
                ',': '\\dotsc',
                '\\not': '\\dotsb',
                // \keybin@ checks for the following:
                '+': '\\dotsb',
                '=': '\\dotsb',
                '<': '\\dotsb',
                '>': '\\dotsb',
                '-': '\\dotsb',
                '*': '\\dotsb',
                ':': '\\dotsb',
                // Symbols whose definition starts with \DOTSB:
                '\\DOTSB': '\\dotsb',
                '\\coprod': '\\dotsb',
                '\\bigvee': '\\dotsb',
                '\\bigwedge': '\\dotsb',
                '\\biguplus': '\\dotsb',
                '\\bigcap': '\\dotsb',
                '\\bigcup': '\\dotsb',
                '\\prod': '\\dotsb',
                '\\sum': '\\dotsb',
                '\\bigotimes': '\\dotsb',
                '\\bigoplus': '\\dotsb',
                '\\bigodot': '\\dotsb',
                '\\bigsqcup': '\\dotsb',
                '\\And': '\\dotsb',
                '\\longrightarrow': '\\dotsb',
                '\\Longrightarrow': '\\dotsb',
                '\\longleftarrow': '\\dotsb',
                '\\Longleftarrow': '\\dotsb',
                '\\longleftrightarrow': '\\dotsb',
                '\\Longleftrightarrow': '\\dotsb',
                '\\mapsto': '\\dotsb',
                '\\longmapsto': '\\dotsb',
                '\\hookrightarrow': '\\dotsb',
                '\\doteq': '\\dotsb',
                // Symbols whose definition starts with \mathbin:
                '\\mathbin': '\\dotsb',
                // Symbols whose definition starts with \mathrel:
                '\\mathrel': '\\dotsb',
                '\\relbar': '\\dotsb',
                '\\Relbar': '\\dotsb',
                '\\xrightarrow': '\\dotsb',
                '\\xleftarrow': '\\dotsb',
                // Symbols whose definition starts with \DOTSI:
                '\\DOTSI': '\\dotsi',
                '\\int': '\\dotsi',
                '\\oint': '\\dotsi',
                '\\iint': '\\dotsi',
                '\\iiint': '\\dotsi',
                '\\iiiint': '\\dotsi',
                '\\idotsint': '\\dotsi',
                // Symbols whose definition starts with \DOTSX:
                '\\DOTSX': '\\dotsx'
            };
            defineMacro("\\dots", function (context) {
                // TODO: If used in text mode, should expand to \textellipsis.
                // However, in KaTeX, \textellipsis and \ldots behave the same
                // (in text mode), and it's unlikely we'd see any of the math commands
                // that affect the behavior of \dots when in text mode.  So fine for now
                // (until we support \ifmmode ... \else ... \fi).
                let thedots = '\\dotso';
                const next = context.expandAfterFuture().text;
                if (next in dotsByToken) {
                    thedots = dotsByToken[next];
                }
                else if (next.substr(0, 4) === '\\not') {
                    thedots = '\\dotsb';
                }
                else if (next in symbols.math) {
                    if (utils.contains(['bin', 'rel'], symbols.math[next].group)) {
                        thedots = '\\dotsb';
                    }
                }
                return thedots;
            });
            spaceAfterDots = {
                // \rightdelim@ checks for the following:
                ')': true,
                ']': true,
                '\\rbrack': true,
                '\\}': true,
                '\\rbrace': true,
                '\\rangle': true,
                '\\rceil': true,
                '\\rfloor': true,
                '\\rgroup': true,
                '\\rmoustache': true,
                '\\right': true,
                '\\bigr': true,
                '\\biggr': true,
                '\\Bigr': true,
                '\\Biggr': true,
                // \extra@ also tests for the following:
                '$': true,
                // \extrap@ checks for the following:
                ';': true,
                '.': true,
                ',': true
            };
            defineMacro("\\dotso", function (context) {
                const next = context.future().text;
                if (next in spaceAfterDots) {
                    return "\\ldots\\,";
                }
                else {
                    return "\\ldots";
                }
            });
            defineMacro("\\dotsc", function (context) {
                const next = context.future().text; // \dotsc uses \extra@ but not \extrap@, instead specially checking for
                // ';' and '.', but doesn't check for ','.
                if (next in spaceAfterDots && next !== ',') {
                    return "\\ldots\\,";
                }
                else {
                    return "\\ldots";
                }
            });
            defineMacro("\\cdots", function (context) {
                const next = context.future().text;
                if (next in spaceAfterDots) {
                    return "\\@cdots\\,";
                }
                else {
                    return "\\@cdots";
                }
            });
            defineMacro("\\dotsb", "\\cdots");
            defineMacro("\\dotsm", "\\cdots");
            defineMacro("\\dotsi", "\\!\\cdots"); // amsmath doesn't actually define \dotsx, but \dots followed by a macro
            // starting with \DOTSX implies \dotso, and then \extra@ detects this case
            // and forces the added `\,`.
            defineMacro("\\dotsx", "\\ldots\\,"); // \let\DOTSI\relax
            // \let\DOTSB\relax
            // \let\DOTSX\relax
            defineMacro("\\DOTSI", "\\relax");
            defineMacro("\\DOTSB", "\\relax");
            defineMacro("\\DOTSX", "\\relax"); // Spacing, based on amsmath.sty's override of LaTeX defaults
            // \DeclareRobustCommand{\tmspace}[3]{%
            //   \ifmmode\mskip#1#2\else\kern#1#3\fi\relax}
            defineMacro("\\tmspace", "\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax"); // \renewcommand{\,}{\tmspace+\thinmuskip{.1667em}}
            // TODO: math mode should use \thinmuskip
            defineMacro("\\,", "\\tmspace+{3mu}{.1667em}"); // \let\thinspace\,
            defineMacro("\\thinspace", "\\,"); // \def\>{\mskip\medmuskip}
            // \renewcommand{\:}{\tmspace+\medmuskip{.2222em}}
            // TODO: \> and math mode of \: should use \medmuskip = 4mu plus 2mu minus 4mu
            defineMacro("\\>", "\\mskip{4mu}");
            defineMacro("\\:", "\\tmspace+{4mu}{.2222em}"); // \let\medspace\:
            defineMacro("\\medspace", "\\:"); // \renewcommand{\;}{\tmspace+\thickmuskip{.2777em}}
            // TODO: math mode should use \thickmuskip = 5mu plus 5mu
            defineMacro("\\;", "\\tmspace+{5mu}{.2777em}"); // \let\thickspace\;
            defineMacro("\\thickspace", "\\;"); // \renewcommand{\!}{\tmspace-\thinmuskip{.1667em}}
            // TODO: math mode should use \thinmuskip
            defineMacro("\\!", "\\tmspace-{3mu}{.1667em}"); // \let\negthinspace\!
            defineMacro("\\negthinspace", "\\!"); // \newcommand{\negmedspace}{\tmspace-\medmuskip{.2222em}}
            // TODO: math mode should use \medmuskip
            defineMacro("\\negmedspace", "\\tmspace-{4mu}{.2222em}"); // \newcommand{\negthickspace}{\tmspace-\thickmuskip{.2777em}}
            // TODO: math mode should use \thickmuskip
            defineMacro("\\negthickspace", "\\tmspace-{5mu}{.277em}"); // \def\enspace{\kern.5em }
            defineMacro("\\enspace", "\\kern.5em "); // \def\enskip{\hskip.5em\relax}
            defineMacro("\\enskip", "\\hskip.5em\\relax"); // \def\quad{\hskip1em\relax}
            defineMacro("\\quad", "\\hskip1em\\relax"); // \def\qquad{\hskip2em\relax}
            defineMacro("\\qquad", "\\hskip2em\\relax"); // \tag@in@display form of \tag
            defineMacro("\\tag", "\\@ifstar\\tag@literal\\tag@paren");
            defineMacro("\\tag@paren", "\\tag@literal{({#1})}");
            defineMacro("\\tag@literal", context => {
                if (context.macros.get("\\df@tag")) {
                    throw new ParseError("Multiple \\tag");
                }
                return "\\gdef\\df@tag{\\text{#1}}";
            }); // \renewcommand{\bmod}{\nonscript\mskip-\medmuskip\mkern5mu\mathbin
            //   {\operator@font mod}\penalty900
            //   \mkern5mu\nonscript\mskip-\medmuskip}
            // \newcommand{\pod}[1]{\allowbreak
            //   \if@display\mkern18mu\else\mkern8mu\fi(#1)}
            // \renewcommand{\pmod}[1]{\pod{{\operator@font mod}\mkern6mu#1}}
            // \newcommand{\mod}[1]{\allowbreak\if@display\mkern18mu
            //   \else\mkern12mu\fi{\operator@font mod}\,\,#1}
            // TODO: math mode should use \medmuskip = 4mu plus 2mu minus 4mu
            defineMacro("\\bmod", "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}" + "\\mathbin{\\rm mod}" + "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}");
            defineMacro("\\pod", "\\allowbreak" + "\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)");
            defineMacro("\\pmod", "\\pod{{\\rm mod}\\mkern6mu#1}");
            defineMacro("\\mod", "\\allowbreak" + "\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}" + "{\\rm mod}\\,\\,#1"); // \pmb    --   A simulation of bold.
            // The version in ambsy.sty works by typesetting three copies of the argument
            // with small offsets. We use two copies. We omit the vertical offset because
            // of rendering problems that makeVList encounters in Safari.
            defineMacro("\\pmb", "\\html@mathml{" + "\\@binrel{#1}{\\mathrlap{#1}\\kern0.5px#1}}" + "{\\mathbf{#1}}"); //////////////////////////////////////////////////////////////////////
            // LaTeX source2e
            // \\ defaults to \newline, but changes to \cr within array environment
            defineMacro("\\\\", "\\newline"); // \def\TeX{T\kern-.1667em\lower.5ex\hbox{E}\kern-.125emX\@}
            // TODO: Doesn't normally work in math mode because \@ fails.  KaTeX doesn't
            // support \@ yet, so that's omitted, and we add \text so that the result
            // doesn't look funny in math mode.
            defineMacro("\\TeX", "\\textrm{\\html@mathml{" + "T\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125emX" + "}{TeX}}"); // \DeclareRobustCommand{\LaTeX}{L\kern-.36em%
            //         {\sbox\z@ T%
            //          \vbox to\ht\z@{\hbox{\check@mathfonts
            //                               \fontsize\sf@size\z@
            //                               \math@fontsfalse\selectfont
            //                               A}%
            //                         \vss}%
            //         }%
            //         \kern-.15em%
            //         \TeX}
            // This code aligns the top of the A with the T (from the perspective of TeX's
            // boxes, though visually the A appears to extend above slightly).
            // We compute the corresponding \raisebox when A is rendered in \normalsize
            // \scriptstyle, which has a scale factor of 0.7 (see Options.js).
            latexRaiseA = metricMap['Main-Regular']["T".charCodeAt(0)][1] - 0.7 * metricMap['Main-Regular']["A".charCodeAt(0)][1] + "em";
            defineMacro("\\LaTeX", "\\textrm{\\html@mathml{" + `L\\kern-.36em\\raisebox{${latexRaiseA}}{\\scriptstyle A}` + "\\kern-.15em\\TeX}{LaTeX}}"); // New KaTeX logo based on tweaking LaTeX logo
            defineMacro("\\KaTeX", "\\textrm{\\html@mathml{" + `K\\kern-.17em\\raisebox{${latexRaiseA}}{\\scriptstyle A}` + "\\kern-.15em\\TeX}{KaTeX}}"); // \DeclareRobustCommand\hspace{\@ifstar\@hspacer\@hspace}
            // \def\@hspace#1{\hskip  #1\relax}
            // \def\@hspacer#1{\vrule \@width\z@\nobreak
            //                 \hskip #1\hskip \z@skip}
            defineMacro("\\hspace", "\\@ifstar\\@hspacer\\@hspace");
            defineMacro("\\@hspace", "\\hskip #1\\relax");
            defineMacro("\\@hspacer", "\\rule{0pt}{0pt}\\hskip #1\\relax"); //////////////////////////////////////////////////////////////////////
            // mathtools.sty
            //\providecommand\ordinarycolon{:}
            defineMacro("\\ordinarycolon", ":"); //\def\vcentcolon{\mathrel{\mathop\ordinarycolon}}
            //TODO(edemaine): Not yet centered. Fix via \raisebox or #726
            defineMacro("\\vcentcolon", "\\mathrel{\\mathop\\ordinarycolon}"); // \providecommand*\dblcolon{\vcentcolon\mathrel{\mkern-.9mu}\vcentcolon}
            defineMacro("\\dblcolon", "\\html@mathml{" + "\\mathrel{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}}" + "{\\mathop{\\char\"2237}}"); // \providecommand*\coloneqq{\vcentcolon\mathrel{\mkern-1.2mu}=}
            defineMacro("\\coloneqq", "\\html@mathml{" + "\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}}" + "{\\mathop{\\char\"2254}}"); // 
            // \providecommand*\Coloneqq{\dblcolon\mathrel{\mkern-1.2mu}=}
            defineMacro("\\Coloneqq", "\\html@mathml{" + "\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}=}}" + "{\\mathop{\\char\"2237\\char\"3d}}"); // \providecommand*\coloneq{\vcentcolon\mathrel{\mkern-1.2mu}\mathrel{-}}
            defineMacro("\\coloneq", "\\html@mathml{" + "\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}" + "{\\mathop{\\char\"3a\\char\"2212}}"); // \providecommand*\Coloneq{\dblcolon\mathrel{\mkern-1.2mu}\mathrel{-}}
            defineMacro("\\Coloneq", "\\html@mathml{" + "\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}" + "{\\mathop{\\char\"2237\\char\"2212}}"); // \providecommand*\eqqcolon{=\mathrel{\mkern-1.2mu}\vcentcolon}
            defineMacro("\\eqqcolon", "\\html@mathml{" + "\\mathrel{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}}" + "{\\mathop{\\char\"2255}}"); // 
            // \providecommand*\Eqqcolon{=\mathrel{\mkern-1.2mu}\dblcolon}
            defineMacro("\\Eqqcolon", "\\html@mathml{" + "\\mathrel{=\\mathrel{\\mkern-1.2mu}\\dblcolon}}" + "{\\mathop{\\char\"3d\\char\"2237}}"); // \providecommand*\eqcolon{\mathrel{-}\mathrel{\mkern-1.2mu}\vcentcolon}
            defineMacro("\\eqcolon", "\\html@mathml{" + "\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}}" + "{\\mathop{\\char\"2239}}"); // \providecommand*\Eqcolon{\mathrel{-}\mathrel{\mkern-1.2mu}\dblcolon}
            defineMacro("\\Eqcolon", "\\html@mathml{" + "\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}}" + "{\\mathop{\\char\"2212\\char\"2237}}"); // \providecommand*\colonapprox{\vcentcolon\mathrel{\mkern-1.2mu}\approx}
            defineMacro("\\colonapprox", "\\html@mathml{" + "\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}}" + "{\\mathop{\\char\"3a\\char\"2248}}"); // \providecommand*\Colonapprox{\dblcolon\mathrel{\mkern-1.2mu}\approx}
            defineMacro("\\Colonapprox", "\\html@mathml{" + "\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}}" + "{\\mathop{\\char\"2237\\char\"2248}}"); // \providecommand*\colonsim{\vcentcolon\mathrel{\mkern-1.2mu}\sim}
            defineMacro("\\colonsim", "\\html@mathml{" + "\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}}" + "{\\mathop{\\char\"3a\\char\"223c}}"); // \providecommand*\Colonsim{\dblcolon\mathrel{\mkern-1.2mu}\sim}
            defineMacro("\\Colonsim", "\\html@mathml{" + "\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}}" + "{\\mathop{\\char\"2237\\char\"223c}}"); // Some Unicode characters are implemented with macros to mathtools functions.
            defineMacro("\u2237", "\\dblcolon"); // ::
            defineMacro("\u2239", "\\eqcolon"); // -:
            defineMacro("\u2254", "\\coloneqq"); // :=
            defineMacro("\u2255", "\\eqqcolon"); // =:
            defineMacro("\u2A74", "\\Coloneqq"); // ::=
            //////////////////////////////////////////////////////////////////////
            // colonequals.sty
            // Alternate names for mathtools's macros:
            defineMacro("\\ratio", "\\vcentcolon");
            defineMacro("\\coloncolon", "\\dblcolon");
            defineMacro("\\colonequals", "\\coloneqq");
            defineMacro("\\coloncolonequals", "\\Coloneqq");
            defineMacro("\\equalscolon", "\\eqqcolon");
            defineMacro("\\equalscoloncolon", "\\Eqqcolon");
            defineMacro("\\colonminus", "\\coloneq");
            defineMacro("\\coloncolonminus", "\\Coloneq");
            defineMacro("\\minuscolon", "\\eqcolon");
            defineMacro("\\minuscoloncolon", "\\Eqcolon"); // \colonapprox name is same in mathtools and colonequals.
            defineMacro("\\coloncolonapprox", "\\Colonapprox"); // \colonsim name is same in mathtools and colonequals.
            defineMacro("\\coloncolonsim", "\\Colonsim"); // Additional macros, implemented by analogy with mathtools definitions:
            defineMacro("\\simcolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
            defineMacro("\\simcoloncolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\dblcolon}");
            defineMacro("\\approxcolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
            defineMacro("\\approxcoloncolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\dblcolon}"); // Present in newtxmath, pxfonts and txfonts
            defineMacro("\\notni", "\\html@mathml{\\not\\ni}{\\mathrel{\\char`\u220C}}");
            defineMacro("\\limsup", "\\DOTSB\\operatorname*{lim\\,sup}");
            defineMacro("\\liminf", "\\DOTSB\\operatorname*{lim\\,inf}"); //////////////////////////////////////////////////////////////////////
            // MathML alternates for KaTeX glyphs in the Unicode private area
            defineMacro("\\gvertneqq", "\\html@mathml{\\@gvertneqq}{\u2269}");
            defineMacro("\\lvertneqq", "\\html@mathml{\\@lvertneqq}{\u2268}");
            defineMacro("\\ngeqq", "\\html@mathml{\\@ngeqq}{\u2271}");
            defineMacro("\\ngeqslant", "\\html@mathml{\\@ngeqslant}{\u2271}");
            defineMacro("\\nleqq", "\\html@mathml{\\@nleqq}{\u2270}");
            defineMacro("\\nleqslant", "\\html@mathml{\\@nleqslant}{\u2270}");
            defineMacro("\\nshortmid", "\\html@mathml{\\@nshortmid}{}");
            defineMacro("\\nshortparallel", "\\html@mathml{\\@nshortparallel}{}");
            defineMacro("\\nsubseteqq", "\\html@mathml{\\@nsubseteqq}{\u2288}");
            defineMacro("\\nsupseteqq", "\\html@mathml{\\@nsupseteqq}{\u2289}");
            defineMacro("\\varsubsetneq", "\\html@mathml{\\@varsubsetneq}{}");
            defineMacro("\\varsubsetneqq", "\\html@mathml{\\@varsubsetneqq}{}");
            defineMacro("\\varsupsetneq", "\\html@mathml{\\@varsupsetneq}{}");
            defineMacro("\\varsupsetneqq", "\\html@mathml{\\@varsupsetneqq}{}"); //////////////////////////////////////////////////////////////////////
            // stmaryrd and semantic
            // The stmaryrd and semantic packages render the next four items by calling a
            // glyph. Those glyphs do not exist in the KaTeX fonts. Hence the macros.
            defineMacro("\\llbracket", "\\html@mathml{" + "\\mathopen{[\\mkern-3.2mu[}}" + "{\\mathopen{\\char`\u27e6}}");
            defineMacro("\\rrbracket", "\\html@mathml{" + "\\mathclose{]\\mkern-3.2mu]}}" + "{\\mathclose{\\char`\u27e7}}");
            defineMacro("\u27e6", "\\llbracket"); // blackboard bold [
            defineMacro("\u27e7", "\\rrbracket"); // blackboard bold ]
            defineMacro("\\lBrace", "\\html@mathml{" + "\\mathopen{\\{\\mkern-3.2mu[}}" + "{\\mathopen{\\char`\u2983}}");
            defineMacro("\\rBrace", "\\html@mathml{" + "\\mathclose{]\\mkern-3.2mu\\}}}" + "{\\mathclose{\\char`\u2984}}");
            defineMacro("\u2983", "\\lBrace"); // blackboard bold {
            defineMacro("\u2984", "\\rBrace"); // blackboard bold }
            // TODO: Create variable sized versions of the last two items. I believe that
            // will require new font glyphs.
            //////////////////////////////////////////////////////////////////////
            // texvc.sty
            // The texvc package contains macros available in mediawiki pages.
            // We omit the functions deprecated at
            // https://en.wikipedia.org/wiki/Help:Displaying_a_formula#Deprecated_syntax
            // We also omit texvc's \O, which conflicts with \text{\O}
            defineMacro("\\darr", "\\downarrow");
            defineMacro("\\dArr", "\\Downarrow");
            defineMacro("\\Darr", "\\Downarrow");
            defineMacro("\\lang", "\\langle");
            defineMacro("\\rang", "\\rangle");
            defineMacro("\\uarr", "\\uparrow");
            defineMacro("\\uArr", "\\Uparrow");
            defineMacro("\\Uarr", "\\Uparrow");
            defineMacro("\\N", "\\mathbb{N}");
            defineMacro("\\R", "\\mathbb{R}");
            defineMacro("\\Z", "\\mathbb{Z}");
            defineMacro("\\alef", "\\aleph");
            defineMacro("\\alefsym", "\\aleph");
            defineMacro("\\Alpha", "\\mathrm{A}");
            defineMacro("\\Beta", "\\mathrm{B}");
            defineMacro("\\bull", "\\bullet");
            defineMacro("\\Chi", "\\mathrm{X}");
            defineMacro("\\clubs", "\\clubsuit");
            defineMacro("\\cnums", "\\mathbb{C}");
            defineMacro("\\Complex", "\\mathbb{C}");
            defineMacro("\\Dagger", "\\ddagger");
            defineMacro("\\diamonds", "\\diamondsuit");
            defineMacro("\\empty", "\\emptyset");
            defineMacro("\\Epsilon", "\\mathrm{E}");
            defineMacro("\\Eta", "\\mathrm{H}");
            defineMacro("\\exist", "\\exists");
            defineMacro("\\harr", "\\leftrightarrow");
            defineMacro("\\hArr", "\\Leftrightarrow");
            defineMacro("\\Harr", "\\Leftrightarrow");
            defineMacro("\\hearts", "\\heartsuit");
            defineMacro("\\image", "\\Im");
            defineMacro("\\infin", "\\infty");
            defineMacro("\\Iota", "\\mathrm{I}");
            defineMacro("\\isin", "\\in");
            defineMacro("\\Kappa", "\\mathrm{K}");
            defineMacro("\\larr", "\\leftarrow");
            defineMacro("\\lArr", "\\Leftarrow");
            defineMacro("\\Larr", "\\Leftarrow");
            defineMacro("\\lrarr", "\\leftrightarrow");
            defineMacro("\\lrArr", "\\Leftrightarrow");
            defineMacro("\\Lrarr", "\\Leftrightarrow");
            defineMacro("\\Mu", "\\mathrm{M}");
            defineMacro("\\natnums", "\\mathbb{N}");
            defineMacro("\\Nu", "\\mathrm{N}");
            defineMacro("\\Omicron", "\\mathrm{O}");
            defineMacro("\\plusmn", "\\pm");
            defineMacro("\\rarr", "\\rightarrow");
            defineMacro("\\rArr", "\\Rightarrow");
            defineMacro("\\Rarr", "\\Rightarrow");
            defineMacro("\\real", "\\Re");
            defineMacro("\\reals", "\\mathbb{R}");
            defineMacro("\\Reals", "\\mathbb{R}");
            defineMacro("\\Rho", "\\mathrm{P}");
            defineMacro("\\sdot", "\\cdot");
            defineMacro("\\sect", "\\S");
            defineMacro("\\spades", "\\spadesuit");
            defineMacro("\\sub", "\\subset");
            defineMacro("\\sube", "\\subseteq");
            defineMacro("\\supe", "\\supseteq");
            defineMacro("\\Tau", "\\mathrm{T}");
            defineMacro("\\thetasym", "\\vartheta"); // TODO: defineMacro("\\varcoppa", "\\\mbox{\\coppa}");
            defineMacro("\\weierp", "\\wp");
            defineMacro("\\Zeta", "\\mathrm{Z}"); //////////////////////////////////////////////////////////////////////
            // statmath.sty
            // https://ctan.math.illinois.edu/macros/latex/contrib/statmath/statmath.pdf
            defineMacro("\\argmin", "\\DOTSB\\operatorname*{arg\\,min}");
            defineMacro("\\argmax", "\\DOTSB\\operatorname*{arg\\,max}");
            defineMacro("\\plim", "\\DOTSB\\mathop{\\operatorname{plim}}\\limits"); // Custom Khan Academy colors, should be moved to an optional package
            defineMacro("\\blue", "\\textcolor{##6495ed}{#1}");
            defineMacro("\\orange", "\\textcolor{##ffa500}{#1}");
            defineMacro("\\pink", "\\textcolor{##ff00af}{#1}");
            defineMacro("\\red", "\\textcolor{##df0030}{#1}");
            defineMacro("\\green", "\\textcolor{##28ae7b}{#1}");
            defineMacro("\\gray", "\\textcolor{gray}{#1}");
            defineMacro("\\purple", "\\textcolor{##9d38bd}{#1}");
            defineMacro("\\blueA", "\\textcolor{##ccfaff}{#1}");
            defineMacro("\\blueB", "\\textcolor{##80f6ff}{#1}");
            defineMacro("\\blueC", "\\textcolor{##63d9ea}{#1}");
            defineMacro("\\blueD", "\\textcolor{##11accd}{#1}");
            defineMacro("\\blueE", "\\textcolor{##0c7f99}{#1}");
            defineMacro("\\tealA", "\\textcolor{##94fff5}{#1}");
            defineMacro("\\tealB", "\\textcolor{##26edd5}{#1}");
            defineMacro("\\tealC", "\\textcolor{##01d1c1}{#1}");
            defineMacro("\\tealD", "\\textcolor{##01a995}{#1}");
            defineMacro("\\tealE", "\\textcolor{##208170}{#1}");
            defineMacro("\\greenA", "\\textcolor{##b6ffb0}{#1}");
            defineMacro("\\greenB", "\\textcolor{##8af281}{#1}");
            defineMacro("\\greenC", "\\textcolor{##74cf70}{#1}");
            defineMacro("\\greenD", "\\textcolor{##1fab54}{#1}");
            defineMacro("\\greenE", "\\textcolor{##0d923f}{#1}");
            defineMacro("\\goldA", "\\textcolor{##ffd0a9}{#1}");
            defineMacro("\\goldB", "\\textcolor{##ffbb71}{#1}");
            defineMacro("\\goldC", "\\textcolor{##ff9c39}{#1}");
            defineMacro("\\goldD", "\\textcolor{##e07d10}{#1}");
            defineMacro("\\goldE", "\\textcolor{##a75a05}{#1}");
            defineMacro("\\redA", "\\textcolor{##fca9a9}{#1}");
            defineMacro("\\redB", "\\textcolor{##ff8482}{#1}");
            defineMacro("\\redC", "\\textcolor{##f9685d}{#1}");
            defineMacro("\\redD", "\\textcolor{##e84d39}{#1}");
            defineMacro("\\redE", "\\textcolor{##bc2612}{#1}");
            defineMacro("\\maroonA", "\\textcolor{##ffbde0}{#1}");
            defineMacro("\\maroonB", "\\textcolor{##ff92c6}{#1}");
            defineMacro("\\maroonC", "\\textcolor{##ed5fa6}{#1}");
            defineMacro("\\maroonD", "\\textcolor{##ca337c}{#1}");
            defineMacro("\\maroonE", "\\textcolor{##9e034e}{#1}");
            defineMacro("\\purpleA", "\\textcolor{##ddd7ff}{#1}");
            defineMacro("\\purpleB", "\\textcolor{##c6b9fc}{#1}");
            defineMacro("\\purpleC", "\\textcolor{##aa87ff}{#1}");
            defineMacro("\\purpleD", "\\textcolor{##7854ab}{#1}");
            defineMacro("\\purpleE", "\\textcolor{##543b78}{#1}");
            defineMacro("\\mintA", "\\textcolor{##f5f9e8}{#1}");
            defineMacro("\\mintB", "\\textcolor{##edf2df}{#1}");
            defineMacro("\\mintC", "\\textcolor{##e0e5cc}{#1}");
            defineMacro("\\grayA", "\\textcolor{##f6f7f7}{#1}");
            defineMacro("\\grayB", "\\textcolor{##f0f1f2}{#1}");
            defineMacro("\\grayC", "\\textcolor{##e3e5e6}{#1}");
            defineMacro("\\grayD", "\\textcolor{##d6d8da}{#1}");
            defineMacro("\\grayE", "\\textcolor{##babec2}{#1}");
            defineMacro("\\grayF", "\\textcolor{##888d93}{#1}");
            defineMacro("\\grayG", "\\textcolor{##626569}{#1}");
            defineMacro("\\grayH", "\\textcolor{##3b3e40}{#1}");
            defineMacro("\\grayI", "\\textcolor{##21242c}{#1}");
            defineMacro("\\kaBlue", "\\textcolor{##314453}{#1}");
            defineMacro("\\kaGreen", "\\textcolor{##71B307}{#1}");
            /**
             * This file contains the gullet where macros are expanded
             * until only non-macro tokens remain.
             */
            // List of commands that act like macros but aren't defined as a macro,
            // function, or symbol.  Used in `isDefined`.
            implicitCommands = {
                "\\relax": true,
                // MacroExpander.js
                "^": true,
                // Parser.js
                "_": true,
                // Parser.js
                "\\limits": true,
                // Parser.js
                "\\nolimits": true // Parser.js
            };
            MacroExpander = class MacroExpander {
                constructor(input, settings, mode) {
                    this.settings = void 0;
                    this.expansionCount = void 0;
                    this.lexer = void 0;
                    this.macros = void 0;
                    this.stack = void 0;
                    this.mode = void 0;
                    this.settings = settings;
                    this.expansionCount = 0;
                    this.feed(input); // Make new global namespace
                    this.macros = new Namespace(builtinMacros, settings.macros);
                    this.mode = mode;
                    this.stack = []; // contains tokens in REVERSE order
                }
                /**
                 * Feed a new input string to the same MacroExpander
                 * (with existing macros etc.).
                 */
                feed(input) {
                    this.lexer = new Lexer(input, this.settings);
                }
                /**
                 * Switches between "text" and "math" modes.
                 */
                switchMode(newMode) {
                    this.mode = newMode;
                }
                /**
                 * Start a new group nesting within all namespaces.
                 */
                beginGroup() {
                    this.macros.beginGroup();
                }
                /**
                 * End current group nesting within all namespaces.
                 */
                endGroup() {
                    this.macros.endGroup();
                }
                /**
                 * Returns the topmost token on the stack, without expanding it.
                 * Similar in behavior to TeX's `\futurelet`.
                 */
                future() {
                    if (this.stack.length === 0) {
                        this.pushToken(this.lexer.lex());
                    }
                    return this.stack[this.stack.length - 1];
                }
                /**
                 * Remove and return the next unexpanded token.
                 */
                popToken() {
                    this.future(); // ensure non-empty stack
                    return this.stack.pop();
                }
                /**
                 * Add a given token to the token stack.  In particular, this get be used
                 * to put back a token returned from one of the other methods.
                 */
                pushToken(token) {
                    this.stack.push(token);
                }
                /**
                 * Append an array of tokens to the token stack.
                 */
                pushTokens(tokens) {
                    this.stack.push(...tokens);
                }
                /**
                 * Consume all following space tokens, without expansion.
                 */
                consumeSpaces() {
                    for (;;) {
                        const token = this.future();
                        if (token.text === " ") {
                            this.stack.pop();
                        }
                        else {
                            break;
                        }
                    }
                }
                /**
                 * Consume the specified number of arguments from the token stream,
                 * and return the resulting array of arguments.
                 */
                consumeArgs(numArgs) {
                    const args = []; // obtain arguments, either single token or balanced {} group
                    for (let i = 0; i < numArgs; ++i) {
                        this.consumeSpaces(); // ignore spaces before each argument
                        const startOfArg = this.popToken();
                        if (startOfArg.text === "{") {
                            const arg = [];
                            let depth = 1;
                            while (depth !== 0) {
                                const tok = this.popToken();
                                arg.push(tok);
                                if (tok.text === "{") {
                                    ++depth;
                                }
                                else if (tok.text === "}") {
                                    --depth;
                                }
                                else if (tok.text === "EOF") {
                                    throw new ParseError("End of input in macro argument", startOfArg);
                                }
                            }
                            arg.pop(); // remove last }
                            arg.reverse(); // like above, to fit in with stack order
                            args[i] = arg;
                        }
                        else if (startOfArg.text === "EOF") {
                            throw new ParseError("End of input expecting macro argument");
                        }
                        else {
                            args[i] = [startOfArg];
                        }
                    }
                    return args;
                }
                /**
                 * Expand the next token only once if possible.
                 *
                 * If the token is expanded, the resulting tokens will be pushed onto
                 * the stack in reverse order and will be returned as an array,
                 * also in reverse order.
                 *
                 * If not, the next token will be returned without removing it
                 * from the stack.  This case can be detected by a `Token` return value
                 * instead of an `Array` return value.
                 *
                 * In either case, the next token will be on the top of the stack,
                 * or the stack will be empty.
                 *
                 * Used to implement `expandAfterFuture` and `expandNextToken`.
                 *
                 * At the moment, macro expansion doesn't handle delimited macros,
                 * i.e. things like those defined by \def\foo#1\end{}.
                 * See the TeX book page 202ff. for details on how those should behave.
                 */
                expandOnce() {
                    const topToken = this.popToken();
                    const name = topToken.text;
                    const expansion = this._getExpansion(name);
                    if (expansion == null) {
                        // mainly checking for undefined here
                        // Fully expanded
                        this.pushToken(topToken);
                        return topToken;
                    }
                    this.expansionCount++;
                    if (this.expansionCount > this.settings.maxExpand) {
                        throw new ParseError("Too many expansions: infinite loop or " + "need to increase maxExpand setting");
                    }
                    let tokens = expansion.tokens;
                    if (expansion.numArgs) {
                        const args = this.consumeArgs(expansion.numArgs); // paste arguments in place of the placeholders
                        tokens = tokens.slice(); // make a shallow copy
                        for (let i = tokens.length - 1; i >= 0; --i) {
                            let tok = tokens[i];
                            if (tok.text === "#") {
                                if (i === 0) {
                                    throw new ParseError("Incomplete placeholder at end of macro body", tok);
                                }
                                tok = tokens[--i]; // next token on stack
                                if (tok.text === "#") {
                                    // ##  #
                                    tokens.splice(i + 1, 1); // drop first #
                                }
                                else if (/^[1-9]$/.test(tok.text)) {
                                    // replace the placeholder with the indicated argument
                                    tokens.splice(i, 2, ...args[+tok.text - 1]);
                                }
                                else {
                                    throw new ParseError("Not a valid argument number", tok);
                                }
                            }
                        }
                    } // Concatenate expansion onto top of stack.
                    this.pushTokens(tokens);
                    return tokens;
                }
                /**
                 * Expand the next token only once (if possible), and return the resulting
                 * top token on the stack (without removing anything from the stack).
                 * Similar in behavior to TeX's `\expandafter\futurelet`.
                 * Equivalent to expandOnce() followed by future().
                 */
                expandAfterFuture() {
                    this.expandOnce();
                    return this.future();
                }
                /**
                 * Recursively expand first token, then return first non-expandable token.
                 */
                expandNextToken() {
                    for (;;) {
                        const expanded = this.expandOnce(); // expandOnce returns Token if and only if it's fully expanded.
                        if (expanded instanceof Token) {
                            // \relax stops the expansion, but shouldn't get returned (a
                            // null return value couldn't get implemented as a function).
                            if (expanded.text === "\\relax") {
                                this.stack.pop();
                            }
                            else {
                                return this.stack.pop(); // === expanded
                            }
                        }
                    } // Flow unable to figure out that this pathway is impossible.
                    // https://github.com/facebook/flow/issues/4808
                    throw new Error(); // eslint-disable-line no-unreachable
                }
                /**
                 * Fully expand the given macro name and return the resulting list of
                 * tokens, or return `undefined` if no such macro is defined.
                 */
                expandMacro(name) {
                    if (!this.macros.get(name)) {
                        return undefined;
                    }
                    const output = [];
                    const oldStackLength = this.stack.length;
                    this.pushToken(new Token(name));
                    while (this.stack.length > oldStackLength) {
                        const expanded = this.expandOnce(); // expandOnce returns Token if and only if it's fully expanded.
                        if (expanded instanceof Token) {
                            output.push(this.stack.pop());
                        }
                    }
                    return output;
                }
                /**
                 * Fully expand the given macro name and return the result as a string,
                 * or return `undefined` if no such macro is defined.
                 */
                expandMacroAsText(name) {
                    const tokens = this.expandMacro(name);
                    if (tokens) {
                        return tokens.map(token => token.text).join("");
                    }
                    else {
                        return tokens;
                    }
                }
                /**
                 * Returns the expanded macro as a reversed array of tokens and a macro
                 * argument count.  Or returns `null` if no such macro.
                 */
                _getExpansion(name) {
                    const definition = this.macros.get(name);
                    if (definition == null) {
                        // mainly checking for undefined here
                        return definition;
                    }
                    const expansion = typeof definition === "function" ? definition(this) : definition;
                    if (typeof expansion === "string") {
                        let numArgs = 0;
                        if (expansion.indexOf("#") !== -1) {
                            const stripped = expansion.replace(/##/g, "");
                            while (stripped.indexOf("#" + (numArgs + 1)) !== -1) {
                                ++numArgs;
                            }
                        }
                        const bodyLexer = new Lexer(expansion, this.settings);
                        const tokens = [];
                        let tok = bodyLexer.lex();
                        while (tok.text !== "EOF") {
                            tokens.push(tok);
                            tok = bodyLexer.lex();
                        }
                        tokens.reverse(); // to fit in with stack using push and pop
                        const expanded = {
                            tokens,
                            numArgs
                        };
                        return expanded;
                    }
                    return expansion;
                }
                /**
                 * Determine whether a command is currently "defined" (has some
                 * functionality), meaning that it's a macro (in the current group),
                 * a function, a symbol, or one of the special commands listed in
                 * `implicitCommands`.
                 */
                isDefined(name) {
                    return this.macros.has(name) || functions.hasOwnProperty(name) || symbols.math.hasOwnProperty(name) || symbols.text.hasOwnProperty(name) || implicitCommands.hasOwnProperty(name);
                }
            };
            // Mapping of Unicode accent characters to their LaTeX equivalent in text and
            // math mode (when they exist).
            unicodeAccents = {
                '\u0301': {
                    text: "\\'",
                    math: '\\acute'
                },
                '\u0300': {
                    text: '\\`',
                    math: '\\grave'
                },
                '\u0308': {
                    text: '\\"',
                    math: '\\ddot'
                },
                '\u0303': {
                    text: '\\~',
                    math: '\\tilde'
                },
                '\u0304': {
                    text: '\\=',
                    math: '\\bar'
                },
                '\u0306': {
                    text: '\\u',
                    math: '\\breve'
                },
                '\u030c': {
                    text: '\\v',
                    math: '\\check'
                },
                '\u0302': {
                    text: '\\^',
                    math: '\\hat'
                },
                '\u0307': {
                    text: '\\.',
                    math: '\\dot'
                },
                '\u030a': {
                    text: '\\r',
                    math: '\\mathring'
                },
                '\u030b': {
                    text: '\\H'
                }
            };
            // This file is GENERATED by unicodeMake.js. DO NOT MODIFY.
            unicodeSymbols = {
                "\u00e1": "\u0061\u0301",
                //  = \'{a}
                "\u00e0": "\u0061\u0300",
                //  = \`{a}
                "\u00e4": "\u0061\u0308",
                //  = \"{a}
                "\u01df": "\u0061\u0308\u0304",
                //  = \"\={a}
                "\u00e3": "\u0061\u0303",
                //  = \~{a}
                "\u0101": "\u0061\u0304",
                //  = \={a}
                "\u0103": "\u0061\u0306",
                //  = \u{a}
                "\u1eaf": "\u0061\u0306\u0301",
                //  = \u\'{a}
                "\u1eb1": "\u0061\u0306\u0300",
                //  = \u\`{a}
                "\u1eb5": "\u0061\u0306\u0303",
                //  = \u\~{a}
                "\u01ce": "\u0061\u030c",
                //  = \v{a}
                "\u00e2": "\u0061\u0302",
                //  = \^{a}
                "\u1ea5": "\u0061\u0302\u0301",
                //  = \^\'{a}
                "\u1ea7": "\u0061\u0302\u0300",
                //  = \^\`{a}
                "\u1eab": "\u0061\u0302\u0303",
                //  = \^\~{a}
                "\u0227": "\u0061\u0307",
                //  = \.{a}
                "\u01e1": "\u0061\u0307\u0304",
                //  = \.\={a}
                "\u00e5": "\u0061\u030a",
                //  = \r{a}
                "\u01fb": "\u0061\u030a\u0301",
                //  = \r\'{a}
                "\u1e03": "\u0062\u0307",
                //  = \.{b}
                "\u0107": "\u0063\u0301",
                //  = \'{c}
                "\u010d": "\u0063\u030c",
                //  = \v{c}
                "\u0109": "\u0063\u0302",
                //  = \^{c}
                "\u010b": "\u0063\u0307",
                //  = \.{c}
                "\u010f": "\u0064\u030c",
                //  = \v{d}
                "\u1e0b": "\u0064\u0307",
                //  = \.{d}
                "\u00e9": "\u0065\u0301",
                //  = \'{e}
                "\u00e8": "\u0065\u0300",
                //  = \`{e}
                "\u00eb": "\u0065\u0308",
                //  = \"{e}
                "\u1ebd": "\u0065\u0303",
                //  = \~{e}
                "\u0113": "\u0065\u0304",
                //  = \={e}
                "\u1e17": "\u0065\u0304\u0301",
                //  = \=\'{e}
                "\u1e15": "\u0065\u0304\u0300",
                //  = \=\`{e}
                "\u0115": "\u0065\u0306",
                //  = \u{e}
                "\u011b": "\u0065\u030c",
                //  = \v{e}
                "\u00ea": "\u0065\u0302",
                //  = \^{e}
                "\u1ebf": "\u0065\u0302\u0301",
                //  = \^\'{e}
                "\u1ec1": "\u0065\u0302\u0300",
                //  = \^\`{e}
                "\u1ec5": "\u0065\u0302\u0303",
                //  = \^\~{e}
                "\u0117": "\u0065\u0307",
                //  = \.{e}
                "\u1e1f": "\u0066\u0307",
                //  = \.{f}
                "\u01f5": "\u0067\u0301",
                //  = \'{g}
                "\u1e21": "\u0067\u0304",
                //  = \={g}
                "\u011f": "\u0067\u0306",
                //  = \u{g}
                "\u01e7": "\u0067\u030c",
                //  = \v{g}
                "\u011d": "\u0067\u0302",
                //  = \^{g}
                "\u0121": "\u0067\u0307",
                //  = \.{g}
                "\u1e27": "\u0068\u0308",
                //  = \"{h}
                "\u021f": "\u0068\u030c",
                //  = \v{h}
                "\u0125": "\u0068\u0302",
                //  = \^{h}
                "\u1e23": "\u0068\u0307",
                //  = \.{h}
                "\u00ed": "\u0069\u0301",
                //  = \'{i}
                "\u00ec": "\u0069\u0300",
                //  = \`{i}
                "\u00ef": "\u0069\u0308",
                //  = \"{i}
                "\u1e2f": "\u0069\u0308\u0301",
                //  = \"\'{i}
                "\u0129": "\u0069\u0303",
                //  = \~{i}
                "\u012b": "\u0069\u0304",
                //  = \={i}
                "\u012d": "\u0069\u0306",
                //  = \u{i}
                "\u01d0": "\u0069\u030c",
                //  = \v{i}
                "\u00ee": "\u0069\u0302",
                //  = \^{i}
                "\u01f0": "\u006a\u030c",
                //  = \v{j}
                "\u0135": "\u006a\u0302",
                //  = \^{j}
                "\u1e31": "\u006b\u0301",
                //  = \'{k}
                "\u01e9": "\u006b\u030c",
                //  = \v{k}
                "\u013a": "\u006c\u0301",
                //  = \'{l}
                "\u013e": "\u006c\u030c",
                //  = \v{l}
                "\u1e3f": "\u006d\u0301",
                //  = \'{m}
                "\u1e41": "\u006d\u0307",
                //  = \.{m}
                "\u0144": "\u006e\u0301",
                //  = \'{n}
                "\u01f9": "\u006e\u0300",
                //  = \`{n}
                "\u00f1": "\u006e\u0303",
                //  = \~{n}
                "\u0148": "\u006e\u030c",
                //  = \v{n}
                "\u1e45": "\u006e\u0307",
                //  = \.{n}
                "\u00f3": "\u006f\u0301",
                //  = \'{o}
                "\u00f2": "\u006f\u0300",
                //  = \`{o}
                "\u00f6": "\u006f\u0308",
                //  = \"{o}
                "\u022b": "\u006f\u0308\u0304",
                //  = \"\={o}
                "\u00f5": "\u006f\u0303",
                //  = \~{o}
                "\u1e4d": "\u006f\u0303\u0301",
                //  = \~\'{o}
                "\u1e4f": "\u006f\u0303\u0308",
                //  = \~\"{o}
                "\u022d": "\u006f\u0303\u0304",
                //  = \~\={o}
                "\u014d": "\u006f\u0304",
                //  = \={o}
                "\u1e53": "\u006f\u0304\u0301",
                //  = \=\'{o}
                "\u1e51": "\u006f\u0304\u0300",
                //  = \=\`{o}
                "\u014f": "\u006f\u0306",
                //  = \u{o}
                "\u01d2": "\u006f\u030c",
                //  = \v{o}
                "\u00f4": "\u006f\u0302",
                //  = \^{o}
                "\u1ed1": "\u006f\u0302\u0301",
                //  = \^\'{o}
                "\u1ed3": "\u006f\u0302\u0300",
                //  = \^\`{o}
                "\u1ed7": "\u006f\u0302\u0303",
                //  = \^\~{o}
                "\u022f": "\u006f\u0307",
                //  = \.{o}
                "\u0231": "\u006f\u0307\u0304",
                //  = \.\={o}
                "\u0151": "\u006f\u030b",
                //  = \H{o}
                "\u1e55": "\u0070\u0301",
                //  = \'{p}
                "\u1e57": "\u0070\u0307",
                //  = \.{p}
                "\u0155": "\u0072\u0301",
                //  = \'{r}
                "\u0159": "\u0072\u030c",
                //  = \v{r}
                "\u1e59": "\u0072\u0307",
                //  = \.{r}
                "\u015b": "\u0073\u0301",
                //  = \'{s}
                "\u1e65": "\u0073\u0301\u0307",
                //  = \'\.{s}
                "\u0161": "\u0073\u030c",
                //  = \v{s}
                "\u1e67": "\u0073\u030c\u0307",
                //  = \v\.{s}
                "\u015d": "\u0073\u0302",
                //  = \^{s}
                "\u1e61": "\u0073\u0307",
                //  = \.{s}
                "\u1e97": "\u0074\u0308",
                //  = \"{t}
                "\u0165": "\u0074\u030c",
                //  = \v{t}
                "\u1e6b": "\u0074\u0307",
                //  = \.{t}
                "\u00fa": "\u0075\u0301",
                //  = \'{u}
                "\u00f9": "\u0075\u0300",
                //  = \`{u}
                "\u00fc": "\u0075\u0308",
                //  = \"{u}
                "\u01d8": "\u0075\u0308\u0301",
                //  = \"\'{u}
                "\u01dc": "\u0075\u0308\u0300",
                //  = \"\`{u}
                "\u01d6": "\u0075\u0308\u0304",
                //  = \"\={u}
                "\u01da": "\u0075\u0308\u030c",
                //  = \"\v{u}
                "\u0169": "\u0075\u0303",
                //  = \~{u}
                "\u1e79": "\u0075\u0303\u0301",
                //  = \~\'{u}
                "\u016b": "\u0075\u0304",
                //  = \={u}
                "\u1e7b": "\u0075\u0304\u0308",
                //  = \=\"{u}
                "\u016d": "\u0075\u0306",
                //  = \u{u}
                "\u01d4": "\u0075\u030c",
                //  = \v{u}
                "\u00fb": "\u0075\u0302",
                //  = \^{u}
                "\u016f": "\u0075\u030a",
                //  = \r{u}
                "\u0171": "\u0075\u030b",
                //  = \H{u}
                "\u1e7d": "\u0076\u0303",
                //  = \~{v}
                "\u1e83": "\u0077\u0301",
                //  = \'{w}
                "\u1e81": "\u0077\u0300",
                //  = \`{w}
                "\u1e85": "\u0077\u0308",
                //  = \"{w}
                "\u0175": "\u0077\u0302",
                //  = \^{w}
                "\u1e87": "\u0077\u0307",
                //  = \.{w}
                "\u1e98": "\u0077\u030a",
                //  = \r{w}
                "\u1e8d": "\u0078\u0308",
                //  = \"{x}
                "\u1e8b": "\u0078\u0307",
                //  = \.{x}
                "\u00fd": "\u0079\u0301",
                //  = \'{y}
                "\u1ef3": "\u0079\u0300",
                //  = \`{y}
                "\u00ff": "\u0079\u0308",
                //  = \"{y}
                "\u1ef9": "\u0079\u0303",
                //  = \~{y}
                "\u0233": "\u0079\u0304",
                //  = \={y}
                "\u0177": "\u0079\u0302",
                //  = \^{y}
                "\u1e8f": "\u0079\u0307",
                //  = \.{y}
                "\u1e99": "\u0079\u030a",
                //  = \r{y}
                "\u017a": "\u007a\u0301",
                //  = \'{z}
                "\u017e": "\u007a\u030c",
                //  = \v{z}
                "\u1e91": "\u007a\u0302",
                //  = \^{z}
                "\u017c": "\u007a\u0307",
                //  = \.{z}
                "\u00c1": "\u0041\u0301",
                //  = \'{A}
                "\u00c0": "\u0041\u0300",
                //  = \`{A}
                "\u00c4": "\u0041\u0308",
                //  = \"{A}
                "\u01de": "\u0041\u0308\u0304",
                //  = \"\={A}
                "\u00c3": "\u0041\u0303",
                //  = \~{A}
                "\u0100": "\u0041\u0304",
                //  = \={A}
                "\u0102": "\u0041\u0306",
                //  = \u{A}
                "\u1eae": "\u0041\u0306\u0301",
                //  = \u\'{A}
                "\u1eb0": "\u0041\u0306\u0300",
                //  = \u\`{A}
                "\u1eb4": "\u0041\u0306\u0303",
                //  = \u\~{A}
                "\u01cd": "\u0041\u030c",
                //  = \v{A}
                "\u00c2": "\u0041\u0302",
                //  = \^{A}
                "\u1ea4": "\u0041\u0302\u0301",
                //  = \^\'{A}
                "\u1ea6": "\u0041\u0302\u0300",
                //  = \^\`{A}
                "\u1eaa": "\u0041\u0302\u0303",
                //  = \^\~{A}
                "\u0226": "\u0041\u0307",
                //  = \.{A}
                "\u01e0": "\u0041\u0307\u0304",
                //  = \.\={A}
                "\u00c5": "\u0041\u030a",
                //  = \r{A}
                "\u01fa": "\u0041\u030a\u0301",
                //  = \r\'{A}
                "\u1e02": "\u0042\u0307",
                //  = \.{B}
                "\u0106": "\u0043\u0301",
                //  = \'{C}
                "\u010c": "\u0043\u030c",
                //  = \v{C}
                "\u0108": "\u0043\u0302",
                //  = \^{C}
                "\u010a": "\u0043\u0307",
                //  = \.{C}
                "\u010e": "\u0044\u030c",
                //  = \v{D}
                "\u1e0a": "\u0044\u0307",
                //  = \.{D}
                "\u00c9": "\u0045\u0301",
                //  = \'{E}
                "\u00c8": "\u0045\u0300",
                //  = \`{E}
                "\u00cb": "\u0045\u0308",
                //  = \"{E}
                "\u1ebc": "\u0045\u0303",
                //  = \~{E}
                "\u0112": "\u0045\u0304",
                //  = \={E}
                "\u1e16": "\u0045\u0304\u0301",
                //  = \=\'{E}
                "\u1e14": "\u0045\u0304\u0300",
                //  = \=\`{E}
                "\u0114": "\u0045\u0306",
                //  = \u{E}
                "\u011a": "\u0045\u030c",
                //  = \v{E}
                "\u00ca": "\u0045\u0302",
                //  = \^{E}
                "\u1ebe": "\u0045\u0302\u0301",
                //  = \^\'{E}
                "\u1ec0": "\u0045\u0302\u0300",
                //  = \^\`{E}
                "\u1ec4": "\u0045\u0302\u0303",
                //  = \^\~{E}
                "\u0116": "\u0045\u0307",
                //  = \.{E}
                "\u1e1e": "\u0046\u0307",
                //  = \.{F}
                "\u01f4": "\u0047\u0301",
                //  = \'{G}
                "\u1e20": "\u0047\u0304",
                //  = \={G}
                "\u011e": "\u0047\u0306",
                //  = \u{G}
                "\u01e6": "\u0047\u030c",
                //  = \v{G}
                "\u011c": "\u0047\u0302",
                //  = \^{G}
                "\u0120": "\u0047\u0307",
                //  = \.{G}
                "\u1e26": "\u0048\u0308",
                //  = \"{H}
                "\u021e": "\u0048\u030c",
                //  = \v{H}
                "\u0124": "\u0048\u0302",
                //  = \^{H}
                "\u1e22": "\u0048\u0307",
                //  = \.{H}
                "\u00cd": "\u0049\u0301",
                //  = \'{I}
                "\u00cc": "\u0049\u0300",
                //  = \`{I}
                "\u00cf": "\u0049\u0308",
                //  = \"{I}
                "\u1e2e": "\u0049\u0308\u0301",
                //  = \"\'{I}
                "\u0128": "\u0049\u0303",
                //  = \~{I}
                "\u012a": "\u0049\u0304",
                //  = \={I}
                "\u012c": "\u0049\u0306",
                //  = \u{I}
                "\u01cf": "\u0049\u030c",
                //  = \v{I}
                "\u00ce": "\u0049\u0302",
                //  = \^{I}
                "\u0130": "\u0049\u0307",
                //  = \.{I}
                "\u0134": "\u004a\u0302",
                //  = \^{J}
                "\u1e30": "\u004b\u0301",
                //  = \'{K}
                "\u01e8": "\u004b\u030c",
                //  = \v{K}
                "\u0139": "\u004c\u0301",
                //  = \'{L}
                "\u013d": "\u004c\u030c",
                //  = \v{L}
                "\u1e3e": "\u004d\u0301",
                //  = \'{M}
                "\u1e40": "\u004d\u0307",
                //  = \.{M}
                "\u0143": "\u004e\u0301",
                //  = \'{N}
                "\u01f8": "\u004e\u0300",
                //  = \`{N}
                "\u00d1": "\u004e\u0303",
                //  = \~{N}
                "\u0147": "\u004e\u030c",
                //  = \v{N}
                "\u1e44": "\u004e\u0307",
                //  = \.{N}
                "\u00d3": "\u004f\u0301",
                //  = \'{O}
                "\u00d2": "\u004f\u0300",
                //  = \`{O}
                "\u00d6": "\u004f\u0308",
                //  = \"{O}
                "\u022a": "\u004f\u0308\u0304",
                //  = \"\={O}
                "\u00d5": "\u004f\u0303",
                //  = \~{O}
                "\u1e4c": "\u004f\u0303\u0301",
                //  = \~\'{O}
                "\u1e4e": "\u004f\u0303\u0308",
                //  = \~\"{O}
                "\u022c": "\u004f\u0303\u0304",
                //  = \~\={O}
                "\u014c": "\u004f\u0304",
                //  = \={O}
                "\u1e52": "\u004f\u0304\u0301",
                //  = \=\'{O}
                "\u1e50": "\u004f\u0304\u0300",
                //  = \=\`{O}
                "\u014e": "\u004f\u0306",
                //  = \u{O}
                "\u01d1": "\u004f\u030c",
                //  = \v{O}
                "\u00d4": "\u004f\u0302",
                //  = \^{O}
                "\u1ed0": "\u004f\u0302\u0301",
                //  = \^\'{O}
                "\u1ed2": "\u004f\u0302\u0300",
                //  = \^\`{O}
                "\u1ed6": "\u004f\u0302\u0303",
                //  = \^\~{O}
                "\u022e": "\u004f\u0307",
                //  = \.{O}
                "\u0230": "\u004f\u0307\u0304",
                //  = \.\={O}
                "\u0150": "\u004f\u030b",
                //  = \H{O}
                "\u1e54": "\u0050\u0301",
                //  = \'{P}
                "\u1e56": "\u0050\u0307",
                //  = \.{P}
                "\u0154": "\u0052\u0301",
                //  = \'{R}
                "\u0158": "\u0052\u030c",
                //  = \v{R}
                "\u1e58": "\u0052\u0307",
                //  = \.{R}
                "\u015a": "\u0053\u0301",
                //  = \'{S}
                "\u1e64": "\u0053\u0301\u0307",
                //  = \'\.{S}
                "\u0160": "\u0053\u030c",
                //  = \v{S}
                "\u1e66": "\u0053\u030c\u0307",
                //  = \v\.{S}
                "\u015c": "\u0053\u0302",
                //  = \^{S}
                "\u1e60": "\u0053\u0307",
                //  = \.{S}
                "\u0164": "\u0054\u030c",
                //  = \v{T}
                "\u1e6a": "\u0054\u0307",
                //  = \.{T}
                "\u00da": "\u0055\u0301",
                //  = \'{U}
                "\u00d9": "\u0055\u0300",
                //  = \`{U}
                "\u00dc": "\u0055\u0308",
                //  = \"{U}
                "\u01d7": "\u0055\u0308\u0301",
                //  = \"\'{U}
                "\u01db": "\u0055\u0308\u0300",
                //  = \"\`{U}
                "\u01d5": "\u0055\u0308\u0304",
                //  = \"\={U}
                "\u01d9": "\u0055\u0308\u030c",
                //  = \"\v{U}
                "\u0168": "\u0055\u0303",
                //  = \~{U}
                "\u1e78": "\u0055\u0303\u0301",
                //  = \~\'{U}
                "\u016a": "\u0055\u0304",
                //  = \={U}
                "\u1e7a": "\u0055\u0304\u0308",
                //  = \=\"{U}
                "\u016c": "\u0055\u0306",
                //  = \u{U}
                "\u01d3": "\u0055\u030c",
                //  = \v{U}
                "\u00db": "\u0055\u0302",
                //  = \^{U}
                "\u016e": "\u0055\u030a",
                //  = \r{U}
                "\u0170": "\u0055\u030b",
                //  = \H{U}
                "\u1e7c": "\u0056\u0303",
                //  = \~{V}
                "\u1e82": "\u0057\u0301",
                //  = \'{W}
                "\u1e80": "\u0057\u0300",
                //  = \`{W}
                "\u1e84": "\u0057\u0308",
                //  = \"{W}
                "\u0174": "\u0057\u0302",
                //  = \^{W}
                "\u1e86": "\u0057\u0307",
                //  = \.{W}
                "\u1e8c": "\u0058\u0308",
                //  = \"{X}
                "\u1e8a": "\u0058\u0307",
                //  = \.{X}
                "\u00dd": "\u0059\u0301",
                //  = \'{Y}
                "\u1ef2": "\u0059\u0300",
                //  = \`{Y}
                "\u0178": "\u0059\u0308",
                //  = \"{Y}
                "\u1ef8": "\u0059\u0303",
                //  = \~{Y}
                "\u0232": "\u0059\u0304",
                //  = \={Y}
                "\u0176": "\u0059\u0302",
                //  = \^{Y}
                "\u1e8e": "\u0059\u0307",
                //  = \.{Y}
                "\u0179": "\u005a\u0301",
                //  = \'{Z}
                "\u017d": "\u005a\u030c",
                //  = \v{Z}
                "\u1e90": "\u005a\u0302",
                //  = \^{Z}
                "\u017b": "\u005a\u0307",
                //  = \.{Z}
                "\u03ac": "\u03b1\u0301",
                //  = \'{}
                "\u1f70": "\u03b1\u0300",
                //  = \`{}
                "\u1fb1": "\u03b1\u0304",
                //  = \={}
                "\u1fb0": "\u03b1\u0306",
                //  = \u{}
                "\u03ad": "\u03b5\u0301",
                //  = \'{}
                "\u1f72": "\u03b5\u0300",
                //  = \`{}
                "\u03ae": "\u03b7\u0301",
                //  = \'{}
                "\u1f74": "\u03b7\u0300",
                //  = \`{}
                "\u03af": "\u03b9\u0301",
                //  = \'{}
                "\u1f76": "\u03b9\u0300",
                //  = \`{}
                "\u03ca": "\u03b9\u0308",
                //  = \"{}
                "\u0390": "\u03b9\u0308\u0301",
                //  = \"\'{}
                "\u1fd2": "\u03b9\u0308\u0300",
                //  = \"\`{}
                "\u1fd1": "\u03b9\u0304",
                //  = \={}
                "\u1fd0": "\u03b9\u0306",
                //  = \u{}
                "\u03cc": "\u03bf\u0301",
                //  = \'{}
                "\u1f78": "\u03bf\u0300",
                //  = \`{}
                "\u03cd": "\u03c5\u0301",
                //  = \'{}
                "\u1f7a": "\u03c5\u0300",
                //  = \`{}
                "\u03cb": "\u03c5\u0308",
                //  = \"{}
                "\u03b0": "\u03c5\u0308\u0301",
                //  = \"\'{}
                "\u1fe2": "\u03c5\u0308\u0300",
                //  = \"\`{}
                "\u1fe1": "\u03c5\u0304",
                //  = \={}
                "\u1fe0": "\u03c5\u0306",
                //  = \u{}
                "\u03ce": "\u03c9\u0301",
                //  = \'{}
                "\u1f7c": "\u03c9\u0300",
                //  = \`{}
                "\u038e": "\u03a5\u0301",
                //  = \'{}
                "\u1fea": "\u03a5\u0300",
                //  = \`{}
                "\u03ab": "\u03a5\u0308",
                //  = \"{}
                "\u1fe9": "\u03a5\u0304",
                //  = \={}
                "\u1fe8": "\u03a5\u0306",
                //  = \u{}
                "\u038f": "\u03a9\u0301",
                //  = \'{}
                "\u1ffa": "\u03a9\u0300" //  = \`{}
            };
            /* eslint no-constant-condition:0 */
            /**
             * This file contains the parser used to parse out a TeX expression from the
             * input. Since TeX isn't context-free, standard parsers don't work particularly
             * well.
             *
             * The strategy of this parser is as such:
             *
             * The main functions (the `.parse...` ones) take a position in the current
             * parse string to parse tokens from. The lexer (found in Lexer.js, stored at
             * this.gullet.lexer) also supports pulling out tokens at arbitrary places. When
             * individual tokens are needed at a position, the lexer is called to pull out a
             * token, which is then used.
             *
             * The parser has a property called "mode" indicating the mode that
             * the parser is currently in. Currently it has to be one of "math" or
             * "text", which denotes whether the current environment is a math-y
             * one or a text-y one (e.g. inside \text). Currently, this serves to
             * limit the functions which can be used in text mode.
             *
             * The main functions then return an object which contains the useful data that
             * was parsed at its given point, and a new position at the end of the parsed
             * data. The main functions can call each other and continue the parsing by
             * using the returned position as a new starting point.
             *
             * There are also extra `.handle...` functions, which pull out some reused
             * functionality into self-contained functions.
             *
             * The functions return ParseNodes.
             */
            Parser = class Parser {
                constructor(input, settings) {
                    this.mode = void 0;
                    this.gullet = void 0;
                    this.settings = void 0;
                    this.leftrightDepth = void 0;
                    this.nextToken = void 0;
                    // Start in math mode
                    this.mode = "math"; // Create a new macro expander (gullet) and (indirectly via that) also a
                    // new lexer (mouth) for this parser (stomach, in the language of TeX)
                    this.gullet = new MacroExpander(input, settings, this.mode); // Store the settings for use in parsing
                    this.settings = settings; // Count leftright depth (for \middle errors)
                    this.leftrightDepth = 0;
                }
                /**
                 * Checks a result to make sure it has the right type, and throws an
                 * appropriate error otherwise.
                 */
                expect(text, consume) {
                    if (consume === void 0) {
                        consume = true;
                    }
                    if (this.fetch().text !== text) {
                        throw new ParseError(`Expected '${text}', got '${this.fetch().text}'`, this.fetch());
                    }
                    if (consume) {
                        this.consume();
                    }
                }
                /**
                 * Discards the current lookahead token, considering it consumed.
                 */
                consume() {
                    this.nextToken = null;
                }
                /**
                 * Return the current lookahead token, or if there isn't one (at the
                 * beginning, or if the previous lookahead token was consume()d),
                 * fetch the next token as the new lookahead token and return it.
                 */
                fetch() {
                    if (this.nextToken == null) {
                        this.nextToken = this.gullet.expandNextToken();
                    }
                    return this.nextToken;
                }
                /**
                 * Switches between "text" and "math" modes.
                 */
                switchMode(newMode) {
                    this.mode = newMode;
                    this.gullet.switchMode(newMode);
                }
                /**
                 * Main parsing function, which parses an entire input.
                 */
                parse() {
                    // Create a group namespace for the math expression.
                    // (LaTeX creates a new group for every $...$, $$...$$, \[...\].)
                    this.gullet.beginGroup(); // Use old \color behavior (same as LaTeX's \textcolor) if requested.
                    // We do this within the group for the math expression, so it doesn't
                    // pollute settings.macros.
                    if (this.settings.colorIsTextColor) {
                        this.gullet.macros.set("\\color", "\\textcolor");
                    } // Try to parse the input
                    const parse = this.parseExpression(false); // If we succeeded, make sure there's an EOF at the end
                    this.expect("EOF"); // End the group namespace for the expression
                    this.gullet.endGroup();
                    return parse;
                }
                parseExpression(breakOnInfix, breakOnTokenText) {
                    const body = []; // Keep adding atoms to the body until we can't parse any more atoms (either
                    // we reached the end, a }, or a \right)
                    while (true) {
                        // Ignore spaces in math mode
                        if (this.mode === "math") {
                            this.consumeSpaces();
                        }
                        const lex = this.fetch();
                        if (Parser.endOfExpression.indexOf(lex.text) !== -1) {
                            break;
                        }
                        if (breakOnTokenText && lex.text === breakOnTokenText) {
                            break;
                        }
                        if (breakOnInfix && functions[lex.text] && functions[lex.text].infix) {
                            break;
                        }
                        const atom = this.parseAtom(breakOnTokenText);
                        if (!atom) {
                            break;
                        }
                        body.push(atom);
                    }
                    if (this.mode === "text") {
                        this.formLigatures(body);
                    }
                    return this.handleInfixNodes(body);
                }
                /**
                 * Rewrites infix operators such as \over with corresponding commands such
                 * as \frac.
                 *
                 * There can only be one infix operator per group.  If there's more than one
                 * then the expression is ambiguous.  This can be resolved by adding {}.
                 */
                handleInfixNodes(body) {
                    let overIndex = -1;
                    let funcName;
                    for (let i = 0; i < body.length; i++) {
                        const node = checkNodeType(body[i], "infix");
                        if (node) {
                            if (overIndex !== -1) {
                                throw new ParseError("only one infix operator per group", node.token);
                            }
                            overIndex = i;
                            funcName = node.replaceWith;
                        }
                    }
                    if (overIndex !== -1 && funcName) {
                        let numerNode;
                        let denomNode;
                        const numerBody = body.slice(0, overIndex);
                        const denomBody = body.slice(overIndex + 1);
                        if (numerBody.length === 1 && numerBody[0].type === "ordgroup") {
                            numerNode = numerBody[0];
                        }
                        else {
                            numerNode = {
                                type: "ordgroup",
                                mode: this.mode,
                                body: numerBody
                            };
                        }
                        if (denomBody.length === 1 && denomBody[0].type === "ordgroup") {
                            denomNode = denomBody[0];
                        }
                        else {
                            denomNode = {
                                type: "ordgroup",
                                mode: this.mode,
                                body: denomBody
                            };
                        }
                        let node;
                        if (funcName === "\\\\abovefrac") {
                            node = this.callFunction(funcName, [numerNode, body[overIndex], denomNode], []);
                        }
                        else {
                            node = this.callFunction(funcName, [numerNode, denomNode], []);
                        }
                        return [node];
                    }
                    else {
                        return body;
                    }
                } // The greediness of a superscript or subscript
                /**
                 * Handle a subscript or superscript with nice errors.
                 */
                handleSupSubscript(name) {
                    const symbolToken = this.fetch();
                    const symbol = symbolToken.text;
                    this.consume();
                    const group = this.parseGroup(name, false, Parser.SUPSUB_GREEDINESS, undefined, undefined, true); // ignore spaces before sup/subscript argument
                    if (!group) {
                        throw new ParseError("Expected group after '" + symbol + "'", symbolToken);
                    }
                    return group;
                }
                /**
                 * Converts the textual input of an unsupported command into a text node
                 * contained within a color node whose color is determined by errorColor
                 */
                formatUnsupportedCmd(text) {
                    const textordArray = [];
                    for (let i = 0; i < text.length; i++) {
                        textordArray.push({
                            type: "textord",
                            mode: "text",
                            text: text[i]
                        });
                    }
                    const textNode = {
                        type: "text",
                        mode: this.mode,
                        body: textordArray
                    };
                    const colorNode = {
                        type: "color",
                        mode: this.mode,
                        color: this.settings.errorColor,
                        body: [textNode]
                    };
                    return colorNode;
                }
                /**
                 * Parses a group with optional super/subscripts.
                 */
                parseAtom(breakOnTokenText) {
                    // The body of an atom is an implicit group, so that things like
                    // \left(x\right)^2 work correctly.
                    const base = this.parseGroup("atom", false, null, breakOnTokenText); // In text mode, we don't have superscripts or subscripts
                    if (this.mode === "text") {
                        return base;
                    } // Note that base may be empty (i.e. null) at this point.
                    let superscript;
                    let subscript;
                    while (true) {
                        // Guaranteed in math mode, so eat any spaces first.
                        this.consumeSpaces(); // Lex the first token
                        const lex = this.fetch();
                        if (lex.text === "\\limits" || lex.text === "\\nolimits") {
                            // We got a limit control
                            let opNode = checkNodeType(base, "op");
                            if (opNode) {
                                const limits = lex.text === "\\limits";
                                opNode.limits = limits;
                                opNode.alwaysHandleSupSub = true;
                            }
                            else {
                                opNode = checkNodeType(base, "operatorname");
                                if (opNode && opNode.alwaysHandleSupSub) {
                                    const limits = lex.text === "\\limits";
                                    opNode.limits = limits;
                                }
                                else {
                                    throw new ParseError("Limit controls must follow a math operator", lex);
                                }
                            }
                            this.consume();
                        }
                        else if (lex.text === "^") {
                            // We got a superscript start
                            if (superscript) {
                                throw new ParseError("Double superscript", lex);
                            }
                            superscript = this.handleSupSubscript("superscript");
                        }
                        else if (lex.text === "_") {
                            // We got a subscript start
                            if (subscript) {
                                throw new ParseError("Double subscript", lex);
                            }
                            subscript = this.handleSupSubscript("subscript");
                        }
                        else if (lex.text === "'") {
                            // We got a prime
                            if (superscript) {
                                throw new ParseError("Double superscript", lex);
                            }
                            const prime = {
                                type: "textord",
                                mode: this.mode,
                                text: "\\prime"
                            }; // Many primes can be grouped together, so we handle this here
                            const primes = [prime];
                            this.consume(); // Keep lexing tokens until we get something that's not a prime
                            while (this.fetch().text === "'") {
                                // For each one, add another prime to the list
                                primes.push(prime);
                                this.consume();
                            } // If there's a superscript following the primes, combine that
                            // superscript in with the primes.
                            if (this.fetch().text === "^") {
                                primes.push(this.handleSupSubscript("superscript"));
                            } // Put everything into an ordgroup as the superscript
                            superscript = {
                                type: "ordgroup",
                                mode: this.mode,
                                body: primes
                            };
                        }
                        else {
                            // If it wasn't ^, _, or ', stop parsing super/subscripts
                            break;
                        }
                    } // Base must be set if superscript or subscript are set per logic above,
                    // but need to check here for type check to pass.
                    if (superscript || subscript) {
                        // If we got either a superscript or subscript, create a supsub
                        return {
                            type: "supsub",
                            mode: this.mode,
                            base: base,
                            sup: superscript,
                            sub: subscript
                        };
                    }
                    else {
                        // Otherwise return the original body
                        return base;
                    }
                }
                /**
                 * Parses an entire function, including its base and all of its arguments.
                 */
                parseFunction(breakOnTokenText, name, // For error reporting.
                greediness) {
                    const token = this.fetch();
                    const func = token.text;
                    const funcData = functions[func];
                    if (!funcData) {
                        return null;
                    }
                    this.consume(); // consume command token
                    if (greediness != null && funcData.greediness <= greediness) {
                        throw new ParseError("Got function '" + func + "' with no arguments" + (name ? " as " + name : ""), token);
                    }
                    else if (this.mode === "text" && !funcData.allowedInText) {
                        throw new ParseError("Can't use function '" + func + "' in text mode", token);
                    }
                    else if (this.mode === "math" && funcData.allowedInMath === false) {
                        throw new ParseError("Can't use function '" + func + "' in math mode", token);
                    }
                    const _this$parseArguments = this.parseArguments(func, funcData), args = _this$parseArguments.args, optArgs = _this$parseArguments.optArgs;
                    return this.callFunction(func, args, optArgs, token, breakOnTokenText);
                }
                /**
                 * Call a function handler with a suitable context and arguments.
                 */
                callFunction(name, args, optArgs, token, breakOnTokenText) {
                    const context = {
                        funcName: name,
                        parser: this,
                        token,
                        breakOnTokenText
                    };
                    const func = functions[name];
                    if (func && func.handler) {
                        return func.handler(context, args, optArgs);
                    }
                    else {
                        throw new ParseError(`No function handler for ${name}`);
                    }
                }
                /**
                 * Parses the arguments of a function or environment
                 */
                parseArguments(func, // Should look like "\name" or "\begin{name}".
                funcData) {
                    const totalArgs = funcData.numArgs + funcData.numOptionalArgs;
                    if (totalArgs === 0) {
                        return {
                            args: [],
                            optArgs: []
                        };
                    }
                    const baseGreediness = funcData.greediness;
                    const args = [];
                    const optArgs = [];
                    for (let i = 0; i < totalArgs; i++) {
                        const argType = funcData.argTypes && funcData.argTypes[i];
                        const isOptional = i < funcData.numOptionalArgs; // Ignore spaces between arguments.  As the TeXbook says:
                        // "After you have said \def\row#1#2{...}, you are allowed to
                        //  put spaces between the arguments (e.g., \row x n), because
                        //  TeX doesnt use single spaces as undelimited arguments."
                        const consumeSpaces = i > 0 && !isOptional || // Also consume leading spaces in math mode, as parseSymbol
                            // won't know what to do with them.  This can only happen with
                            // macros, e.g. \frac\foo\foo where \foo expands to a space symbol.
                            // In LaTeX, the \foo's get treated as (blank) arguments.
                            // In KaTeX, for now, both spaces will get consumed.
                            // TODO(edemaine)
                            i === 0 && !isOptional && this.mode === "math";
                        const arg = this.parseGroupOfType(`argument to '${func}'`, argType, isOptional, baseGreediness, consumeSpaces);
                        if (!arg) {
                            if (isOptional) {
                                optArgs.push(null);
                                continue;
                            }
                            throw new ParseError(`Expected group after '${func}'`, this.fetch());
                        }
                        (isOptional ? optArgs : args).push(arg);
                    }
                    return {
                        args,
                        optArgs
                    };
                }
                /**
                 * Parses a group when the mode is changing.
                 */
                parseGroupOfType(name, type, optional, greediness, consumeSpaces) {
                    switch (type) {
                        case "color":
                            if (consumeSpaces) {
                                this.consumeSpaces();
                            }
                            return this.parseColorGroup(optional);
                        case "size":
                            if (consumeSpaces) {
                                this.consumeSpaces();
                            }
                            return this.parseSizeGroup(optional);
                        case "url":
                            return this.parseUrlGroup(optional, consumeSpaces);
                        case "math":
                        case "text":
                            return this.parseGroup(name, optional, greediness, undefined, type, consumeSpaces);
                        case "hbox":
                            {
                                // hbox argument type wraps the argument in the equivalent of
                                // \hbox, which is like \text but switching to \textstyle size.
                                const group = this.parseGroup(name, optional, greediness, undefined, "text", consumeSpaces);
                                if (!group) {
                                    return group;
                                }
                                const styledGroup = {
                                    type: "styling",
                                    mode: group.mode,
                                    body: [group],
                                    style: "text" // simulate \textstyle
                                };
                                return styledGroup;
                            }
                        case "raw":
                            {
                                if (consumeSpaces) {
                                    this.consumeSpaces();
                                }
                                if (optional && this.fetch().text === "{") {
                                    return null;
                                }
                                const token = this.parseStringGroup("raw", optional, true);
                                if (token) {
                                    return {
                                        type: "raw",
                                        mode: "text",
                                        string: token.text
                                    };
                                }
                                else {
                                    throw new ParseError("Expected raw group", this.fetch());
                                }
                            }
                        case "original":
                        case null:
                        case undefined:
                            return this.parseGroup(name, optional, greediness, undefined, undefined, consumeSpaces);
                        default:
                            throw new ParseError("Unknown group type as " + name, this.fetch());
                    }
                }
                /**
                 * Discard any space tokens, fetching the next non-space token.
                 */
                consumeSpaces() {
                    while (this.fetch().text === " ") {
                        this.consume();
                    }
                }
                /**
                 * Parses a group, essentially returning the string formed by the
                 * brace-enclosed tokens plus some position information.
                 */
                parseStringGroup(modeName, // Used to describe the mode in error messages.
                optional, raw) {
                    const groupBegin = optional ? "[" : "{";
                    const groupEnd = optional ? "]" : "}";
                    const beginToken = this.fetch();
                    if (beginToken.text !== groupBegin) {
                        if (optional) {
                            return null;
                        }
                        else if (raw && beginToken.text !== "EOF" && /[^{}[\]]/.test(beginToken.text)) {
                            this.consume();
                            return beginToken;
                        }
                    }
                    const outerMode = this.mode;
                    this.mode = "text";
                    this.expect(groupBegin);
                    let str = "";
                    const firstToken = this.fetch();
                    let nested = 0; // allow nested braces in raw string group
                    let lastToken = firstToken;
                    let nextToken;
                    while ((nextToken = this.fetch()).text !== groupEnd || raw && nested > 0) {
                        switch (nextToken.text) {
                            case "EOF":
                                throw new ParseError("Unexpected end of input in " + modeName, firstToken.range(lastToken, str));
                            case groupBegin:
                                nested++;
                                break;
                            case groupEnd:
                                nested--;
                                break;
                        }
                        lastToken = nextToken;
                        str += lastToken.text;
                        this.consume();
                    }
                    this.expect(groupEnd);
                    this.mode = outerMode;
                    return firstToken.range(lastToken, str);
                }
                /**
                 * Parses a regex-delimited group: the largest sequence of tokens
                 * whose concatenated strings match `regex`. Returns the string
                 * formed by the tokens plus some position information.
                 */
                parseRegexGroup(regex, modeName) {
                    const outerMode = this.mode;
                    this.mode = "text";
                    const firstToken = this.fetch();
                    let lastToken = firstToken;
                    let str = "";
                    let nextToken;
                    while ((nextToken = this.fetch()).text !== "EOF" && regex.test(str + nextToken.text)) {
                        lastToken = nextToken;
                        str += lastToken.text;
                        this.consume();
                    }
                    if (str === "") {
                        throw new ParseError("Invalid " + modeName + ": '" + firstToken.text + "'", firstToken);
                    }
                    this.mode = outerMode;
                    return firstToken.range(lastToken, str);
                }
                /**
                 * Parses a color description.
                 */
                parseColorGroup(optional) {
                    const res = this.parseStringGroup("color", optional);
                    if (!res) {
                        return null;
                    }
                    const match = /^(#[a-f0-9]{3}|#?[a-f0-9]{6}|[a-z]+)$/i.exec(res.text);
                    if (!match) {
                        throw new ParseError("Invalid color: '" + res.text + "'", res);
                    }
                    let color = match[0];
                    if (/^[0-9a-f]{6}$/i.test(color)) {
                        // We allow a 6-digit HTML color spec without a leading "#".
                        // This follows the xcolor package's HTML color model.
                        // Predefined color names are all missed by this RegEx pattern.
                        color = "#" + color;
                    }
                    return {
                        type: "color-token",
                        mode: this.mode,
                        color
                    };
                }
                /**
                 * Parses a size specification, consisting of magnitude and unit.
                 */
                parseSizeGroup(optional) {
                    let res;
                    let isBlank = false;
                    if (!optional && this.fetch().text !== "{") {
                        res = this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/, "size");
                    }
                    else {
                        res = this.parseStringGroup("size", optional);
                    }
                    if (!res) {
                        return null;
                    }
                    if (!optional && res.text.length === 0) {
                        // Because we've tested for what is !optional, this block won't
                        // affect \kern, \hspace, etc. It will capture the mandatory arguments
                        // to \genfrac and \above.
                        res.text = "0pt"; // Enable \above{}
                        isBlank = true; // This is here specifically for \genfrac
                    }
                    const match = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(res.text);
                    if (!match) {
                        throw new ParseError("Invalid size: '" + res.text + "'", res);
                    }
                    const data = {
                        number: +(match[1] + match[2]),
                        // sign + magnitude, cast to number
                        unit: match[3]
                    };
                    if (!validUnit(data)) {
                        throw new ParseError("Invalid unit: '" + data.unit + "'", res);
                    }
                    return {
                        type: "size",
                        mode: this.mode,
                        value: data,
                        isBlank
                    };
                }
                /**
                 * Parses an URL, checking escaped letters and allowed protocols,
                 * and setting the catcode of % as an active character (as in \hyperref).
                 */
                parseUrlGroup(optional, consumeSpaces) {
                    this.gullet.lexer.setCatcode("%", 13); // active character
                    const res = this.parseStringGroup("url", optional, true); // get raw string
                    this.gullet.lexer.setCatcode("%", 14); // comment character
                    if (!res) {
                        return null;
                    } // hyperref package allows backslashes alone in href, but doesn't
                    // generate valid links in such cases; we interpret this as
                    // "undefined" behaviour, and keep them as-is. Some browser will
                    // replace backslashes with forward slashes.
                    const url = res.text.replace(/\\([#$%&~_^{}])/g, '$1');
                    return {
                        type: "url",
                        mode: this.mode,
                        url
                    };
                }
                /**
                 * If `optional` is false or absent, this parses an ordinary group,
                 * which is either a single nucleus (like "x") or an expression
                 * in braces (like "{x+y}") or an implicit group, a group that starts
                 * at the current position, and ends right before a higher explicit
                 * group ends, or at EOF.
                 * If `optional` is true, it parses either a bracket-delimited expression
                 * (like "[x+y]") or returns null to indicate the absence of a
                 * bracket-enclosed group.
                 * If `mode` is present, switches to that mode while parsing the group,
                 * and switches back after.
                 */
                parseGroup(name, // For error reporting.
                optional, greediness, breakOnTokenText, mode, consumeSpaces) {
                    // Switch to specified mode
                    const outerMode = this.mode;
                    if (mode) {
                        this.switchMode(mode);
                    } // Consume spaces if requested, crucially *after* we switch modes,
                    // so that the next non-space token is parsed in the correct mode.
                    if (consumeSpaces) {
                        this.consumeSpaces();
                    } // Get first token
                    const firstToken = this.fetch();
                    const text = firstToken.text;
                    let result; // Try to parse an open brace or \begingroup
                    if (optional ? text === "[" : text === "{" || text === "\\begingroup") {
                        this.consume();
                        const groupEnd = Parser.endOfGroup[text]; // Start a new group namespace
                        this.gullet.beginGroup(); // If we get a brace, parse an expression
                        const expression = this.parseExpression(false, groupEnd);
                        const lastToken = this.fetch(); // Check that we got a matching closing brace
                        this.expect(groupEnd); // End group namespace
                        this.gullet.endGroup();
                        result = {
                            type: "ordgroup",
                            mode: this.mode,
                            loc: SourceLocation.range(firstToken, lastToken),
                            body: expression,
                            // A group formed by \begingroup...\endgroup is a semi-simple group
                            // which doesn't affect spacing in math mode, i.e., is transparent.
                            // https://tex.stackexchange.com/questions/1930/when-should-one-
                            // use-begingroup-instead-of-bgroup
                            semisimple: text === "\\begingroup" || undefined
                        };
                    }
                    else if (optional) {
                        // Return nothing for an optional group
                        result = null;
                    }
                    else {
                        // If there exists a function with this name, parse the function.
                        // Otherwise, just return a nucleus
                        result = this.parseFunction(breakOnTokenText, name, greediness) || this.parseSymbol();
                        if (result == null && text[0] === "\\" && !implicitCommands.hasOwnProperty(text)) {
                            if (this.settings.throwOnError) {
                                throw new ParseError("Undefined control sequence: " + text, firstToken);
                            }
                            result = this.formatUnsupportedCmd(text);
                            this.consume();
                        }
                    } // Switch mode back
                    if (mode) {
                        this.switchMode(outerMode);
                    }
                    return result;
                }
                /**
                 * Form ligature-like combinations of characters for text mode.
                 * This includes inputs like "--", "---", "``" and "''".
                 * The result will simply replace multiple textord nodes with a single
                 * character in each value by a single textord node having multiple
                 * characters in its value.  The representation is still ASCII source.
                 * The group will be modified in place.
                 */
                formLigatures(group) {
                    let n = group.length - 1;
                    for (let i = 0; i < n; ++i) {
                        const a = group[i]; // $FlowFixMe: Not every node type has a `text` property.
                        const v = a.text;
                        if (v === "-" && group[i + 1].text === "-") {
                            if (i + 1 < n && group[i + 2].text === "-") {
                                group.splice(i, 3, {
                                    type: "textord",
                                    mode: "text",
                                    loc: SourceLocation.range(a, group[i + 2]),
                                    text: "---"
                                });
                                n -= 2;
                            }
                            else {
                                group.splice(i, 2, {
                                    type: "textord",
                                    mode: "text",
                                    loc: SourceLocation.range(a, group[i + 1]),
                                    text: "--"
                                });
                                n -= 1;
                            }
                        }
                        if ((v === "'" || v === "`") && group[i + 1].text === v) {
                            group.splice(i, 2, {
                                type: "textord",
                                mode: "text",
                                loc: SourceLocation.range(a, group[i + 1]),
                                text: v + v
                            });
                            n -= 1;
                        }
                    }
                }
                /**
                 * Parse a single symbol out of the string. Here, we handle single character
                 * symbols and special functions like \verb.
                 */
                parseSymbol() {
                    const nucleus = this.fetch();
                    let text = nucleus.text;
                    if (/^\\verb[^a-zA-Z]/.test(text)) {
                        this.consume();
                        let arg = text.slice(5);
                        const star = arg.charAt(0) === "*";
                        if (star) {
                            arg = arg.slice(1);
                        } // Lexer's tokenRegex is constructed to always have matching
                        // first/last characters.
                        if (arg.length < 2 || arg.charAt(0) !== arg.slice(-1)) {
                            throw new ParseError(`\\verb assertion failed --
                    please report what input caused this bug`);
                        }
                        arg = arg.slice(1, -1); // remove first and last char
                        return {
                            type: "verb",
                            mode: "text",
                            body: arg,
                            star
                        };
                    } // At this point, we should have a symbol, possibly with accents.
                    // First expand any accented base symbol according to unicodeSymbols.
                    if (unicodeSymbols.hasOwnProperty(text[0]) && !symbols[this.mode][text[0]]) {
                        // This behavior is not strict (XeTeX-compatible) in math mode.
                        if (this.settings.strict && this.mode === "math") {
                            this.settings.reportNonstrict("unicodeTextInMathMode", `Accented Unicode text character "${text[0]}" used in ` + `math mode`, nucleus);
                        }
                        text = unicodeSymbols[text[0]] + text.substr(1);
                    } // Strip off any combining characters
                    const match = combiningDiacriticalMarksEndRegex.exec(text);
                    if (match) {
                        text = text.substring(0, match.index);
                        if (text === 'i') {
                            text = '\u0131'; // dotless i, in math and text mode
                        }
                        else if (text === 'j') {
                            text = '\u0237'; // dotless j, in math and text mode
                        }
                    } // Recognize base symbol
                    let symbol;
                    if (symbols[this.mode][text]) {
                        if (this.settings.strict && this.mode === 'math' && extraLatin.indexOf(text) >= 0) {
                            this.settings.reportNonstrict("unicodeTextInMathMode", `Latin-1/Unicode text character "${text[0]}" used in ` + `math mode`, nucleus);
                        }
                        const group = symbols[this.mode][text].group;
                        const loc = SourceLocation.range(nucleus);
                        let s;
                        if (ATOMS.hasOwnProperty(group)) {
                            // $FlowFixMe
                            const family = group;
                            s = {
                                type: "atom",
                                mode: this.mode,
                                family,
                                loc,
                                text
                            };
                        }
                        else {
                            // $FlowFixMe
                            s = {
                                type: group,
                                mode: this.mode,
                                loc,
                                text
                            };
                        }
                        symbol = s;
                    }
                    else if (text.charCodeAt(0) >= 0x80) {
                        // no symbol for e.g. ^
                        if (this.settings.strict) {
                            if (!supportedCodepoint(text.charCodeAt(0))) {
                                this.settings.reportNonstrict("unknownSymbol", `Unrecognized Unicode character "${text[0]}"` + ` (${text.charCodeAt(0)})`, nucleus);
                            }
                            else if (this.mode === "math") {
                                this.settings.reportNonstrict("unicodeTextInMathMode", `Unicode text character "${text[0]}" used in math mode`, nucleus);
                            }
                        } // All nonmathematical Unicode characters are rendered as if they
                        // are in text mode (wrapped in \text) because that's what it
                        // takes to render them in LaTeX.  Setting `mode: this.mode` is
                        // another natural choice (the user requested math mode), but
                        // this makes it more difficult for getCharacterMetrics() to
                        // distinguish Unicode characters without metrics and those for
                        // which we want to simulate the letter M.
                        symbol = {
                            type: "textord",
                            mode: "text",
                            loc: SourceLocation.range(nucleus),
                            text
                        };
                    }
                    else {
                        return null; // EOF, ^, _, {, }, etc.
                    }
                    this.consume(); // Transform combining characters into accents
                    if (match) {
                        for (let i = 0; i < match[0].length; i++) {
                            const accent = match[0][i];
                            if (!unicodeAccents[accent]) {
                                throw new ParseError(`Unknown accent ' ${accent}'`, nucleus);
                            }
                            const command = unicodeAccents[accent][this.mode];
                            if (!command) {
                                throw new ParseError(`Accent ${accent} unsupported in ${this.mode} mode`, nucleus);
                            }
                            symbol = {
                                type: "accent",
                                mode: this.mode,
                                loc: SourceLocation.range(nucleus),
                                label: command,
                                isStretchy: false,
                                isShifty: true,
                                base: symbol
                            };
                        }
                    }
                    return symbol;
                }
            };
            Parser.endOfExpression = ["}", "\\endgroup", "\\end", "\\right", "&"];
            Parser.endOfGroup = {
                "[": "]",
                "{": "}",
                "\\begingroup": "\\endgroup"
                /**
                 * Parses an "expression", which is a list of atoms.
                 *
                 * `breakOnInfix`: Should the parsing stop when we hit infix nodes? This
                 *                 happens when functions have higher precendence han infix
                 *                 nodes in implicit parses.
                 *
                 * `breakOnTokenText`: The text of the token that the expression should end
                 *                     with, or `null` if something else should end the
                 *                     expression.
                 */
            };
            Parser.SUPSUB_GREEDINESS = 1;
            /**
             * Provides a single function for parsing an expression using a Parser
             * TODO(emily): Remove this
             */
            /**
             * Parses an expression using a Parser, then returns the parsed result.
             */
            parseTree = function parseTree(toParse, settings) {
                if (!(typeof toParse === 'string' || toParse instanceof String)) {
                    throw new TypeError('KaTeX can only parse string typed expression');
                }
                const parser = new Parser(toParse, settings); // Blank out any \df@tag to avoid spurious "Duplicate \tag" errors
                delete parser.gullet.macros.current["\\df@tag"];
                let tree = parser.parse(); // If the input used \tag, it will set the \df@tag macro to the tag.
                // In this case, we separately parse the tag and wrap the tree.
                if (parser.gullet.macros.get("\\df@tag")) {
                    if (!settings.displayMode) {
                        throw new ParseError("\\tag works only in display equations");
                    }
                    parser.gullet.feed("\\df@tag");
                    tree = [{
                            type: "tag",
                            mode: "text",
                            body: tree,
                            tag: parser.parse()
                        }];
                }
                return tree;
            };
            /* eslint no-console:0 */
            /**
             * Parse and build an expression, and place that expression in the DOM node
             * given.
             */
            render = function render(expression, baseNode, options) {
                baseNode.textContent = "";
                const node = renderToDomTree(expression, options).toNode();
                baseNode.appendChild(node);
            }; // KaTeX's styles don't work properly in quirks mode. Print out an error, and
            // disable rendering.
            if (typeof document !== "undefined") {
                if (document.compatMode !== "CSS1Compat") {
                    typeof console !== "undefined" && console.warn("Warning: KaTeX doesn't work in quirks mode. Make sure your " + "website has a suitable doctype.");
                    render = function render() {
                        throw new ParseError("KaTeX doesn't work in quirks mode.");
                    };
                }
            }
            /**
             * Parse and build an expression, and return the markup for that.
             */
            renderToString = function renderToString(expression, options) {
                const markup = renderToDomTree(expression, options).toMarkup();
                return markup;
            };
            /**
             * Parse an expression and return the parse tree.
             */
            generateParseTree = function generateParseTree(expression, options) {
                const settings = new Settings(options);
                return parseTree(expression, settings);
            };
            /**
             * If the given error is a KaTeX ParseError and options.throwOnError is false,
             * renders the invalid LaTeX as a span with hover title giving the KaTeX
             * error message.  Otherwise, simply throws the error.
             */
            renderError = function renderError(error, expression, options) {
                if (options.throwOnError || !(error instanceof ParseError)) {
                    throw error;
                }
                const node = buildCommon.makeSpan(["katex-error"], [new SymbolNode(expression)]);
                node.setAttribute("title", error.toString());
                node.setAttribute("style", `color:${options.errorColor}`);
                return node;
            };
            /**
             * Generates and returns the katex build tree. This is used for advanced
             * use cases (like rendering to custom output).
             */
            renderToDomTree = function renderToDomTree(expression, options) {
                const settings = new Settings(options);
                try {
                    const tree = parseTree(expression, settings);
                    return buildTree(tree, expression, settings);
                }
                catch (error) {
                    return renderError(error, expression, settings);
                }
            };
            /**
             * Generates and returns the katex build tree, with just HTML (no MathML).
             * This is used for advanced use cases (like rendering to custom output).
             */
            renderToHTMLTree = function renderToHTMLTree(expression, options) {
                const settings = new Settings(options);
                try {
                    const tree = parseTree(expression, settings);
                    return buildHTMLTree(tree, expression, settings);
                }
                catch (error) {
                    return renderError(error, expression, settings);
                }
            };
            katex = {
                /**
                 * Current KaTeX version
                 */
                version: "0.11.1",
                /**
                 * Renders the given LaTeX into an HTML+MathML combination, and adds
                 * it as a child to the specified DOM node.
                 */
                render,
                /**
                 * Renders the given LaTeX into an HTML+MathML combination string,
                 * for sending to the client.
                 */
                renderToString,
                /**
                 * KaTeX error, usually during parsing.
                 */
                ParseError,
                /**
                 * Parses the given LaTeX into KaTeX's internal parse tree structure,
                 * without rendering to HTML or MathML.
                 *
                 * NOTE: This method is not currently recommended for public use.
                 * The internal tree representation is unstable and is very likely
                 * to change. Use at your own risk.
                 */
                __parse: generateParseTree,
                /**
                 * Renders the given LaTeX into an HTML+MathML internal DOM tree
                 * representation, without flattening that representation to a string.
                 *
                 * NOTE: This method is not currently recommended for public use.
                 * The internal tree representation is unstable and is very likely
                 * to change. Use at your own risk.
                 */
                __renderToDomTree: renderToDomTree,
                /**
                 * Renders the given LaTeX into an HTML internal DOM tree representation,
                 * without MathML and without flattening that representation to a string.
                 *
                 * NOTE: This method is not currently recommended for public use.
                 * The internal tree representation is unstable and is very likely
                 * to change. Use at your own risk.
                 */
                __renderToHTMLTree: renderToHTMLTree,
                /**
                 * extends internal font metrics object with a new object
                 * each key in the new object represents a font name
                */
                __setFontMetrics: setFontMetrics,
                /**
                 * adds a new symbol to builtin symbols table
                 */
                __defineSymbol: defineSymbol,
                /**
                 * adds a new macro to builtin macro list
                 */
                __defineMacro: defineMacro,
                /**
                 * Expose the dom tree node types, which can be useful for type checking nodes.
                 *
                 * NOTE: This method is not currently recommended for public use.
                 * The internal tree representation is unstable and is very likely
                 * to change. Use at your own risk.
                 */
                __domTree: {
                    Span,
                    Anchor,
                    SymbolNode,
                    SvgNode,
                    PathNode,
                    LineNode
                }
            };
            exports_32("default", katex);
        }
    };
});
System.register("http://localhost:5501/src/deps/katex", ["https://unpkg.com/katex@0.11.1/dist/katex.mjs"], function (exports_33, context_33) {
    "use strict";
    var k, katex;
    var __moduleName = context_33 && context_33.id;
    return {
        setters: [
            function (k_1) {
                k = k_1;
            }
        ],
        execute: function () {
            katex = k.default;
            exports_33("katex", katex);
        }
    };
});
System.register("http://localhost:5501/src/components/FMath", ["http://localhost:5501/src/deps/vue", "http://localhost:5501/src/deps/katex"], function (exports_34, context_34) {
    "use strict";
    var vue_js_14, katex_js_1, FMath;
    var __moduleName = context_34 && context_34.id;
    return {
        setters: [
            function (vue_js_14_1) {
                vue_js_14 = vue_js_14_1;
            },
            function (katex_js_1_1) {
                katex_js_1 = katex_js_1_1;
            }
        ],
        execute: function () {
            exports_34("FMath", FMath = {
                setup(_, { slots }) {
                    const math = vue_js_14.ref("");
                    vue_js_14.watch(() => slots.default(), nodes => {
                        const node = nodes[0].children;
                        math.value = katex_js_1.katex.renderToString(String.raw `${node}`, {
                            throwOnError: false
                        });
                    });
                    return { math };
                },
                template: `<div style="margin-bottom: var(--base)" v-html="math" />`,
                css: /*css */ `
  @import url('https://unpkg.com/katex@0.11.1/dist/katex.min.css');
  `
            });
        }
    };
});
System.register("http://localhost:5501/src/components/FSceneSvg", ["http://localhost:5501/src/deps/vue", "http://localhost:5501/src/internals/size"], function (exports_35, context_35) {
    "use strict";
    var vue_js_15, size_js_2, FSceneSvg;
    var __moduleName = context_35 && context_35.id;
    return {
        setters: [
            function (vue_js_15_1) {
                vue_js_15 = vue_js_15_1;
            },
            function (size_js_2_1) {
                size_js_2 = size_js_2_1;
            }
        ],
        execute: function () {
            exports_35("FSceneSvg", FSceneSvg = {
                props: { ...size_js_2.sizeProps },
                setup(props) {
                    const el = vue_js_15.ref(null);
                    const { width, height, viewBox } = size_js_2.useSize(props);
                    const unit = vue_js_15.computed(() => 1);
                    const sceneContext = vue_js_15.inject("sceneContext");
                    sceneContext.unit = unit;
                    return { el, width, height, viewBox };
                },
                template: `<div ref="el">
    <svg
      :width="width"
      :height="width"
      :view-box.camel="viewBox"
      style="border: 1px solid red;"
    >
      <slot />
    </svg>
  </div>
  `
            });
        }
    };
});
System.register("http://localhost:5501/src/components/FSceneCanvas", ["http://localhost:5501/src/deps/vue", "http://localhost:5501/src/internals/size"], function (exports_36, context_36) {
    "use strict";
    var vue_js_16, size_js_3, FSceneCanvas;
    var __moduleName = context_36 && context_36.id;
    return {
        setters: [
            function (vue_js_16_1) {
                vue_js_16 = vue_js_16_1;
            },
            function (size_js_3_1) {
                size_js_3 = size_js_3_1;
            }
        ],
        execute: function () {
            exports_36("FSceneCanvas", FSceneCanvas = {
                props: { ...size_js_3.sizeProps },
                setup(props) {
                    const el = vue_js_16.ref(null);
                    const ctx = vue_js_16.ref(null);
                    const { width, height } = size_js_3.useSize(props);
                    const sceneContext = vue_js_16.inject("sceneContext");
                    sceneContext.width = width;
                    sceneContext.height = height;
                    sceneContext.ctx = ctx;
                    vue_js_16.onMounted(() => {
                        const canvas = el.value;
                        canvas.width = width.value;
                        canvas.height = height.value;
                        sceneContext.ctx.value = canvas.getContext("2d");
                    });
                    vue_js_16.onBeforeUpdate(() => {
                        sceneContext.ctx.value.clearRect(0, 0, width.value, height.value);
                    });
                    return { el };
                },
                template: `
  <canvas ref="el" style="border: 1px solid red;">
    <slot />
  </canvas>
  `
            });
        }
    };
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author julianwa / https://github.com/julianwa
 */
System.register("https://unpkg.com/three@0.113.2/examples/jsm/renderers/Projector", ["https://unpkg.com/three@0.113.2/build/three.module"], function (exports_37, context_37) {
    "use strict";
    var three_module_js_2, RenderableObject, RenderableFace, RenderableVertex, RenderableLine, RenderableSprite, Projector;
    var __moduleName = context_37 && context_37.id;
    return {
        setters: [
            function (three_module_js_2_1) {
                three_module_js_2 = three_module_js_2_1;
            }
        ],
        execute: function () {
            RenderableObject = function () {
                this.id = 0;
                this.object = null;
                this.z = 0;
                this.renderOrder = 0;
            };
            exports_37("RenderableObject", RenderableObject);
            //
            RenderableFace = function () {
                this.id = 0;
                this.v1 = new RenderableVertex();
                this.v2 = new RenderableVertex();
                this.v3 = new RenderableVertex();
                this.normalModel = new three_module_js_2.Vector3();
                this.vertexNormalsModel = [new three_module_js_2.Vector3(), new three_module_js_2.Vector3(), new three_module_js_2.Vector3()];
                this.vertexNormalsLength = 0;
                this.color = new three_module_js_2.Color();
                this.material = null;
                this.uvs = [new three_module_js_2.Vector2(), new three_module_js_2.Vector2(), new three_module_js_2.Vector2()];
                this.z = 0;
                this.renderOrder = 0;
            };
            exports_37("RenderableFace", RenderableFace);
            //
            RenderableVertex = function () {
                this.position = new three_module_js_2.Vector3();
                this.positionWorld = new three_module_js_2.Vector3();
                this.positionScreen = new three_module_js_2.Vector4();
                this.visible = true;
            };
            exports_37("RenderableVertex", RenderableVertex);
            RenderableVertex.prototype.copy = function (vertex) {
                this.positionWorld.copy(vertex.positionWorld);
                this.positionScreen.copy(vertex.positionScreen);
            };
            //
            RenderableLine = function () {
                this.id = 0;
                this.v1 = new RenderableVertex();
                this.v2 = new RenderableVertex();
                this.vertexColors = [new three_module_js_2.Color(), new three_module_js_2.Color()];
                this.material = null;
                this.z = 0;
                this.renderOrder = 0;
            };
            exports_37("RenderableLine", RenderableLine);
            //
            RenderableSprite = function () {
                this.id = 0;
                this.object = null;
                this.x = 0;
                this.y = 0;
                this.z = 0;
                this.rotation = 0;
                this.scale = new three_module_js_2.Vector2();
                this.material = null;
                this.renderOrder = 0;
            };
            exports_37("RenderableSprite", RenderableSprite);
            //
            Projector = function () {
                var _object, _objectCount, _objectPool = [], _objectPoolLength = 0, _vertex, _vertexCount, _vertexPool = [], _vertexPoolLength = 0, _face, _faceCount, _facePool = [], _facePoolLength = 0, _line, _lineCount, _linePool = [], _linePoolLength = 0, _sprite, _spriteCount, _spritePool = [], _spritePoolLength = 0, _renderData = { objects: [], lights: [], elements: [] }, _vector3 = new three_module_js_2.Vector3(), _vector4 = new three_module_js_2.Vector4(), _clipBox = new three_module_js_2.Box3(new three_module_js_2.Vector3(-1, -1, -1), new three_module_js_2.Vector3(1, 1, 1)), _boundingBox = new three_module_js_2.Box3(), _points3 = new Array(3), _viewMatrix = new three_module_js_2.Matrix4(), _viewProjectionMatrix = new three_module_js_2.Matrix4(), _modelMatrix, _modelViewProjectionMatrix = new three_module_js_2.Matrix4(), _normalMatrix = new three_module_js_2.Matrix3(), _frustum = new three_module_js_2.Frustum(), _clippedVertex1PositionScreen = new three_module_js_2.Vector4(), _clippedVertex2PositionScreen = new three_module_js_2.Vector4();
                //
                this.projectVector = function (vector, camera) {
                    console.warn('THREE.Projector: .projectVector() is now vector.project().');
                    vector.project(camera);
                };
                this.unprojectVector = function (vector, camera) {
                    console.warn('THREE.Projector: .unprojectVector() is now vector.unproject().');
                    vector.unproject(camera);
                };
                this.pickingRay = function () {
                    console.error('THREE.Projector: .pickingRay() is now raycaster.setFromCamera().');
                };
                //
                var RenderList = function () {
                    var normals = [];
                    var colors = [];
                    var uvs = [];
                    var object = null;
                    var normalMatrix = new three_module_js_2.Matrix3();
                    function setObject(value) {
                        object = value;
                        normalMatrix.getNormalMatrix(object.matrixWorld);
                        normals.length = 0;
                        colors.length = 0;
                        uvs.length = 0;
                    }
                    function projectVertex(vertex) {
                        var position = vertex.position;
                        var positionWorld = vertex.positionWorld;
                        var positionScreen = vertex.positionScreen;
                        positionWorld.copy(position).applyMatrix4(_modelMatrix);
                        positionScreen.copy(positionWorld).applyMatrix4(_viewProjectionMatrix);
                        var invW = 1 / positionScreen.w;
                        positionScreen.x *= invW;
                        positionScreen.y *= invW;
                        positionScreen.z *= invW;
                        vertex.visible = positionScreen.x >= -1 && positionScreen.x <= 1 &&
                            positionScreen.y >= -1 && positionScreen.y <= 1 &&
                            positionScreen.z >= -1 && positionScreen.z <= 1;
                    }
                    function pushVertex(x, y, z) {
                        _vertex = getNextVertexInPool();
                        _vertex.position.set(x, y, z);
                        projectVertex(_vertex);
                    }
                    function pushNormal(x, y, z) {
                        normals.push(x, y, z);
                    }
                    function pushColor(r, g, b) {
                        colors.push(r, g, b);
                    }
                    function pushUv(x, y) {
                        uvs.push(x, y);
                    }
                    function checkTriangleVisibility(v1, v2, v3) {
                        if (v1.visible === true || v2.visible === true || v3.visible === true)
                            return true;
                        _points3[0] = v1.positionScreen;
                        _points3[1] = v2.positionScreen;
                        _points3[2] = v3.positionScreen;
                        return _clipBox.intersectsBox(_boundingBox.setFromPoints(_points3));
                    }
                    function checkBackfaceCulling(v1, v2, v3) {
                        return ((v3.positionScreen.x - v1.positionScreen.x) *
                            (v2.positionScreen.y - v1.positionScreen.y) -
                            (v3.positionScreen.y - v1.positionScreen.y) *
                                (v2.positionScreen.x - v1.positionScreen.x)) < 0;
                    }
                    function pushLine(a, b) {
                        var v1 = _vertexPool[a];
                        var v2 = _vertexPool[b];
                        // Clip
                        v1.positionScreen.copy(v1.position).applyMatrix4(_modelViewProjectionMatrix);
                        v2.positionScreen.copy(v2.position).applyMatrix4(_modelViewProjectionMatrix);
                        if (clipLine(v1.positionScreen, v2.positionScreen) === true) {
                            // Perform the perspective divide
                            v1.positionScreen.multiplyScalar(1 / v1.positionScreen.w);
                            v2.positionScreen.multiplyScalar(1 / v2.positionScreen.w);
                            _line = getNextLineInPool();
                            _line.id = object.id;
                            _line.v1.copy(v1);
                            _line.v2.copy(v2);
                            _line.z = Math.max(v1.positionScreen.z, v2.positionScreen.z);
                            _line.renderOrder = object.renderOrder;
                            _line.material = object.material;
                            if (object.material.vertexColors === three_module_js_2.VertexColors) {
                                _line.vertexColors[0].fromArray(colors, a * 3);
                                _line.vertexColors[1].fromArray(colors, b * 3);
                            }
                            _renderData.elements.push(_line);
                        }
                    }
                    function pushTriangle(a, b, c, material) {
                        var v1 = _vertexPool[a];
                        var v2 = _vertexPool[b];
                        var v3 = _vertexPool[c];
                        if (checkTriangleVisibility(v1, v2, v3) === false)
                            return;
                        if (material.side === three_module_js_2.DoubleSide || checkBackfaceCulling(v1, v2, v3) === true) {
                            _face = getNextFaceInPool();
                            _face.id = object.id;
                            _face.v1.copy(v1);
                            _face.v2.copy(v2);
                            _face.v3.copy(v3);
                            _face.z = (v1.positionScreen.z + v2.positionScreen.z + v3.positionScreen.z) / 3;
                            _face.renderOrder = object.renderOrder;
                            // face normal
                            _vector3.subVectors(v3.position, v2.position);
                            _vector4.subVectors(v1.position, v2.position);
                            _vector3.cross(_vector4);
                            _face.normalModel.copy(_vector3);
                            _face.normalModel.applyMatrix3(normalMatrix).normalize();
                            for (var i = 0; i < 3; i++) {
                                var normal = _face.vertexNormalsModel[i];
                                normal.fromArray(normals, arguments[i] * 3);
                                normal.applyMatrix3(normalMatrix).normalize();
                                var uv = _face.uvs[i];
                                uv.fromArray(uvs, arguments[i] * 2);
                            }
                            _face.vertexNormalsLength = 3;
                            _face.material = material;
                            if (material.vertexColors === three_module_js_2.FaceColors || material.vertexColors === three_module_js_2.VertexColors) {
                                _face.color.fromArray(colors, a * 3);
                            }
                            _renderData.elements.push(_face);
                        }
                    }
                    return {
                        setObject: setObject,
                        projectVertex: projectVertex,
                        checkTriangleVisibility: checkTriangleVisibility,
                        checkBackfaceCulling: checkBackfaceCulling,
                        pushVertex: pushVertex,
                        pushNormal: pushNormal,
                        pushColor: pushColor,
                        pushUv: pushUv,
                        pushLine: pushLine,
                        pushTriangle: pushTriangle
                    };
                };
                var renderList = new RenderList();
                function projectObject(object) {
                    if (object.visible === false)
                        return;
                    if (object instanceof three_module_js_2.Light) {
                        _renderData.lights.push(object);
                    }
                    else if (object instanceof three_module_js_2.Mesh || object instanceof three_module_js_2.Line || object instanceof three_module_js_2.Points) {
                        if (object.material.visible === false)
                            return;
                        if (object.frustumCulled === true && _frustum.intersectsObject(object) === false)
                            return;
                        addObject(object);
                    }
                    else if (object instanceof three_module_js_2.Sprite) {
                        if (object.material.visible === false)
                            return;
                        if (object.frustumCulled === true && _frustum.intersectsSprite(object) === false)
                            return;
                        addObject(object);
                    }
                    var children = object.children;
                    for (var i = 0, l = children.length; i < l; i++) {
                        projectObject(children[i]);
                    }
                }
                function addObject(object) {
                    _object = getNextObjectInPool();
                    _object.id = object.id;
                    _object.object = object;
                    _vector3.setFromMatrixPosition(object.matrixWorld);
                    _vector3.applyMatrix4(_viewProjectionMatrix);
                    _object.z = _vector3.z;
                    _object.renderOrder = object.renderOrder;
                    _renderData.objects.push(_object);
                }
                this.projectScene = function (scene, camera, sortObjects, sortElements) {
                    _faceCount = 0;
                    _lineCount = 0;
                    _spriteCount = 0;
                    _renderData.elements.length = 0;
                    if (scene.autoUpdate === true)
                        scene.updateMatrixWorld();
                    if (camera.parent === null)
                        camera.updateMatrixWorld();
                    _viewMatrix.copy(camera.matrixWorldInverse);
                    _viewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, _viewMatrix);
                    _frustum.setFromProjectionMatrix(_viewProjectionMatrix);
                    //
                    _objectCount = 0;
                    _renderData.objects.length = 0;
                    _renderData.lights.length = 0;
                    projectObject(scene);
                    if (sortObjects === true) {
                        _renderData.objects.sort(painterSort);
                    }
                    //
                    var objects = _renderData.objects;
                    for (var o = 0, ol = objects.length; o < ol; o++) {
                        var object = objects[o].object;
                        var geometry = object.geometry;
                        renderList.setObject(object);
                        _modelMatrix = object.matrixWorld;
                        _vertexCount = 0;
                        if (object instanceof three_module_js_2.Mesh) {
                            if (geometry instanceof three_module_js_2.BufferGeometry) {
                                var material = object.material;
                                var isMultiMaterial = Array.isArray(material);
                                var attributes = geometry.attributes;
                                var groups = geometry.groups;
                                if (attributes.position === undefined)
                                    continue;
                                var positions = attributes.position.array;
                                for (var i = 0, l = positions.length; i < l; i += 3) {
                                    var x = positions[i];
                                    var y = positions[i + 1];
                                    var z = positions[i + 2];
                                    if (material.morphTargets === true) {
                                        var morphTargets = geometry.morphAttributes.position;
                                        var morphTargetsRelative = geometry.morphTargetsRelative;
                                        var morphInfluences = object.morphTargetInfluences;
                                        for (var t = 0, tl = morphTargets.length; t < tl; t++) {
                                            var influence = morphInfluences[t];
                                            if (influence === 0)
                                                continue;
                                            var target = morphTargets[t];
                                            if (morphTargetsRelative) {
                                                x += target.getX(i / 3) * influence;
                                                y += target.getY(i / 3) * influence;
                                                z += target.getZ(i / 3) * influence;
                                            }
                                            else {
                                                x += (target.getX(i / 3) - positions[i]) * influence;
                                                y += (target.getY(i / 3) - positions[i + 1]) * influence;
                                                z += (target.getZ(i / 3) - positions[i + 2]) * influence;
                                            }
                                        }
                                    }
                                    renderList.pushVertex(x, y, z);
                                }
                                if (attributes.normal !== undefined) {
                                    var normals = attributes.normal.array;
                                    for (var i = 0, l = normals.length; i < l; i += 3) {
                                        renderList.pushNormal(normals[i], normals[i + 1], normals[i + 2]);
                                    }
                                }
                                if (attributes.color !== undefined) {
                                    var colors = attributes.color.array;
                                    for (var i = 0, l = colors.length; i < l; i += 3) {
                                        renderList.pushColor(colors[i], colors[i + 1], colors[i + 2]);
                                    }
                                }
                                if (attributes.uv !== undefined) {
                                    var uvs = attributes.uv.array;
                                    for (var i = 0, l = uvs.length; i < l; i += 2) {
                                        renderList.pushUv(uvs[i], uvs[i + 1]);
                                    }
                                }
                                if (geometry.index !== null) {
                                    var indices = geometry.index.array;
                                    if (groups.length > 0) {
                                        for (var g = 0; g < groups.length; g++) {
                                            var group = groups[g];
                                            material = isMultiMaterial === true
                                                ? object.material[group.materialIndex]
                                                : object.material;
                                            if (material === undefined)
                                                continue;
                                            for (var i = group.start, l = group.start + group.count; i < l; i += 3) {
                                                renderList.pushTriangle(indices[i], indices[i + 1], indices[i + 2], material);
                                            }
                                        }
                                    }
                                    else {
                                        for (var i = 0, l = indices.length; i < l; i += 3) {
                                            renderList.pushTriangle(indices[i], indices[i + 1], indices[i + 2], material);
                                        }
                                    }
                                }
                                else {
                                    if (groups.length > 0) {
                                        for (var g = 0; g < groups.length; g++) {
                                            var group = groups[g];
                                            material = isMultiMaterial === true
                                                ? object.material[group.materialIndex]
                                                : object.material;
                                            if (material === undefined)
                                                continue;
                                            for (var i = group.start, l = group.start + group.count; i < l; i += 3) {
                                                renderList.pushTriangle(i, i + 1, i + 2, material);
                                            }
                                        }
                                    }
                                    else {
                                        for (var i = 0, l = positions.length / 3; i < l; i += 3) {
                                            renderList.pushTriangle(i, i + 1, i + 2, material);
                                        }
                                    }
                                }
                            }
                            else if (geometry instanceof three_module_js_2.Geometry) {
                                var vertices = geometry.vertices;
                                var faces = geometry.faces;
                                var faceVertexUvs = geometry.faceVertexUvs[0];
                                _normalMatrix.getNormalMatrix(_modelMatrix);
                                var material = object.material;
                                var isMultiMaterial = Array.isArray(material);
                                for (var v = 0, vl = vertices.length; v < vl; v++) {
                                    var vertex = vertices[v];
                                    _vector3.copy(vertex);
                                    if (material.morphTargets === true) {
                                        var morphTargets = geometry.morphTargets;
                                        var morphInfluences = object.morphTargetInfluences;
                                        for (var t = 0, tl = morphTargets.length; t < tl; t++) {
                                            var influence = morphInfluences[t];
                                            if (influence === 0)
                                                continue;
                                            var target = morphTargets[t];
                                            var targetVertex = target.vertices[v];
                                            _vector3.x += (targetVertex.x - vertex.x) * influence;
                                            _vector3.y += (targetVertex.y - vertex.y) * influence;
                                            _vector3.z += (targetVertex.z - vertex.z) * influence;
                                        }
                                    }
                                    renderList.pushVertex(_vector3.x, _vector3.y, _vector3.z);
                                }
                                for (var f = 0, fl = faces.length; f < fl; f++) {
                                    var face = faces[f];
                                    material = isMultiMaterial === true
                                        ? object.material[face.materialIndex]
                                        : object.material;
                                    if (material === undefined)
                                        continue;
                                    var side = material.side;
                                    var v1 = _vertexPool[face.a];
                                    var v2 = _vertexPool[face.b];
                                    var v3 = _vertexPool[face.c];
                                    if (renderList.checkTriangleVisibility(v1, v2, v3) === false)
                                        continue;
                                    var visible = renderList.checkBackfaceCulling(v1, v2, v3);
                                    if (side !== three_module_js_2.DoubleSide) {
                                        if (side === three_module_js_2.FrontSide && visible === false)
                                            continue;
                                        if (side === three_module_js_2.BackSide && visible === true)
                                            continue;
                                    }
                                    _face = getNextFaceInPool();
                                    _face.id = object.id;
                                    _face.v1.copy(v1);
                                    _face.v2.copy(v2);
                                    _face.v3.copy(v3);
                                    _face.normalModel.copy(face.normal);
                                    if (visible === false && (side === three_module_js_2.BackSide || side === three_module_js_2.DoubleSide)) {
                                        _face.normalModel.negate();
                                    }
                                    _face.normalModel.applyMatrix3(_normalMatrix).normalize();
                                    var faceVertexNormals = face.vertexNormals;
                                    for (var n = 0, nl = Math.min(faceVertexNormals.length, 3); n < nl; n++) {
                                        var normalModel = _face.vertexNormalsModel[n];
                                        normalModel.copy(faceVertexNormals[n]);
                                        if (visible === false && (side === three_module_js_2.BackSide || side === three_module_js_2.DoubleSide)) {
                                            normalModel.negate();
                                        }
                                        normalModel.applyMatrix3(_normalMatrix).normalize();
                                    }
                                    _face.vertexNormalsLength = faceVertexNormals.length;
                                    var vertexUvs = faceVertexUvs[f];
                                    if (vertexUvs !== undefined) {
                                        for (var u = 0; u < 3; u++) {
                                            _face.uvs[u].copy(vertexUvs[u]);
                                        }
                                    }
                                    _face.color = face.color;
                                    _face.material = material;
                                    _face.z = (v1.positionScreen.z + v2.positionScreen.z + v3.positionScreen.z) / 3;
                                    _face.renderOrder = object.renderOrder;
                                    _renderData.elements.push(_face);
                                }
                            }
                        }
                        else if (object instanceof three_module_js_2.Line) {
                            _modelViewProjectionMatrix.multiplyMatrices(_viewProjectionMatrix, _modelMatrix);
                            if (geometry instanceof three_module_js_2.BufferGeometry) {
                                var attributes = geometry.attributes;
                                if (attributes.position !== undefined) {
                                    var positions = attributes.position.array;
                                    for (var i = 0, l = positions.length; i < l; i += 3) {
                                        renderList.pushVertex(positions[i], positions[i + 1], positions[i + 2]);
                                    }
                                    if (attributes.color !== undefined) {
                                        var colors = attributes.color.array;
                                        for (var i = 0, l = colors.length; i < l; i += 3) {
                                            renderList.pushColor(colors[i], colors[i + 1], colors[i + 2]);
                                        }
                                    }
                                    if (geometry.index !== null) {
                                        var indices = geometry.index.array;
                                        for (var i = 0, l = indices.length; i < l; i += 2) {
                                            renderList.pushLine(indices[i], indices[i + 1]);
                                        }
                                    }
                                    else {
                                        var step = object instanceof three_module_js_2.LineSegments ? 2 : 1;
                                        for (var i = 0, l = (positions.length / 3) - 1; i < l; i += step) {
                                            renderList.pushLine(i, i + 1);
                                        }
                                    }
                                }
                            }
                            else if (geometry instanceof three_module_js_2.Geometry) {
                                var vertices = object.geometry.vertices;
                                if (vertices.length === 0)
                                    continue;
                                v1 = getNextVertexInPool();
                                v1.positionScreen.copy(vertices[0]).applyMatrix4(_modelViewProjectionMatrix);
                                var step = object instanceof three_module_js_2.LineSegments ? 2 : 1;
                                for (var v = 1, vl = vertices.length; v < vl; v++) {
                                    v1 = getNextVertexInPool();
                                    v1.positionScreen.copy(vertices[v]).applyMatrix4(_modelViewProjectionMatrix);
                                    if ((v + 1) % step > 0)
                                        continue;
                                    v2 = _vertexPool[_vertexCount - 2];
                                    _clippedVertex1PositionScreen.copy(v1.positionScreen);
                                    _clippedVertex2PositionScreen.copy(v2.positionScreen);
                                    if (clipLine(_clippedVertex1PositionScreen, _clippedVertex2PositionScreen) === true) {
                                        // Perform the perspective divide
                                        _clippedVertex1PositionScreen.multiplyScalar(1 / _clippedVertex1PositionScreen.w);
                                        _clippedVertex2PositionScreen.multiplyScalar(1 / _clippedVertex2PositionScreen.w);
                                        _line = getNextLineInPool();
                                        _line.id = object.id;
                                        _line.v1.positionScreen.copy(_clippedVertex1PositionScreen);
                                        _line.v2.positionScreen.copy(_clippedVertex2PositionScreen);
                                        _line.z = Math.max(_clippedVertex1PositionScreen.z, _clippedVertex2PositionScreen.z);
                                        _line.renderOrder = object.renderOrder;
                                        _line.material = object.material;
                                        if (object.material.vertexColors === three_module_js_2.VertexColors) {
                                            _line.vertexColors[0].copy(object.geometry.colors[v]);
                                            _line.vertexColors[1].copy(object.geometry.colors[v - 1]);
                                        }
                                        _renderData.elements.push(_line);
                                    }
                                }
                            }
                        }
                        else if (object instanceof three_module_js_2.Points) {
                            _modelViewProjectionMatrix.multiplyMatrices(_viewProjectionMatrix, _modelMatrix);
                            if (geometry instanceof three_module_js_2.Geometry) {
                                var vertices = object.geometry.vertices;
                                for (var v = 0, vl = vertices.length; v < vl; v++) {
                                    var vertex = vertices[v];
                                    _vector4.set(vertex.x, vertex.y, vertex.z, 1);
                                    _vector4.applyMatrix4(_modelViewProjectionMatrix);
                                    pushPoint(_vector4, object, camera);
                                }
                            }
                            else if (geometry instanceof three_module_js_2.BufferGeometry) {
                                var attributes = geometry.attributes;
                                if (attributes.position !== undefined) {
                                    var positions = attributes.position.array;
                                    for (var i = 0, l = positions.length; i < l; i += 3) {
                                        _vector4.set(positions[i], positions[i + 1], positions[i + 2], 1);
                                        _vector4.applyMatrix4(_modelViewProjectionMatrix);
                                        pushPoint(_vector4, object, camera);
                                    }
                                }
                            }
                        }
                        else if (object instanceof three_module_js_2.Sprite) {
                            object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
                            _vector4.set(_modelMatrix.elements[12], _modelMatrix.elements[13], _modelMatrix.elements[14], 1);
                            _vector4.applyMatrix4(_viewProjectionMatrix);
                            pushPoint(_vector4, object, camera);
                        }
                    }
                    if (sortElements === true) {
                        _renderData.elements.sort(painterSort);
                    }
                    return _renderData;
                };
                function pushPoint(_vector4, object, camera) {
                    var invW = 1 / _vector4.w;
                    _vector4.z *= invW;
                    if (_vector4.z >= -1 && _vector4.z <= 1) {
                        _sprite = getNextSpriteInPool();
                        _sprite.id = object.id;
                        _sprite.x = _vector4.x * invW;
                        _sprite.y = _vector4.y * invW;
                        _sprite.z = _vector4.z;
                        _sprite.renderOrder = object.renderOrder;
                        _sprite.object = object;
                        _sprite.rotation = object.rotation;
                        _sprite.scale.x = object.scale.x * Math.abs(_sprite.x - (_vector4.x + camera.projectionMatrix.elements[0]) / (_vector4.w + camera.projectionMatrix.elements[12]));
                        _sprite.scale.y = object.scale.y * Math.abs(_sprite.y - (_vector4.y + camera.projectionMatrix.elements[5]) / (_vector4.w + camera.projectionMatrix.elements[13]));
                        _sprite.material = object.material;
                        _renderData.elements.push(_sprite);
                    }
                }
                // Pools
                function getNextObjectInPool() {
                    if (_objectCount === _objectPoolLength) {
                        var object = new RenderableObject();
                        _objectPool.push(object);
                        _objectPoolLength++;
                        _objectCount++;
                        return object;
                    }
                    return _objectPool[_objectCount++];
                }
                function getNextVertexInPool() {
                    if (_vertexCount === _vertexPoolLength) {
                        var vertex = new RenderableVertex();
                        _vertexPool.push(vertex);
                        _vertexPoolLength++;
                        _vertexCount++;
                        return vertex;
                    }
                    return _vertexPool[_vertexCount++];
                }
                function getNextFaceInPool() {
                    if (_faceCount === _facePoolLength) {
                        var face = new RenderableFace();
                        _facePool.push(face);
                        _facePoolLength++;
                        _faceCount++;
                        return face;
                    }
                    return _facePool[_faceCount++];
                }
                function getNextLineInPool() {
                    if (_lineCount === _linePoolLength) {
                        var line = new RenderableLine();
                        _linePool.push(line);
                        _linePoolLength++;
                        _lineCount++;
                        return line;
                    }
                    return _linePool[_lineCount++];
                }
                function getNextSpriteInPool() {
                    if (_spriteCount === _spritePoolLength) {
                        var sprite = new RenderableSprite();
                        _spritePool.push(sprite);
                        _spritePoolLength++;
                        _spriteCount++;
                        return sprite;
                    }
                    return _spritePool[_spriteCount++];
                }
                //
                function painterSort(a, b) {
                    if (a.renderOrder !== b.renderOrder) {
                        return a.renderOrder - b.renderOrder;
                    }
                    else if (a.z !== b.z) {
                        return b.z - a.z;
                    }
                    else if (a.id !== b.id) {
                        return a.id - b.id;
                    }
                    else {
                        return 0;
                    }
                }
                function clipLine(s1, s2) {
                    var alpha1 = 0, alpha2 = 1, 
                    // Calculate the boundary coordinate of each vertex for the near and far clip planes,
                    // Z = -1 and Z = +1, respectively.
                    bc1near = s1.z + s1.w, bc2near = s2.z + s2.w, bc1far = -s1.z + s1.w, bc2far = -s2.z + s2.w;
                    if (bc1near >= 0 && bc2near >= 0 && bc1far >= 0 && bc2far >= 0) {
                        // Both vertices lie entirely within all clip planes.
                        return true;
                    }
                    else if ((bc1near < 0 && bc2near < 0) || (bc1far < 0 && bc2far < 0)) {
                        // Both vertices lie entirely outside one of the clip planes.
                        return false;
                    }
                    else {
                        // The line segment spans at least one clip plane.
                        if (bc1near < 0) {
                            // v1 lies outside the near plane, v2 inside
                            alpha1 = Math.max(alpha1, bc1near / (bc1near - bc2near));
                        }
                        else if (bc2near < 0) {
                            // v2 lies outside the near plane, v1 inside
                            alpha2 = Math.min(alpha2, bc1near / (bc1near - bc2near));
                        }
                        if (bc1far < 0) {
                            // v1 lies outside the far plane, v2 inside
                            alpha1 = Math.max(alpha1, bc1far / (bc1far - bc2far));
                        }
                        else if (bc2far < 0) {
                            // v2 lies outside the far plane, v2 inside
                            alpha2 = Math.min(alpha2, bc1far / (bc1far - bc2far));
                        }
                        if (alpha2 < alpha1) {
                            // The line segment spans two boundaries, but is outside both of them.
                            // (This can't happen when we're only clipping against just near/far but good
                            //  to leave the check here for future usage if other clip planes are added.)
                            return false;
                        }
                        else {
                            // Update the s1 and s2 vertices to match the clipped line segment.
                            s1.lerp(s2, alpha1);
                            s2.lerp(s1, 1 - alpha2);
                            return true;
                        }
                    }
                }
            };
            exports_37("Projector", Projector);
        }
    };
});
/**
 * @author mrdoob / http://mrdoob.com/
 */
System.register("https://unpkg.com/three@0.113.2/examples/jsm/renderers/SVGRenderer", ["https://unpkg.com/three@0.113.2/build/three.module", "https://unpkg.com/three@0.113.2/examples/jsm/renderers/Projector"], function (exports_38, context_38) {
    "use strict";
    var three_module_js_3, Projector_js_1, Projector_js_2, Projector_js_3, Projector_js_4, SVGObject, SVGRenderer;
    var __moduleName = context_38 && context_38.id;
    return {
        setters: [
            function (three_module_js_3_1) {
                three_module_js_3 = three_module_js_3_1;
            },
            function (Projector_js_1_1) {
                Projector_js_1 = Projector_js_1_1;
                Projector_js_2 = Projector_js_1_1;
                Projector_js_3 = Projector_js_1_1;
                Projector_js_4 = Projector_js_1_1;
            }
        ],
        execute: function () {
            SVGObject = function (node) {
                three_module_js_3.Object3D.call(this);
                this.node = node;
            };
            exports_38("SVGObject", SVGObject);
            SVGObject.prototype = Object.create(three_module_js_3.Object3D.prototype);
            SVGObject.prototype.constructor = SVGObject;
            SVGRenderer = function () {
                var _this = this, _renderData, _elements, _lights, _projector = new Projector_js_1.Projector(), _svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg'), _svgWidth, _svgHeight, _svgWidthHalf, _svgHeightHalf, _v1, _v2, _v3, _clipBox = new three_module_js_3.Box2(), _elemBox = new three_module_js_3.Box2(), _color = new three_module_js_3.Color(), _diffuseColor = new three_module_js_3.Color(), _ambientLight = new three_module_js_3.Color(), _directionalLights = new three_module_js_3.Color(), _pointLights = new three_module_js_3.Color(), _clearColor = new three_module_js_3.Color(), _vector3 = new three_module_js_3.Vector3(), // Needed for PointLight
                _centroid = new three_module_js_3.Vector3(), _normal = new three_module_js_3.Vector3(), _normalViewMatrix = new three_module_js_3.Matrix3(), _viewMatrix = new three_module_js_3.Matrix4(), _viewProjectionMatrix = new three_module_js_3.Matrix4(), _svgPathPool = [], _svgNode, _pathCount = 0, _currentPath, _currentStyle, _quality = 1, _precision = null;
                this.domElement = _svg;
                this.autoClear = true;
                this.sortObjects = true;
                this.sortElements = true;
                this.overdraw = 0.5;
                this.info = {
                    render: {
                        vertices: 0,
                        faces: 0
                    }
                };
                this.setQuality = function (quality) {
                    switch (quality) {
                        case "high":
                            _quality = 1;
                            break;
                        case "low":
                            _quality = 0;
                            break;
                    }
                };
                this.setClearColor = function (color) {
                    _clearColor.set(color);
                };
                this.setPixelRatio = function () { };
                this.setSize = function (width, height) {
                    _svgWidth = width;
                    _svgHeight = height;
                    _svgWidthHalf = _svgWidth / 2;
                    _svgHeightHalf = _svgHeight / 2;
                    _svg.setAttribute('viewBox', (-_svgWidthHalf) + ' ' + (-_svgHeightHalf) + ' ' + _svgWidth + ' ' + _svgHeight);
                    _svg.setAttribute('width', _svgWidth);
                    _svg.setAttribute('height', _svgHeight);
                    _clipBox.min.set(-_svgWidthHalf, -_svgHeightHalf);
                    _clipBox.max.set(_svgWidthHalf, _svgHeightHalf);
                };
                this.setPrecision = function (precision) {
                    _precision = precision;
                };
                function removeChildNodes() {
                    _pathCount = 0;
                    while (_svg.childNodes.length > 0) {
                        _svg.removeChild(_svg.childNodes[0]);
                    }
                }
                function convert(c) {
                    return _precision !== null ? c.toFixed(_precision) : c;
                }
                this.clear = function () {
                    removeChildNodes();
                    _svg.style.backgroundColor = _clearColor.getStyle();
                };
                this.render = function (scene, camera) {
                    if (camera instanceof three_module_js_3.Camera === false) {
                        console.error('THREE.SVGRenderer.render: camera is not an instance of Camera.');
                        return;
                    }
                    var background = scene.background;
                    if (background && background.isColor) {
                        removeChildNodes();
                        _svg.style.backgroundColor = background.getStyle();
                    }
                    else if (this.autoClear === true) {
                        this.clear();
                    }
                    _this.info.render.vertices = 0;
                    _this.info.render.faces = 0;
                    _viewMatrix.copy(camera.matrixWorldInverse);
                    _viewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, _viewMatrix);
                    _renderData = _projector.projectScene(scene, camera, this.sortObjects, this.sortElements);
                    _elements = _renderData.elements;
                    _lights = _renderData.lights;
                    _normalViewMatrix.getNormalMatrix(camera.matrixWorldInverse);
                    calculateLights(_lights);
                    // reset accumulated path
                    _currentPath = '';
                    _currentStyle = '';
                    for (var e = 0, el = _elements.length; e < el; e++) {
                        var element = _elements[e];
                        var material = element.material;
                        if (material === undefined || material.opacity === 0)
                            continue;
                        _elemBox.makeEmpty();
                        if (element instanceof Projector_js_4.RenderableSprite) {
                            _v1 = element;
                            _v1.x *= _svgWidthHalf;
                            _v1.y *= -_svgHeightHalf;
                            renderSprite(_v1, element, material);
                        }
                        else if (element instanceof Projector_js_3.RenderableLine) {
                            _v1 = element.v1;
                            _v2 = element.v2;
                            _v1.positionScreen.x *= _svgWidthHalf;
                            _v1.positionScreen.y *= -_svgHeightHalf;
                            _v2.positionScreen.x *= _svgWidthHalf;
                            _v2.positionScreen.y *= -_svgHeightHalf;
                            _elemBox.setFromPoints([_v1.positionScreen, _v2.positionScreen]);
                            if (_clipBox.intersectsBox(_elemBox) === true) {
                                renderLine(_v1, _v2, element, material);
                            }
                        }
                        else if (element instanceof Projector_js_2.RenderableFace) {
                            _v1 = element.v1;
                            _v2 = element.v2;
                            _v3 = element.v3;
                            if (_v1.positionScreen.z < -1 || _v1.positionScreen.z > 1)
                                continue;
                            if (_v2.positionScreen.z < -1 || _v2.positionScreen.z > 1)
                                continue;
                            if (_v3.positionScreen.z < -1 || _v3.positionScreen.z > 1)
                                continue;
                            _v1.positionScreen.x *= _svgWidthHalf;
                            _v1.positionScreen.y *= -_svgHeightHalf;
                            _v2.positionScreen.x *= _svgWidthHalf;
                            _v2.positionScreen.y *= -_svgHeightHalf;
                            _v3.positionScreen.x *= _svgWidthHalf;
                            _v3.positionScreen.y *= -_svgHeightHalf;
                            if (this.overdraw > 0) {
                                expand(_v1.positionScreen, _v2.positionScreen, this.overdraw);
                                expand(_v2.positionScreen, _v3.positionScreen, this.overdraw);
                                expand(_v3.positionScreen, _v1.positionScreen, this.overdraw);
                            }
                            _elemBox.setFromPoints([
                                _v1.positionScreen,
                                _v2.positionScreen,
                                _v3.positionScreen
                            ]);
                            if (_clipBox.intersectsBox(_elemBox) === true) {
                                renderFace3(_v1, _v2, _v3, element, material);
                            }
                        }
                    }
                    flushPath(); // just to flush last svg:path
                    scene.traverseVisible(function (object) {
                        if (object instanceof SVGObject) {
                            _vector3.setFromMatrixPosition(object.matrixWorld);
                            _vector3.applyMatrix4(_viewProjectionMatrix);
                            if (_vector3.z < -1 || _vector3.z > 1)
                                return;
                            var x = _vector3.x * _svgWidthHalf;
                            var y = -_vector3.y * _svgHeightHalf;
                            var node = object.node;
                            node.setAttribute('transform', 'translate(' + x + ',' + y + ')');
                            _svg.appendChild(node);
                        }
                    });
                };
                function calculateLights(lights) {
                    _ambientLight.setRGB(0, 0, 0);
                    _directionalLights.setRGB(0, 0, 0);
                    _pointLights.setRGB(0, 0, 0);
                    for (var l = 0, ll = lights.length; l < ll; l++) {
                        var light = lights[l];
                        var lightColor = light.color;
                        if (light.isAmbientLight) {
                            _ambientLight.r += lightColor.r;
                            _ambientLight.g += lightColor.g;
                            _ambientLight.b += lightColor.b;
                        }
                        else if (light.isDirectionalLight) {
                            _directionalLights.r += lightColor.r;
                            _directionalLights.g += lightColor.g;
                            _directionalLights.b += lightColor.b;
                        }
                        else if (light.isPointLight) {
                            _pointLights.r += lightColor.r;
                            _pointLights.g += lightColor.g;
                            _pointLights.b += lightColor.b;
                        }
                    }
                }
                function calculateLight(lights, position, normal, color) {
                    for (var l = 0, ll = lights.length; l < ll; l++) {
                        var light = lights[l];
                        var lightColor = light.color;
                        if (light.isDirectionalLight) {
                            var lightPosition = _vector3.setFromMatrixPosition(light.matrixWorld).normalize();
                            var amount = normal.dot(lightPosition);
                            if (amount <= 0)
                                continue;
                            amount *= light.intensity;
                            color.r += lightColor.r * amount;
                            color.g += lightColor.g * amount;
                            color.b += lightColor.b * amount;
                        }
                        else if (light.isPointLight) {
                            var lightPosition = _vector3.setFromMatrixPosition(light.matrixWorld);
                            var amount = normal.dot(_vector3.subVectors(lightPosition, position).normalize());
                            if (amount <= 0)
                                continue;
                            amount *= light.distance == 0 ? 1 : 1 - Math.min(position.distanceTo(lightPosition) / light.distance, 1);
                            if (amount == 0)
                                continue;
                            amount *= light.intensity;
                            color.r += lightColor.r * amount;
                            color.g += lightColor.g * amount;
                            color.b += lightColor.b * amount;
                        }
                    }
                }
                function renderSprite(v1, element, material) {
                    var scaleX = element.scale.x * _svgWidthHalf;
                    var scaleY = element.scale.y * _svgHeightHalf;
                    if (material.isPointsMaterial) {
                        scaleX *= material.size;
                        scaleY *= material.size;
                    }
                    var path = 'M' + convert(v1.x - scaleX * 0.5) + ',' + convert(v1.y - scaleY * 0.5) + 'h' + convert(scaleX) + 'v' + convert(scaleY) + 'h' + convert(-scaleX) + 'z';
                    var style = "";
                    if (material.isSpriteMaterial || material.isPointsMaterial) {
                        style = 'fill:' + material.color.getStyle() + ';fill-opacity:' + material.opacity;
                    }
                    addPath(style, path);
                }
                function renderLine(v1, v2, element, material) {
                    var path = 'M' + convert(v1.positionScreen.x) + ',' + convert(v1.positionScreen.y) + 'L' + convert(v2.positionScreen.x) + ',' + convert(v2.positionScreen.y);
                    if (material.isLineBasicMaterial) {
                        var style = 'fill:none;stroke:' + material.color.getStyle() + ';stroke-opacity:' + material.opacity + ';stroke-width:' + material.linewidth + ';stroke-linecap:' + material.linecap;
                        if (material.isLineDashedMaterial) {
                            style = style + ';stroke-dasharray:' + material.dashSize + "," + material.gapSize;
                        }
                        addPath(style, path);
                    }
                }
                function renderFace3(v1, v2, v3, element, material) {
                    _this.info.render.vertices += 3;
                    _this.info.render.faces++;
                    var path = 'M' + convert(v1.positionScreen.x) + ',' + convert(v1.positionScreen.y) + 'L' + convert(v2.positionScreen.x) + ',' + convert(v2.positionScreen.y) + 'L' + convert(v3.positionScreen.x) + ',' + convert(v3.positionScreen.y) + 'z';
                    var style = '';
                    if (material.isMeshBasicMaterial) {
                        _color.copy(material.color);
                        if (material.vertexColors === three_module_js_3.FaceColors || material.vertexColors === three_module_js_3.VertexColors) {
                            _color.multiply(element.color);
                        }
                    }
                    else if (material.isMeshLambertMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial) {
                        _diffuseColor.copy(material.color);
                        if (material.vertexColors === three_module_js_3.FaceColors || material.vertexColors === three_module_js_3.VertexColors) {
                            _diffuseColor.multiply(element.color);
                        }
                        _color.copy(_ambientLight);
                        _centroid.copy(v1.positionWorld).add(v2.positionWorld).add(v3.positionWorld).divideScalar(3);
                        calculateLight(_lights, _centroid, element.normalModel, _color);
                        _color.multiply(_diffuseColor).add(material.emissive);
                    }
                    else if (material.isMeshNormalMaterial) {
                        _normal.copy(element.normalModel).applyMatrix3(_normalViewMatrix).normalize();
                        _color.setRGB(_normal.x, _normal.y, _normal.z).multiplyScalar(0.5).addScalar(0.5);
                    }
                    if (material.wireframe) {
                        style = 'fill:none;stroke:' + _color.getStyle() + ';stroke-opacity:' + material.opacity + ';stroke-width:' + material.wireframeLinewidth + ';stroke-linecap:' + material.wireframeLinecap + ';stroke-linejoin:' + material.wireframeLinejoin;
                    }
                    else {
                        style = 'fill:' + _color.getStyle() + ';fill-opacity:' + material.opacity;
                    }
                    addPath(style, path);
                }
                // Hide anti-alias gaps
                function expand(v1, v2, pixels) {
                    var x = v2.x - v1.x, y = v2.y - v1.y, det = x * x + y * y, idet;
                    if (det === 0)
                        return;
                    idet = pixels / Math.sqrt(det);
                    x *= idet;
                    y *= idet;
                    v2.x += x;
                    v2.y += y;
                    v1.x -= x;
                    v1.y -= y;
                }
                function addPath(style, path) {
                    if (_currentStyle === style) {
                        _currentPath += path;
                    }
                    else {
                        flushPath();
                        _currentStyle = style;
                        _currentPath = path;
                    }
                }
                function flushPath() {
                    if (_currentPath) {
                        _svgNode = getPathNode(_pathCount++);
                        _svgNode.setAttribute('d', _currentPath);
                        _svgNode.setAttribute('style', _currentStyle);
                        _svg.appendChild(_svgNode);
                    }
                    _currentPath = '';
                    _currentStyle = '';
                }
                function getPathNode(id) {
                    if (_svgPathPool[id] == null) {
                        _svgPathPool[id] = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        if (_quality == 0) {
                            _svgPathPool[id].setAttribute('shape-rendering', 'crispEdges'); //optimizeSpeed
                        }
                        return _svgPathPool[id];
                    }
                    return _svgPathPool[id];
                }
            };
            exports_38("SVGRenderer", SVGRenderer);
        }
    };
});
System.register("http://localhost:5501/src/deps/svgrenderer", ["https://unpkg.com/three@0.113.2/examples/jsm/renderers/SVGRenderer"], function (exports_39, context_39) {
    "use strict";
    var __moduleName = context_39 && context_39.id;
    function exportStar_4(m) {
        var exports = {};
        for (var n in m) {
            if (n !== "default") exports[n] = m[n];
        }
        exports_39(exports);
    }
    return {
        setters: [
            function (SVGRenderer_js_1_1) {
                exportStar_4(SVGRenderer_js_1_1);
            }
        ],
        execute: function () {
        }
    };
});
System.register("http://localhost:5501/src/components/FSceneThree", ["http://localhost:5501/src/deps/vue", "http://localhost:5501/src/deps/three", "http://localhost:5501/src/deps/svgrenderer", "http://localhost:5501/src/internals/size"], function (exports_40, context_40) {
    "use strict";
    var vue_js_17, three_js_4, svgrenderer_js_1, size_js_4, FSceneThree;
    var __moduleName = context_40 && context_40.id;
    return {
        setters: [
            function (vue_js_17_1) {
                vue_js_17 = vue_js_17_1;
            },
            function (three_js_4_1) {
                three_js_4 = three_js_4_1;
            },
            function (svgrenderer_js_1_1) {
                svgrenderer_js_1 = svgrenderer_js_1_1;
            },
            function (size_js_4_1) {
                size_js_4 = size_js_4_1;
            }
        ],
        execute: function () {
            exports_40("FSceneThree", FSceneThree = {
                props: {
                    ...size_js_4.sizeProps,
                    renderer: {
                        default: "svg",
                        type: String
                    }
                },
                setup(props) {
                    const el = vue_js_17.ref(null);
                    const { width, height } = size_js_4.useSize(props);
                    const scene = new three_js_4.Scene();
                    scene.background = new three_js_4.Color("white");
                    const directionalLight = new three_js_4.DirectionalLight("white", 1);
                    directionalLight.position.set(0, 0, 10);
                    scene.add(directionalLight);
                    const camera = new three_js_4.PerspectiveCamera(100, width.value / height.value, 0.1, 1000);
                    camera.position.z = width.value / 2.5;
                    const renderer = props.renderer == "webgl" ? new three_js_4.WebGLRenderer() : new svgrenderer_js_1.SVGRenderer();
                    renderer.setSize(width.value, height.value);
                    renderer.setPixelRatio(window.devicePixelRatio ? window.devicePixelRatio : 1);
                    const sceneContext = vue_js_17.inject("sceneContext");
                    sceneContext.width = width;
                    sceneContext.height = height;
                    sceneContext.scene = scene;
                    vue_js_17.onMounted(() => {
                        el.value.append(renderer.domElement);
                        renderer.render(scene, camera);
                    });
                    vue_js_17.onBeforeUpdate(() => {
                        renderer.render(scene, camera);
                    });
                    return { el };
                },
                template: `
    <div class="f-scene-three" ref="el">
      <slot />
    </div>
  `,
                css: /*css*/ `
    .f-scene-three > * {
      display: block;
      border: 1px solid red;
    }
  `
            });
        }
    };
});
System.register("http://localhost:5501/src/components/FScene", ["http://localhost:5501/src/deps/vue", "http://localhost:5501/src/components/FSceneSvg", "http://localhost:5501/src/components/FSceneCanvas", "http://localhost:5501/src/components/FSceneThree"], function (exports_41, context_41) {
    "use strict";
    var vue_js_18, FSceneSvg_js_1, FSceneCanvas_js_1, FSceneThree_js_1, FSceneThreeSvg, FSceneThreeWebgl, FScene;
    var __moduleName = context_41 && context_41.id;
    return {
        setters: [
            function (vue_js_18_1) {
                vue_js_18 = vue_js_18_1;
            },
            function (FSceneSvg_js_1_1) {
                FSceneSvg_js_1 = FSceneSvg_js_1_1;
            },
            function (FSceneCanvas_js_1_1) {
                FSceneCanvas_js_1 = FSceneCanvas_js_1_1;
            },
            function (FSceneThree_js_1_1) {
                FSceneThree_js_1 = FSceneThree_js_1_1;
            }
        ],
        execute: function () {
            exports_41("FSceneThreeSvg", FSceneThreeSvg = (props, context) => vue_js_18.h(FSceneThree_js_1.FSceneThree, { ...props, renderer: "svg" }, context.slots));
            exports_41("FSceneThreeWebgl", FSceneThreeWebgl = (props, context) => vue_js_18.h(FSceneThree_js_1.FSceneThree, { ...props, renderer: "webgl" }, context.slots));
            exports_41("FScene", FScene = {
                props: {
                    type: {
                        default: "svg",
                        type: String
                    }
                },
                setup(props, context) {
                    const types = {
                        svg: FSceneSvg_js_1.FSceneSvg,
                        canvas: FSceneCanvas_js_1.FSceneCanvas,
                        three: FSceneThreeSvg,
                        webgl: FSceneThreeWebgl
                    };
                    const type = vue_js_18.computed(() => props.type);
                    vue_js_18.provide("sceneContext", { type });
                    return () => vue_js_18.h(types[type.value], { ...props }, context.slots);
                }
            });
        }
    };
});
System.register("http://localhost:5501/src/components/FSlider", ["http://localhost:5501/fachwerk", "http://localhost:5501/src/internals/dynamic"], function (exports_42, context_42) {
    "use strict";
    var fachwerk_js_4, dynamic_js_2, FSlider;
    var __moduleName = context_42 && context_42.id;
    return {
        setters: [
            function (fachwerk_js_4_1) {
                fachwerk_js_4 = fachwerk_js_4_1;
            },
            function (dynamic_js_2_1) {
                dynamic_js_2 = dynamic_js_2_1;
            }
        ],
        execute: function () {
            exports_42("FSlider", FSlider = {
                props: { ...dynamic_js_2.dynamicProps, value: { default: 0, type: [String, Number] } },
                setup(props, { emit }) {
                    const onInput = e => {
                        const currentValue = fachwerk_js_4.toNumber(e.target.value);
                        emit("value", currentValue);
                        if (props.set) {
                            fachwerk_js_4.set(props.set, currentValue);
                        }
                    };
                    return { onInput };
                },
                template: `<input
    type="range"
    :value="value"
    @input="onInput"
    :min="from"
    :max="to"
    :step="integer ? 1 : step ? step : 0.01"
  />`
            });
        }
    };
});
System.register("http://localhost:5501/src/components/index", ["http://localhost:5501/src/components/FAnimate", "http://localhost:5501/src/components/FSquare", "http://localhost:5501/src/components/FSquareCanvas", "http://localhost:5501/src/components/FSquareSvg", "http://localhost:5501/src/components/FSquareThree", "http://localhost:5501/src/components/FCircle", "http://localhost:5501/src/components/FCircleCanvas", "http://localhost:5501/src/components/FCircleSvg", "http://localhost:5501/src/components/FCompiler", "http://localhost:5501/src/components/FEditor", "http://localhost:5501/src/components/FContent", "http://localhost:5501/src/components/FMath", "http://localhost:5501/src/components/FScene", "http://localhost:5501/src/components/FSceneCanvas", "http://localhost:5501/src/components/FSceneSvg", "http://localhost:5501/src/components/FSceneThree", "http://localhost:5501/src/components/FSlider"], function (exports_43, context_43) {
    "use strict";
    var __moduleName = context_43 && context_43.id;
    function exportStar_5(m) {
        var exports = {};
        for (var n in m) {
            if (n !== "default") exports[n] = m[n];
        }
        exports_43(exports);
    }
    return {
        setters: [
            function (FAnimate_js_1_1) {
                exportStar_5(FAnimate_js_1_1);
            },
            function (FSquare_js_1_1) {
                exportStar_5(FSquare_js_1_1);
            },
            function (FSquareCanvas_js_2_1) {
                exportStar_5(FSquareCanvas_js_2_1);
            },
            function (FSquareSvg_js_2_1) {
                exportStar_5(FSquareSvg_js_2_1);
            },
            function (FSquareThree_js_2_1) {
                exportStar_5(FSquareThree_js_2_1);
            },
            function (FCircle_js_1_1) {
                exportStar_5(FCircle_js_1_1);
            },
            function (FCircleCanvas_js_2_1) {
                exportStar_5(FCircleCanvas_js_2_1);
            },
            function (FCircleSvg_js_2_1) {
                exportStar_5(FCircleSvg_js_2_1);
            },
            function (FCompiler_js_1_1) {
                exportStar_5(FCompiler_js_1_1);
            },
            function (FEditor_js_1_1) {
                exportStar_5(FEditor_js_1_1);
            },
            function (FContent_js_1_1) {
                exportStar_5(FContent_js_1_1);
            },
            function (FMath_js_1_1) {
                exportStar_5(FMath_js_1_1);
            },
            function (FScene_js_1_1) {
                exportStar_5(FScene_js_1_1);
            },
            function (FSceneCanvas_js_2_1) {
                exportStar_5(FSceneCanvas_js_2_1);
            },
            function (FSceneSvg_js_2_1) {
                exportStar_5(FSceneSvg_js_2_1);
            },
            function (FSceneThree_js_2_1) {
                exportStar_5(FSceneThree_js_2_1);
            },
            function (FSlider_js_1_1) {
                exportStar_5(FSlider_js_1_1);
            }
        ],
        execute: function () {
        }
    };
});
System.register("http://localhost:5501/fachwerk", ["http://localhost:5501/src/components/index", "http://localhost:5501/src/utils/index"], function (exports_44, context_44) {
    "use strict";
    var components, utils;
    var __moduleName = context_44 && context_44.id;
    var exportedNames_1 = {
        "components": true,
        "utils": true
    };
    function exportStar_6(m) {
        var exports = {};
        for (var n in m) {
            if (n !== "default" && !exportedNames_1.hasOwnProperty(n)) exports[n] = m[n];
        }
        exports_44(exports);
    }
    return {
        setters: [
            function (index_js_11_1) {
                exportStar_6(index_js_11_1);
                components = index_js_11_1;
            },
            function (index_js_12_1) {
                exportStar_6(index_js_12_1);
                utils = index_js_12_1;
            }
        ],
        execute: function () {
            exports_44("components", components);
            exports_44("utils", utils);
        }
    };
});
System.register("http://localhost:5501/src/utils/fachwerk", ["http://localhost:5501/src/deps/vue", "http://localhost:5501/fachwerk"], function (exports_45, context_45) {
    "use strict";
    var vue_js_19, fachwerk_js_5, fachwerk;
    var __moduleName = context_45 && context_45.id;
    return {
        setters: [
            function (vue_js_19_1) {
                vue_js_19 = vue_js_19_1;
            },
            function (fachwerk_js_5_1) {
                fachwerk_js_5 = fachwerk_js_5_1;
            }
        ],
        execute: function () {
            exports_45("fachwerk", fachwerk = (options = {}) => {
                const customOptions = {
                    file: "./index.md",
                    components: {},
                    utils: {},
                    template: "",
                    ...options
                };
                const App = {
                    setup() {
                        vue_js_19.provide("customUtils", customOptions.utils);
                        const { content } = fachwerk_js_5.useFetch(customOptions.file);
                        return { content };
                    },
                    template: customOptions.template ||
                        `
      <f-content :content="content" />
    `
                };
                const app = vue_js_19.createApp(App);
                Object.entries({
                    ...fachwerk_js_5.components,
                    ...customOptions.components
                }).forEach(([name, component]) => app.component(name, component));
                fachwerk_js_5.componentCss(fachwerk_js_5.components);
                // app.config.errorHandler = onError;
                // app.config.warnHandler = onWarning;
                app.mount("#app");
            });
        }
    };
});
System.register("http://localhost:5501/src/utils/fetch", ["http://localhost:5501/src/deps/vue"], function (exports_46, context_46) {
    "use strict";
    var vue_js_20, useFetch;
    var __moduleName = context_46 && context_46.id;
    return {
        setters: [
            function (vue_js_20_1) {
                vue_js_20 = vue_js_20_1;
            }
        ],
        execute: function () {
            exports_46("useFetch", useFetch = src => {
                const content = vue_js_20.ref("");
                if (src) {
                    fetch(src)
                        .then(res => res.text())
                        .then(res => {
                        content.value = res;
                    });
                }
                return { content };
            });
        }
    };
});
System.register("http://localhost:5501/src/utils/log", [], function (exports_47, context_47) {
    "use strict";
    var __moduleName = context_47 && context_47.id;
    function log() {
        console.log(...arguments);
    }
    exports_47("log", log);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("http://localhost:5501/src/utils/math", [], function (exports_48, context_48) {
    "use strict";
    var fit;
    var __moduleName = context_48 && context_48.id;
    return {
        setters: [],
        execute: function () {
            exports_48("fit", fit = (value, start1, stop1, start2 = -2, stop2 = 2) => {
                return ((value - start1) / (stop1 - start1)) * (stop2 - start2) + start2;
            });
        }
    };
});
System.register("http://localhost:5501/src/utils/state", ["http://localhost:5501/src/deps/vue"], function (exports_49, context_49) {
    "use strict";
    var vue_js_21, state, set, get;
    var __moduleName = context_49 && context_49.id;
    return {
        setters: [
            function (vue_js_21_1) {
                vue_js_21 = vue_js_21_1;
            }
        ],
        execute: function () {
            state = vue_js_21.ref({});
            exports_49("set", set = (key, value) => (state.value[key] = value));
            exports_49("get", get = (key = null) => (key ? state.value[key] : state.value));
        }
    };
});
System.register("http://localhost:5501/src/utils/string", [], function (exports_50, context_50) {
    "use strict";
    var shorten;
    var __moduleName = context_50 && context_50.id;
    return {
        setters: [],
        execute: function () {
            exports_50("shorten", shorten = (str, length = 50, suffix = "...") => `${str.slice(0, length)}${str.length - 1 > length ? suffix : ""}`);
        }
    };
});
System.register("http://localhost:5501/src/utils/test", ["http://localhost:5501/src/utils/index"], function (exports_51, context_51) {
    "use strict";
    var index_js_13, isKeyedCollection, equal, test;
    var __moduleName = context_51 && context_51.id;
    return {
        setters: [
            function (index_js_13_1) {
                index_js_13 = index_js_13_1;
            }
        ],
        execute: function () {
            // From https://github.com/denoland/deno/blob/master/std/testing/asserts.ts
            isKeyedCollection = x => [Symbol.iterator, "size"].every(k => k in x);
            exports_51("equal", equal = (c, d) => {
                const seen = new Map();
                return (function compare(a, b) {
                    if (a &&
                        b &&
                        ((a instanceof RegExp && b instanceof RegExp) ||
                            (a instanceof Date && b instanceof Date))) {
                        return String(a) === String(b);
                    }
                    if (Object.is(a, b)) {
                        return true;
                    }
                    if (a && typeof a === "object" && b && typeof b === "object") {
                        if (seen.get(a) === b) {
                            return true;
                        }
                        if (Object.keys(a || {}).length !== Object.keys(b || {}).length) {
                            return false;
                        }
                        if (isKeyedCollection(a) && isKeyedCollection(b)) {
                            if (a.size !== b.size) {
                                return false;
                            }
                            let unmatchedEntries = a.size;
                            for (const [aKey, aValue] of a.entries()) {
                                for (const [bKey, bValue] of b.entries()) {
                                    if ((aKey === aValue && bKey === bValue && compare(aKey, bKey)) ||
                                        (compare(aKey, bKey) && compare(aValue, bValue))) {
                                        unmatchedEntries--;
                                    }
                                }
                            }
                            return unmatchedEntries === 0;
                        }
                        const merged = Object.assign(Object.assign({}, a), b);
                        for (const key in merged) {
                            if (!compare(a && a[key], b && b[key])) {
                                return false;
                            }
                        }
                        seen.set(a, b);
                        return true;
                    }
                    return false;
                })(c, d);
            });
            exports_51("test", test = tests => {
                const reset = "\x1b[0m";
                const red = "\x1b[31m";
                const redbg = "\x1b[41m";
                const green = "\x1b[32m";
                const greenbg = "\x1b[42m";
                const dim = "\x1b[2m";
                console.log(`\n  ${dim}Running Fachwerk tests${reset}\n`);
                const filteredKey = typeof process !== "undefined" ? process.argv[2] : null;
                let passed = 0;
                let failed = 0;
                tests.forEach(([name, test]) => {
                    const [actual, expected] = test();
                    if (equal(actual, expected)) {
                        passed++;
                        console.log(`  ${index_js_13.shorten(name).padEnd(53)}\t${green}OK${reset}`);
                    }
                    else {
                        failed++;
                        console.log(`  ${index_js_13.shorten(name).padEnd(53)}\t${red}Failed${reset}${dim}
 
${String(test)
                            .split("\r?\n")
                            .map(row => `    ${row}`)
                            .join("\n")}

    Actual: ${reset}${red}${JSON.stringify(actual)}${reset}${dim}

    Expected: ${JSON.stringify(expected)}
${reset}`);
                    }
                });
                if (passed || failed) {
                    console.log(`

  ${greenbg} Tests passed: ${passed} ${reset} ${failed ? `${redbg} Tests failed: ${failed} ${reset}` : ""}

`);
                    return failed > 0 ? 1 : 0;
                }
                else {
                    console.log(`
  No tests found

`);
                    return 0;
                }
            });
        }
    };
});
System.register("http://localhost:5501/src/utils/trig", [], function (exports_52, context_52) {
    "use strict";
    var deg2rad;
    var __moduleName = context_52 && context_52.id;
    return {
        setters: [],
        execute: function () {
            exports_52("deg2rad", deg2rad = deg => (deg * Math.PI) / 180);
        }
    };
});
System.register("http://localhost:5501/src/utils/types", [], function (exports_53, context_53) {
    "use strict";
    var isObject, isBoolean, isNull, isArray, isNumber, isString, isFunction, test_isObject_object, test_isObject_array, test_isObject_date, toNumber, test_toNumber_numeric_string, test_toNumber_nonnumeric_string, test_toNumber_empty_string, test_toNumber_zero, test_toNumber_integer, test_toNumber_float, test_toNumber_gibberish;
    var __moduleName = context_53 && context_53.id;
    return {
        setters: [],
        execute: function () {
            exports_53("isObject", isObject = input => typeof input === "object" &&
                !isArray(input) &&
                Object.prototype.toString.call(input) !== "[object Date]");
            exports_53("isBoolean", isBoolean = input => typeof input === typeof true);
            exports_53("isNull", isNull = input => input === null && typeof input === "object");
            exports_53("isArray", isArray = input => Array.isArray(input));
            exports_53("isNumber", isNumber = input => typeof input === "number");
            exports_53("isString", isString = input => typeof input === "string");
            exports_53("isFunction", isFunction = input => typeof input === "function");
            exports_53("test_isObject_object", test_isObject_object = () => [isObject({ x: 1 }), true]);
            exports_53("test_isObject_array", test_isObject_array = () => [isObject([1]), false]);
            exports_53("test_isObject_date", test_isObject_date = () => [isObject(new Date()), false]);
            // toNumber
            exports_53("toNumber", toNumber = (value, def = 0) => {
                const float = parseFloat(value);
                if (isNaN(float)) {
                    return def;
                }
                return float;
            });
            exports_53("test_toNumber_numeric_string", test_toNumber_numeric_string = () => {
                return [toNumber("0"), 0];
            });
            exports_53("test_toNumber_nonnumeric_string", test_toNumber_nonnumeric_string = () => {
                return [toNumber("a"), 0];
            });
            exports_53("test_toNumber_empty_string", test_toNumber_empty_string = () => {
                return [toNumber(""), 0];
            });
            exports_53("test_toNumber_zero", test_toNumber_zero = () => {
                return [toNumber(0), 0];
            });
            exports_53("test_toNumber_integer", test_toNumber_integer = () => {
                return [toNumber(1), 1];
            });
            exports_53("test_toNumber_float", test_toNumber_float = () => {
                return [toNumber(0.1), 0.1];
            });
            exports_53("test_toNumber_gibberish", test_toNumber_gibberish = () => {
                return [toNumber("*"), 0];
            });
        }
    };
});
System.register("http://localhost:5501/src/utils/index", ["http://localhost:5501/src/utils/array", "http://localhost:5501/src/utils/css", "http://localhost:5501/src/utils/error", "http://localhost:5501/src/utils/events", "http://localhost:5501/src/utils/fachwerk", "http://localhost:5501/src/utils/fetch", "http://localhost:5501/src/utils/log", "http://localhost:5501/src/utils/math", "http://localhost:5501/src/utils/state", "http://localhost:5501/src/utils/string", "http://localhost:5501/src/utils/test", "http://localhost:5501/src/utils/trig", "http://localhost:5501/src/utils/types"], function (exports_54, context_54) {
    "use strict";
    var __moduleName = context_54 && context_54.id;
    function exportStar_7(m) {
        var exports = {};
        for (var n in m) {
            if (n !== "default") exports[n] = m[n];
        }
        exports_54(exports);
    }
    return {
        setters: [
            function (array_js_1_1) {
                exportStar_7(array_js_1_1);
            },
            function (css_js_1_1) {
                exportStar_7(css_js_1_1);
            },
            function (error_js_1_1) {
                exportStar_7(error_js_1_1);
            },
            function (events_js_1_1) {
                exportStar_7(events_js_1_1);
            },
            function (fachwerk_js_6_1) {
                exportStar_7(fachwerk_js_6_1);
            },
            function (fetch_js_1_1) {
                exportStar_7(fetch_js_1_1);
            },
            function (log_js_1_1) {
                exportStar_7(log_js_1_1);
            },
            function (math_js_1_1) {
                exportStar_7(math_js_1_1);
            },
            function (state_js_1_1) {
                exportStar_7(state_js_1_1);
            },
            function (string_js_1_1) {
                exportStar_7(string_js_1_1);
            },
            function (test_js_1_1) {
                exportStar_7(test_js_1_1);
            },
            function (trig_js_1_1) {
                exportStar_7(trig_js_1_1);
            },
            function (types_js_1_1) {
                exportStar_7(types_js_1_1);
            }
        ],
        execute: function () {
        }
    };
});

const __exp = __instantiate("http://localhost:5501/src/utils/index");
export const padArrayRight = __exp["padArrayRight"];
export const test_padArrayRight_empty = __exp["test_padArrayRight_empty"];
export const test_padArrayRight_existing = __exp["test_padArrayRight_existing"];
export const getCssVariable = __exp["getCssVariable"];
export const setCssVariable = __exp["setCssVariable"];
export const injectCss = __exp["injectCss"];
export const componentCss = __exp["componentCss"];
export const onError = __exp["onError"];
export const onWarning = __exp["onWarning"];
export const onCompilerError = __exp["onCompilerError"];
export const send = __exp["send"];
export const receive = __exp["receive"];
export const fachwerk = __exp["fachwerk"];
export const useFetch = __exp["useFetch"];
export const log = __exp["log"];
export const fit = __exp["fit"];
export const set = __exp["set"];
export const get = __exp["get"];
export const shorten = __exp["shorten"];
export const equal = __exp["equal"];
export const test = __exp["test"];
export const deg2rad = __exp["deg2rad"];
export const isObject = __exp["isObject"];
export const isBoolean = __exp["isBoolean"];
export const isNull = __exp["isNull"];
export const isArray = __exp["isArray"];
export const isNumber = __exp["isNumber"];
export const isString = __exp["isString"];
export const isFunction = __exp["isFunction"];
export const test_isObject_object = __exp["test_isObject_object"];
export const test_isObject_array = __exp["test_isObject_array"];
export const test_isObject_date = __exp["test_isObject_date"];
export const toNumber = __exp["toNumber"];
export const test_toNumber_numeric_string = __exp["test_toNumber_numeric_string"];
export const test_toNumber_nonnumeric_string = __exp["test_toNumber_nonnumeric_string"];
export const test_toNumber_empty_string = __exp["test_toNumber_empty_string"];
export const test_toNumber_zero = __exp["test_toNumber_zero"];
export const test_toNumber_integer = __exp["test_toNumber_integer"];
export const test_toNumber_float = __exp["test_toNumber_float"];
export const test_toNumber_gibberish = __exp["test_toNumber_gibberish"];

